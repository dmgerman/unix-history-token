begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on the DEC Alpha.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001 Free Software Foundation, Inc.     Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_comment
comment|/* External data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify which cpu to schedule for.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|alpha_cpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|alpha_cpu_name
index|[]
init|=
block|{
literal|"ev4"
block|,
literal|"ev5"
block|,
literal|"ev6"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify how accurate floating-point traps need to be.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_trap_precision
name|alpha_tp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify the floating-point rounding mode.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_fp_rounding_mode
name|alpha_fprm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify which things cause traps.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_fp_trap_mode
name|alpha_fptm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings decoded into the above options.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_cpu_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mcpu= */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_tune_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mtune= */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_tp_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mtrap-precision=[p|s|i] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_fprm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mfp-rounding-mode=[n|m|c|d] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_fptm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mfp-trap-mode=[n|u|su|sui] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_mlat_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mmemory-latency= */
end_comment

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|struct
name|alpha_compare
name|alpha_compare
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if inside of a function, because the Alpha asm can't    handle .files inside of functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inside_function
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of cycles of latency we should assume on memory reads.  */
end_comment

begin_decl_stmt
name|int
name|alpha_memory_latency
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the function needs the GP.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_function_needs_gp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The alias set for prologue/epilogue register save/restore.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_sr_alias_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The assembler name of the current function.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alpha_fnname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next explicit relocation sequence number.  */
end_comment

begin_decl_stmt
name|int
name|alpha_next_sequence_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The literal and gpdisp sequence numbers for this insn, as printed    by %# and %* respectively.  */
end_comment

begin_decl_stmt
name|int
name|alpha_this_literal_sequence_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alpha_this_gpdisp_sequence_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declarations of static functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|decl_in_text_section
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|some_small_symbolic_mem_operand_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|split_small_symbolic_mem_operand_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|local_symbol_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_set_memflags_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alpha_emit_set_const_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_expand_unaligned_load_words
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|out_regs
operator|,
name|rtx
name|smem
operator|,
name|HOST_WIDE_INT
name|words
operator|,
name|HOST_WIDE_INT
name|ofs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_expand_unaligned_store_words
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|out_regs
operator|,
name|rtx
name|smem
operator|,
name|HOST_WIDE_INT
name|words
operator|,
name|HOST_WIDE_INT
name|ofs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_sa_mask
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|*
name|imaskP
operator|,
name|unsigned
name|long
operator|*
name|fmaskP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_lo_sum
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_does_function_need_gp
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_ra_ever_killed
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_trap_mode_suffix
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_round_mode_suffix
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|set_frame_related_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alpha_lookup_xfloating_lib_func
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_compute_xfloating_mode_arg
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
expr|enum
name|alpha_fp_rounding_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_emit_xfloating_libcall
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rtx
operator|,
name|rtx
index|[]
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alpha_emit_xfloating_compare
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_output_function_end_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_issue_rate
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_variable_issue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|TARGET_ABI_UNICOSMK
end_if

begin_decl_stmt
specifier|static
name|void
name|alpha_init_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_mark_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_free_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|unicosmk_output_deferred_case_vectors
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unicosmk_gen_dsib
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|*
name|imaskP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unicosmk_output_ssib
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unicosmk_need_dex
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the number of args of a function in one of two ways.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
operator|||
name|TARGET_ABI_UNICOSMK
end_if

begin_define
define|#
directive|define
name|NUM_ARGS
value|current_function_args_info.num_args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUM_ARGS
value|current_function_args_info
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REG_PV
value|27
end_define

begin_define
define|#
directive|define
name|REG_RA
value|26
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
end_if

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|vms_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|vms_section_type_flags
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vms_asm_named_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vms_asm_out_constructor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vms_asm_out_destructor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|vms_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SECTION_TYPE_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SECTION_TYPE_FLAGS
value|vms_section_type_flags
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET_ABI_UNICOSMK
end_if

begin_decl_stmt
specifier|static
name|void
name|unicosmk_asm_named_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unicosmk_insert_attributes
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|unicosmk_section_type_flags
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|TARGET_INSERT_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_INSERT_ATTRIBUTES
value|unicosmk_insert_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SECTION_TYPE_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SECTION_TYPE_FLAGS
value|unicosmk_section_type_flags
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\t.quad\t"
end_define

begin_comment
comment|/* Default unaligned ops are provided for ELF systems.  To get unaligned    data for non-ELF systems, we have to turn off auto alignment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
end_ifndef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.align 0\n\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.align 0\n\t.long\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\t.align 0\n\t.quad\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_END_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_END_PROLOGUE
value|alpha_output_function_end_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|alpha_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|alpha_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|alpha_variable_issue
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Parse target option strings.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
name|cpu_table
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
name|int
name|flags
decl_stmt|;
block|}
name|cpu_table
index|[]
init|=
block|{
define|#
directive|define
name|EV5_MASK
value|(MASK_CPU_EV5)
define|#
directive|define
name|EV6_MASK
value|(MASK_CPU_EV6|MASK_BWX|MASK_MAX|MASK_FIX)
block|{
literal|"ev4"
block|,
name|PROCESSOR_EV4
block|,
literal|0
block|}
block|,
block|{
literal|"ev45"
block|,
name|PROCESSOR_EV4
block|,
literal|0
block|}
block|,
block|{
literal|"21064"
block|,
name|PROCESSOR_EV4
block|,
literal|0
block|}
block|,
block|{
literal|"ev5"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
block|}
block|,
block|{
literal|"21164"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
block|}
block|,
block|{
literal|"ev56"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
block|}
block|,
block|{
literal|"21164a"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
block|}
block|,
block|{
literal|"pca56"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
operator||
name|MASK_MAX
block|}
block|,
block|{
literal|"21164PC"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
operator||
name|MASK_MAX
block|}
block|,
block|{
literal|"21164pc"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
operator||
name|MASK_MAX
block|}
block|,
block|{
literal|"ev6"
block|,
name|PROCESSOR_EV6
block|,
name|EV6_MASK
block|}
block|,
block|{
literal|"21264"
block|,
name|PROCESSOR_EV6
block|,
name|EV6_MASK
block|}
block|,
block|{
literal|"ev67"
block|,
name|PROCESSOR_EV6
block|,
name|EV6_MASK
operator||
name|MASK_CIX
block|}
block|,
block|{
literal|"21264a"
block|,
name|PROCESSOR_EV6
block|,
name|EV6_MASK
operator||
name|MASK_CIX
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
comment|/* Unicos/Mk doesn't have shared libraries.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|flag_pic
condition|)
block|{
name|warning
argument_list|(
literal|"-f%s ignored for Unicos/Mk (not supported)"
argument_list|,
operator|(
name|flag_pic
operator|>
literal|1
operator|)
condition|?
literal|"PIC"
else|:
literal|"pic"
argument_list|)
expr_stmt|;
name|flag_pic
operator|=
literal|0
expr_stmt|;
block|}
comment|/* On Unicos/Mk, the native compiler consistenly generates /d suffices for       floating-point instructions.  Make that the default for this target.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_DYN
expr_stmt|;
else|else
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
name|alpha_tp
operator|=
name|ALPHA_TP_PROG
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_N
expr_stmt|;
comment|/* We cannot use su and sui qualifiers for conversion instructions on       Unicos/Mk.  I'm not sure if this is due to assembler or hardware      limitations.  Right now, we issue a warning if -mieee is specified      and then ignore it; eventually, we should either get it right or      disable the option altogether.  */
if|if
condition|(
name|TARGET_IEEE
condition|)
block|{
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|warning
argument_list|(
literal|"-mieee not supported on Unicos/Mk"
argument_list|)
expr_stmt|;
else|else
block|{
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_IEEE_WITH_INEXACT
condition|)
block|{
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|warning
argument_list|(
literal|"-mieee-with-inexact not supported on Unicos/Mk"
argument_list|)
expr_stmt|;
else|else
block|{
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SUI
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alpha_tp_string
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"p"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_PROG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"f"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_FUNC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"i"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mtrap-precision switch"
argument_list|,
name|alpha_tp_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fprm_string
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"n"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"m"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_MINF
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"c"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_CHOP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"d"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_DYN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mfp-rounding-mode switch"
argument_list|,
name|alpha_fprm_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fptm_string
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_N
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"u"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_U
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"su"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"sui"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SUI
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mfp-trap-mode switch"
argument_list|,
name|alpha_fptm_string
argument_list|)
expr_stmt|;
block|}
name|alpha_cpu
operator|=
name|TARGET_CPU_DEFAULT
operator|&
name|MASK_CPU_EV6
condition|?
name|PROCESSOR_EV6
else|:
operator|(
name|TARGET_CPU_DEFAULT
operator|&
name|MASK_CPU_EV5
condition|?
name|PROCESSOR_EV5
else|:
name|PROCESSOR_EV4
operator|)
expr_stmt|;
if|if
condition|(
name|alpha_cpu_string
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|cpu_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_BWX
operator||
name|MASK_MAX
operator||
name|MASK_FIX
operator||
name|MASK_CIX
operator||
name|MASK_CPU_EV5
operator||
name|MASK_CPU_EV6
operator|)
expr_stmt|;
name|target_flags
operator||=
name|cpu_table
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
condition|)
name|error
argument_list|(
literal|"bad value `%s' for -mcpu switch"
argument_list|,
name|alpha_cpu_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_tune_string
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tune_string
argument_list|,
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|cpu_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
condition|)
name|error
argument_list|(
literal|"bad value `%s' for -mcpu switch"
argument_list|,
name|alpha_tune_string
argument_list|)
expr_stmt|;
block|}
comment|/* Do some sanity checks on the above options.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|alpha_fptm
operator|!=
name|ALPHA_FPTM_N
condition|)
block|{
name|warning
argument_list|(
literal|"trap mode not supported on Unicos/Mk"
argument_list|)
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_N
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SU
operator|||
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SUI
operator|)
operator|&&
name|alpha_tp
operator|!=
name|ALPHA_TP_INSN
operator|&&
operator|!
name|TARGET_CPU_EV6
condition|)
block|{
name|warning
argument_list|(
literal|"fp software completion requires -mtrap-precision=i"
argument_list|)
expr_stmt|;
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_CPU_EV6
condition|)
block|{
comment|/* Except for EV6 pass 1 (not released), we always have precise 	 arithmetic traps.  Which means we can do software completion 	 without minding trap shadows.  */
name|alpha_tp
operator|=
name|ALPHA_TP_PROG
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_FLOAT_VAX
condition|)
block|{
if|if
condition|(
name|alpha_fprm
operator|==
name|ALPHA_FPRM_MINF
operator|||
name|alpha_fprm
operator|==
name|ALPHA_FPRM_DYN
condition|)
block|{
name|warning
argument_list|(
literal|"rounding mode not supported for VAX floats"
argument_list|)
expr_stmt|;
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SUI
condition|)
block|{
name|warning
argument_list|(
literal|"trap mode not supported for VAX floats"
argument_list|)
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
block|}
block|}
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|lat
decl_stmt|;
if|if
condition|(
operator|!
name|alpha_mlat_string
condition|)
name|alpha_mlat_string
operator|=
literal|"L1"
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|alpha_mlat_string
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|lat
operator|=
name|strtol
argument_list|(
name|alpha_mlat_string
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
operator|,
operator|*
name|end
operator|==
literal|'\0'
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|alpha_mlat_string
index|[
literal|0
index|]
operator|==
literal|'L'
operator|||
name|alpha_mlat_string
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|alpha_mlat_string
index|[
literal|1
index|]
argument_list|)
operator|&&
name|alpha_mlat_string
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|static
name|int
specifier|const
name|cache_latency
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|3
block|,
literal|30
block|,
operator|-
literal|1
block|}
block|,
comment|/* ev4 -- Bcache is a guess */
block|{
literal|2
block|,
literal|12
block|,
literal|38
block|}
block|,
comment|/* ev5 -- Bcache from PC164 LMbench numbers */
block|{
literal|3
block|,
literal|12
block|,
literal|30
block|}
block|,
comment|/* ev6 -- Bcache from DS20 LMbench.  */
block|}
decl_stmt|;
name|lat
operator|=
name|alpha_mlat_string
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|lat
operator|<=
literal|0
operator|||
name|lat
operator|>
literal|3
operator|||
name|cache_latency
index|[
name|alpha_cpu
index|]
index|[
name|lat
operator|-
literal|1
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"L%d cache latency unknown for %s"
argument_list|,
name|lat
argument_list|,
name|alpha_cpu_name
index|[
name|alpha_cpu
index|]
argument_list|)
expr_stmt|;
name|lat
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|lat
operator|=
name|cache_latency
index|[
name|alpha_cpu
index|]
index|[
name|lat
operator|-
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_mlat_string
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
comment|/* Most current memories have about 370ns latency.  This is 	   a reasonable guess for a fast cpu.  */
name|lat
operator|=
literal|150
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"bad value `%s' for -mmemory-latency"
argument_list|,
name|alpha_mlat_string
argument_list|)
expr_stmt|;
name|lat
operator|=
literal|3
expr_stmt|;
block|}
name|alpha_memory_latency
operator|=
name|lat
expr_stmt|;
block|}
comment|/* Default the definition of "small data" to 8 bytes.  */
if|if
condition|(
operator|!
name|g_switch_set
condition|)
name|g_switch_value
operator|=
literal|8
expr_stmt|;
comment|/* Infer TARGET_SMALL_DATA from -fpic/-fPIC.  */
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
name|target_flags
operator||=
name|MASK_SMALL_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_SMALL_DATA
expr_stmt|;
comment|/* Align labels and loops for optimal branching.  */
comment|/* ??? Kludge these by not doing anything if we don't optimize and also if      we are writing ECOFF symbols to work around a bug in DEC's assembler.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|write_symbols
operator|!=
name|SDB_DEBUG
condition|)
block|{
if|if
condition|(
name|align_loops
operator|<=
literal|0
condition|)
name|align_loops
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|<=
literal|0
condition|)
name|align_jumps
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|align_functions
operator|<=
literal|0
condition|)
name|align_functions
operator|=
literal|16
expr_stmt|;
comment|/* Acquire a unique set number for our register saves and restores.  */
name|alpha_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
comment|/* Register variables and functions with the garbage collector.  */
if|#
directive|if
name|TARGET_ABI_UNICOSMK
comment|/* Set up function hooks.  */
name|init_machine_status
operator|=
name|alpha_init_machine_status
expr_stmt|;
name|mark_machine_status
operator|=
name|alpha_mark_machine_status
expr_stmt|;
name|free_machine_status
operator|=
name|alpha_free_machine_status
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */
end_comment

begin_function
name|int
name|zap_mask
parameter_list|(
name|value
parameter_list|)
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0xff
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either the constant zero or a register.  If a    register, it must be in the proper mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant in the range of 0-63 (for a shift) or    any register.  */
end_comment

begin_function
name|int
name|reg_or_6bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant or any register.  */
end_comment

begin_function
name|int
name|reg_or_8bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant.  */
end_comment

begin_function
name|int
name|cint8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to an add insn.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/* Constraints I, J, O and P are covered by K.  */
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to a sign-extending    add insn.  */
end_comment

begin_function
name|int
name|sext_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'O'
argument_list|)
operator|)
return|;
return|return
name|reg_not_elim_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant 4 or 8.  */
end_comment

begin_function
name|int
name|const48_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an AND insn.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
operator|(
name|zap_mask
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
name|zap_mask
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an IOR or XOR insn.  */
end_comment

begin_function
name|int
name|or_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width, in bits, of an integral    mode smaller than DImode.  */
end_comment

begin_function
name|int
name|mode_width_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|32
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|64
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width of an integral machine mode    smaller than an integer.  */
end_comment

begin_function
name|int
name|mode_mask_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xff
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xffff
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a multiple of 8 less than 64.  */
end_comment

begin_function
name|int
name|mul8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|7
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant zero in floating-point.  */
end_comment

begin_function
name|int
name|fp0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the floating-point constant zero or a register.  */
end_comment

begin_function
name|int
name|reg_or_fp0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|fp0_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a hard floating-point register.  */
end_comment

begin_function
name|int
name|hard_fp_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|FLOAT_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a hard general register.  */
end_comment

begin_function
name|int
name|hard_int_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|GENERAL_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register or a constant integer.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is something that can be reloaded into a register;    if it is a MEM, it need not be valid.  */
end_comment

begin_function
name|int
name|some_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|MEM
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|HIGH
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
return|return
name|some_operand
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but don't accept constants.  */
end_comment

begin_function
name|int
name|some_ni_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the source of a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
comment|/* We don't split symbolic operands into something unintelligable 	     until after reload, but we do not wish non-small, non-global 	     symbolic operands to be reconstructed from their high/lo_sum 	     form.  */
return|return
operator|(
name|small_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|global_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
comment|/* This handles both the Windows/NT and OSF cases.  */
return|return
name|mode
operator|==
name|ptr_mode
operator|||
name|mode
operator|==
name|DImode
return|;
case|case
name|HIGH
case|:
return|return
operator|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|local_symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
return|;
case|case
name|REG
case|:
case|case
name|ADDRESSOF
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ... fall through ...  */
case|case
name|MEM
case|:
return|return
operator|(
operator|(
name|TARGET_BWX
operator|||
operator|(
name|mode
operator|!=
name|HImode
operator|&&
name|mode
operator|!=
name|QImode
operator|)
operator|)
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
case|case
name|CONST_DOUBLE
case|:
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|add_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONSTANT_P_RTX
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a SYMBOL_REF for a function known to be in this    file, and in the same section as the current function.  */
end_comment

begin_function
name|int
name|current_file_function_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
comment|/* Easy test for recursion.  */
if|if
condition|(
name|op
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, we need the DECL for the SYMBOL_REF, which we can't get.      So SYMBOL_REF_FLAG has been declared to imply that the function is      in the default text section.  So we must also check that the current      function is also in the text section.  */
if|if
condition|(
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
operator|&&
name|decl_in_text_section
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a SYMBOL_REF for which we can make a call via bsr.  */
end_comment

begin_function
name|int
name|direct_call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Must be defined in this file.  */
if|if
condition|(
operator|!
name|current_file_function_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If profiling is implemented via linker tricks, we can't jump      to the nogp alternate entry point.  */
comment|/* ??? TARGET_PROFILING_NEEDS_GP isn't really the right test,      but is approximately correct for the OSF ABIs.  Don't know      what to do for VMS, NT, or UMK.  */
if|if
condition|(
operator|!
name|TARGET_PROFILING_NEEDS_GP
operator|&&
operator|!
name|current_function_profile
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing    a variable known to be defined in this file.  */
end_comment

begin_function
specifier|static
name|bool
name|local_symbol_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* ??? SYMBOL_REF_FLAG is set for local function symbols, but we      run into problems with the rtl inliner in that the symbol was      once external, but is local after inlining, which results in      unrecognizable insns.  */
return|return
operator|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
comment|/* If @, then ENCODE_SECTION_INFO sez it's local.  */
operator|||
name|str
index|[
literal|0
index|]
operator|==
literal|'@'
comment|/* If *$, then ASM_GENERATE_INTERNAL_LABEL sez it's local.  */
operator|||
operator|(
name|str
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|str
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|local_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
name|local_symbol_p
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a SYMBOL_REF or CONST referencing a variable    known to be defined in this file in the small data area.  */
end_comment

begin_function
name|int
name|small_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_SMALL_DATA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<=
operator|(
name|unsigned
operator|)
name|g_switch_value
return|;
else|else
block|{
name|str
operator|=
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|str
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|str
index|[
literal|1
index|]
operator|==
literal|'s'
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if OP is a SYMBOL_REF or CONST referencing a variable    not known (or known not) to be defined in this file.  */
end_comment

begin_function
name|int
name|global_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|local_symbol_p
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|Pmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|TARGET_ABI_OSF
condition|)
block|{
comment|/* Disallow virtual registers to cope with pathalogical test cases 	     such as compile/930117-1.c in which the virtual reg decomposes 	     to the frame pointer.  Which is a hard reg that is not $27.  */
return|return
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
literal|27
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,    possibly with an offset.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha comparison operator.  Here we know which    comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha comparison operator against zero.     Here we know which comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_zero_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha swapped comparison operator.  */
end_comment

begin_function
name|int
name|alpha_swapped_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|)
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a signed comparison operation.  */
end_comment

begin_function
name|int
name|signed_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha floating point comparison operator.    Here we know which comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_fp_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|UNORDERED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a divide or modulus operator.  */
end_comment

begin_function
name|int
name|divmod_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this memory address is a known aligned register plus    a constant.  It must be a valid address.  This means that we can do    this as an aligned reference plus some offset.     Take into account what reload will do.  */
end_comment

begin_function
name|int
name|aligned_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)      sorts of constructs.  Dig for the real base register.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|base
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|op
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|>=
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but return 1 if OP is a MEM which is not alignable.  */
end_comment

begin_function
name|int
name|unaligned_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)      sorts of constructs.  Dig for the real base register.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|base
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|op
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|<
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is either a register or an unaligned memory location.  */
end_comment

begin_function
name|int
name|reg_or_unaligned_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|unaligned_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is any memory location.  During reload a pseudo matches.  */
end_comment

begin_function
name|int
name|any_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is not an eliminable register.     This exists to cure a pathological abort in the s8addq (et al) patterns,  	long foo () { long t; bar(); return (long)&t * 26107; }     which run afoul of a hack in reload to cure a (presumably) similar    problem with lea-type instructions on other targets.  But there is    one of us and many of them, so work around the problem by selectively    preventing combine from making the optimization.  */
end_comment

begin_function
name|int
name|reg_not_elim_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|inner
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|==
name|frame_pointer_rtx
operator|||
name|inner
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is OP is a memory location that is not a reference (using    an AND) to an unaligned location.  Take into account what reload    will do.  */
end_comment

begin_function
name|int
name|normal_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
comment|/* This may not have been assigned an equivalent address if it will 	     be eliminated.  In that case, it doesn't matter what we do.  */
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|AND
return|;
block|}
end_function

begin_comment
comment|/* Accept a register, but not a subreg of any kind.  This allows us to    avoid pathological cases in reload wrt data movement common in     int->fp conversion.  */
end_comment

begin_function
name|int
name|reg_no_subreg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recognize an addition operation that includes a constant.  Used to    convince reload to canonize (plus (plus reg c1) c2) during register    elimination.  */
end_comment

begin_function
name|int
name|addition_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Implements CONST_OK_FOR_LETTER_P.  Return true if the value matches    the range defined for C in [I-P].  */
end_comment

begin_function
name|bool
name|alpha_const_ok_for_letter_p
parameter_list|(
name|value
parameter_list|,
name|c
parameter_list|)
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
comment|/* An unsigned 8 bit constant.  */
return|return
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|value
operator|<
literal|0x100
return|;
case|case
literal|'J'
case|:
comment|/* The constant zero.  */
return|return
name|value
operator|==
literal|0
return|;
case|case
literal|'K'
case|:
comment|/* A signed 16 bit constant.  */
return|return
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|value
operator|+
literal|0x8000
argument_list|)
operator|<
literal|0x10000
return|;
case|case
literal|'L'
case|:
comment|/* A shifted signed 16 bit constant appropriate for LDAH.  */
return|return
operator|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|value
operator|)
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|value
operator|>>
literal|31
operator|==
literal|0
operator|)
operator|)
return|;
case|case
literal|'M'
case|:
comment|/* A constant that can be AND'ed with using a ZAP insn.  */
return|return
name|zap_mask
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'N'
case|:
comment|/* A complemented unsigned 8 bit constant.  */
return|return
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|~
name|value
argument_list|)
operator|<
literal|0x100
return|;
case|case
literal|'O'
case|:
comment|/* A negated unsigned 8 bit constant.  */
return|return
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
name|value
argument_list|)
operator|<
literal|0x100
return|;
case|case
literal|'P'
case|:
comment|/* The constant 1, 2 or 3.  */
return|return
name|value
operator|==
literal|1
operator|||
name|value
operator|==
literal|2
operator|||
name|value
operator|==
literal|3
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implements CONST_DOUBLE_OK_FOR_LETTER_P.  Return true if VALUE    matches for C in [GH].  */
end_comment

begin_function
name|bool
name|alpha_const_double_ok_for_letter_p
parameter_list|(
name|value
parameter_list|,
name|c
parameter_list|)
name|rtx
name|value
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'G'
case|:
comment|/* The floating point zero constant.  */
return|return
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|value
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'H'
case|:
comment|/* A valid operand of a ZAP insn.  */
return|return
operator|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implements CONST_DOUBLE_OK_FOR_LETTER_P.  Return true if VALUE    matches for C.  */
end_comment

begin_function
name|bool
name|alpha_extra_constraint
parameter_list|(
name|value
parameter_list|,
name|c
parameter_list|)
name|rtx
name|value
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
return|return
name|normal_memory_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
literal|'R'
case|:
return|return
name|direct_call_operand
argument_list|(
name|value
argument_list|,
name|Pmode
argument_list|)
return|;
case|case
literal|'S'
case|:
return|return
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<
literal|64
operator|)
return|;
case|case
literal|'T'
case|:
return|return
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|HIGH
return|;
case|case
literal|'U'
case|:
return|return
name|TARGET_ABI_UNICOSMK
operator|&&
name|symbolic_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if this function can directly return via $26.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|()
block|{
return|return
operator|(
operator|!
name|TARGET_ABI_OPEN_VMS
operator|&&
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
name|reload_completed
operator|&&
name|alpha_sa_size
argument_list|()
operator|==
literal|0
operator|&&
name|get_frame_size
argument_list|()
operator|==
literal|0
operator|&&
name|current_function_outgoing_args_size
operator|==
literal|0
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the ADDR_VEC associated with a tablejump insn.  */
end_comment

begin_function
name|rtx
name|alpha_tablejump_addr_vec
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|NULL_RTX
return|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
return|return
name|PATTERN
argument_list|(
name|tmp
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return the label of the predicted edge, or CONST0_RTX if we don't know.  */
end_comment

begin_function
name|rtx
name|alpha_tablejump_best_label
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|jump_table
init|=
name|alpha_tablejump_addr_vec
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|best_label
init|=
name|NULL_RTX
decl_stmt|;
comment|/* ??? Once the CFG doesn't keep getting completely rebuilt, look      there for edge frequency counts from profile data.  */
if|if
condition|(
name|jump_table
condition|)
block|{
name|int
name|n_labels
init|=
name|XVECLEN
argument_list|(
name|jump_table
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|best_count
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_labels
condition|;
name|i
operator|++
control|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_labels
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|jump_table
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|jump_table
argument_list|,
literal|1
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|best_count
condition|)
name|best_count
operator|=
name|count
operator|,
name|best_label
operator|=
name|XVECEXP
argument_list|(
name|jump_table
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|best_label
condition|?
name|best_label
else|:
name|const0_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the function DECL will be placed in the default text    section.  */
end_comment

begin_comment
comment|/* ??? Ideally we'd be able to always move from a SYMBOL_REF back to the    decl, as that would allow us to determine if two functions are in the    same section, which is what we really want to know.  */
end_comment

begin_function
specifier|static
name|bool
name|decl_in_text_section
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
operator|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
operator|(
name|flag_function_sections
operator|||
operator|(
name|targetm
operator|.
name|have_named_sections
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If we are referencing a function that is static, make the SYMBOL_REF    special.  We use this to see indicate we can branch to this function    without setting PV or restoring GP.      If this is a variable that is known to be defined locally, add "@v"    to the name.  If in addition the variable is to go in .sdata/.sbss,    then add "@s" instead.  */
end_comment

begin_function
name|void
name|alpha_encode_section_info
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|symbol_str
decl_stmt|;
name|bool
name|is_local
decl_stmt|,
name|is_small
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We mark public functions once they are emitted; otherwise we 	 don't know that they exist in this unit of translation.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Do not mark functions that are not in .text; otherwise we 	 don't know that they are near enough for a direct branch.  */
if|if
condition|(
operator|!
name|decl_in_text_section
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|SYMBOL_REF_FLAG
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Early out if we're not going to do anything with this data.  */
if|if
condition|(
operator|!
name|TARGET_EXPLICIT_RELOCS
condition|)
return|return;
comment|/* Careful not to prod global register variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return;
name|symbol_str
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A variable is considered "local" if it is defined in this module.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|is_local
operator|=
name|false
expr_stmt|;
comment|/* Linkonce and weak data is never local.  */
elseif|else
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|is_local
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|is_local
operator|=
name|true
expr_stmt|;
comment|/* If PIC, then assume that any global name can be overridden by      symbols resolved from other modules.  */
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|is_local
operator|=
name|false
expr_stmt|;
comment|/* Uninitialized COMMON variable may be unified with symbols      resolved from other modules.  */
elseif|else
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|is_local
operator|=
name|false
expr_stmt|;
comment|/* Otherwise we're left with initialized (or non-common) global data      which is of necessity defined locally.  */
else|else
name|is_local
operator|=
name|true
expr_stmt|;
comment|/* Determine if DECL will wind up in .sdata/.sbss.  */
name|is_small
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|is_small
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the variable has already been defined in the output file, then it 	 is too late to put it in sdata if it wasn't put there in the first 	 place.  The test is here rather than above, because if it is already 	 in sdata, then it can stay there.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
comment|/* If this is an incomplete type with size 0, then we can't put it in 	 sdata because it might be too big when completed.  */
elseif|else
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|g_switch_value
condition|)
name|is_small
operator|=
name|true
expr_stmt|;
block|}
comment|/* Finally, encode this into the symbol string.  */
if|if
condition|(
name|is_local
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|symbol_str
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|symbol_str
index|[
literal|1
index|]
operator|==
operator|(
name|is_small
condition|?
literal|'s'
else|:
literal|'v'
operator|)
condition|)
return|return;
name|symbol_str
operator|+=
literal|2
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|symbol_str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|newstr
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|newstr
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|newstr
index|[
literal|1
index|]
operator|=
operator|(
name|is_small
condition|?
literal|'s'
else|:
literal|'v'
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|newstr
operator|+
literal|2
argument_list|,
name|symbol_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|string
operator|=
name|ggc_alloc_string
argument_list|(
name|newstr
argument_list|,
name|len
operator|+
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|string
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol_str
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* legitimate_address_p recognizes an RTL expression that is a valid    memory address for an instruction.  The MODE argument is the    machine mode for the MEM expression that wants to use this address.     For Alpha, we have either a constant address or the sum of a    register and a constant address, or just a register.  For DImode,    any of those forms can be surrounded with an AND that clear the    low-order three bits; this is an "unaligned" access.  */
end_comment

begin_function
name|bool
name|alpha_legitimate_address_p
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|strict
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
comment|/* If this is an ldq_u type address, discard the outer AND.  */
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|8
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard non-paradoxical subregs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Unadorned general registers are valid.  */
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|strict
condition|?
name|STRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
else|:
name|NONSTRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* Constant addresses (i.e. +/- 32k) are valid.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Register plus a small constant offset is valid.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|ofs
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard non-paradoxical subregs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strict
operator|&&
name|NONSTRICT_REG_OK_FP_BASE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|ofs
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|strict
condition|?
name|STRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
else|:
name|NONSTRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|ofs
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|ofs
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|true
return|;
block|}
comment|/* If we're managing explicit relocations, LO_SUM is valid, as      are small data symbols.  */
elseif|else
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
if|if
condition|(
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
name|rtx
name|ofs
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard non-paradoxical subregs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Must have a valid base register.  */
if|if
condition|(
operator|!
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|strict
condition|?
name|STRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
else|:
name|NONSTRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* The symbol must be local.  */
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|ofs
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.  */
end_comment

begin_function
name|rtx
name|alpha_legitimize_address
parameter_list|(
name|x
parameter_list|,
name|scratch
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|scratch
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|addend
decl_stmt|;
comment|/* If the address is (plus reg const_int) and the CONST_INT is not a      valid offset, compute the high part of the constant and add it to      the register.  Then our address is (plus temp low-part-const).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|addend
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|split_addend
goto|;
block|}
comment|/* If the address is (const (plus FOO const_int)), find the low-order      part of the CONST_INT.  Then load FOO plus any high-order part of the      CONST_INT into a register.  Our address is (plus reg low-part-const).      This is done to reduce the number of GOT entries.  */
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addend
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|split_addend
goto|;
block|}
comment|/* If we have a (plus reg const), emit the load as in (2), then add      the two registers, and finally generate (plus reg low-part-const) as      our address.  */
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addend
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
goto|goto
name|split_addend
goto|;
block|}
comment|/* If this is a local symbol, split the address into HIGH/LO_SUM parts.  */
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|x
return|;
else|else
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|scratch
argument_list|,
name|x
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
name|split_addend
label|:
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|low
operator|=
operator|(
operator|(
name|addend
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|addend
operator|-=
name|low
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|addend
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
name|addend
operator|-=
name|high
expr_stmt|;
if|if
condition|(
name|addend
condition|)
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|addend
argument_list|)
argument_list|,
operator|(
name|no_new_pseudos
condition|?
name|scratch
else|:
name|NULL_RTX
operator|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
condition|)
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|high
argument_list|)
argument_list|,
operator|(
name|no_new_pseudos
condition|?
name|scratch
else|:
name|NULL_RTX
operator|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|x
argument_list|,
name|low
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* For TARGET_EXPLICIT_RELOCS, we don't obfuscate a SYMBOL_REF to a    small symbolic operand until after reload.  At which point we need    to replace (mem (symbol_ref)) with (mem (lo_sum $29 symbol_ref))    so that sched2 has the proper dependency information.  */
end_comment

begin_function
name|int
name|some_small_symbolic_mem_operand
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|some_small_symbolic_mem_operand_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|some_small_symbolic_mem_operand_1
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is an ldq_u type address, discard the outer AND.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|rtx
name|split_small_symbolic_mem_operand
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|x
operator|=
name|copy_insn
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|split_small_symbolic_mem_operand_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|split_small_symbolic_mem_operand_1
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|px
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|x
operator|=
operator|*
name|px
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
condition|)
name|px
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|x
operator|=
operator|*
name|px
expr_stmt|;
if|if
condition|(
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|x
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Try a machine-dependent way of reloading an illegitimate address    operand.  If we find one, push the reload and return the new rtx.  */
end_comment

begin_function
name|rtx
name|alpha_legitimize_reload_address
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|ind_levels
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|ind_levels
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We must recognize output that we have already generated ourselves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* We wish to handle large displacements off a base register by      splitting the addend across an ldah and the mem insn.  This      cuts number of extra insns needed from 3 to 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
operator|(
name|val
operator|-
name|low
operator|)
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
decl_stmt|;
comment|/* Check for 32-bit overflow.  */
if|if
condition|(
name|high
operator|+
name|low
operator|!=
name|val
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Reload the high part into a base reg; leave the low part 	 in the mem directly.  */
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* REF is an alignable memory location.  Place an aligned SImode    reference into *PALIGNED_MEM and the number of bits to shift into    *PBITNUM.  SCRATCH is a free register for use in reloading out    of range stack slots.  */
end_comment

begin_function
name|void
name|get_aligned_mem
parameter_list|(
name|ref
parameter_list|,
name|paligned_mem
parameter_list|,
name|pbitnum
parameter_list|)
name|rtx
name|ref
decl_stmt|;
name|rtx
modifier|*
name|paligned_mem
decl_stmt|,
decl|*
name|pbitnum
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|paligned_mem
operator|=
name|widen_memory_access
argument_list|(
name|ref
argument_list|,
name|SImode
argument_list|,
operator|(
name|offset
operator|&
operator|~
literal|3
operator|)
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
operator|*
name|pbitnum
operator|=
name|GEN_INT
argument_list|(
literal|32
operator|-
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|+
operator|(
name|offset
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|pbitnum
operator|=
name|GEN_INT
argument_list|(
operator|(
name|offset
operator|&
literal|3
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Similar, but just get the address.  Handle the two reload cases.      Add EXTRA_OFFSET to the address we return.  */
end_comment

begin_function
name|rtx
name|get_unaligned_address
parameter_list|(
name|ref
parameter_list|,
name|extra_offset
parameter_list|)
name|rtx
name|ref
decl_stmt|;
name|int
name|extra_offset
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
name|extra_offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* On the Alpha, all (non-symbolic) constants except zero go into    a floating-point register via memory.  Note that we cannot     return anything that is not a subset of CLASS, and that some    symbolic constants cannot be dropped to memory.  */
end_comment

begin_function
name|enum
name|reg_class
name|alpha_preferred_reload_class
parameter_list|(
name|x
parameter_list|,
name|class
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
comment|/* Zero is present in any register class.  */
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|class
return|;
comment|/* These sorts of constants we can easily drop to memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|FLOAT_REGS
condition|)
return|return
name|NO_REGS
return|;
if|if
condition|(
name|class
operator|==
name|ALL_REGS
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
name|class
return|;
block|}
comment|/* All other kinds of constants should not (and in the case of HIGH      cannot) be dropped to memory -- instead we use a GENERAL_REGS      secondary reload.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|class
operator|==
name|ALL_REGS
condition|?
name|GENERAL_REGS
else|:
name|class
operator|)
return|;
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* Loading and storing HImode or QImode values to and from memory    usually requires a scratch register.  The exceptions are loading    QImode and HImode from an aligned address to a general register    unless byte instructions are permitted.      We also cannot load an unaligned address or a paradoxical SUBREG    into an FP register.      We also cannot do integral arithmetic into FP regs, as might result    from register elimination into a DImode fp register.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|x
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|in
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|)
operator|&&
operator|!
name|TARGET_BWX
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|in
operator|||
operator|!
name|aligned_memory_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|GENERAL_REGS
return|;
block|}
block|}
if|if
condition|(
name|class
operator|==
name|FLOAT_REGS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
return|return
name|GENERAL_REGS
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|GENERAL_REGS
return|;
if|if
condition|(
name|in
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
operator|(
name|memory_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|||
name|x
operator|==
name|const0_rtx
operator|)
condition|)
return|return
name|GENERAL_REGS
return|;
block|}
return|return
name|NO_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subfunction of the following function.  Update the flags of any MEM    found in part of X.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_set_memflags_1
parameter_list|(
name|x
parameter_list|,
name|in_struct_p
parameter_list|,
name|volatile_p
parameter_list|,
name|unchanging_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|in_struct_p
decl_stmt|,
name|volatile_p
decl_stmt|,
name|unchanging_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SEQUENCE
case|:
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|alpha_set_memflags_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|alpha_set_memflags_1
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|alpha_set_memflags_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
name|alpha_set_memflags_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|volatile_p
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
comment|/* Sadly, we cannot use alias sets because the extra aliasing 	 produced by the AND interferes.  Given that two-byte quantities 	 are the only thing we would be able to differentiate anyway, 	 there does not seem to be any point in convoluting the early 	 out of the alias check.  */
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given INSN, which is either an INSN or a SEQUENCE generated to    perform a memory operation, look for any MEMs in either a SET_DEST or    a SET_SRC and copy the in-struct, unchanging, and volatile flags from    REF into each of the MEMs found.  If REF is not a MEM, don't do    anything.  */
end_comment

begin_function
name|void
name|alpha_set_memflags
parameter_list|(
name|insn
parameter_list|,
name|ref
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ref
decl_stmt|;
block|{
name|int
name|in_struct_p
decl_stmt|,
name|volatile_p
decl_stmt|,
name|unchanging_p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|in_struct_p
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|volatile_p
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|unchanging_p
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* This is only called from alpha.md, after having had something       generated from one of the insn patterns.  So if everything is      zero, the pattern is already up-to-date.  */
if|if
condition|(
operator|!
name|in_struct_p
operator|&&
operator|!
name|volatile_p
operator|&&
operator|!
name|unchanging_p
condition|)
return|return;
name|alpha_set_memflags_1
argument_list|(
name|insn
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to output insns to set TARGET equal to the constant C if it can be    done in less than N insns.  Do all computations in MODE.  Returns the place    where the output has been placed if it can be done and the insns have been    emitted.  If it would take more than N insns, zero is returned and no    insns and emitted.  */
end_comment

begin_function
name|rtx
name|alpha_emit_set_const
parameter_list|(
name|target
parameter_list|,
name|mode
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Try 1 insn, then 2, then up to N.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pat
operator|=
name|alpha_emit_set_const_1
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|pat
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internal routine for the above to check for N or below insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|alpha_emit_set_const_1
parameter_list|(
name|target
parameter_list|,
name|mode
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
comment|/* Use a pseudo if highly optimizing and still generating RTL.  */
name|rtx
name|subtarget
init|=
operator|(
name|flag_expensive_optimizations
operator|&&
name|rtx_equal_function_value_matters
condition|?
literal|0
else|:
name|target
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
comment|/* We are only called for SImode and DImode.  If this is SImode, ensure that      we are sign extended to a full word.  This does not make any sense when      cross-compiling on a narrow machine.  */
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|c
operator|=
operator|(
operator|(
name|c
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
endif|#
directive|endif
comment|/* If this is a sign-extended 32-bit constant, we can do this in at most      three insns, so do it if we have enough insns left.  We always have      a sign-extended 32-bit constant when compiling on a narrow machine.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
operator|||
name|c
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|c
operator|>>
literal|31
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|c
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|c
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|extra
init|=
literal|0
decl_stmt|;
comment|/* If HIGH will be interpreted as negative but the constant is 	 positive, we must adjust it to do two ldha insns.  */
if|if
condition|(
operator|(
name|high
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|low
operator|||
operator|(
name|low
operator|==
literal|0
operator|&&
name|extra
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* We used to use copy_to_suggested_reg (GEN_INT (c), target, mode) 	     but that meant that we can't handle INT_MIN on 32-bit machines 	     (like NT/Alpha), because we recurse indefinitely through  	     emit_move_insn to gen_movdi.  So instead, since we know exactly 	     what we want, create it explicitly.  */
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
literal|2
operator|+
operator|(
name|extra
operator|!=
literal|0
operator|)
condition|)
block|{
name|temp
operator|=
name|copy_to_suggested_reg
argument_list|(
name|GEN_INT
argument_list|(
name|high
operator|<<
literal|16
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|extra
operator|<<
literal|16
argument_list|)
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
block|}
block|}
comment|/* If we couldn't do it that way, try some other methods.  But if we have      no instructions left, don't bother.  Likewise, if this is SImode and      we can't make pseudos, we can't do anything since the expand_binop      and expand_unop calls will widen and try to make pseudos.  */
if|if
condition|(
name|n
operator|==
literal|1
operator|||
operator|(
name|mode
operator|==
name|SImode
operator|&&
operator|!
name|rtx_equal_function_value_matters
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Next, see if we can load a related constant and then shift and possibly      negate it to get the constant we want.  Try this once each increasing      numbers of insns.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* First, see if minus some low bits, we've an easy load of 	 high bits.  */
name|new
operator|=
operator|(
operator|(
name|c
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|-
name|new
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|new
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Next try complementing.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|~
name|c
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|temp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Next try to form a constant and do a left shift.  We can do this 	 if some low-order bits are zero; the exact_log2 call below tells 	 us that information.  The bits we are shifting out could be any 	 value, but here we'll just try the 0- and sign-extended forms of 	 the constant.  To try to increase the chance of having the same 	 constant in more than one insn, start at the highest number of 	 bits to shift, but try all possibilities in case a ZAPNOT will 	 be useful.  */
if|if
condition|(
operator|(
name|bits
operator|=
name|exact_log2
argument_list|(
name|c
operator|&
operator|-
name|c
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|c
operator|)
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashl_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Now try high-order zero bits.  Here we try the shifted-in bits as 	 all zero and all ones.  Be careful to avoid shifting outside the 	 mode and to avoid shifting outside the host wide int size.  */
comment|/* On narrow hosts, don't shift a 1 into the high bit, since we'll 	 confuse the recursive call and set all of the high 32 bits.  */
if|if
condition|(
operator|(
name|bits
operator|=
operator|(
name|MIN
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
literal|8
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|c
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|)
operator|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|lshr_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Now try high-order 1 bits.  We get that with a sign-extension. 	 But one bit isn't enough here.  Be careful to avoid shifting outside 	 the mode and to avoid shifting outside the host wide int size.  */
if|if
condition|(
operator|(
name|bits
operator|=
operator|(
name|MIN
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
literal|8
argument_list|)
operator|-
name|floor_log2
argument_list|(
operator|~
name|c
argument_list|)
operator|-
literal|2
operator|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
block|}
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
comment|/* Finally, see if can load a value into the target that is the same as the      constant except that all bytes that are 0 are changed to be 0xff.  If we      can, then we can do a ZAPNOT to obtain the desired constant.  */
name|new
operator|=
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|+=
literal|8
control|)
if|if
condition|(
operator|(
name|new
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|new
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
expr_stmt|;
comment|/* We are only called for SImode and DImode.  If this is SImode, ensure that      we are sign extended to a full word.  */
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|new
operator|=
operator|(
operator|(
name|new
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|c
operator|&&
name|new
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|new
argument_list|,
name|n
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|c
operator||
operator|~
name|new
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Having failed to find a 3 insn sequence in alpha_emit_set_const,    fall back to a straight forward decomposition.  We do this to avoid    exponential run times encountered when looking for longer sequences    with alpha_emit_set_const.  */
end_comment

begin_function
name|rtx
name|alpha_emit_set_long_const
parameter_list|(
name|target
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|HOST_WIDE_INT
name|c1
decl_stmt|,
name|c2
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|;
comment|/* Decompose the entire word */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|c2
operator|!=
operator|-
operator|(
name|c1
operator|<
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|d1
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d1
expr_stmt|;
name|d2
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
name|c1
operator|=
operator|(
name|c1
operator|-
name|d2
operator|)
operator|>>
literal|32
expr_stmt|;
name|d3
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d3
expr_stmt|;
name|d4
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|d4
condition|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|d1
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d1
expr_stmt|;
name|d2
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|d2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|c2
operator|+=
operator|(
name|d2
operator|<
literal|0
operator|)
expr_stmt|;
name|d3
operator|=
operator|(
operator|(
name|c2
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c2
operator|-=
name|d3
expr_stmt|;
name|d4
operator|=
operator|(
operator|(
name|c2
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c2
operator|!=
name|d4
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Construct the high word */
if|if
condition|(
name|d4
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d3
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shift it into place */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add in the low bits.  */
if|if
condition|(
name|d2
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a move instruction; return true if all work is done.    We don't handle non-bwx subword loads here.  */
end_comment

begin_function
name|bool
name|alpha_expand_mov
parameter_list|(
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* If the output is not a register, the input must be.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|reg_or_0_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Allow legitimize_address to perform some simplifications.  */
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
name|symbolic_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|alpha_legitimize_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Early out for non-constants and valid constants.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|input_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Split large integers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|i0
decl_stmt|,
name|i1
decl_stmt|;
name|rtx
name|temp
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|i0
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i1
operator|=
operator|-
operator|(
name|i0
operator|<
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
block|{
name|i0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i1
operator|=
operator|-
operator|(
name|i0
operator|<
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|i0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|i1
operator|==
operator|-
operator|(
name|i0
operator|<
literal|0
operator|)
condition|)
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|,
name|i0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
operator|&&
name|TARGET_BUILD_CONSTANTS
condition|)
name|temp
operator|=
name|alpha_emit_set_long_const
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|temp
argument_list|)
condition|)
return|return
name|true
return|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Otherwise we've nothing left but to drop the thing to memory.  */
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|copy_rtx
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|operands
index|[
literal|1
index|]
operator|=
name|validize_mem
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Expand a non-bwx QImode or HImode move instruction;    return true if all work is done.  */
end_comment

begin_function
name|bool
name|alpha_expand_mov_nobwx
parameter_list|(
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* If the output is not a register, the input must be.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Handle four memory cases, unaligned and aligned for either the input      or the output.  The only case where we can be called during reload is      for aligned loads; all other cases require temporaries.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
if|if
condition|(
name|aligned_memory_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|QImode
condition|?
name|gen_reload_inqi_help
else|:
name|gen_reload_inhi_help
operator|)
operator|(
name|operands
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|1
index|]
operator|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|aligned_mem
decl_stmt|,
name|bitnum
decl_stmt|;
name|rtx
name|scratch
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|get_aligned_mem
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|aligned_mem
argument_list|,
operator|&
name|bitnum
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|QImode
condition|?
name|gen_aligned_loadqi
else|:
name|gen_aligned_loadhi
operator|)
operator|(
name|operands
index|[
literal|0
index|]
operator|,
name|aligned_mem
operator|,
name|bitnum
operator|,
name|scratch
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Don't pass these as parameters since that makes the generated 	     code depend on parameter evaluation order which will cause 	     bootstrap failures.  */
name|rtx
name|temp1
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp2
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|seq
init|=
operator|(
operator|(
name|mode
operator|==
name|QImode
condition|?
name|gen_unaligned_loadqi
else|:
name|gen_unaligned_loadhi
operator|)
operator|(
name|operands
index|[
literal|0
index|]
expr|,
name|get_unaligned_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr|,
name|temp1
expr|,
name|temp2
operator|)
operator|)
decl_stmt|;
name|alpha_set_memflags
argument_list|(
name|seq
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
if|if
condition|(
name|aligned_memory_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|aligned_mem
decl_stmt|,
name|bitnum
decl_stmt|;
name|rtx
name|temp1
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|temp2
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|get_aligned_mem
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
operator|&
name|aligned_mem
argument_list|,
operator|&
name|bitnum
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_aligned_store
argument_list|(
name|aligned_mem
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|bitnum
argument_list|,
name|temp1
argument_list|,
name|temp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|temp1
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp2
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp3
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|seq
init|=
operator|(
operator|(
name|mode
operator|==
name|QImode
condition|?
name|gen_unaligned_storeqi
else|:
name|gen_unaligned_storehi
operator|)
operator|(
name|get_unaligned_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr|,
name|operands
index|[
literal|1
index|]
expr|,
name|temp1
expr|,
name|temp2
expr|,
name|temp3
operator|)
operator|)
decl_stmt|;
name|alpha_set_memflags
argument_list|(
name|seq
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Generate an unsigned DImode to FP conversion.  This is the same code    optabs would emit if we didn't have TFmode patterns.     For SFmode, this is the only construction I've found that can pass    gcc.c-torture/execute/ieee/rbug.c.  No scenario that uses DFmode    intermediates will work, because you'll get intermediate rounding    that ruins the end result.  Some of this could be fixed by turning    on round-to-positive-infinity, but that requires diddling the fpsr,    which kills performance.  I tried turning this around and converting    to a negative number, so that I could turn on /m, but either I did    it wrong or there's something else cause I wound up with the exact    same single-bit error.  There is a branch-less form of this same code:  	srl     $16,1,$1 	and     $16,1,$2 	cmplt   $16,0,$3 	or      $1,$2,$2 	cmovge  $16,$16,$2 	itoft	$3,$f10 	itoft	$2,$f11 	cvtqs   $f11,$f11 	adds    $f11,$f11,$f0 	fcmoveq $f10,$f11,$f0     I'm not using it because it's the same number of instructions as    this branch-full form, and it has more serialized long latency    instructions on the critical path.     For DFmode, we can avoid rounding errors by breaking up the word    into two pieces, converting them separately, and adding them back:     LC0: .long 0,0x5f800000  	itoft	$16,$f11 	lda	$2,LC0 	cmplt	$16,0,$1 	cpyse	$f11,$f31,$f10 	cpyse	$f31,$f11,$f11 	s4addq	$1,$2,$1 	lds	$f12,0($1) 	cvtqt	$f10,$f10 	cvtqt	$f11,$f11 	addt	$f12,$f10,$f0 	addt	$f0,$f11,$f0     This doesn't seem to be a clear-cut win over the optabs form.    It probably all depends on the distribution of numbers being    converted -- in the optabs form, all but high-bit-set has a    much lower minimum execution time.  */
end_comment

begin_function
name|void
name|alpha_emit_floatuns
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
block|{
name|rtx
name|neglab
decl_stmt|,
name|donelab
decl_stmt|,
name|i0
decl_stmt|,
name|i1
decl_stmt|,
name|f0
decl_stmt|,
name|in
decl_stmt|,
name|out
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|in
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|neglab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|donelab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i0
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|i1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|f0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|in
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|const0_rtx
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|mode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|donelab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|i0
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|i1
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iordi3
argument_list|(
name|i0
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|f0
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|mode
argument_list|,
name|i0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|f0
argument_list|,
name|f0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|donelab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the comparison for a conditional branch.  */
end_comment

begin_function
name|rtx
name|alpha_emit_conditional_branch
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|cmp_code
decl_stmt|,
name|branch_code
decl_stmt|;
name|enum
name|machine_mode
name|cmp_mode
decl_stmt|,
name|branch_mode
init|=
name|VOIDmode
decl_stmt|;
name|rtx
name|op0
init|=
name|alpha_compare
operator|.
name|op0
decl_stmt|,
name|op1
init|=
name|alpha_compare
operator|.
name|op1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|alpha_compare
operator|.
name|fp_p
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAS_XFLOATING_LIBS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* X_floating library comparison functions return 	   -1  unordered 	    0  false 	    1  true 	 Convert the compare against the raw return value.  */
if|if
condition|(
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|ORDERED
condition|)
name|cmp_code
operator|=
name|EQ
expr_stmt|;
else|else
name|cmp_code
operator|=
name|code
expr_stmt|;
name|op0
operator|=
name|alpha_emit_xfloating_compare
argument_list|(
name|cmp_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|alpha_compare
operator|.
name|fp_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNORDERED
condition|)
name|code
operator|=
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ORDERED
condition|)
name|code
operator|=
name|GE
expr_stmt|;
else|else
name|code
operator|=
name|GT
expr_stmt|;
block|}
comment|/* The general case: fold the comparison code to the types of compares      that we have, choosing the branch as necessary.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|UNORDERED
case|:
comment|/* We have these compares: */
name|cmp_code
operator|=
name|code
operator|,
name|branch_code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|ORDERED
case|:
comment|/* These must be reversed.  */
name|cmp_code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|branch_code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* For FP, we swap them, for INT, we reverse them.  */
if|if
condition|(
name|alpha_compare
operator|.
name|fp_p
condition|)
block|{
name|cmp_code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|branch_code
operator|=
name|NE
expr_stmt|;
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
else|else
block|{
name|cmp_code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|branch_code
operator|=
name|EQ
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|alpha_compare
operator|.
name|fp_p
condition|)
block|{
name|cmp_mode
operator|=
name|DFmode
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
comment|/* When we are not as concerned about non-finite values, and we 	     are comparing against zero, we can branch directly.  */
if|if
condition|(
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
condition|)
name|cmp_code
operator|=
name|NIL
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
condition|)
block|{
comment|/* Undo the swap we probably did just above.  */
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|branch_code
operator|=
name|swap_condition
argument_list|(
name|cmp_code
argument_list|)
expr_stmt|;
name|cmp_code
operator|=
name|NIL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ??? We mark the the branch mode to be CCmode to prevent the 	     compare and branch from being combined, since the compare  	     insn follows IEEE rules that the branch does not.  */
name|branch_mode
operator|=
name|CCmode
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmp_mode
operator|=
name|DImode
expr_stmt|;
comment|/* The following optimizations are only for signed compares.  */
if|if
condition|(
name|code
operator|!=
name|LEU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|GTU
condition|)
block|{
comment|/* Whee.  Compare and branch against 0 directly.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
name|cmp_code
operator|=
name|NIL
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
comment|/* We want to use cmpcc/bcc when we can, since there is a zero delay 	     bypass between logicals and br/cmov on EV5.  But we don't want to 	     force valid immediate constants into registers needlessly.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|v
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|,
name|n
init|=
operator|-
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|v
argument_list|,
literal|'I'
argument_list|)
operator|&&
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|n
argument_list|,
literal|'K'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|n
argument_list|,
literal|'L'
argument_list|)
operator|)
condition|)
block|{
name|cmp_code
operator|=
name|PLUS
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|reg_or_0_operand
argument_list|(
name|op0
argument_list|,
name|DImode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_code
operator|!=
name|PLUS
operator|&&
operator|!
name|reg_or_8bit_operand
argument_list|(
name|op1
argument_list|,
name|DImode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Emit an initial compare instruction, if necessary.  */
name|tem
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|cmp_code
operator|!=
name|NIL
condition|)
block|{
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|cmp_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|cmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Zero the operands.  */
name|memset
argument_list|(
operator|&
name|alpha_compare
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alpha_compare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the branch comparison.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|branch_code
argument_list|,
name|branch_mode
argument_list|,
name|tem
argument_list|,
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Certain simplifications can be done to make invalid setcc operations    valid.  Return the final comparison, or NULL if we can't work.  */
end_comment

begin_function
name|rtx
name|alpha_emit_setcc
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
name|rtx
name|op0
init|=
name|alpha_compare
operator|.
name|op0
decl_stmt|,
name|op1
init|=
name|alpha_compare
operator|.
name|op1
decl_stmt|;
name|int
name|fp_p
init|=
name|alpha_compare
operator|.
name|fp_p
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* Zero the operands.  */
name|memset
argument_list|(
operator|&
name|alpha_compare
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alpha_compare
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_p
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAS_XFLOATING_LIBS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* X_floating library comparison functions return 	   -1  unordered 	    0  false 	    1  true 	 Convert the compare against the raw return value.  */
if|if
condition|(
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|ORDERED
condition|)
name|cmp_code
operator|=
name|EQ
expr_stmt|;
else|else
name|cmp_code
operator|=
name|code
expr_stmt|;
name|op0
operator|=
name|alpha_emit_xfloating_compare
argument_list|(
name|cmp_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|fp_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNORDERED
condition|)
name|code
operator|=
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ORDERED
condition|)
name|code
operator|=
name|GE
expr_stmt|;
else|else
name|code
operator|=
name|GT
expr_stmt|;
block|}
if|if
condition|(
name|fp_p
operator|&&
operator|!
name|TARGET_FIX
condition|)
return|return
name|NULL_RTX
return|;
comment|/* The general case: fold the comparison code to the types of compares      that we have, choosing the branch as necessary.  */
name|cmp_code
operator|=
name|NIL
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|UNORDERED
case|:
comment|/* We have these compares.  */
if|if
condition|(
name|fp_p
condition|)
name|cmp_code
operator|=
name|code
operator|,
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
operator|!
name|fp_p
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|ORDERED
case|:
name|cmp_code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* These normally need swapping, but for integer zero we have 	 special patterns that recognize swapped operands.  */
if|if
condition|(
operator|!
name|fp_p
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
break|break;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_p
condition|)
name|cmp_code
operator|=
name|code
operator|,
name|code
operator|=
name|NE
expr_stmt|;
name|tmp
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fp_p
condition|)
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|DImode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_or_8bit_operand
argument_list|(
name|op1
argument_list|,
name|DImode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Emit an initial compare instruction, if necessary.  */
if|if
condition|(
name|cmp_code
operator|!=
name|NIL
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|fp_p
condition|?
name|DFmode
else|:
name|DImode
decl_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|fp_p
condition|?
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
else|:
name|tmp
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* Return the setcc comparison.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|DImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rewrite a comparison against zero CMP of the form    (CODE (cc0) (const_int 0)) so it can be written validly in    a conditional move (if_then_else CMP ...).    If both of the operands that set cc0 are non-zero we must emit    an insn to perform the compare (it can't be done within    the conditional move).  */
end_comment

begin_function
name|rtx
name|alpha_emit_conditional_move
parameter_list|(
name|cmp
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|cmp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|cmp
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|cmov_code
init|=
name|NE
decl_stmt|;
name|rtx
name|op0
init|=
name|alpha_compare
operator|.
name|op0
decl_stmt|;
name|rtx
name|op1
init|=
name|alpha_compare
operator|.
name|op1
decl_stmt|;
name|int
name|fp_p
init|=
name|alpha_compare
operator|.
name|fp_p
decl_stmt|;
name|enum
name|machine_mode
name|cmp_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|cmp_op_mode
init|=
name|fp_p
condition|?
name|DFmode
else|:
name|DImode
decl_stmt|;
name|enum
name|machine_mode
name|cmov_mode
init|=
name|VOIDmode
decl_stmt|;
name|int
name|local_fast_math
init|=
name|flag_unsafe_math_optimizations
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* Zero the operands.  */
name|memset
argument_list|(
operator|&
name|alpha_compare
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alpha_compare
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_p
operator|!=
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_FIX
condition|)
return|return
literal|0
return|;
comment|/* If we have fp<->int register move instructions, do a cmov by 	 performing the comparison in fp registers, and move the 	 zero/non-zero value to integer registers, where we can then 	 use a normal cmov, or vice-versa.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
comment|/* We have these compares.  */
name|cmp_code
operator|=
name|code
operator|,
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
comment|/* This must be reversed.  */
name|cmp_code
operator|=
name|EQ
operator|,
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* These normally need swapping, but for integer zero we have 	     special patterns that recognize swapped operands.  */
if|if
condition|(
operator|!
name|fp_p
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
name|cmp_code
operator|=
name|code
operator|,
name|code
operator|=
name|NE
expr_stmt|;
else|else
block|{
name|cmp_code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|cmp_op_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tem
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|cmp_op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cmp_mode
operator|=
name|cmp_op_mode
operator|=
name|fp_p
condition|?
name|DImode
else|:
name|DFmode
expr_stmt|;
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|cmp_op_mode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|cmp_op_mode
argument_list|)
expr_stmt|;
name|fp_p
operator|=
operator|!
name|fp_p
expr_stmt|;
name|local_fast_math
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We may be able to use a conditional move directly.      This avoids emitting spurious compares.  */
if|if
condition|(
name|signed_comparison_operator
argument_list|(
name|cmp
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|(
operator|!
name|fp_p
operator|||
name|local_fast_math
operator|)
operator|&&
operator|(
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
operator|||
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* We can't put the comparison inside the conditional move;      emit a compare instruction and put that inside the      conditional move.  Make sure we emit only comparisons we have;      swap or reverse as necessary.  */
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|NULL_RTX
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
comment|/* We have these compares: */
break|break;
case|case
name|NE
case|:
comment|/* This must be reversed.  */
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|cmov_code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* These must be swapped.  */
if|if
condition|(
name|op1
operator|!=
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
condition|)
block|{
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fp_p
condition|)
block|{
if|if
condition|(
operator|!
name|reg_or_0_operand
argument_list|(
name|op0
argument_list|,
name|DImode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_or_8bit_operand
argument_list|(
name|op1
argument_list|,
name|DImode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* ??? We mark the branch mode to be CCmode to prevent the compare      and cmov from being combined, since the compare insn follows IEEE      rules that the cmov does not.  */
if|if
condition|(
name|fp_p
operator|&&
operator|!
name|local_fast_math
condition|)
name|cmov_mode
operator|=
name|CCmode
expr_stmt|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|cmp_op_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|cmp_op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|cmov_code
argument_list|,
name|cmov_mode
argument_list|,
name|tem
argument_list|,
name|CONST0_RTX
argument_list|(
name|cmp_op_mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Simplify a conditional move of two constants into a setcc with    arithmetic.  This is done with a splitter since combine would    just undo the work if done during code generation.  It also catches    cases we wouldn't have before cse.  */
end_comment

begin_function
name|int
name|alpha_split_conditional_move
parameter_list|(
name|code
parameter_list|,
name|dest
parameter_list|,
name|cond
parameter_list|,
name|t_rtx
parameter_list|,
name|f_rtx
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|cond
decl_stmt|,
name|t_rtx
decl_stmt|,
name|f_rtx
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|t
decl_stmt|,
name|f
decl_stmt|,
name|diff
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|subtarget
decl_stmt|,
name|tmp
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|t
operator|=
name|INTVAL
argument_list|(
name|t_rtx
argument_list|)
expr_stmt|;
name|f
operator|=
name|INTVAL
argument_list|(
name|f_rtx
argument_list|)
expr_stmt|;
name|diff
operator|=
name|t
operator|-
name|f
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|diff
operator|<
literal|0
operator|)
operator|||
operator|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GT
operator|)
condition|)
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|diff
operator|=
name|t
operator|,
name|t
operator|=
name|f
operator|,
name|f
operator|=
name|diff
expr_stmt|;
name|diff
operator|=
name|t
operator|-
name|f
expr_stmt|;
block|}
name|subtarget
operator|=
name|target
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DImode
condition|)
block|{
name|target
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
else|else
name|subtarget
operator|=
name|target
expr_stmt|;
block|}
comment|/* Below, we must be careful to use copy_rtx on target and subtarget      in intermediate insns, as they may be a subreg rtx, which may not      be shared.  */
if|if
condition|(
name|f
operator|==
literal|0
operator|&&
name|exact_log2
argument_list|(
name|diff
argument_list|)
operator|>
literal|0
comment|/* On EV6, we've got enough shifters to make non-arithmatic shifts 	 viable over a longer latency cmove.  On EV5, the E0 slot is a 	 scarce resource, and on EV4 shift has the same latency as a cmove.  */
operator|&&
operator|(
name|diff
operator|<=
literal|8
operator|||
name|alpha_cpu
operator|==
name|PROCESSOR_EV6
operator|)
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|DImode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|exact_log2
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
literal|0
operator|&&
name|t
operator|==
operator|-
literal|1
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|DImode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_negdi2
argument_list|(
name|target
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
literal|1
operator|||
name|diff
operator|==
literal|4
operator|||
name|diff
operator|==
literal|8
condition|)
block|{
name|rtx
name|add_op
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|DImode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|target
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|add_op
operator|=
name|GEN_INT
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|sext_add_operand
argument_list|(
name|add_op
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_MULT
argument_list|(
name|DImode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|,
name|add_op
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up the function X_floating library function name for the    given operation.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alpha_lookup_xfloating_lib_func
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
struct|struct
name|xfloating_op
block|{
specifier|const
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|func
decl_stmt|;
block|}
struct|;
specifier|static
specifier|const
name|struct
name|xfloating_op
name|vms_xfloating_ops
index|[]
init|=
block|{
block|{
name|PLUS
block|,
literal|"OTS$ADD_X"
block|}
block|,
block|{
name|MINUS
block|,
literal|"OTS$SUB_X"
block|}
block|,
block|{
name|MULT
block|,
literal|"OTS$MUL_X"
block|}
block|,
block|{
name|DIV
block|,
literal|"OTS$DIV_X"
block|}
block|,
block|{
name|EQ
block|,
literal|"OTS$EQL_X"
block|}
block|,
block|{
name|NE
block|,
literal|"OTS$NEQ_X"
block|}
block|,
block|{
name|LT
block|,
literal|"OTS$LSS_X"
block|}
block|,
block|{
name|LE
block|,
literal|"OTS$LEQ_X"
block|}
block|,
block|{
name|GT
block|,
literal|"OTS$GTR_X"
block|}
block|,
block|{
name|GE
block|,
literal|"OTS$GEQ_X"
block|}
block|,
block|{
name|FIX
block|,
literal|"OTS$CVTXQ"
block|}
block|,
block|{
name|FLOAT
block|,
literal|"OTS$CVTQX"
block|}
block|,
block|{
name|UNSIGNED_FLOAT
block|,
literal|"OTS$CVTQUX"
block|}
block|,
block|{
name|FLOAT_EXTEND
block|,
literal|"OTS$CVT_FLOAT_T_X"
block|}
block|,
block|{
name|FLOAT_TRUNCATE
block|,
literal|"OTS$CVT_FLOAT_X_T"
block|}
block|,     }
decl_stmt|;
specifier|static
specifier|const
name|struct
name|xfloating_op
name|osf_xfloating_ops
index|[]
init|=
block|{
block|{
name|PLUS
block|,
literal|"_OtsAddX"
block|}
block|,
block|{
name|MINUS
block|,
literal|"_OtsSubX"
block|}
block|,
block|{
name|MULT
block|,
literal|"_OtsMulX"
block|}
block|,
block|{
name|DIV
block|,
literal|"_OtsDivX"
block|}
block|,
block|{
name|EQ
block|,
literal|"_OtsEqlX"
block|}
block|,
block|{
name|NE
block|,
literal|"_OtsNeqX"
block|}
block|,
block|{
name|LT
block|,
literal|"_OtsLssX"
block|}
block|,
block|{
name|LE
block|,
literal|"_OtsLeqX"
block|}
block|,
block|{
name|GT
block|,
literal|"_OtsGtrX"
block|}
block|,
block|{
name|GE
block|,
literal|"_OtsGeqX"
block|}
block|,
block|{
name|FIX
block|,
literal|"_OtsCvtXQ"
block|}
block|,
block|{
name|FLOAT
block|,
literal|"_OtsCvtQX"
block|}
block|,
block|{
name|UNSIGNED_FLOAT
block|,
literal|"_OtsCvtQUX"
block|}
block|,
block|{
name|FLOAT_EXTEND
block|,
literal|"_OtsConvertFloatTX"
block|}
block|,
block|{
name|FLOAT_TRUNCATE
block|,
literal|"_OtsConvertFloatXT"
block|}
block|,     }
decl_stmt|;
specifier|const
name|struct
name|xfloating_op
modifier|*
name|ops
decl_stmt|;
specifier|const
name|long
name|n
init|=
name|ARRAY_SIZE
argument_list|(
name|osf_xfloating_ops
argument_list|)
decl_stmt|;
name|long
name|i
decl_stmt|;
comment|/* How irritating.  Nothing to key off for the table.  Hardcode      knowledge of the G_floating routines.  */
if|if
condition|(
name|TARGET_FLOAT_VAX
condition|)
block|{
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|FLOAT_EXTEND
condition|)
return|return
literal|"OTS$CVT_FLOAT_G_X"
return|;
if|if
condition|(
name|code
operator|==
name|FLOAT_TRUNCATE
condition|)
return|return
literal|"OTS$CVT_FLOAT_X_G"
return|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|FLOAT_EXTEND
condition|)
return|return
literal|"_OtsConvertFloatGX"
return|;
if|if
condition|(
name|code
operator|==
name|FLOAT_TRUNCATE
condition|)
return|return
literal|"_OtsConvertFloatXG"
return|;
block|}
block|}
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|ops
operator|=
name|vms_xfloating_ops
expr_stmt|;
else|else
name|ops
operator|=
name|osf_xfloating_ops
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ops
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
name|ops
index|[
name|i
index|]
operator|.
name|func
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Most X_floating operations take the rounding mode as an argument.    Compute that here.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_compute_xfloating_mode_arg
parameter_list|(
name|code
parameter_list|,
name|round
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|alpha_fp_rounding_mode
name|round
decl_stmt|;
block|{
name|int
name|mode
decl_stmt|;
switch|switch
condition|(
name|round
condition|)
block|{
case|case
name|ALPHA_FPRM_NORM
case|:
name|mode
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ALPHA_FPRM_MINF
case|:
name|mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ALPHA_FPRM_CHOP
case|:
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ALPHA_FPRM_DYN
case|:
name|mode
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* XXX For reference, round to +inf is mode = 3.  */
block|}
if|if
condition|(
name|code
operator|==
name|FLOAT_TRUNCATE
operator|&&
name|alpha_fptm
operator|==
name|ALPHA_FPTM_N
condition|)
name|mode
operator||=
literal|0x10000
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Emit an X_floating library function call.     Note that these functions do not follow normal calling conventions:    TFmode arguments are passed in two integer registers (as opposed to    indirect); TFmode return values appear in R16+R17.      FUNC is the function name to call.    TARGET is where the output belongs.    OPERANDS are the inputs.    NOPERANDS is the count of inputs.    EQUIV is the expression equivalent for the function. */
end_comment

begin_function
specifier|static
name|void
name|alpha_emit_xfloating_libcall
parameter_list|(
name|func
parameter_list|,
name|target
parameter_list|,
name|operands
parameter_list|,
name|noperands
parameter_list|,
name|equiv
parameter_list|)
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|rtx
name|equiv
decl_stmt|;
block|{
name|rtx
name|usage
init|=
name|NULL_RTX
decl_stmt|,
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|regno
init|=
literal|16
decl_stmt|,
name|i
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
name|TFmode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|TFmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regno
operator|+
literal|32
argument_list|)
expr_stmt|;
name|regno
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|VOIDmode
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|DImode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|usage
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|TFmode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|TFmode
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
operator|(
name|char
operator|*
operator|)
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_call_insn
argument_list|(
name|GEN_CALL_VALUE
argument_list|(
name|reg
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|tmp
argument_list|)
operator|=
name|usage
expr_stmt|;
name|tmp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|tmp
argument_list|,
name|target
argument_list|,
name|reg
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an X_floating library function call for arithmetic (+,-,*,/).  */
end_comment

begin_function
name|void
name|alpha_emit_xfloating_arith
parameter_list|(
name|code
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|rtx
name|out_operands
index|[
literal|3
index|]
decl_stmt|;
name|func
operator|=
name|alpha_lookup_xfloating_lib_func
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|mode
operator|=
name|alpha_compute_xfloating_mode_arg
argument_list|(
name|code
argument_list|,
name|alpha_fprm
argument_list|)
expr_stmt|;
name|out_operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|out_operands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|out_operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|alpha_emit_xfloating_libcall
argument_list|(
name|func
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|out_operands
argument_list|,
literal|3
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|TFmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an X_floating library function call for a comparison.  */
end_comment

begin_function
specifier|static
name|rtx
name|alpha_emit_xfloating_compare
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|rtx
name|out
decl_stmt|,
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|func
operator|=
name|alpha_lookup_xfloating_lib_func
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|out
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
comment|/* ??? Strange mode for equiv because what's actually returned      is -1,0,1, not a proper boolean value.  */
name|alpha_emit_xfloating_libcall
argument_list|(
name|func
argument_list|,
name|out
argument_list|,
name|operands
argument_list|,
literal|2
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|CCmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/* Emit an X_floating library function call for a conversion.  */
end_comment

begin_function
name|void
name|alpha_emit_xfloating_cvt
parameter_list|(
name|code
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|int
name|noperands
init|=
literal|1
decl_stmt|,
name|mode
decl_stmt|;
name|rtx
name|out_operands
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|func
operator|=
name|alpha_lookup_xfloating_lib_func
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|out_operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FIX
case|:
name|mode
operator|=
name|alpha_compute_xfloating_mode_arg
argument_list|(
name|code
argument_list|,
name|ALPHA_FPRM_CHOP
argument_list|)
expr_stmt|;
name|out_operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|noperands
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|mode
operator|=
name|alpha_compute_xfloating_mode_arg
argument_list|(
name|code
argument_list|,
name|alpha_fprm
argument_list|)
expr_stmt|;
name|out_operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|noperands
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|alpha_emit_xfloating_libcall
argument_list|(
name|func
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|out_operands
argument_list|,
name|noperands
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split a TFmode OP[1] into DImode OP[2,3] and likewise for    OP[0] into OP[0,1].  Naturally, output operand ordering is    little-endian.  */
end_comment

begin_function
name|void
name|alpha_split_tfmode_pair
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[
literal|4
index|]
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|operands
index|[
literal|3
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|operands
index|[
literal|3
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|CONST0_RTX
argument_list|(
name|TFmode
argument_list|)
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|3
index|]
operator|=
name|const0_rtx
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement negtf2 or abstf2.  Op0 is destination, op1 is source,     op2 is a register containing the sign bit, operation is the     logical operation to be performed.  */
end_comment

begin_function_decl
name|void
name|alpha_split_tfmode_frobsign
parameter_list|(
name|operands
parameter_list|,
name|operation
parameter_list|)
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
function_decl|rtx
parameter_list|(
function_decl|*operation
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|rtx
name|high_bit
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|scratch
decl_stmt|;
name|int
name|move
decl_stmt|;
name|alpha_split_tfmode_pair
argument_list|(
name|operands
argument_list|)
expr_stmt|;
comment|/* Detect three flavours of operand overlap.  */
name|move
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
name|move
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|high_bit
argument_list|)
condition|)
name|move
operator|=
literal|2
expr_stmt|;
else|else
name|move
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|move
operator|<
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* ??? If the destination overlaps both source tf and high_bit, then      assume source tf is dead in its entirety and use the other half      for a scratch register.  Otherwise "scratch" is just the proper      destination register.  */
name|scratch
operator|=
name|operands
index|[
name|move
operator|<
literal|2
condition|?
literal|1
else|:
literal|3
index|]
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|operation
call|)
argument_list|(
name|scratch
argument_list|,
name|high_bit
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move
operator|>
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|move
operator|>
literal|1
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Use ext[wlq][lh] as the Architecture Handbook describes for extracting    unaligned data:             unsigned:                       signed:    word:   ldq_u  r1,X(r11)                ldq_u  r1,X(r11)            ldq_u  r2,X+1(r11)              ldq_u  r2,X+1(r11)            lda    r3,X(r11)                lda    r3,X+2(r11)            extwl  r1,r3,r1                 extql  r1,r3,r1            extwh  r2,r3,r2                 extqh  r2,r3,r2            or     r1.r2.r1                 or     r1,r2,r1                                            sra    r1,48,r1     long:   ldq_u  r1,X(r11)                ldq_u  r1,X(r11)            ldq_u  r2,X+3(r11)              ldq_u  r2,X+3(r11)            lda    r3,X(r11)                lda    r3,X(r11)            extll  r1,r3,r1                 extll  r1,r3,r1            extlh  r2,r3,r2                 extlh  r2,r3,r2            or     r1.r2.r1                 addl   r1,r2,r1     quad:   ldq_u  r1,X(r11)            ldq_u  r2,X+7(r11)            lda    r3,X(r11)            extql  r1,r3,r1            extqh  r2,r3,r2            or     r1.r2.r1 */
end_comment

begin_function
name|void
name|alpha_expand_unaligned_load
parameter_list|(
name|tgt
parameter_list|,
name|mem
parameter_list|,
name|size
parameter_list|,
name|ofs
parameter_list|,
name|sign
parameter_list|)
name|rtx
name|tgt
decl_stmt|,
name|mem
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|ofs
decl_stmt|;
name|int
name|sign
decl_stmt|;
block|{
name|rtx
name|meml
decl_stmt|,
name|memh
decl_stmt|,
name|addr
decl_stmt|,
name|extl
decl_stmt|,
name|exth
decl_stmt|,
name|tmp
decl_stmt|,
name|mema
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|meml
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|memh
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|extl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|exth
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|mema
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mema
argument_list|)
operator|==
name|LO_SUM
condition|)
name|mema
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mema
argument_list|)
expr_stmt|;
comment|/* AND addresses cannot be in any alias set, since they may implicitly      alias surrounding code.  Ideally we'd have some alias set that       covered all types except those with alignment 8 or higher.  */
name|tmp
operator|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|meml
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memh
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|sign
operator|&&
operator|(
name|size
operator|==
literal|2
operator|||
name|size
operator|==
literal|4
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extqh_be
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl_be
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|GEN_INT
argument_list|(
literal|64
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|extl
argument_list|,
name|exth
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ashr_optab
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
literal|64
operator|-
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sign
operator|&&
name|size
operator|==
literal|2
condition|)
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl_le
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|GEN_INT
argument_list|(
literal|64
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extqh_le
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must use tgt here for the target.  Alpha-vms port fails if we use 	 addr for the target, because addr is marked as a pointer and combine 	 knows that pointers are always sign-extended 32 bit values.  */
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|extl
argument_list|,
name|exth
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ashr_optab
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
literal|48
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_extwh_be
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_extlh_be
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_extqh_be
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_extxl_be
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl_le
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_extwh_le
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_extlh_le
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_extqh_le
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|addr
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|extl
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|exth
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|tgt
argument_list|)
argument_list|,
name|sign
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
name|tgt
condition|)
name|emit_move_insn
argument_list|(
name|tgt
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|tgt
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, use ins and msk instructions to perform unaligned stores.  */
end_comment

begin_function
name|void
name|alpha_expand_unaligned_store
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|,
name|ofs
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|ofs
decl_stmt|;
block|{
name|rtx
name|dstl
decl_stmt|,
name|dsth
decl_stmt|,
name|addr
decl_stmt|,
name|insl
decl_stmt|,
name|insh
decl_stmt|,
name|meml
decl_stmt|,
name|memh
decl_stmt|,
name|dsta
decl_stmt|;
name|dstl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|dsth
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|insl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|insh
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|dsta
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dsta
argument_list|)
operator|==
name|LO_SUM
condition|)
name|dsta
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|dsta
argument_list|)
expr_stmt|;
comment|/* AND addresses cannot be in any alias set, since they may implicitly      alias surrounding code.  Ideally we'd have some alias set that       covered all types except those with alignment 8 or higher.  */
name|meml
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|dsta
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|meml
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memh
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|dsta
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|memh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dsth
argument_list|,
name|memh
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dstl
argument_list|,
name|meml
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|dsta
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_inswl_be
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_insll_be
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_insql_be
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|insl
argument_list|,
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_mskxl_be
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffff
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_mskxl_be
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffffffff
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|rtx
name|msk
init|=
name|immed_double_const
argument_list|(
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|msk
init|=
name|constm1_rtx
decl_stmt|;
endif|#
directive|endif
name|emit_insn
argument_list|(
name|gen_mskxl_be
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|msk
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|dsta
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_inswl_le
argument_list|(
name|insl
argument_list|,
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_insll_le
argument_list|(
name|insl
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_insql_le
argument_list|(
name|insl
argument_list|,
name|src
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_mskxl_le
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffff
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_mskxl_le
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffffffff
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|rtx
name|msk
init|=
name|immed_double_const
argument_list|(
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|msk
init|=
name|constm1_rtx
decl_stmt|;
endif|#
directive|endif
name|emit_insn
argument_list|(
name|gen_mskxl_le
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|msk
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
name|dsth
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|insh
argument_list|,
name|dsth
argument_list|,
name|dsth
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|dstl
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|insl
argument_list|,
name|dstl
argument_list|,
name|dstl
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_move_insn
argument_list|(
name|meml
argument_list|,
name|dstl
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memh
argument_list|,
name|dsth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Must store high before low for degenerate case of aligned.  */
name|emit_move_insn
argument_list|(
name|memh
argument_list|,
name|dsth
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|meml
argument_list|,
name|dstl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The block move code tries to maximize speed by separating loads and    stores at the expense of register pressure: we load all of the data    before we store it back out.  There are two secondary effects worth    mentioning, that this speeds copying to/from aligned and unaligned    buffers, and that it makes the code significantly easier to write.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MOVE_WORDS
value|8
end_define

begin_comment
comment|/* Load an integral number of consecutive unaligned quadwords.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_expand_unaligned_load_words
parameter_list|(
name|out_regs
parameter_list|,
name|smem
parameter_list|,
name|words
parameter_list|,
name|ofs
parameter_list|)
name|rtx
modifier|*
name|out_regs
decl_stmt|;
name|rtx
name|smem
decl_stmt|;
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|ofs
decl_stmt|;
block|{
name|rtx
specifier|const
name|im8
init|=
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
decl_stmt|;
name|rtx
specifier|const
name|i64
init|=
name|GEN_INT
argument_list|(
literal|64
argument_list|)
decl_stmt|;
name|rtx
name|ext_tmps
index|[
name|MAX_MOVE_WORDS
index|]
decl_stmt|,
name|data_regs
index|[
name|MAX_MOVE_WORDS
operator|+
literal|1
index|]
decl_stmt|;
name|rtx
name|sreg
decl_stmt|,
name|areg
decl_stmt|,
name|tmp
decl_stmt|,
name|smema
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|smema
operator|=
name|XEXP
argument_list|(
name|smem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|smema
argument_list|)
operator|==
name|LO_SUM
condition|)
name|smema
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|smema
argument_list|)
expr_stmt|;
comment|/* Generate all the tmp registers we need.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|data_regs
index|[
name|i
index|]
operator|=
name|out_regs
index|[
name|i
index|]
expr_stmt|;
name|ext_tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
name|data_regs
index|[
name|words
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
name|smem
operator|=
name|adjust_address
argument_list|(
name|smem
argument_list|,
name|GET_MODE
argument_list|(
name|smem
argument_list|)
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
comment|/* Load up all of the source data.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|tmp
operator|=
name|change_address
argument_list|(
name|smem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|smema
argument_list|,
literal|8
operator|*
name|i
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|change_address
argument_list|(
name|smem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|smema
argument_list|,
literal|8
operator|*
name|words
operator|-
literal|1
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|words
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Extract the half-word fragments.  Unfortunately DEC decided to make      extxh with offset zero a noop instead of zeroing the register, so       we must take care of that edge condition ourselves with cmov.  */
name|sreg
operator|=
name|copy_addr_to_reg
argument_list|(
name|smema
argument_list|)
expr_stmt|;
name|areg
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|and_optab
argument_list|,
name|sreg
argument_list|,
name|GEN_INT
argument_list|(
literal|7
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|emit_move_insn
argument_list|(
name|sreg
argument_list|,
name|plus_constant
argument_list|(
name|sreg
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_extqh_be
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl_be
argument_list|(
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|i64
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_extxl_le
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|i64
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extqh_le
argument_list|(
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_EQ
argument_list|(
name|DImode
argument_list|,
name|areg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the half-words into whole words.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|out_regs
index|[
name|i
index|]
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store an integral number of consecutive unaligned quadwords.  DATA_REGS    may be NULL to store zeros.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_expand_unaligned_store_words
parameter_list|(
name|data_regs
parameter_list|,
name|dmem
parameter_list|,
name|words
parameter_list|,
name|ofs
parameter_list|)
name|rtx
modifier|*
name|data_regs
decl_stmt|;
name|rtx
name|dmem
decl_stmt|;
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|ofs
decl_stmt|;
block|{
name|rtx
specifier|const
name|im8
init|=
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
decl_stmt|;
name|rtx
specifier|const
name|i64
init|=
name|GEN_INT
argument_list|(
literal|64
argument_list|)
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|rtx
specifier|const
name|im1
init|=
name|immed_double_const
argument_list|(
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
specifier|const
name|im1
init|=
name|constm1_rtx
decl_stmt|;
endif|#
directive|endif
name|rtx
name|ins_tmps
index|[
name|MAX_MOVE_WORDS
index|]
decl_stmt|;
name|rtx
name|st_tmp_1
decl_stmt|,
name|st_tmp_2
decl_stmt|,
name|dreg
decl_stmt|;
name|rtx
name|st_addr_1
decl_stmt|,
name|st_addr_2
decl_stmt|,
name|dmema
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|dmema
operator|=
name|XEXP
argument_list|(
name|dmem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dmema
argument_list|)
operator|==
name|LO_SUM
condition|)
name|dmema
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|dmema
argument_list|)
expr_stmt|;
comment|/* Generate all the tmp registers we need.  */
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|ins_tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|st_tmp_1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|st_tmp_2
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
name|dmem
operator|=
name|adjust_address
argument_list|(
name|dmem
argument_list|,
name|GET_MODE
argument_list|(
name|dmem
argument_list|)
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|st_addr_2
operator|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|dmema
argument_list|,
name|words
operator|*
literal|8
operator|-
literal|1
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|st_addr_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st_addr_1
operator|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|dmema
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|st_addr_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Load up the destination end bits.  */
name|emit_move_insn
argument_list|(
name|st_tmp_2
argument_list|,
name|st_addr_2
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|st_tmp_1
argument_list|,
name|st_addr_1
argument_list|)
expr_stmt|;
comment|/* Shift the input data into place.  */
name|dreg
operator|=
name|copy_addr_to_reg
argument_list|(
name|dmema
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|emit_move_insn
argument_list|(
name|dreg
argument_list|,
name|plus_constant
argument_list|(
name|dreg
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_insql_be
argument_list|(
name|ins_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|ins_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_insql_le
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Split and merge the ends with the destination data.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_mskxl_be
argument_list|(
name|st_tmp_2
argument_list|,
name|st_tmp_2
argument_list|,
name|im1
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|st_tmp_1
argument_list|,
name|st_tmp_1
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|st_tmp_2
argument_list|,
name|st_tmp_2
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mskxl_le
argument_list|(
name|st_tmp_1
argument_list|,
name|st_tmp_1
argument_list|,
name|im1
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
block|{
name|st_tmp_2
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|st_tmp_2
argument_list|,
name|ins_tmps
index|[
name|words
operator|-
literal|1
index|]
argument_list|,
name|st_tmp_2
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|st_tmp_1
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|st_tmp_1
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|,
name|st_tmp_1
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Store it all.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|emit_move_insn
argument_list|(
name|st_addr_1
argument_list|,
name|st_tmp_1
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|st_addr_2
argument_list|,
name|st_tmp_2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|tmp
init|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|dmema
argument_list|,
name|WORDS_BIG_ENDIAN
condition|?
name|i
operator|*
literal|8
operator|-
literal|1
else|:
name|i
operator|*
literal|8
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|data_regs
condition|?
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
else|:
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|emit_move_insn
argument_list|(
name|st_addr_2
argument_list|,
name|st_tmp_2
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|st_addr_1
argument_list|,
name|st_tmp_1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand string/block move operations.     operands[0] is the pointer to the destination.    operands[1] is the pointer to the source.    operands[2] is the number of bytes to move.    operands[3] is the alignment.  */
end_comment

begin_function
name|int
name|alpha_expand_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|orig_bytes
init|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bytes
init|=
name|orig_bytes
decl_stmt|;
name|HOST_WIDE_INT
name|src_align
init|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|dst_align
init|=
name|src_align
decl_stmt|;
name|rtx
name|orig_src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|orig_dst
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|data_regs
index|[
literal|2
operator|*
name|MAX_MOVE_WORDS
operator|+
literal|16
index|]
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|words
decl_stmt|,
name|ofs
decl_stmt|,
name|nregs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|orig_bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|orig_bytes
operator|>
name|MAX_MOVE_WORDS
operator|*
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
comment|/* Look for additional alignment information from recorded register info.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|src_align
operator|=
name|MAX
argument_list|(
name|src_align
argument_list|,
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|src_align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|64
operator|&&
name|c
operator|%
literal|8
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|32
operator|&&
name|c
operator|%
literal|4
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|16
operator|&&
name|c
operator|%
literal|2
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|16
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|dst_align
operator|=
name|MAX
argument_list|(
name|dst_align
argument_list|,
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|dst_align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|64
operator|&&
name|c
operator|%
literal|8
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|32
operator|&&
name|c
operator|%
literal|4
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|16
operator|&&
name|c
operator|%
literal|2
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|16
expr_stmt|;
block|}
block|}
comment|/* Load the entire block into registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't use the existing register if we're reading more than 	 is held in the register.  Nor if there is not a mode that 	 handles the exact size.  */
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|>=
name|bytes
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
block|{
name|data_regs
index|[
name|nregs
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|data_regs
index|[
name|nregs
operator|+
literal|1
index|]
operator|=
name|gen_highpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|nregs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|src_done
goto|;
block|}
comment|/* No appropriate mode; fall back on memory.  */
name|orig_src
operator|=
name|replace_equiv_address
argument_list|(
name|orig_src
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_align
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ofs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|src_align
operator|>=
literal|64
operator|&&
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
argument_list|,
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|DImode
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|src_align
operator|>=
literal|32
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
argument_list|,
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|SImode
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|4
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load_words
argument_list|(
name|data_regs
operator|+
name|nregs
argument_list|,
name|orig_src
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_BWX
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load
argument_list|(
name|tmp
argument_list|,
name|orig_src
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|src_align
operator|>=
literal|16
condition|)
block|{
do|do
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|HImode
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|bytes
operator|>=
literal|2
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_BWX
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load
argument_list|(
name|tmp
argument_list|,
name|orig_src
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|QImode
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|1
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
name|src_done
label|:
if|if
condition|(
name|nregs
operator|>
name|ARRAY_SIZE
argument_list|(
name|data_regs
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now save it back out again.  */
name|i
operator|=
literal|0
operator|,
name|ofs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|orig_bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|mode
condition|)
block|{
if|if
condition|(
name|nregs
operator|==
literal|1
condition|)
block|{
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
goto|goto
name|dst_done
goto|;
block|}
elseif|else
if|if
condition|(
name|nregs
operator|==
literal|2
operator|&&
name|mode
operator|==
name|TImode
condition|)
block|{
comment|/* Undo the subregging done above when copying between 		 two TImode registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|TImode
condition|)
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|SUBREG_REG
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|data_regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|seq
argument_list|,
name|tmp
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|,
name|data_regs
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|2
expr_stmt|;
goto|goto
name|dst_done
goto|;
block|}
block|}
comment|/* ??? If nregs> 1, consider reconstructing the word in regs.  */
comment|/* ??? Optimize mode< dst_mode with strict_low_part.  */
comment|/* No appropriate mode; fall back on memory.  We can speed things 	 up by recognizing extra alignment information.  */
name|orig_dst
operator|=
name|replace_equiv_address
argument_list|(
name|orig_dst
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dst_align
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the data in whatever chunks reading the source allowed.  */
if|if
condition|(
name|dst_align
operator|>=
literal|64
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|8
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dst_align
operator|>=
literal|32
condition|)
block|{
comment|/* If the source has remaining DImode regs, write them out in 	 two pieces.  */
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|tmp
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|lshr_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
operator|+
literal|4
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|8
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
comment|/* Write out a remaining block of words using unaligned methods.  */
for|for
control|(
name|words
operator|=
literal|1
init|;
name|i
operator|+
name|words
operator|<
name|nregs
condition|;
name|words
operator|++
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
operator|+
name|words
index|]
argument_list|)
operator|!=
name|DImode
condition|)
break|break;
if|if
condition|(
name|words
operator|==
literal|1
condition|)
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|8
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
else|else
name|alpha_expand_unaligned_store_words
argument_list|(
name|data_regs
operator|+
name|i
argument_list|,
name|orig_dst
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|i
operator|+=
name|words
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
comment|/* Due to the above, this won't be aligned.  */
comment|/* ??? If we have more than one of these, consider constructing full      words in registers and using alpha_expand_unaligned_store_words.  */
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dst_align
operator|>=
literal|16
condition|)
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|HImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|HImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|HImode
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|QImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
name|dst_done
label|:
if|if
condition|(
name|i
operator|!=
name|nregs
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|alpha_expand_block_clear
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|orig_bytes
init|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bytes
init|=
name|orig_bytes
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|alignofs
init|=
literal|0
decl_stmt|;
name|rtx
name|orig_dst
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|words
decl_stmt|,
name|ofs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|orig_bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|orig_bytes
operator|>
name|MAX_MOVE_WORDS
operator|*
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
comment|/* Look for stricter alignment.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|64
condition|)
name|align
operator|=
name|a
operator|,
name|alignofs
operator|=
literal|8
operator|-
name|c
operator|%
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|32
condition|)
name|align
operator|=
name|a
operator|,
name|alignofs
operator|=
literal|4
operator|-
name|c
operator|%
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|16
condition|)
name|align
operator|=
name|a
operator|,
name|alignofs
operator|=
literal|2
operator|-
name|c
operator|%
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* No appropriate mode; fall back on memory.  */
name|orig_dst
operator|=
name|replace_equiv_address
argument_list|(
name|orig_dst
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle an unaligned prefix first.  */
if|if
condition|(
name|alignofs
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
comment|/* Given that alignofs is bounded by align, the only time BWX could 	 generate three stores is for a 7 byte fill.  Prefer two individual 	 stores over a load/mask/store sequence.  */
if|if
condition|(
operator|(
operator|!
name|TARGET_BWX
operator|||
name|alignofs
operator|==
literal|7
operator|)
operator|&&
name|align
operator|>=
literal|32
operator|&&
operator|!
operator|(
name|alignofs
operator|==
literal|4
operator|&&
name|bytes
operator|>=
literal|4
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
operator|(
name|align
operator|>=
literal|64
condition|?
name|DImode
else|:
name|SImode
operator|)
decl_stmt|;
name|int
name|inv_alignofs
init|=
operator|(
name|align
operator|>=
literal|64
condition|?
literal|8
else|:
literal|4
operator|)
operator|-
name|alignofs
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|tmp
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|mode
argument_list|,
name|ofs
operator|-
name|inv_alignofs
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|inv_alignofs
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
name|alignofs
condition|)
block|{
name|mask
operator||=
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
operator|(
name|inv_alignofs
operator|+
name|bytes
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|ofs
operator|+=
name|bytes
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bytes
operator|-=
name|alignofs
expr_stmt|;
name|ofs
operator|+=
name|alignofs
expr_stmt|;
block|}
name|alignofs
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|mem
argument_list|,
name|GEN_INT
argument_list|(
name|mask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TARGET_BWX
operator|&&
operator|(
name|alignofs
operator|&
literal|1
operator|)
operator|&&
name|bytes
operator|>=
literal|1
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|QImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|1
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
name|alignofs
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_BWX
operator|&&
name|align
operator|>=
literal|16
operator|&&
operator|(
name|alignofs
operator|&
literal|3
operator|)
operator|==
literal|2
operator|&&
name|bytes
operator|>=
literal|2
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|HImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
name|alignofs
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|alignofs
operator|==
literal|4
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|alignofs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we've not used the extra lead alignment information by now, 	 we won't be able to.  Downgrade align to match what's left over.  */
if|if
condition|(
name|alignofs
operator|>
literal|0
condition|)
block|{
name|alignofs
operator|=
name|alignofs
operator|&
operator|-
name|alignofs
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|alignofs
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle a block of contiguous long-words.  */
if|if
condition|(
name|align
operator|>=
literal|64
operator|&&
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|8
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
comment|/* If the block is large and appropriately aligned, emit a single      store followed by a sequence of stq_u insns.  */
if|if
condition|(
name|align
operator|>=
literal|32
operator|&&
name|bytes
operator|>
literal|16
condition|)
block|{
name|rtx
name|orig_dsta
decl_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|orig_dsta
operator|=
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_dsta
argument_list|)
operator|==
name|LO_SUM
condition|)
name|orig_dsta
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|orig_dsta
argument_list|)
expr_stmt|;
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|mem
init|=
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|orig_dsta
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|8
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Depending on the alignment, the first stq_u may have overlapped 	 with the initial stl, which means that the last stq_u didn't 	 write as much as it would appear.  Leave those questionable bytes 	 unaccounted for.  */
name|bytes
operator|-=
name|words
operator|*
literal|8
operator|-
literal|4
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
operator|-
literal|4
expr_stmt|;
block|}
comment|/* Handle a smaller block of aligned words.  */
if|if
condition|(
operator|(
name|align
operator|>=
literal|64
operator|&&
name|bytes
operator|==
literal|4
operator|)
operator|||
operator|(
name|align
operator|==
literal|32
operator|&&
name|bytes
operator|>=
literal|4
operator|)
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|4
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|4
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|4
expr_stmt|;
block|}
comment|/* An unaligned block uses stq_u stores for as many as possible.  */
if|if
condition|(
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
name|alpha_expand_unaligned_store_words
argument_list|(
name|NULL
argument_list|,
name|orig_dst
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
comment|/* Next clean up any trailing pieces.  */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
comment|/* Count the number of bits in BYTES for which aligned stores could      be emitted.  */
name|words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|TARGET_BWX
condition|?
literal|1
else|:
literal|4
operator|)
init|;
name|i
operator|*
name|BITS_PER_UNIT
operator|<=
name|align
condition|;
name|i
operator|<<=
literal|1
control|)
if|if
condition|(
name|bytes
operator|&
name|i
condition|)
name|words
operator|+=
literal|1
expr_stmt|;
comment|/* If we have appropriate alignment (and it wouldn't take too many      instructions otherwise), mask out the bytes we need.  */
if|if
condition|(
name|TARGET_BWX
condition|?
name|words
operator|>
literal|2
else|:
name|bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|align
operator|>=
literal|64
condition|)
block|{
name|rtx
name|mem
decl_stmt|,
name|tmp
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|bytes
operator|*
literal|8
operator|)
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|and_optab
argument_list|,
name|mem
argument_list|,
name|GEN_INT
argument_list|(
name|mask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|align
operator|>=
literal|32
operator|&&
name|bytes
operator|<
literal|4
condition|)
block|{
name|rtx
name|mem
decl_stmt|,
name|tmp
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|bytes
operator|*
literal|8
operator|)
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|and_optab
argument_list|,
name|mem
argument_list|,
name|GEN_INT
argument_list|(
name|mask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|TARGET_BWX
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|const0_rtx
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|align
operator|>=
literal|16
condition|)
block|{
do|do
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|HImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|bytes
operator|>=
literal|2
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_BWX
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|const0_rtx
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|QImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|1
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|,
name|set_src
decl_stmt|;
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_insn_type
decl_stmt|;
comment|/* If the dependence is an anti-dependence, there is no cost.  For an      output dependence, there is sometimes a cost, but it doesn't seem      worth handling those few cases.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_insn_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* Bring in the user-defined memory latency.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_ILD
operator|||
name|dep_insn_type
operator|==
name|TYPE_FLD
operator|||
name|dep_insn_type
operator|==
name|TYPE_LDSYM
condition|)
name|cost
operator|+=
name|alpha_memory_latency
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|alpha_cpu
condition|)
block|{
case|case
name|PROCESSOR_EV4
case|:
comment|/* On EV4, if INSN is a store insn and DEP_INSN is setting the data 	 being stored, we can sometimes lower the cost.  */
if|if
condition|(
operator|(
name|insn_type
operator|==
name|TYPE_IST
operator|||
name|insn_type
operator|==
name|TYPE_FST
operator|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|dep_insn_type
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_FLD
case|:
comment|/* No savings here.  */
return|return
name|cost
return|;
case|case
name|TYPE_IMUL
case|:
comment|/* In these cases, we save one cycle.  */
return|return
name|cost
operator|-
literal|1
return|;
default|default:
comment|/* In all other cases, we save two cycles.  */
return|return
name|MAX
argument_list|(
literal|0
argument_list|,
name|cost
operator|-
literal|2
argument_list|)
return|;
block|}
block|}
comment|/* Another case that needs adjustment is an arithmetic or logical 	 operation.  It's cost is usually one cycle, but we default it to 	 two in the MD file.  The only case that it is actually two is 	 for the address in loads, stores, and jumps.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IADD
operator|||
name|dep_insn_type
operator|==
name|TYPE_ILOG
condition|)
block|{
switch|switch
condition|(
name|insn_type
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_IST
case|:
case|case
name|TYPE_FLD
case|:
case|case
name|TYPE_FST
case|:
case|case
name|TYPE_JSR
case|:
return|return
name|cost
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
comment|/* The final case is when a compare feeds into an integer branch; 	 the cost is only one cycle in that case.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_ICMP
operator|&&
name|insn_type
operator|==
name|TYPE_IBR
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|PROCESSOR_EV5
case|:
comment|/* And the lord DEC saith:  "A special bypass provides an effective 	 latency of 0 cycles for an ICMP or ILOG insn producing the test 	 operand of an IBR or ICMOV insn." */
if|if
condition|(
operator|(
name|dep_insn_type
operator|==
name|TYPE_ICMP
operator|||
name|dep_insn_type
operator|==
name|TYPE_ILOG
operator|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* A branch only has one input.  This must be it.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IBR
condition|)
return|return
literal|0
return|;
comment|/* A conditional move has three, make sure it is the test.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_ICMOV
operator|&&
name|GET_CODE
argument_list|(
name|set_src
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set_src
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* "The multiplier is unable to receive data from IEU bypass paths. 	 The instruction issues at the expected time, but its latency is 	 increased by the time it takes for the input data to become 	 available to the multiplier" -- which happens in pipeline stage 	 six, when results are comitted to the register file.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IMUL
condition|)
block|{
switch|switch
condition|(
name|dep_insn_type
condition|)
block|{
comment|/* These insns produce their results in pipeline stage five.  */
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_ICMOV
case|:
case|case
name|TYPE_IMUL
case|:
case|case
name|TYPE_MVI
case|:
return|return
name|cost
operator|+
literal|1
return|;
comment|/* Other integer insns produce results in pipeline stage four.  */
default|default:
return|return
name|cost
operator|+
literal|2
return|;
block|}
block|}
break|break;
case|case
name|PROCESSOR_EV6
case|:
comment|/* There is additional latency to move the result of (most) FP           operations anywhere but the FP register file.  */
if|if
condition|(
operator|(
name|insn_type
operator|==
name|TYPE_FST
operator|||
name|insn_type
operator|==
name|TYPE_FTOI
operator|)
operator|&&
operator|(
name|dep_insn_type
operator|==
name|TYPE_FADD
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMUL
operator|||
name|dep_insn_type
operator|==
name|TYPE_FCMOV
operator|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
break|break;
block|}
comment|/* Otherwise, return the default cost.  */
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Function to initialize the issue rate used by the scheduler.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_issue_rate
parameter_list|()
block|{
return|return
operator|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV4
condition|?
literal|2
else|:
literal|4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_variable_issue
parameter_list|(
name|dump
parameter_list|,
name|verbose
parameter_list|,
name|insn
parameter_list|,
name|cim
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|cim
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_MULTI
condition|)
return|return
literal|0
return|;
return|return
name|cim
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register global variables and machine-specific functions with the    garbage collector.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ABI_UNICOSMK
end_if

begin_function
specifier|static
name|void
name|alpha_init_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|machine
operator|=
operator|(
expr|struct
name|machine_function
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|->
name|first_ciw
operator|=
name|NULL_RTX
expr_stmt|;
name|p
operator|->
name|machine
operator|->
name|last_ciw
operator|=
name|NULL_RTX
expr_stmt|;
name|p
operator|->
name|machine
operator|->
name|ciw_count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|machine
operator|->
name|addr_list
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alpha_mark_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|p
operator|->
name|machine
decl_stmt|;
if|if
condition|(
name|machine
condition|)
block|{
name|ggc_mark_rtx
argument_list|(
name|machine
operator|->
name|first_ciw
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|machine
operator|->
name|addr_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|alpha_free_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|free
argument_list|(
name|p
operator|->
name|machine
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_ABI_UNICOSMK */
end_comment

begin_comment
comment|/* Functions to save and restore alpha_return_addr_rtx.  */
end_comment

begin_comment
comment|/* Start the ball rolling with RETURN_ADDR_RTX.  */
end_comment

begin_function
name|rtx
name|alpha_return_addr
parameter_list|(
name|count
parameter_list|,
name|frame
parameter_list|)
name|int
name|count
decl_stmt|;
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|const0_rtx
return|;
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|REG_RA
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return or create a pseudo containing the gp value for the current    function.  Needed only if TARGET_LD_BUGGY_LDGP.  */
end_comment

begin_function
name|rtx
name|alpha_gp_save_rtx
parameter_list|()
block|{
return|return
name|get_hard_reg_initial_val
argument_list|(
name|DImode
argument_list|,
literal|29
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_ra_ever_killed
parameter_list|()
block|{
name|rtx
name|top
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
name|current_function_is_thunk
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|has_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|REG_RA
argument_list|)
condition|)
return|return
name|regs_ever_live
index|[
name|REG_RA
index|]
return|;
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|top
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|reg_set_between_p
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REG_RA
argument_list|)
argument_list|,
name|top
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the trap mode suffix applicable to the current    instruction, or NULL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_trap_mode_suffix
parameter_list|()
block|{
name|enum
name|attr_trap_suffix
name|s
init|=
name|get_attr_trap_suffix
argument_list|(
name|current_output_insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|TRAP_SUFFIX_NONE
case|:
return|return
name|NULL
return|;
case|case
name|TRAP_SUFFIX_SU
case|:
if|if
condition|(
name|alpha_fptm
operator|>=
name|ALPHA_FPTM_SU
condition|)
return|return
literal|"su"
return|;
return|return
name|NULL
return|;
case|case
name|TRAP_SUFFIX_SUI
case|:
if|if
condition|(
name|alpha_fptm
operator|>=
name|ALPHA_FPTM_SUI
condition|)
return|return
literal|"sui"
return|;
return|return
name|NULL
return|;
case|case
name|TRAP_SUFFIX_V_SV
case|:
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
return|return
name|NULL
return|;
case|case
name|ALPHA_FPTM_U
case|:
return|return
literal|"v"
return|;
case|case
name|ALPHA_FPTM_SU
case|:
case|case
name|ALPHA_FPTM_SUI
case|:
return|return
literal|"sv"
return|;
block|}
break|break;
case|case
name|TRAP_SUFFIX_V_SV_SVI
case|:
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
return|return
name|NULL
return|;
case|case
name|ALPHA_FPTM_U
case|:
return|return
literal|"v"
return|;
case|case
name|ALPHA_FPTM_SU
case|:
return|return
literal|"sv"
return|;
case|case
name|ALPHA_FPTM_SUI
case|:
return|return
literal|"svi"
return|;
block|}
break|break;
case|case
name|TRAP_SUFFIX_U_SU_SUI
case|:
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
return|return
name|NULL
return|;
case|case
name|ALPHA_FPTM_U
case|:
return|return
literal|"u"
return|;
case|case
name|ALPHA_FPTM_SU
case|:
return|return
literal|"su"
return|;
case|case
name|ALPHA_FPTM_SUI
case|:
return|return
literal|"sui"
return|;
block|}
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the rounding mode suffix applicable to the current    instruction, or NULL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_round_mode_suffix
parameter_list|()
block|{
name|enum
name|attr_round_suffix
name|s
init|=
name|get_attr_round_suffix
argument_list|(
name|current_output_insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|ROUND_SUFFIX_NONE
case|:
return|return
name|NULL
return|;
case|case
name|ROUND_SUFFIX_NORMAL
case|:
switch|switch
condition|(
name|alpha_fprm
condition|)
block|{
case|case
name|ALPHA_FPRM_NORM
case|:
return|return
name|NULL
return|;
case|case
name|ALPHA_FPRM_MINF
case|:
return|return
literal|"m"
return|;
case|case
name|ALPHA_FPRM_CHOP
case|:
return|return
literal|"c"
return|;
case|case
name|ALPHA_FPRM_DYN
case|:
return|return
literal|"d"
return|;
block|}
break|break;
case|case
name|ROUND_SUFFIX_C
case|:
return|return
literal|"c"
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'~'
case|:
comment|/* Print the assembler name of the current function.  */
name|assemble_name
argument_list|(
name|file
argument_list|,
name|alpha_fnname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
block|{
specifier|const
name|char
modifier|*
name|trap
init|=
name|get_trap_mode_suffix
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|round
init|=
name|get_round_mode_suffix
argument_list|()
decl_stmt|;
if|if
condition|(
name|trap
operator|||
name|round
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
operator|(
name|TARGET_AS_SLASH_BEFORE_SUFFIX
condition|?
literal|"/%s%s"
else|:
literal|"%s%s"
operator|)
argument_list|,
operator|(
name|trap
condition|?
name|trap
else|:
literal|""
operator|)
argument_list|,
operator|(
name|round
condition|?
name|round
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|','
case|:
comment|/* Generates single precision instruction suffix.  */
name|fputc
argument_list|(
operator|(
name|TARGET_FLOAT_VAX
condition|?
literal|'f'
else|:
literal|'s'
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* Generates double precision instruction suffix.  */
name|fputc
argument_list|(
operator|(
name|TARGET_FLOAT_VAX
condition|?
literal|'g'
else|:
literal|'t'
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|alpha_this_literal_sequence_number
operator|==
literal|0
condition|)
name|alpha_this_literal_sequence_number
operator|=
name|alpha_next_sequence_number
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|alpha_this_literal_sequence_number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|alpha_this_gpdisp_sequence_number
operator|==
literal|0
condition|)
name|alpha_this_gpdisp_sequence_number
operator|=
name|alpha_next_sequence_number
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|alpha_this_gpdisp_sequence_number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%H value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t\t!lituse_jsr!%d"
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%J value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* If this operand is the constant zero, write it as "$31".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%r value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Similar, but for floating-point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$f31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Write the 1's complement of a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Write 1<< C, for a constant C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Write the high-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%h value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Write the low-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%L value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x8000
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Write mask for ZAP insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|value
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|value
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|mask
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|,
name|value
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* 'b', 'w', 'l', or 'q' as the value of the constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|8
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|16
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|32
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|64
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|8
condition|?
literal|"b"
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|16
condition|?
literal|"w"
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|32
condition|?
literal|"l"
else|:
literal|"q"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Similar, except do it from the mask.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffffffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%U value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Write the constant value divided by 8 for little-endian mode or 	 (56 - value) / 8 for big-endian mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|56
else|:
literal|64
operator|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|WORDS_BIG_ENDIAN
condition|?
operator|(
literal|56
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|8
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Same, except compute (64 - c) / 8 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|8
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
literal|64
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
block|{
comment|/* On Unicos/Mk systems: use a DEX expression if the symbol 	   clashes with a register name.  */
name|int
name|dex
init|=
name|unicosmk_need_dex
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|dex
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"DEX(%d)"
argument_list|,
name|dex
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
comment|/* Write out comparison name.  */
block|{
name|enum
name|rtx_code
name|c
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|c
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%C value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'D'
condition|)
name|c
operator|=
name|reverse_condition
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'c'
condition|)
name|c
operator|=
name|swap_condition
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'d'
condition|)
name|c
operator|=
name|swap_condition
argument_list|(
name|reverse_condition
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|LEU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ule"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|LTU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ult"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|UNORDERED
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"un"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
comment|/* Write the divide or modulus operator.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/* Write "_u" for unaligned access.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_u"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|int
name|basereg
init|=
literal|31
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|AND
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|fputc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|subreg_regno
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"($%d)\t\t!%s"
argument_list|,
name|basereg
argument_list|,
operator|(
name|basereg
operator|==
literal|29
condition|?
literal|"gprel"
else|:
literal|"gprellow"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|subreg_regno
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"($%d)"
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline at    TRAMP. FNADDR is an RTX for the address of the function's pure    code.  CXT is an RTX for the static chain value for the function.     The three offset parameters are for the individual template's    layout.  A JMPOFS< 0 indicates that the trampoline does not     contain instructions at all.     We assume here that a function will be called many more times than    its address is taken (e.g., it might be passed to qsort), so we    take the trouble to initialize the "hint" field in the JMP insn.    Note that the hint field is PC (new) + 4 * bits 13:0.  */
end_comment

begin_function
name|void
name|alpha_initialize_trampoline
parameter_list|(
name|tramp
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|,
name|fnofs
parameter_list|,
name|cxtofs
parameter_list|,
name|jmpofs
parameter_list|)
name|rtx
name|tramp
decl_stmt|,
name|fnaddr
decl_stmt|,
name|cxt
decl_stmt|;
name|int
name|fnofs
decl_stmt|,
name|cxtofs
decl_stmt|,
name|jmpofs
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|,
name|temp1
decl_stmt|,
name|addr
decl_stmt|;
comment|/* VMS really uses DImode pointers in memory at this point.  */
name|enum
name|machine_mode
name|mode
init|=
name|TARGET_ABI_OPEN_VMS
condition|?
name|Pmode
else|:
name|ptr_mode
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|fnaddr
operator|=
name|convert_memory_address
argument_list|(
name|mode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|cxt
operator|=
name|convert_memory_address
argument_list|(
name|mode
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Store function address and CXT.  */
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|fnofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|cxtofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
comment|/* This has been disabled since the hint only has a 32k range, and in      no existing OS is the stack within 32k of the text segment.  */
if|if
condition|(
literal|0
operator|&&
name|jmpofs
operator|>=
literal|0
condition|)
block|{
comment|/* Compute hint value.  */
name|temp
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|jmpofs
operator|+
literal|4
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|sub_optab
argument_list|,
name|fnaddr
argument_list|,
name|temp
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|Pmode
argument_list|,
name|temp
argument_list|,
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_and
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3fff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge in the hint.  */
name|addr
operator|=
name|memory_address
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|jmpofs
argument_list|)
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_and
argument_list|(
name|temp1
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffffc000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|temp1
argument_list|,
name|temp
argument_list|,
name|temp1
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRANSFER_FROM_TRAMPOLINE
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|jmpofs
operator|>=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_imb
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).     On Alpha the first 6 words of args are normally in registers    and the rest are pushed.  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|basereg
decl_stmt|;
name|int
name|num_args
decl_stmt|;
comment|/* Set up defaults for FP operands passed in FP registers, and      integral operands passed in integer registers.  */
if|if
condition|(
name|TARGET_FPREGS
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|)
condition|)
name|basereg
operator|=
literal|32
operator|+
literal|16
expr_stmt|;
else|else
name|basereg
operator|=
literal|16
expr_stmt|;
comment|/* ??? Irritatingly, the definition of CUMULATIVE_ARGS is different for      the three platforms, so we can't avoid conditional compilation.  */
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
return|return
name|alpha_arg_info_reg_val
argument_list|(
name|cum
argument_list|)
return|;
name|num_args
operator|=
name|cum
operator|.
name|num_args
expr_stmt|;
if|if
condition|(
name|num_args
operator|>=
literal|6
operator|||
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
block|}
else|#
directive|else
if|#
directive|if
name|TARGET_ABI_UNICOSMK
block|{
name|int
name|size
decl_stmt|;
comment|/* If this is the last argument, generate the call info word (CIW).  */
comment|/* ??? We don't include the caller's line number in the CIW because 	 I don't know how to determine it if debug infos are turned off.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|rtx
name|ciw
decl_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cum
operator|.
name|num_reg_words
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cum
operator|.
name|reg_args_type
index|[
name|i
index|]
condition|)
name|lo
operator||=
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
name|i
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|cum
operator|.
name|num_reg_words
operator|==
literal|6
operator|&&
name|cum
operator|.
name|reg_args_type
index|[
literal|5
index|]
condition|)
name|lo
operator||=
literal|7
expr_stmt|;
else|else
name|lo
operator||=
name|cum
operator|.
name|num_reg_words
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|hi
operator|=
operator|(
name|cum
operator|.
name|num_args
operator|<<
literal|20
operator|)
operator||
name|cum
operator|.
name|num_arg_words
expr_stmt|;
else|#
directive|else
name|lo
operator|=
name|lo
operator||
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|cum
operator|.
name|num_args
operator|<<
literal|52
operator|)
operator||
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|cum
operator|.
name|num_arg_words
operator|<<
literal|32
operator|)
expr_stmt|;
name|hi
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ciw
operator|=
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_UNSPEC
argument_list|(
name|DImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|ciw
argument_list|)
argument_list|,
name|UNSPEC_UMK_LOAD_CIW
argument_list|)
return|;
block|}
name|size
operator|=
name|ALPHA_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
expr_stmt|;
name|num_args
operator|=
name|cum
operator|.
name|num_reg_words
expr_stmt|;
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|||
name|cum
operator|.
name|num_reg_words
operator|+
name|size
operator|>
literal|6
operator|||
name|cum
operator|.
name|force_stack
condition|)
return|return
name|NULL_RTX
return|;
elseif|else
if|if
condition|(
name|type
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
name|reg1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|num_args
operator|+
literal|16
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|DImode
argument_list|,
name|reg1
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* The argument fits in two registers. Note that we still need to 	     reserve a register for empty structures.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|NULL_RTX
return|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|1
condition|)
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg1
argument_list|)
argument_list|)
return|;
else|else
block|{
name|reg2
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|num_args
operator|+
literal|17
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|DImode
argument_list|,
name|reg2
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
else|#
directive|else
block|{
if|if
condition|(
name|cum
operator|>=
literal|6
condition|)
return|return
name|NULL_RTX
return|;
name|num_args
operator|=
name|cum
expr_stmt|;
comment|/* VOID is passed as a special flag for "last argument".  */
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
name|basereg
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
elseif|else
if|if
condition|(
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
condition|)
name|basereg
operator|=
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TARGET_ABI_UNICOSMK */
endif|#
directive|endif
comment|/* TARGET_ABI_OPEN_VMS */
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|num_args
operator|+
name|basereg
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|alpha_build_va_list
parameter_list|()
block|{
name|tree
name|base
decl_stmt|,
name|ofs
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|||
name|TARGET_ABI_UNICOSMK
condition|)
return|return
name|ptr_type_node
return|;
name|record
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
comment|/* C++? SET_IS_AGGR_TYPE (record, 1); */
name|ofs
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__offset"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|ofs
argument_list|)
operator|=
name|record
expr_stmt|;
name|base
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__base"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|base
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
operator|=
name|ofs
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|base
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
return|return
name|record
return|;
block|}
end_function

begin_function
name|void
name|alpha_va_start
parameter_list|(
name|stdarg_p
parameter_list|,
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|int
name|stdarg_p
decl_stmt|;
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|offset_field
decl_stmt|,
name|base_field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|std_expand_builtin_va_start
argument_list|(
name|stdarg_p
argument_list|,
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
comment|/* For Unix, SETUP_INCOMING_VARARGS moves the starting address base      up by 48, storing fp arg registers in the first 48 bytes, and the      integer arg registers in the next 48 bytes.  This is only done,      however, if any integer registers need to be stored.       If no integer registers need be stored, then we must subtract 48      in order to account for the integer arg registers which are counted      in argsize above, but which are not actually stored on the stack.  */
if|if
condition|(
name|NUM_ARGS
operator|<=
literal|5
operator|+
name|stdarg_p
condition|)
name|offset
operator|=
name|TARGET_ABI_OPEN_VMS
condition|?
name|UNITS_PER_WORD
else|:
literal|6
operator|*
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|offset
operator|=
operator|-
literal|6
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
name|nextarg
operator|=
name|plus_constant
argument_list|(
name|nextarg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|plus_constant
argument_list|(
name|nextarg
argument_list|,
name|NUM_ARGS
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|nextarg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_field
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
expr_stmt|;
name|offset_field
operator|=
name|TREE_CHAIN
argument_list|(
name|base_field
argument_list|)
expr_stmt|;
name|base_field
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_field
argument_list|)
argument_list|,
name|valist
argument_list|,
name|base_field
argument_list|)
expr_stmt|;
name|offset_field
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|valist
argument_list|,
name|offset_field
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_field
argument_list|)
argument_list|,
name|base_field
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|NUM_ARGS
operator|*
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|offset_field
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|rtx
name|alpha_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|,
name|type
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|tsize
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|offset_field
decl_stmt|,
name|base_field
decl_stmt|,
name|addr_tree
decl_stmt|,
name|addend
decl_stmt|;
name|tree
name|wide_type
decl_stmt|,
name|wide_ofs
decl_stmt|;
name|int
name|indirect
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|||
name|TARGET_ABI_UNICOSMK
condition|)
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
name|tsize
operator|=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
literal|8
expr_stmt|;
name|base_field
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
expr_stmt|;
name|offset_field
operator|=
name|TREE_CHAIN
argument_list|(
name|base_field
argument_list|)
expr_stmt|;
name|base_field
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_field
argument_list|)
argument_list|,
name|valist
argument_list|,
name|base_field
argument_list|)
expr_stmt|;
name|offset_field
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|valist
argument_list|,
name|offset_field
argument_list|)
expr_stmt|;
name|wide_type
operator|=
name|make_signed_type
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|wide_ofs
operator|=
name|save_expr
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|wide_type
argument_list|,
name|offset_field
argument_list|)
argument_list|)
expr_stmt|;
name|addend
operator|=
name|wide_ofs
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TCmode
condition|)
block|{
name|indirect
operator|=
literal|1
expr_stmt|;
name|tsize
operator|=
name|UNITS_PER_WORD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|fpaddend
decl_stmt|,
name|cond
decl_stmt|;
name|fpaddend
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addend
argument_list|)
argument_list|,
name|addend
argument_list|,
name|build_int_2
argument_list|(
operator|-
literal|6
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|wide_ofs
argument_list|,
name|build_int_2
argument_list|(
literal|6
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addend
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addend
argument_list|)
argument_list|,
name|cond
argument_list|,
name|fpaddend
argument_list|,
name|addend
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr_tree
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_field
argument_list|)
argument_list|,
name|base_field
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|copy_to_reg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|offset_field
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|offset_field
argument_list|,
name|build_int_2
argument_list|(
name|tsize
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
block|{
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the function    prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/* Compute the size of the save area in the stack.  */
end_comment

begin_comment
comment|/* These variables are used for communication between the following functions.    They indicate various things about the current function being compiled    that are used to tell what kind of prologue, epilogue and procedure    descriptior to generate.  */
end_comment

begin_comment
comment|/* Nonzero if we need a stack procedure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_is_stack_procedure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number (either FP or SP) that is used to unwind the frame.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_unwind_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number used to save FP.  We need not have one for RA since    we don't modify it for register procedures.  This is only defined    for register frame procedures.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_save_fp_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number used to reference objects off our PV.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_base_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute register masks for saved registers.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_sa_mask
parameter_list|(
name|imaskP
parameter_list|,
name|fmaskP
parameter_list|)
name|unsigned
name|long
modifier|*
name|imaskP
decl_stmt|;
name|unsigned
name|long
modifier|*
name|fmaskP
decl_stmt|;
block|{
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
operator|!
name|current_function_is_thunk
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|alpha_is_stack_procedure
condition|)
name|imask
operator||=
operator|(
literal|1L
operator|<<
name|HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
comment|/* One for every register we have to save.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|REG_RA
operator|&&
operator|(
operator|!
name|TARGET_ABI_UNICOSMK
operator|||
name|i
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|32
condition|)
name|imask
operator||=
operator|(
literal|1L
operator|<<
name|i
operator|)
expr_stmt|;
else|else
name|fmask
operator||=
operator|(
literal|1L
operator|<<
operator|(
name|i
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
block|}
comment|/* We need to restore these for the handler.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|regno
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|imask
operator||=
literal|1L
operator|<<
name|regno
expr_stmt|;
block|}
block|}
comment|/* If any register spilled, then spill the return address also.  */
comment|/* ??? This is required by the Digital stack unwind specification 	 and isn't needed if we're doing Dwarf2 unwinding.  */
if|if
condition|(
name|imask
operator|||
name|fmask
operator|||
name|alpha_ra_ever_killed
argument_list|()
condition|)
name|imask
operator||=
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
expr_stmt|;
block|}
operator|*
name|imaskP
operator|=
name|imask
expr_stmt|;
operator|*
name|fmaskP
operator|=
name|fmask
expr_stmt|;
block|}
end_function

begin_function
name|int
name|alpha_sa_size
parameter_list|()
block|{
name|unsigned
name|long
name|mask
index|[
literal|2
index|]
decl_stmt|;
name|int
name|sa_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|mask
index|[
literal|0
index|]
argument_list|,
operator|&
name|mask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
if|if
condition|(
name|mask
index|[
literal|0
index|]
operator|||
name|mask
index|[
literal|1
index|]
condition|)
name|sa_size
operator|=
literal|14
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
operator|++
name|j
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|mask
index|[
name|j
index|]
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
name|sa_size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
comment|/* We might not need to generate a frame if we don't make any calls 	 (including calls to __T3E_MISMATCH if this is a vararg function), 	 don't have any local variables which require stack slots, don't 	 use alloca and have not determined that we need a frame for other 	 reasons.  */
name|alpha_is_stack_procedure
operator|=
operator|(
name|sa_size
operator|||
name|get_frame_size
argument_list|()
operator|!=
literal|0
operator|||
name|current_function_outgoing_args_size
operator|||
name|current_function_varargs
operator|||
name|current_function_stdarg
operator|||
name|current_function_calls_alloca
operator|||
name|frame_pointer_needed
operator|)
expr_stmt|;
comment|/* Always reserve space for saving callee-saved registers if we 	 need a frame as required by the calling convention.  */
if|if
condition|(
name|alpha_is_stack_procedure
condition|)
name|sa_size
operator|=
literal|14
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
comment|/* Start by assuming we can use a register procedure if we don't 	 make any calls (REG_RA not used) or need to save any 	 registers and a stack procedure if we do.  */
name|alpha_is_stack_procedure
operator|=
operator|(
operator|(
name|mask
index|[
literal|0
index|]
operator|>>
name|REG_RA
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* Don't reserve space for saving RA yet.  Do that later after we've 	 made the final decision on stack procedure vs register procedure.  */
if|if
condition|(
name|alpha_is_stack_procedure
condition|)
name|sa_size
operator|--
expr_stmt|;
comment|/* Decide whether to refer to objects off our PV via FP or PV. 	 If we need FP for something else or if we receive a nonlocal 	 goto (which expects PV to contain the value), we must use PV. 	 Otherwise, start by assuming we can use FP.  */
name|vms_base_regno
operator|=
operator|(
name|frame_pointer_needed
operator|||
name|current_function_has_nonlocal_label
operator|||
name|alpha_is_stack_procedure
operator|||
name|current_function_outgoing_args_size
condition|?
name|REG_PV
else|:
name|HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
comment|/* If we want to copy PV into FP, we need to find some register 	 in which to save FP.  */
name|vms_save_fp_regno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vms_base_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|vms_save_fp_regno
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|vms_save_fp_regno
operator|==
operator|-
literal|1
condition|)
name|vms_base_regno
operator|=
name|REG_PV
operator|,
name|alpha_is_stack_procedure
operator|=
literal|1
expr_stmt|;
comment|/* Stack unwinding should be done via FP unless we use it for PV.  */
name|vms_unwind_regno
operator|=
operator|(
name|vms_base_regno
operator|==
name|REG_PV
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
expr_stmt|;
comment|/* If this is a stack procedure, allow space for saving FP and RA.  */
if|if
condition|(
name|alpha_is_stack_procedure
condition|)
name|sa_size
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Our size must be even (multiple of 16 bytes).  */
if|if
condition|(
name|sa_size
operator|&
literal|1
condition|)
name|sa_size
operator|++
expr_stmt|;
block|}
return|return
name|sa_size
operator|*
literal|8
return|;
block|}
end_function

begin_function
name|int
name|alpha_pv_save_size
parameter_list|()
block|{
name|alpha_sa_size
argument_list|()
expr_stmt|;
return|return
name|alpha_is_stack_procedure
condition|?
literal|8
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|alpha_using_fp
parameter_list|()
block|{
name|alpha_sa_size
argument_list|()
expr_stmt|;
return|return
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
end_if

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|vms_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"overlaid"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"global"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"initialize"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|find_lo_sum
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
operator|*
name|px
argument_list|)
operator|==
name|LO_SUM
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_does_function_need_gp
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* The GP being variable is an OSF abi thing.  */
if|if
condition|(
operator|!
name|TARGET_ABI_OSF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_PROFILING_NEEDS_GP
operator|&&
name|current_function_profile
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
name|current_function_is_thunk
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first.       Even if we are a static function, we still need to do this in case      our address is taken and passed to something like qsort.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|enum
name|attr_type
name|type
init|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_LDSYM
operator|||
name|type
operator|==
name|TYPE_JSR
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|find_lo_sum
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write a version stamp.  Don't write anything if we are running as a    cross-compiler.  Otherwise, use the versions in /usr/include/stamp.h.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STAMP_H
end_ifdef

begin_include
include|#
directive|include
file|<stamp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|alpha_write_verstamp
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MS_STAMP
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.verstamp %d %d\n"
argument_list|,
name|MS_STAMP
argument_list|,
name|LS_STAMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function to set RTX_FRAME_RELATED_P on instructions, including    sequences.  */
end_comment

begin_function
specifier|static
name|rtx
name|set_frame_related_p
parameter_list|()
block|{
name|rtx
name|seq
init|=
name|gen_sequence
argument_list|()
decl_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|emit_insn
argument_list|(
name|seq
argument_list|)
return|;
block|}
else|else
block|{
name|seq
operator|=
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|seq
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|seq
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|FRP
parameter_list|(
name|exp
parameter_list|)
value|(start_sequence (), exp, set_frame_related_p ())
end_define

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_comment
comment|/* On vms we have two kinds of functions:     - stack frame (PROC_STACK) 	these are 'normal' functions with local vars and which are 	calling other functions    - register frame (PROC_REGISTER) 	keeps all data in registers, needs no stack     We must pass this to the assembler so it can generate the    proper pdsc (procedure descriptor)    This is done with the '.pdesc' command.     On not-vms, we don't really differentiate between the two, as we can    simply allocate stack without saving registers.  */
end_comment

begin_function
name|void
name|alpha_expand_prologue
parameter_list|()
block|{
comment|/* Registers to save.  */
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|rtx
name|sa_reg
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_is_stack_procedure
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
comment|/* We have to allocate space for the DSIB if we generate a frame.  */
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_is_stack_procedure
condition|?
literal|48
else|:
literal|0
operator|)
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
comment|/* Emit an insn to reload GP, if needed.  */
if|if
condition|(
name|TARGET_ABI_OSF
condition|)
block|{
name|alpha_function_needs_gp
operator|=
name|alpha_does_function_need_gp
argument_list|()
expr_stmt|;
if|if
condition|(
name|alpha_function_needs_gp
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_ldgp
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* TARGET_PROFILING_NEEDS_GP actually implies that we need to insert      the call to mcount ourselves, rather than having the linker do it      magically in response to -pg.  Since _mcount has special linkage,      don't represent the call as a call.  */
if|if
condition|(
name|TARGET_PROFILING_NEEDS_GP
operator|&&
name|current_function_profile
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_mcount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|unicosmk_gen_dsib
argument_list|(
operator|&
name|imask
argument_list|)
expr_stmt|;
comment|/* Adjust the stack by the frame size.  If the frame size is> 4096      bytes, we need to be sure we probe somewhere in the first and last      4096 bytes (we can probably get away without the latter test) and      every 8192 bytes in between.  If the frame size is> 32768, we      do this in a loop.  Otherwise, we generate the explicit probe      instructions.        Note that we are only allowed to adjust sp once in the prologue.  */
if|if
condition|(
name|frame_size
operator|<=
literal|32768
condition|)
block|{
if|if
condition|(
name|frame_size
operator|>
literal|4096
condition|)
block|{
name|int
name|probed
init|=
literal|4096
decl_stmt|;
do|do
name|emit_insn
argument_list|(
name|gen_probe_stack
argument_list|(
name|GEN_INT
argument_list|(
name|TARGET_ABI_UNICOSMK
condition|?
operator|-
name|probed
operator|+
literal|64
else|:
operator|-
name|probed
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|probed
operator|+=
literal|8192
operator|)
operator|<
name|frame_size
condition|)
do|;
comment|/* We only have to do this probe if we aren't saving registers.  */
if|if
condition|(
name|sa_size
operator|==
literal|0
operator|&&
name|probed
operator|+
literal|4096
operator|<
name|frame_size
condition|)
name|emit_insn
argument_list|(
name|gen_probe_stack
argument_list|(
name|GEN_INT
argument_list|(
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_size
operator|!=
literal|0
condition|)
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_ABI_UNICOSMK
condition|?
operator|-
name|frame_size
operator|+
literal|64
else|:
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we generate code to set R22 to SP + 4096 and set R23 to the 	 number of 8192 byte blocks to probe.  We then probe each block 	 in the loop and then set SP to the proper location.  If the 	 amount remaining is> 4096, we have to do one more probe if we 	 are not saving any registers.  */
name|HOST_WIDE_INT
name|blocks
init|=
operator|(
name|frame_size
operator|+
literal|4096
operator|)
operator|/
literal|8192
decl_stmt|;
name|HOST_WIDE_INT
name|leftover
init|=
name|frame_size
operator|+
literal|4096
operator|-
name|blocks
operator|*
literal|8192
decl_stmt|;
name|rtx
name|ptr
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|22
argument_list|)
decl_stmt|;
name|rtx
name|count
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|GEN_INT
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|ptr
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_ABI_UNICOSMK
condition|?
literal|4096
operator|-
literal|64
else|:
literal|4096
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because of the difficulty in emitting a new basic block this 	 late in the compilation, generate the loop as a single insn.  */
name|emit_insn
argument_list|(
name|gen_prologue_stack_probe_loop
argument_list|(
name|count
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftover
operator|>
literal|4096
operator|&&
name|sa_size
operator|==
literal|0
condition|)
block|{
name|rtx
name|last
init|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|ptr
argument_list|,
operator|-
name|leftover
argument_list|)
argument_list|)
decl_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|last
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|last
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ABI_WINDOWS_NT
condition|)
block|{
comment|/* For NT stack unwind (done by 'reverse execution'), it's 	     not OK to take the result of a loop, even though the value 	     is already in ptr, so we reload it via a single operation 	     and subtract it to sp.   	     Yes, that's correct -- we have to reload the whole constant 	     into a temporary via ldah+lda then subtract from sp.  To 	     ensure we get ldah+lda, we use a special pattern.  */
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
operator|(
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|hi
operator|=
name|frame_size
operator|-
name|lo
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_nt_lda
argument_list|(
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
name|lo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|leftover
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* This alternative is special, because the DWARF code cannot          possibly intuit through the loop above.  So we invent this          note it looks at instead.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|seq
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|seq
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_ABI_UNICOSMK
condition|?
operator|-
name|frame_size
operator|+
literal|64
else|:
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|seq
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_ABI_UNICOSMK
condition|)
block|{
comment|/* Cope with very large offsets to the register save area.  */
name|sa_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|reg_offset
operator|+
name|sa_size
operator|>
literal|0x8000
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|reg_offset
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|bias
decl_stmt|;
if|if
condition|(
name|low
operator|+
name|sa_size
operator|<=
literal|0x8000
condition|)
name|bias
operator|=
name|reg_offset
operator|-
name|low
operator|,
name|reg_offset
operator|=
name|low
expr_stmt|;
else|else
name|bias
operator|=
name|reg_offset
operator|,
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|sa_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|sa_reg
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|bias
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save regs in stack order.  Beginning with VMS PV.  */
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|alpha_is_stack_procedure
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_PV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save register RA next.  */
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|imask
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Now save any other registers required to be saved.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
operator|+
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|alpha_is_stack_procedure
condition|)
block|{
comment|/* The standard frame on the T3E includes space for saving registers. 	 We just have to use it. We don't have to save the return address and 	 the old frame pointer here - they are saved in the DSIB.  */
name|reg_offset
operator|=
operator|-
literal|56
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|-=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
operator|+
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|-=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
if|if
condition|(
operator|!
name|alpha_is_stack_procedure
condition|)
comment|/* Register frame procedures save the fp.  */
comment|/* ??? Ought to have a dwarf2 save for this.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vms_base_regno
operator|!=
name|REG_PV
condition|)
name|emit_insn
argument_list|(
name|gen_force_movdi
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_base_regno
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_PV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have to allocate space for outgoing args, do it now.  */
if|if
condition|(
name|current_function_outgoing_args_size
operator|!=
literal|0
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_ABI_UNICOSMK
condition|)
block|{
comment|/* If we need a frame pointer, set it from the stack pointer.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|TARGET_CAN_FAULT_IN_PROLOGUE
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* This must always be the last instruction in the 	       prologue, thus we emit a special move + clobber.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_init_fp
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sa_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The ABIs for VMS and OSF/1 say that while we can schedule insns into      the prologue, for exception handling reasons, we cannot do this for      any insn that might fault.  We could prevent this for mems with a      (clobber:BLK (scratch)), but this doesn't work for fp insns.  So we      have to prevent all such scheduling with a blockage.       Linux, on the other hand, never bothered to implement OSF/1's       exception handling, and so doesn't care about such things.  Anyone      planning to use dwarf2 frame-unwind info can also omit the blockage.  */
if|if
condition|(
operator|!
name|TARGET_CAN_FAULT_IN_PROLOGUE
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the textual info surrounding the prologue.  */
end_comment

begin_function
name|void
name|alpha_start_function
parameter_list|(
name|file
parameter_list|,
name|fnname
parameter_list|,
name|decl
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|char
modifier|*
name|entry_label
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fnname
argument_list|)
operator|+
literal|6
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't emit an extern directive for functions defined in the same file.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|tree
name|name_tree
decl_stmt|;
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|alpha_fnname
operator|=
name|fnname
expr_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_is_stack_procedure
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_is_stack_procedure
condition|?
literal|48
else|:
literal|0
operator|)
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
comment|/* Ecoff can handle multiple .file directives, so put out file and lineno.      We have to do that before the .ent directive as we cannot switch      files within procedures with native ecoff because line numbers are      linked to procedure descriptors.      Outputting the lineno helps debugging of one line functions as they      would otherwise get no line number at all. Please note that we would      like to put out last_linenum from final.c, but it is not accessible.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
condition|)
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Issue function start and label.  */
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|||
operator|(
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
operator|!
name|flag_inhibit_size_directive
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.ent "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* If the function needs GP, we'll write the "..ng" label there. 	 Otherwise, do it here.  */
if|if
condition|(
name|TARGET_ABI_OSF
operator|&&
operator|!
name|alpha_function_needs_gp
condition|)
block|{
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..ng:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|entry_label
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|strcat
argument_list|(
name|entry_label
argument_list|,
literal|"..en"
argument_list|)
expr_stmt|;
comment|/* For public functions, the label must be globalized by appending an      additional colon.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|strcat
argument_list|(
name|entry_label
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|entry_label
argument_list|)
expr_stmt|;
name|inside_function
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.base $%d\n"
argument_list|,
name|vms_base_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ABI_OPEN_VMS
operator|&&
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
name|TARGET_IEEE_CONFORMANT
operator|&&
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
comment|/* Set flags in procedure descriptor to request IEEE-conformant 	 math-library routines.  The value we set it to is PDSC_EXC_IEEE 	 (/usr/include/pdsc.h).  */
name|fputs
argument_list|(
literal|"\t.eflag 48\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Set up offsets to alpha virtual arg/local debugging pointer.  */
name|alpha_auto_offset
operator|=
operator|-
name|frame_size
operator|+
name|current_function_pretend_args_size
expr_stmt|;
name|alpha_arg_offset
operator|=
operator|-
name|frame_size
operator|+
literal|48
expr_stmt|;
comment|/* Describe our frame.  If the frame size is larger than an integer,      print it as zero to avoid an assembler error.  We won't be      properly describing such a frame, but that's the best we can do.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $%d,"
argument_list|,
name|vms_unwind_regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|frame_size
operator|>=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|frame_size
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",$26,"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $%d,"
argument_list|,
operator|(
name|frame_pointer_needed
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1l
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|frame_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",$26,%d\n"
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
block|}
comment|/* Describe which registers were spilled.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
if|if
condition|(
name|imask
condition|)
comment|/* ??? Does VMS care if mask contains ra?  The old code didn't            set it, so I don't here.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask 0x%lx,0\n"
argument_list|,
name|imask
operator|&
operator|~
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask 0x%lx,0\n"
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alpha_is_stack_procedure
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fp_save $%d\n"
argument_list|,
name|vms_save_fp_regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
if|if
condition|(
name|imask
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask 0x%lx,"
argument_list|,
name|imask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1l
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|reg_offset
operator|-
name|frame_size
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|fmask
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask 0x%lx,"
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1l
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|reg_offset
operator|-
name|frame_size
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
comment|/* Ifdef'ed cause readonly_section and link_section are only      available then.  */
name|readonly_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align 3\n"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..na:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.ascii \""
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\\0\"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|link_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align 3\n"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.name "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..na\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.pdesc "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"..en,%s\n"
argument_list|,
name|alpha_is_stack_procedure
condition|?
literal|"stack"
else|:
literal|"reg"
argument_list|)
expr_stmt|;
name|alpha_need_linkage
argument_list|(
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit the .prologue note at the scheduled end of the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_output_function_end_prologue
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|fputs
argument_list|(
literal|"\t.prologue\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_WINDOWS_NT
condition|)
name|fputs
argument_list|(
literal|"\t.prologue 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.prologue %d\n"
argument_list|,
name|alpha_function_needs_gp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_comment
comment|/* ??? At some point we will want to support full unwind, and so will     need to mark the epilogue as well.  At the moment, we just confuse    dwarf2out.  */
end_comment

begin_undef
undef|#
directive|undef
name|FRP
end_undef

begin_define
define|#
directive|define
name|FRP
parameter_list|(
name|exp
parameter_list|)
value|exp
end_define

begin_function
name|void
name|alpha_expand_epilogue
parameter_list|()
block|{
comment|/* Registers to save.  */
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|int
name|fp_is_frame_pointer
decl_stmt|,
name|fp_offset
decl_stmt|;
name|rtx
name|sa_reg
decl_stmt|,
name|sa_reg_exp
init|=
name|NULL
decl_stmt|;
name|rtx
name|sp_adj1
decl_stmt|,
name|sp_adj2
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
name|eh_ofs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_is_stack_procedure
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_is_stack_procedure
condition|?
literal|48
else|:
literal|0
operator|)
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
name|fp_is_frame_pointer
operator|=
operator|(
operator|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|alpha_is_stack_procedure
operator|)
operator|||
operator|(
operator|!
name|TARGET_ABI_OPEN_VMS
operator|&&
name|frame_pointer_needed
operator|)
operator|)
expr_stmt|;
name|fp_offset
operator|=
literal|0
expr_stmt|;
name|sa_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|eh_ofs
operator|=
name|EH_RETURN_STACKADJ_RTX
expr_stmt|;
else|else
name|eh_ofs
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
name|sa_size
condition|)
block|{
comment|/* If we have a frame pointer, restore SP from it.  */
if|if
condition|(
operator|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
operator|(
operator|!
name|TARGET_ABI_OPEN_VMS
operator|&&
name|frame_pointer_needed
operator|)
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cope with very large offsets to the register save area.  */
if|if
condition|(
name|reg_offset
operator|+
name|sa_size
operator|>
literal|0x8000
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|reg_offset
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|bias
decl_stmt|;
if|if
condition|(
name|low
operator|+
name|sa_size
operator|<=
literal|0x8000
condition|)
name|bias
operator|=
name|reg_offset
operator|-
name|low
operator|,
name|reg_offset
operator|=
name|low
expr_stmt|;
else|else
name|bias
operator|=
name|reg_offset
operator|,
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|sa_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|sa_reg_exp
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|bias
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|sa_reg
argument_list|,
name|sa_reg_exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore registers in order, excepting a true frame pointer.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eh_ofs
condition|)
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
name|imask
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|fp_is_frame_pointer
condition|)
name|fp_offset
operator|=
name|reg_offset
expr_stmt|;
else|else
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
operator|+
literal|32
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|alpha_is_stack_procedure
condition|)
block|{
comment|/* Restore callee-saved general-purpose registers.  */
name|reg_offset
operator|=
operator|-
literal|56
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|-=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
operator|+
literal|32
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Restore the return address from the DSIB.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_size
operator|||
name|eh_ofs
condition|)
block|{
name|sp_adj1
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|eh_ofs
condition|)
block|{
name|sp_adj1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|sp_adj1
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|eh_ofs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the stack size is large, begin computation into a temporary 	 register so as not to interfere with a potential fp restore, 	 which must be consecutive with an SP restore.  */
if|if
condition|(
name|frame_size
operator|<
literal|32768
operator|&&
operator|!
operator|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|current_function_calls_alloca
operator|)
condition|)
name|sp_adj2
operator|=
name|GEN_INT
argument_list|(
name|frame_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|sp_adj1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|sp_adj1
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|sp_adj2
operator|=
name|const0_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_size
operator|<
literal|0x40007fffL
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|sp_adj2
operator|=
name|plus_constant
argument_list|(
name|sp_adj1
argument_list|,
name|frame_size
operator|-
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_reg_exp
operator|&&
name|rtx_equal_p
argument_list|(
name|sa_reg_exp
argument_list|,
name|sp_adj2
argument_list|)
condition|)
name|sp_adj1
operator|=
name|sa_reg
expr_stmt|;
else|else
block|{
name|sp_adj1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|sp_adj1
argument_list|,
name|sp_adj2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp_adj2
operator|=
name|GEN_INT
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
decl_stmt|;
name|FRP
argument_list|(
name|sp_adj2
operator|=
name|alpha_emit_set_const
argument_list|(
name|tmp
argument_list|,
name|DImode
argument_list|,
name|frame_size
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp_adj2
condition|)
block|{
comment|/* We can't drop new things to memory this late, afaik, 		 so build it up by pieces.  */
name|FRP
argument_list|(
name|sp_adj2
operator|=
name|alpha_emit_set_long_const
argument_list|(
name|tmp
argument_list|,
name|frame_size
argument_list|,
operator|-
operator|(
name|frame_size
operator|<
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp_adj2
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* From now on, things must be in order.  So emit blockages.  */
comment|/* Restore the frame pointer.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp_is_frame_pointer
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|fp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the stack pointer.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp_adj2
operator|==
name|const0_rtx
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sp_adj1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|sp_adj1
argument_list|,
name|sp_adj2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|&&
operator|!
name|alpha_is_stack_procedure
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
operator|!
name|alpha_is_stack_procedure
condition|)
block|{
comment|/* Decrement the frame pointer if the function does not have a 	     frame.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output the rest of the textual info surrounding the epilogue.  */
end_comment

begin_function
name|void
name|alpha_end_function
parameter_list|(
name|file
parameter_list|,
name|fnname
parameter_list|,
name|decl
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* End the function.  */
if|if
condition|(
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.end "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|inside_function
operator|=
name|FALSE
expr_stmt|;
comment|/* Show that we know this function if it is called again.        Don't do this for global functions in object files destined for a      shared library because the function may be overridden by the application      or other libraries.  Similarly, don't do this for weak functions.       Don't do this for functions not defined in the .text section, as      otherwise it's not unlikely that the destination is out of range      for a direct branch.  */
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
operator|)
operator|&&
name|decl_in_text_section
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|SYMBOL_REF_FLAG
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Output jump tables and the static subroutine information block.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|unicosmk_output_ssib
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|unicosmk_output_deferred_case_vectors
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debugging support.  */
end_comment

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* Count the number of sdb related labels are generated (to find block    start and end boundaries).  */
end_comment

begin_decl_stmt
name|int
name|sdb_label_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next label # for each statement.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sym_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of .file directives, so that .loc is up to date.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_source_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file containing the current function.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_function_file
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offsets to alpha virtual arg/local debugging pointers.  */
end_comment

begin_decl_stmt
name|long
name|alpha_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|alpha_auto_offset
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Emit a new filename to a stream.  */
end_comment

begin_function
name|void
name|alpha_output_filename
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|int
name|first_time
init|=
name|TRUE
decl_stmt|;
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|first_time
operator|=
name|FALSE
expr_stmt|;
operator|++
name|num_source_filenames
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_GAS
operator|&&
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#@stabs\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|",%d,0,0,%s\n"
argument_list|,
name|N_SOL
argument_list|,
operator|&
name|ltext_label_name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|current_function_file
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|current_function_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inside_function
operator|&&
operator|!
name|TARGET_GAS
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|num_source_filenames
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
block|}
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a linenumber to a stream.  */
end_comment

begin_function
name|void
name|alpha_output_lineno
parameter_list|(
name|stream
parameter_list|,
name|line
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
comment|/* mips-tfile doesn't understand .stabd directives.  */
operator|++
name|sym_lineno
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$LM%d:\n%s%d,0,%d,$LM%d\n"
argument_list|,
name|sym_lineno
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_SLINE
argument_list|,
name|line
argument_list|,
name|sym_lineno
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n\t.loc\t%d %d\n"
argument_list|,
name|num_source_filenames
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure to show the current status of registers and memory.  */
end_comment

begin_struct
struct|struct
name|shadow_summary
block|{
struct|struct
block|{
name|unsigned
name|int
name|i
range|:
literal|31
decl_stmt|;
comment|/* Mask of int regs */
name|unsigned
name|int
name|fp
range|:
literal|31
decl_stmt|;
comment|/* Mask of fp regs */
name|unsigned
name|int
name|mem
range|:
literal|1
decl_stmt|;
comment|/* mem == imem | fpmem */
block|}
name|used
struct|,
name|defd
struct|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|summarize_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|shadow_summary
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_handle_trap_shadows
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Summary the effects of expression X on the machine.  Update SUM, a pointer    to the summary structure.  SET is nonzero if the insn is setting the    object, otherwise zero.  */
end_comment

begin_function
specifier|static
name|void
name|summarize_insn
parameter_list|(
name|x
parameter_list|,
name|sum
parameter_list|,
name|set
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|shadow_summary
modifier|*
name|sum
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* ??? Note that this case would be incorrect if the Alpha had a 	 ZERO_EXTRACT in SET_DEST.  */
case|case
name|SET
case|:
name|summarize_insn
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|summarize_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|summarize_insn
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|summarize_insn
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
name|summarize_insn
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
operator|(
name|regno
operator|%
literal|32
operator|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
literal|31
operator|||
name|regno
operator|==
literal|63
condition|)
break|break;
if|if
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
name|sum
operator|->
name|defd
operator|.
name|i
operator||=
name|mask
expr_stmt|;
else|else
name|sum
operator|->
name|defd
operator|.
name|fp
operator||=
name|mask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
name|sum
operator|->
name|used
operator|.
name|i
operator||=
name|mask
expr_stmt|;
else|else
name|sum
operator|->
name|used
operator|.
name|fp
operator||=
name|mask
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MEM
case|:
if|if
condition|(
name|set
condition|)
name|sum
operator|->
name|defd
operator|.
name|mem
operator|=
literal|1
expr_stmt|;
else|else
name|sum
operator|->
name|used
operator|.
name|mem
operator|=
literal|1
expr_stmt|;
comment|/* Find the regs used in memory address computation: */
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|SCRATCH
case|:
case|case
name|ASM_INPUT
case|:
break|break;
comment|/* Handle common unary and binary ops for efficiency.  */
case|case
name|COMPARE
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|summarize_insn
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Ensure a sufficient number of `trapb' insns are in the code when    the user requests code with a trap precision of functions or    instructions.     In naive mode, when the user requests a trap-precision of    "instruction", a trapb is needed after every instruction that may    generate a trap.  This ensures that the code is resumption safe but    it is also slow.     When optimizations are turned on, we delay issuing a trapb as long    as possible.  In this context, a trap shadow is the sequence of    instructions that starts with a (potentially) trap generating    instruction and extends to the next trapb or call_pal instruction    (but GCC never generates call_pal by itself).  We can delay (and    therefore sometimes omit) a trapb subject to the following    conditions:     (a) On entry to the trap shadow, if any Alpha register or memory    location contains a value that is used as an operand value by some    instruction in the trap shadow (live on entry), then no instruction    in the trap shadow may modify the register or memory location.     (b) Within the trap shadow, the computation of the base register    for a memory load or store instruction may not involve using the    result of an instruction that might generate an UNPREDICTABLE    result.     (c) Within the trap shadow, no register may be used more than once    as a destination register.  (This is to make life easier for the    trap-handler.)     (d) The trap shadow may not include any branch instructions.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_handle_trap_shadows
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
name|struct
name|shadow_summary
name|shadow
decl_stmt|;
name|int
name|trap_pending
decl_stmt|,
name|exception_nesting
decl_stmt|;
name|rtx
name|i
decl_stmt|,
name|n
decl_stmt|;
name|trap_pending
operator|=
literal|0
expr_stmt|;
name|exception_nesting
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|defd
operator|=
name|shadow
operator|.
name|used
expr_stmt|;
for|for
control|(
name|i
operator|=
name|insns
init|;
name|i
condition|;
name|i
operator|=
name|NEXT_INSN
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|NOTE
condition|)
block|{
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
name|exception_nesting
operator|++
expr_stmt|;
if|if
condition|(
name|trap_pending
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_END
case|:
name|exception_nesting
operator|--
expr_stmt|;
if|if
condition|(
name|trap_pending
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
case|case
name|NOTE_INSN_EPILOGUE_BEG
case|:
if|if
condition|(
name|trap_pending
operator|&&
name|alpha_tp
operator|>=
name|ALPHA_TP_FUNC
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|trap_pending
condition|)
block|{
if|if
condition|(
name|alpha_tp
operator|==
name|ALPHA_TP_FUNC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
goto|goto
name|close_shadow
goto|;
block|}
elseif|else
if|if
condition|(
name|alpha_tp
operator|==
name|ALPHA_TP_INSN
condition|)
block|{
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|struct
name|shadow_summary
name|sum
decl_stmt|;
name|sum
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|defd
operator|=
name|sum
operator|.
name|used
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
comment|/* Annoyingly, get_attr_trap will abort on these.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
name|summarize_insn
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|shadow
operator|.
name|defd
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|shadow
operator|.
name|defd
operator|.
name|fp
operator|)
condition|)
block|{
comment|/* (c) would be violated */
goto|goto
name|close_shadow
goto|;
block|}
comment|/* Combine shadow with summary of current insn: */
name|shadow
operator|.
name|used
operator|.
name|i
operator||=
name|sum
operator|.
name|used
operator|.
name|i
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator||=
name|sum
operator|.
name|used
operator|.
name|fp
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator||=
name|sum
operator|.
name|used
operator|.
name|mem
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|i
operator||=
name|sum
operator|.
name|defd
operator|.
name|i
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|fp
operator||=
name|sum
operator|.
name|defd
operator|.
name|fp
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|mem
operator||=
name|sum
operator|.
name|defd
operator|.
name|mem
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|shadow
operator|.
name|used
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|shadow
operator|.
name|used
operator|.
name|fp
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|mem
operator|&
name|shadow
operator|.
name|used
operator|.
name|mem
operator|)
condition|)
block|{
comment|/* (a) would be violated (also takes care of (b))  */
if|if
condition|(
name|get_attr_trap
argument_list|(
name|i
argument_list|)
operator|==
name|TRAP_YES
operator|&&
operator|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|sum
operator|.
name|used
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|sum
operator|.
name|used
operator|.
name|fp
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
goto|goto
name|close_shadow
goto|;
block|}
break|break;
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
goto|goto
name|close_shadow
goto|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|close_shadow
label|:
name|n
operator|=
name|emit_insn_before
argument_list|(
name|gen_trapb
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|n
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|i
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
name|trap_pending
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|defd
operator|=
name|shadow
operator|.
name|used
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|exception_nesting
operator|>
literal|0
operator|||
name|alpha_tp
operator|>=
name|ALPHA_TP_FUNC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|get_attr_trap
argument_list|(
name|i
argument_list|)
operator|==
name|TRAP_YES
condition|)
block|{
if|if
condition|(
name|optimize
operator|&&
operator|!
name|trap_pending
condition|)
name|summarize_insn
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|shadow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trap_pending
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Alpha can only issue instruction groups simultaneously if they are    suitibly aligned.  This is very processor-specific.  */
end_comment

begin_enum
enum|enum
name|alphaev4_pipe
block|{
name|EV4_STOP
init|=
literal|0
block|,
name|EV4_IB0
init|=
literal|1
block|,
name|EV4_IB1
init|=
literal|2
block|,
name|EV4_IBX
init|=
literal|4
block|}
enum|;
end_enum

begin_enum
enum|enum
name|alphaev5_pipe
block|{
name|EV5_STOP
init|=
literal|0
block|,
name|EV5_NONE
init|=
literal|1
block|,
name|EV5_E01
init|=
literal|2
block|,
name|EV5_E0
init|=
literal|4
block|,
name|EV5_E1
init|=
literal|8
block|,
name|EV5_FAM
init|=
literal|16
block|,
name|EV5_FA
init|=
literal|32
block|,
name|EV5_FM
init|=
literal|64
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|alphaev4_pipe
name|alphaev4_insn_pipe
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|alphaev5_pipe
name|alphaev5_insn_pipe
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alphaev4_next_group
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alphaev5_next_group
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alphaev4_next_nop
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alphaev5_next_nop
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_align_insns
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|int
operator|,
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|int
operator|*
argument_list|,
name|int
operator|*
argument_list|)
operator|,
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|enum
name|alphaev4_pipe
name|alphaev4_insn_pipe
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EV4_STOP
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|EV4_STOP
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_FLD
case|:
return|return
name|EV4_IBX
return|;
case|case
name|TYPE_LDSYM
case|:
case|case
name|TYPE_IADD
case|:
case|case
name|TYPE_ILOG
case|:
case|case
name|TYPE_ICMOV
case|:
case|case
name|TYPE_ICMP
case|:
case|case
name|TYPE_IST
case|:
case|case
name|TYPE_FST
case|:
case|case
name|TYPE_SHIFT
case|:
case|case
name|TYPE_IMUL
case|:
case|case
name|TYPE_FBR
case|:
return|return
name|EV4_IB0
return|;
case|case
name|TYPE_MISC
case|:
case|case
name|TYPE_IBR
case|:
case|case
name|TYPE_JSR
case|:
case|case
name|TYPE_FCPYS
case|:
case|case
name|TYPE_FCMOV
case|:
case|case
name|TYPE_FADD
case|:
case|case
name|TYPE_FDIV
case|:
case|case
name|TYPE_FMUL
case|:
return|return
name|EV4_IB1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|alphaev5_pipe
name|alphaev5_insn_pipe
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EV5_STOP
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|EV5_STOP
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_FLD
case|:
case|case
name|TYPE_LDSYM
case|:
case|case
name|TYPE_IADD
case|:
case|case
name|TYPE_ILOG
case|:
case|case
name|TYPE_ICMOV
case|:
case|case
name|TYPE_ICMP
case|:
return|return
name|EV5_E01
return|;
case|case
name|TYPE_IST
case|:
case|case
name|TYPE_FST
case|:
case|case
name|TYPE_SHIFT
case|:
case|case
name|TYPE_IMUL
case|:
case|case
name|TYPE_MISC
case|:
case|case
name|TYPE_MVI
case|:
return|return
name|EV5_E0
return|;
case|case
name|TYPE_IBR
case|:
case|case
name|TYPE_JSR
case|:
return|return
name|EV5_E1
return|;
case|case
name|TYPE_FCPYS
case|:
return|return
name|EV5_FAM
return|;
case|case
name|TYPE_FBR
case|:
case|case
name|TYPE_FCMOV
case|:
case|case
name|TYPE_FADD
case|:
case|case
name|TYPE_FDIV
case|:
return|return
name|EV5_FA
return|;
case|case
name|TYPE_FMUL
case|:
return|return
name|EV5_FM
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* IN_USE is a mask of the slots currently filled within the insn group.     The mask bits come from alphaev4_pipe above.  If EV4_IBX is set, then    the insn in EV4_IB0 can be swapped by the hardware into EV4_IB1.      LEN is, of course, the length of the group in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|alphaev4_next_group
parameter_list|(
name|insn
parameter_list|,
name|pin_use
parameter_list|,
name|plen
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|pin_use
decl_stmt|,
decl|*
name|plen
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|,
name|in_use
decl_stmt|;
name|len
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next_and_done
goto|;
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|alphaev4_pipe
name|pipe
decl_stmt|;
name|pipe
operator|=
name|alphaev4_insn_pipe
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
name|EV4_STOP
case|:
comment|/* Force complex instructions to start new groups.  */
if|if
condition|(
name|in_use
condition|)
goto|goto
name|done
goto|;
comment|/* If this is a completely unrecognized insn, its an asm. 	     We don't know how long it is, so record length as -1 to 	     signal a needed realignment.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
goto|goto
name|next_and_done
goto|;
case|case
name|EV4_IBX
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB0
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV4_IB1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV4_IB0
operator||
name|EV4_IBX
expr_stmt|;
break|break;
case|case
name|EV4_IB0
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV4_IBX
operator|)
operator|||
operator|(
name|in_use
operator|&
name|EV4_IB1
operator|)
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
block|}
name|in_use
operator||=
name|EV4_IB0
expr_stmt|;
break|break;
case|case
name|EV4_IB1
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|+=
literal|4
expr_stmt|;
comment|/* Haifa doesn't do well scheduling branches.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
goto|goto
name|next_and_done
goto|;
name|next
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Let Haifa tell us where it thinks insn group boundaries are.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next
goto|;
block|}
name|next_and_done
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|done
label|:
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|insn
return|;
block|}
end_block

begin_comment
comment|/* IN_USE is a mask of the slots currently filled within the insn group.     The mask bits come from alphaev5_pipe above.  If EV5_E01 is set, then    the insn in EV5_E0 can be swapped by the hardware into EV5_E1.      LEN is, of course, the length of the group in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|alphaev5_next_group
parameter_list|(
name|insn
parameter_list|,
name|pin_use
parameter_list|,
name|plen
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|pin_use
decl_stmt|,
decl|*
name|plen
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|,
name|in_use
decl_stmt|;
name|len
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next_and_done
goto|;
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|alphaev5_pipe
name|pipe
decl_stmt|;
name|pipe
operator|=
name|alphaev5_insn_pipe
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
name|EV5_STOP
case|:
comment|/* Force complex instructions to start new groups.  */
if|if
condition|(
name|in_use
condition|)
goto|goto
name|done
goto|;
comment|/* If this is a completely unrecognized insn, its an asm. 	     We don't know how long it is, so record length as -1 to 	     signal a needed realignment.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
goto|goto
name|next_and_done
goto|;
comment|/* ??? Most of the places below, we would like to abort, as  	   it would indicate an error either in Haifa, or in the  	   scheduling description.  Unfortunately, Haifa never  	   schedules the last instruction of the BB, so we don't 	   have an accurate TI bit to go off.  */
case|case
name|EV5_E01
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E0
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV5_E1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV5_E0
operator||
name|EV5_E01
expr_stmt|;
break|break;
case|case
name|EV5_E0
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV5_E01
operator|)
operator|||
operator|(
name|in_use
operator|&
name|EV5_E1
operator|)
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
block|}
name|in_use
operator||=
name|EV5_E0
expr_stmt|;
break|break;
case|case
name|EV5_E1
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
break|break;
case|case
name|EV5_FAM
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FA
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV5_FM
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV5_FA
operator||
name|EV5_FAM
expr_stmt|;
break|break;
case|case
name|EV5_FA
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FA
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FA
expr_stmt|;
break|break;
case|case
name|EV5_FM
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FM
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
break|break;
case|case
name|EV5_NONE
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|+=
literal|4
expr_stmt|;
comment|/* Haifa doesn't do well scheduling branches.  */
comment|/* ??? If this is predicted not-taken, slotting continues, except 	 that no more IBR, FBR, or JSR insns may be slotted.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
goto|goto
name|next_and_done
goto|;
name|next
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Let Haifa tell us where it thinks insn group boundaries are.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next
goto|;
block|}
name|next_and_done
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|done
label|:
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|insn
return|;
block|}
end_block

begin_function
specifier|static
name|rtx
name|alphaev4_next_nop
parameter_list|(
name|pin_use
parameter_list|)
name|int
modifier|*
name|pin_use
decl_stmt|;
block|{
name|int
name|in_use
init|=
operator|*
name|pin_use
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV4_IB0
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV4_IB0
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|in_use
operator|&
operator|(
name|EV4_IBX
operator||
name|EV4_IB1
operator|)
operator|)
operator|==
name|EV4_IBX
condition|)
block|{
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV4_IB1
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
else|else
name|nop
operator|=
name|gen_unop
argument_list|()
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|nop
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|alphaev5_next_nop
parameter_list|(
name|pin_use
parameter_list|)
name|int
modifier|*
name|pin_use
decl_stmt|;
block|{
name|int
name|in_use
init|=
operator|*
name|pin_use
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV5_E1
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV5_FA
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_FA
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV5_FM
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
else|else
name|nop
operator|=
name|gen_unop
argument_list|()
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|nop
return|;
block|}
end_function

begin_comment
comment|/* The instruction group alignment main loop.  */
end_comment

begin_function_decl
specifier|static
name|void
name|alpha_align_insns
parameter_list|(
name|insns
parameter_list|,
name|max_align
parameter_list|,
name|next_group
parameter_list|,
name|next_nop
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|unsigned
name|int
name|max_align
decl_stmt|;
function_decl|rtx
parameter_list|(
function_decl|*next_group
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|rtx
argument_list|(
argument|*next_nop
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* ALIGN is the known alignment for the insn group.  */
name|unsigned
name|int
name|align
decl_stmt|;
comment|/* OFS is the offset of the current insn in the insn group.  */
name|int
name|ofs
decl_stmt|;
name|int
name|prev_in_use
decl_stmt|,
name|in_use
decl_stmt|,
name|len
decl_stmt|;
name|rtx
name|i
decl_stmt|,
name|next
decl_stmt|;
comment|/* Let shorten branches care for assigning alignments to code labels.  */
name|shorten_branches
argument_list|(
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_functions
operator|<
literal|4
condition|)
name|align
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|align_functions
operator|<
name|max_align
condition|)
name|align
operator|=
name|align_functions
expr_stmt|;
else|else
name|align
operator|=
name|max_align
expr_stmt|;
name|ofs
operator|=
name|prev_in_use
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|insns
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|NOTE
condition|)
name|i
operator|=
name|next_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|next
operator|=
call|(
modifier|*
name|next_group
call|)
argument_list|(
name|i
argument_list|,
operator|&
name|in_use
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* When we see a label, resync alignment etc.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|unsigned
name|int
name|new_align
init|=
literal|1
operator|<<
name|label_to_alignment
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_align
operator|>=
name|align
condition|)
block|{
name|align
operator|=
name|new_align
operator|<
name|max_align
condition|?
name|new_align
else|:
name|max_align
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ofs
operator|&
operator|(
name|new_align
operator|-
literal|1
operator|)
condition|)
name|ofs
operator|=
operator|(
name|ofs
operator||
operator|(
name|new_align
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Handle complex instructions special.  */
elseif|else
if|if
condition|(
name|in_use
operator|==
literal|0
condition|)
block|{
comment|/* Asms will have length< 0.  This is a signal that we have 	     lost alignment knowledge.  Assume, however, that the asm 	     will not mis-align instructions.  */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|ofs
operator|=
literal|0
expr_stmt|;
name|align
operator|=
literal|4
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the known alignment is smaller than the recognized insn group, 	 realign the output.  */
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|align
operator|<
name|len
condition|)
block|{
name|unsigned
name|int
name|new_log_align
init|=
name|len
operator|>
literal|8
condition|?
literal|4
else|:
literal|3
decl_stmt|;
name|rtx
name|prev
decl_stmt|,
name|where
decl_stmt|;
name|where
operator|=
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|where
operator|||
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|where
operator|=
name|i
expr_stmt|;
comment|/* Can't realign between a call and its gp reload.  */
if|if
condition|(
operator|!
operator|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_realign
argument_list|(
name|GEN_INT
argument_list|(
name|new_log_align
argument_list|)
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|new_log_align
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the group won't fit in the same INT16 as the previous, 	 we need to add padding to keep the group together.  Rather 	 than simply leaving the insn filling to the assembler, we 	 can make use of the knowledge of what sorts of instructions 	 were issued in the previous group to make sure that all of 	 the added nops are really free.  */
elseif|else
if|if
condition|(
name|ofs
operator|+
name|len
operator|>
operator|(
name|int
operator|)
name|align
condition|)
block|{
name|int
name|nop_count
init|=
operator|(
name|align
operator|-
name|ofs
operator|)
operator|/
literal|4
decl_stmt|;
name|rtx
name|where
decl_stmt|;
comment|/* Insert nops before labels, branches, and calls to truely merge 	     the execution of the nops with the previous instruction group.  */
name|where
operator|=
name|prev_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|where2
init|=
name|prev_nonnote_insn
argument_list|(
name|where
argument_list|)
decl_stmt|;
if|if
condition|(
name|where2
operator|&&
name|GET_CODE
argument_list|(
name|where2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|where
operator|=
name|where2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|==
name|INSN
condition|)
name|where
operator|=
name|i
expr_stmt|;
block|}
else|else
name|where
operator|=
name|i
expr_stmt|;
do|do
name|emit_insn_before
argument_list|(
call|(
modifier|*
name|next_nop
call|)
argument_list|(
operator|&
name|prev_in_use
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|nop_count
condition|)
do|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
name|ofs
operator|=
operator|(
name|ofs
operator|+
name|len
operator|)
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|prev_in_use
operator|=
name|in_use
expr_stmt|;
name|i
operator|=
name|next
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Machine dependent reorg pass.  */
end_comment

begin_function
name|void
name|alpha_reorg
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
if|if
condition|(
name|alpha_tp
operator|!=
name|ALPHA_TP_PROG
operator|||
name|flag_exceptions
condition|)
name|alpha_handle_trap_shadows
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* Due to the number of extra trapb insns, don't bother fixing up      alignment when trap precision is instruction.  Moreover, we can      only do our job when sched2 is run.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|optimize_size
operator|&&
name|alpha_tp
operator|!=
name|ALPHA_TP_INSN
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
if|if
condition|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV4
condition|)
name|alpha_align_insns
argument_list|(
name|insns
argument_list|,
literal|8
argument_list|,
name|alphaev4_next_group
argument_list|,
name|alphaev4_next_nop
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV5
condition|)
name|alpha_align_insns
argument_list|(
name|insns
argument_list|,
literal|16
argument_list|,
name|alphaev5_next_group
argument_list|,
name|alphaev5_next_nop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check a floating-point value for validity for a particular machine mode.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|float_strings
index|[]
init|=
block|{
comment|/* These are for FLOAT_VAX.  */
literal|"1.70141173319264430e+38"
block|,
comment|/* 2^127 (2^24 - 1) / 2^24 */
literal|"-1.70141173319264430e+38"
block|,
literal|"2.93873587705571877e-39"
block|,
comment|/* 2^-128 */
literal|"-2.93873587705571877e-39"
block|,
comment|/* These are for the default broken IEEE mode, which traps      on infinity or denormal numbers.  */
literal|"3.402823466385288598117e+38"
block|,
comment|/* 2^128 (1 - 2^-24) */
literal|"-3.402823466385288598117e+38"
block|,
literal|"1.1754943508222875079687e-38"
block|,
comment|/* 2^-126 */
literal|"-1.1754943508222875079687e-38"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|REAL_VALUE_TYPE
name|float_values
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inited_float_values
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|check_float_value
parameter_list|(
name|mode
parameter_list|,
name|d
parameter_list|,
name|overflow
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|d
decl_stmt|;
name|int
name|overflow
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_IEEE
operator|||
name|TARGET_IEEE_CONFORMANT
operator|||
name|TARGET_IEEE_WITH_INEXACT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|inited_float_values
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|float_values
index|[
name|i
index|]
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|float_strings
index|[
name|i
index|]
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|inited_float_values
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|fvptr
decl_stmt|;
if|if
condition|(
name|TARGET_FLOAT_VAX
condition|)
name|fvptr
operator|=
operator|&
name|float_values
index|[
literal|0
index|]
expr_stmt|;
else|else
name|fvptr
operator|=
operator|&
name|float_values
index|[
literal|4
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|r
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|fvptr
index|[
literal|0
index|]
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
operator|&
name|fvptr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|r
argument_list|,
name|fvptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
operator|&
name|fvptr
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|dconst0
argument_list|,
name|r
argument_list|)
operator|&&
name|REAL_VALUES_LESS
argument_list|(
name|r
argument_list|,
name|fvptr
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
operator|&
name|dconst0
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|r
argument_list|,
name|dconst0
argument_list|)
operator|&&
name|REAL_VALUES_LESS
argument_list|(
name|fvptr
index|[
literal|3
index|]
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
operator|&
name|dconst0
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
end_if

begin_comment
comment|/* Return the VMS argument type corresponding to MODE.  */
end_comment

begin_function
name|enum
name|avms_arg_type
name|alpha_arg_type
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
return|return
name|TARGET_FLOAT_VAX
condition|?
name|FF
else|:
name|FS
return|;
case|case
name|DFmode
case|:
return|return
name|TARGET_FLOAT_VAX
condition|?
name|FD
else|:
name|FT
return|;
default|default:
return|return
name|I64
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return an rtx for an integer representing the VMS Argument Information    register value.  */
end_comment

begin_function
name|rtx
name|alpha_arg_info_reg_val
parameter_list|(
name|cum
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|regval
init|=
name|cum
operator|.
name|num_args
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|regval
operator||=
operator|(
operator|(
name|int
operator|)
name|cum
operator|.
name|atypes
index|[
name|i
index|]
operator|)
operator|<<
operator|(
name|i
operator|*
literal|3
operator|+
literal|8
operator|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|regval
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_include
include|#
directive|include
file|<splay-tree.h>
end_include

begin_comment
comment|/* Structure to collect function names for final output    in link section.  */
end_comment

begin_enum
enum|enum
name|links_kind
block|{
name|KIND_UNUSED
block|,
name|KIND_LOCAL
block|,
name|KIND_EXTERN
block|}
enum|;
end_enum

begin_struct
struct|struct
name|alpha_links
block|{
name|rtx
name|linkage
decl_stmt|;
name|enum
name|links_kind
name|kind
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|splay_tree
name|alpha_links
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_alpha_links_node
name|PARAMS
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_alpha_links
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_write_one_linkage
name|PARAMS
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protect alpha_links from garbage collection.  */
end_comment

begin_function
specifier|static
name|int
name|mark_alpha_links_node
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|splay_tree_node
name|node
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|alpha_links
modifier|*
name|links
init|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|node
operator|->
name|value
decl_stmt|;
name|ggc_mark_rtx
argument_list|(
name|links
operator|->
name|linkage
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_alpha_links
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|splay_tree
name|tree
init|=
operator|*
operator|(
name|splay_tree
operator|*
operator|)
name|ptr
decl_stmt|;
name|splay_tree_foreach
argument_list|(
name|tree
argument_list|,
name|mark_alpha_links_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make (or fake) .linkage entry for function call.     IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.     Return an SYMBOL_REF rtx for the linkage.  */
end_comment

begin_function
name|rtx
name|alpha_need_linkage
parameter_list|(
name|name
parameter_list|,
name|is_local
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|is_local
decl_stmt|;
block|{
name|splay_tree_node
name|node
decl_stmt|;
name|struct
name|alpha_links
modifier|*
name|al
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|alpha_links
condition|)
block|{
comment|/* Is this name already defined?  */
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|alpha_links
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|al
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|node
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
block|{
comment|/* Defined here but external assumed.  */
if|if
condition|(
name|al
operator|->
name|kind
operator|==
name|KIND_EXTERN
condition|)
name|al
operator|->
name|kind
operator|=
name|KIND_LOCAL
expr_stmt|;
block|}
else|else
block|{
comment|/* Used here but unused assumed.  */
if|if
condition|(
name|al
operator|->
name|kind
operator|==
name|KIND_UNUSED
condition|)
name|al
operator|->
name|kind
operator|=
name|KIND_LOCAL
expr_stmt|;
block|}
return|return
name|al
operator|->
name|linkage
return|;
block|}
block|}
else|else
block|{
name|alpha_links
operator|=
name|splay_tree_new
argument_list|(
operator|(
name|splay_tree_compare_fn
operator|)
name|strcmp
argument_list|,
operator|(
name|splay_tree_delete_key_fn
operator|)
name|free
argument_list|,
operator|(
name|splay_tree_delete_key_fn
operator|)
name|free
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|alpha_links
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|mark_alpha_links
argument_list|)
expr_stmt|;
block|}
name|al
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_links
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Assume external if no definition.  */
name|al
operator|->
name|kind
operator|=
operator|(
name|is_local
condition|?
name|KIND_UNUSED
else|:
name|KIND_EXTERN
operator|)
expr_stmt|;
comment|/* Ensure we have an IDENTIFIER so assemble_name can mark it used.  */
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Construct a SYMBOL_REF for us to call.  */
block|{
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|linksym
init|=
name|alloca
argument_list|(
name|name_len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|linksym
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|memcpy
argument_list|(
name|linksym
operator|+
literal|1
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|linksym
operator|+
literal|1
operator|+
name|name_len
argument_list|,
literal|"..lk"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|al
operator|->
name|linkage
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_alloc_string
argument_list|(
name|linksym
argument_list|,
name|name_len
operator|+
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splay_tree_insert
argument_list|(
name|alpha_links
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|al
argument_list|)
expr_stmt|;
return|return
name|al
operator|->
name|linkage
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_write_one_linkage
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|splay_tree_node
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|node
operator|->
name|key
decl_stmt|;
name|struct
name|alpha_links
modifier|*
name|links
init|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|node
operator|->
name|value
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
operator|(
name|FILE
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|links
operator|->
name|kind
operator|==
name|KIND_UNUSED
operator|||
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%s..lk:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|links
operator|->
name|kind
operator|==
name|KIND_LOCAL
condition|)
block|{
comment|/* Local and used, build linkage pair.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.quad %s..en\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.quad %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* External and used, request linkage pair.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.linkage %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|alpha_write_linkage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|alpha_links
condition|)
block|{
name|readonly_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.align 3\n"
argument_list|)
expr_stmt|;
name|splay_tree_foreach
argument_list|(
name|alpha_links
argument_list|,
name|alpha_write_one_linkage
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a decl, a section name, and whether the decl initializer    has relocs, choose attributes for the section.  */
end_comment

begin_define
define|#
directive|define
name|SECTION_VMS_OVERLAY
value|SECTION_FORGET
end_define

begin_define
define|#
directive|define
name|SECTION_VMS_GLOBAL
value|SECTION_MACH_DEP
end_define

begin_define
define|#
directive|define
name|SECTION_VMS_INITIALIZE
value|(SECTION_VMS_GLOBAL<< 1)
end_define

begin_function
specifier|static
name|unsigned
name|int
name|vms_section_type_flags
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|unsigned
name|int
name|flags
init|=
name|default_section_type_flags
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"overlaid"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_VMS_OVERLAY
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"global"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_VMS_GLOBAL
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"initialize"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_VMS_INITIALIZE
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Switch to an arbitrary section NAME with attributes as specified    by FLAGS.  ALIGN specifies any known alignment requirements for    the section; 0 if the default should be used.  */
end_comment

begin_function
specifier|static
name|void
name|vms_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".section\t%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_VMS_OVERLAY
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",OVR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_VMS_GLOBAL
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",GBL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_VMS_INITIALIZE
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",NOMOD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_DEBUG
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",NOWRT"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an element in the table of global constructors.  SYMBOL is    a SYMBOL_REF of the function to be called; PRIORITY is a number    between 0 and MAX_INIT_PRIORITY.       Differs from default_ctors_section_asm_out_constructor in that the    width of the .ctors entry is always 64 bits, rather than the 32 bits    used by a normal pointer.  */
end_comment

begin_function
specifier|static
name|void
name|vms_asm_out_constructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ctors_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|UNITS_PER_WORD
argument_list|,
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vms_asm_out_destructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|dtors_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|UNITS_PER_WORD
argument_list|,
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|rtx
name|alpha_need_linkage
parameter_list|(
name|name
parameter_list|,
name|is_local
parameter_list|)
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|is_local
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_ABI_OPEN_VMS */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|TARGET_ABI_UNICOSMK
end_if

begin_decl_stmt
specifier|static
name|void
name|unicosmk_output_module_name
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unicosmk_output_default_externs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unicosmk_output_dex
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unicosmk_output_externs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unicosmk_output_addr_vec
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|unicosmk_ssib_name
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unicosmk_special_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the offset between two registers, one to be eliminated, and the    other its replacement, at the start of a routine.  */
end_comment

begin_function
name|int
name|unicosmk_initial_elimination_offset
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|{
name|int
name|fixed_size
decl_stmt|;
name|fixed_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|fixed_size
operator|!=
literal|0
condition|)
name|fixed_size
operator|+=
literal|48
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
operator|-
name|fixed_size
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
operator|(
name|ALPHA_ROUND
argument_list|(
name|fixed_size
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
argument_list|)
operator|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the module name for .ident and .end directives. We have to strip    directories and add make sure that the module name starts with a letter    or '$'.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_module_name
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Strip directories.  */
name|name
operator|=
name|strrchr
argument_list|(
name|main_input_filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|++
name|name
expr_stmt|;
else|else
name|name
operator|=
name|main_input_filename
expr_stmt|;
comment|/* CAM only accepts module names that start with a letter or '$'. We      prefix the module name with a '$' if necessary.  */
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|name
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output text that to appear at the beginning of an assembler file.  */
end_comment

begin_function
name|void
name|unicosmk_asm_file_start
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fputs
argument_list|(
literal|"\t.ident\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|unicosmk_output_module_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* The Unicos/Mk assembler uses different register names. Instead of trying      to support them, we simply use micro definitions.  */
comment|/* CAM has different register names: rN for the integer register N and fN      for the floating-point register N. Instead of trying to use these in      alpha.md, we define the symbols $N and $fN to refer to the appropriate      register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$%d<- r%d\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$f%d<- f%d\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* The .align directive fill unused space with zeroes which does not work      in code sections. We define the macro 'gcc@code@align' which uses nops      instead. Note that it assumes that code sections always have the      biggest possible alignment since . refers to the current offset from      the beginning of the section.  */
name|fputs
argument_list|(
literal|"\t.macro gcc@code@align n\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gcc@n@bytes = 1<< n\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gcc@here = . % gcc@n@bytes\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.if ne, gcc@here, 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.repeat (gcc@n@bytes - gcc@here) / 4\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tbis r31,r31,r31\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.endr\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.endif\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.endm gcc@code@align\n\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Output extern declarations which should always be visible.  */
name|unicosmk_output_default_externs
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Open a dummy section. We always need to be inside a section for the      section-switching code to work correctly.      ??? This should be a module id or something like that. I still have to      figure out what the rules for those are.  */
name|fputs
argument_list|(
literal|"\n\t.psect\t$SG00000,data\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output text to appear at the end of an assembler file. This includes all    pending extern declarations and DEX expressions.  */
end_comment

begin_function
name|void
name|unicosmk_asm_file_end
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"\t.endp\n\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Output all pending externs.  */
name|unicosmk_output_externs
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Output dex definitions used for functions whose names conflict with       register names.  */
name|unicosmk_output_dex
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.end\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|unicosmk_output_module_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the definition of a common variable.  */
end_comment

begin_function
name|void
name|unicosmk_output_common
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|tree
name|name_tree
decl_stmt|;
name|printf
argument_list|(
literal|"T3E__: common %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|common_section
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.endp\n\n\t.psect "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",%d,common\n"
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte\t0:%d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as defined in this module.  */
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SECTION_PUBLIC
value|SECTION_MACH_DEP
end_define

begin_define
define|#
directive|define
name|SECTION_MAIN
value|(SECTION_PUBLIC<< 1)
end_define

begin_decl_stmt
specifier|static
name|int
name|current_section_align
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|unicosmk_section_type_flags
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|flags
init|=
name|default_section_type_flags
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
return|return
name|flags
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|current_section_align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_functions_log
operator|>
name|current_section_align
condition|)
name|current_section_align
operator|=
name|align_functions_log
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_MAIN
expr_stmt|;
block|}
else|else
name|current_section_align
operator|=
name|floor_log2
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_PUBLIC
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Generate a section name for decl and associate it with the    declaration.  */
end_comment

begin_function
name|void
name|unicosmk_unique_section
parameter_list|(
name|decl
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
name|abort
argument_list|()
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
comment|/* It is essential that we prefix the section name here because  	 otherwise the section names generated for constructors and  	 destructors confuse collect2.  */
name|string
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"code@%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
operator|+
literal|5
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"data@%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
operator|+
literal|5
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Switch to an arbitrary section NAME with attributes as specified    by FLAGS.  ALIGN specifies any known alignment requirements for    the section; 0 if the default should be used.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|kind
decl_stmt|;
comment|/* Close the previous section.  */
name|fputs
argument_list|(
literal|"\t.endp\n\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Find out what kind of section we are opening.  */
if|if
condition|(
name|flags
operator|&
name|SECTION_MAIN
condition|)
name|fputs
argument_list|(
literal|"\t.start\tmain\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
name|kind
operator|=
literal|"code"
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_PUBLIC
condition|)
name|kind
operator|=
literal|"common"
expr_stmt|;
else|else
name|kind
operator|=
literal|"data"
expr_stmt|;
if|if
condition|(
name|current_section_align
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.psect\t%s,%d,%s\n"
argument_list|,
name|name
argument_list|,
name|current_section_align
argument_list|,
name|kind
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.psect\t%s,%s\n"
argument_list|,
name|name
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unicosmk_insert_attributes
parameter_list|(
name|decl
parameter_list|,
name|attr_ptr
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
modifier|*
name|attr_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
name|UNIQUE_SECTION
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an alignment directive. We have to use the macro 'gcc@code@align'    in code sections because .align fill unused space with zeroes.  */
end_comment

begin_function
name|void
name|unicosmk_output_align
parameter_list|(
name|file
parameter_list|,
name|align
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|inside_function
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tgcc@code@align\t%d\n"
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align\t%d\n"
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a case vector to the current function's list of deferred case    vectors. Case vectors have to be put into a separate section because CAM    does not allow data definitions in code sections.  */
end_comment

begin_function
name|void
name|unicosmk_defer_case_vector
parameter_list|(
name|lab
parameter_list|,
name|vec
parameter_list|)
name|rtx
name|lab
decl_stmt|;
name|rtx
name|vec
decl_stmt|;
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|cfun
operator|->
name|machine
decl_stmt|;
name|vec
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|machine
operator|->
name|addr_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|,
name|machine
operator|->
name|addr_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a case vector.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_addr_vec
parameter_list|(
name|file
parameter_list|,
name|vec
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|vec
decl_stmt|;
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|body
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|vlen
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
name|ASM_OUTPUT_ADDR_VEC_ELT
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output current function's deferred case vectors.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_deferred_case_vectors
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|cfun
operator|->
name|machine
decl_stmt|;
name|rtx
name|t
decl_stmt|;
if|if
condition|(
name|machine
operator|->
name|addr_list
operator|==
name|NULL_RTX
condition|)
return|return;
name|data_section
argument_list|()
expr_stmt|;
for|for
control|(
name|t
operator|=
name|machine
operator|->
name|addr_list
init|;
name|t
condition|;
name|t
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
control|)
name|unicosmk_output_addr_vec
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the dynamic subprogram information block (DSIB) and update the     frame pointer register ($15) for subroutines which have a frame. If the     subroutine doesn't have a frame, simply increment $15.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_gen_dsib
parameter_list|(
name|imaskP
parameter_list|)
name|unsigned
name|long
modifier|*
name|imaskP
decl_stmt|;
block|{
if|if
condition|(
name|alpha_is_stack_procedure
condition|)
block|{
specifier|const
name|char
modifier|*
name|ssib_name
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* Allocate 64 bytes for the DSIB.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|64
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Save the return address.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|56
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|imaskP
operator|)
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
expr_stmt|;
comment|/* Save the old frame pointer.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|48
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|imaskP
operator|)
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Store the SSIB pointer.  */
name|ssib_name
operator|=
name|ggc_strdup
argument_list|(
name|unicosmk_ssib_name
argument_list|()
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|5
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ssib_name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the CIW index.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|25
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set the new frame pointer.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|64
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Increment the frame pointer register to indicate that we do not          have a frame.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SSIB_PREFIX
value|"__SSIB_"
end_define

begin_define
define|#
directive|define
name|SSIB_PREFIX_LEN
value|7
end_define

begin_comment
comment|/* Generate the name of the SSIB section for the current function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|unicosmk_ssib_name
parameter_list|()
block|{
comment|/* This is ok since CAM won't be able to deal with names longer than that       anyway.  */
specifier|static
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|int
name|len
decl_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|fnname
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|SSIB_PREFIX_LEN
operator|>
literal|255
condition|)
name|len
operator|=
literal|255
operator|-
name|SSIB_PREFIX_LEN
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|SSIB_PREFIX
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
operator|+
name|SSIB_PREFIX_LEN
argument_list|,
name|fnname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
operator|+
name|SSIB_PREFIX_LEN
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Output the static subroutine information block for the current    function.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_ssib
parameter_list|(
name|file
parameter_list|,
name|fnname
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|ciw
decl_stmt|;
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|cfun
operator|->
name|machine
decl_stmt|;
name|ssib_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.endp\n\n\t.psect\t%s%s,data\n"
argument_list|,
name|user_label_prefix
argument_list|,
name|unicosmk_ssib_name
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Some required stuff and the function name length.  */
name|len
operator|=
name|strlen
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.quad\t^X20008%2.2X28\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Saved registers      ??? We don't do that yet.  */
name|fputs
argument_list|(
literal|"\t.quad\t0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Function address.  */
name|fputs
argument_list|(
literal|"\t.quad\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.quad\t0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.quad\t0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Function name.      ??? We do it the same way Cray CC does it but this could be      simplified.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte\t%d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fnname
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\t.quad\t0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.bits\t%d : 0\n"
argument_list|,
operator|(
literal|8
operator|-
operator|(
name|len
operator|%
literal|8
operator|)
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* All call information words used in the function.  */
for|for
control|(
name|x
operator|=
name|machine
operator|->
name|first_ciw
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ciw
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.quad\t"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|ciw
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|ciw
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|ciw
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a call information word (CIW) to the list of the current function's    CIWs and return its index.     X is a CONST_INT or CONST_DOUBLE representing the CIW.  */
end_comment

begin_function
name|rtx
name|unicosmk_add_call_info_word
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|node
decl_stmt|;
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|cfun
operator|->
name|machine
decl_stmt|;
name|node
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|machine
operator|->
name|first_ciw
operator|==
name|NULL_RTX
condition|)
name|machine
operator|->
name|first_ciw
operator|=
name|node
expr_stmt|;
else|else
name|XEXP
argument_list|(
name|machine
operator|->
name|last_ciw
argument_list|,
literal|1
argument_list|)
operator|=
name|node
expr_stmt|;
name|machine
operator|->
name|last_ciw
operator|=
name|node
expr_stmt|;
operator|++
name|machine
operator|->
name|ciw_count
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|machine
operator|->
name|ciw_count
operator|+
name|strlen
argument_list|(
name|current_function_name
argument_list|)
operator|/
literal|8
operator|+
literal|5
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|unicosmk_section_buf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|unicosmk_text_section
parameter_list|()
block|{
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|unicosmk_section_buf
argument_list|,
literal|"\t.endp\n\n\t.psect\tgcc@text___%d,code"
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
return|return
name|unicosmk_section_buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unicosmk_data_section
parameter_list|()
block|{
specifier|static
name|int
name|count
init|=
literal|1
decl_stmt|;
name|sprintf
argument_list|(
name|unicosmk_section_buf
argument_list|,
literal|"\t.endp\n\n\t.psect\tgcc@data___%d,data"
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
return|return
name|unicosmk_section_buf
return|;
block|}
end_function

begin_comment
comment|/* The Cray assembler doesn't accept extern declarations for symbols which    are defined in the same file. We have to keep track of all global    symbols which are referenced and/or defined in a source file and output    extern declarations for those which are referenced but not defined at    the end of file.  */
end_comment

begin_comment
comment|/* List of identifiers for which an extern declaration might have to be    emitted.  */
end_comment

begin_struct
struct|struct
name|unicosmk_extern_list
block|{
name|struct
name|unicosmk_extern_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|unicosmk_extern_list
modifier|*
name|unicosmk_extern_head
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output extern declarations which are required for every asm file.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_default_externs
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|externs
index|[]
init|=
block|{
literal|"__T3E_MISMATCH"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
name|ARRAY_SIZE
argument_list|(
name|externs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.extern\t%s\n"
argument_list|,
name|externs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output extern declarations for global symbols which are have been    referenced but not defined.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_externs
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|unicosmk_extern_list
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|name_tree
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|user_label_prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|unicosmk_extern_head
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* We have to strip the encoding and possibly remove user_label_prefix  	 from the identifier in order to handle -fleading-underscore and 	 explicit asm names correctly (cf. gcc.dg/asm-names-1.c).  */
name|STRIP_NAME_ENCODING
argument_list|(
name|real_name
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
operator|!
name|memcmp
argument_list|(
name|real_name
argument_list|,
name|user_label_prefix
argument_list|,
name|len
argument_list|)
condition|)
name|real_name
operator|+=
name|len
expr_stmt|;
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record an extern.  */
end_comment

begin_function
name|void
name|unicosmk_add_extern
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|unicosmk_extern_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|unicosmk_extern_list
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unicosmk_extern_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|unicosmk_extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|unicosmk_extern_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The Cray assembler generates incorrect code if identifiers which    conflict with register names are used as instruction operands. We have    to replace such identifiers with DEX expressions.  */
end_comment

begin_comment
comment|/* Structure to collect identifiers which have been replaced by DEX    expressions.  */
end_comment

begin_struct
struct|struct
name|unicosmk_dex
block|{
name|struct
name|unicosmk_dex
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of identifiers which have been replaced by DEX expressions. The DEX     number is determined by the position in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unicosmk_dex
modifier|*
name|unicosmk_dex_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of elements in the DEX list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unicosmk_dex_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check if NAME must be replaced by a DEX expression.  */
end_comment

begin_function
specifier|static
name|int
name|unicosmk_special_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
operator|++
name|name
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
operator|++
name|name
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'r'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'f'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'R'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'F'
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
return|return
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|ISDIGIT
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
case|case
literal|'3'
case|:
return|return
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'0'
operator|||
name|name
index|[
literal|2
index|]
operator|==
literal|'1'
operator|)
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
default|default:
return|return
operator|(
name|ISDIGIT
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the DEX number if X must be replaced by a DEX expression and 0    otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|unicosmk_need_dex
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|unicosmk_dex
modifier|*
name|dex
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unicosmk_special_name
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
name|i
operator|=
name|unicosmk_dex_count
expr_stmt|;
for|for
control|(
name|dex
operator|=
name|unicosmk_dex_list
init|;
name|dex
condition|;
name|dex
operator|=
name|dex
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|dex
operator|->
name|name
argument_list|)
condition|)
return|return
name|i
return|;
operator|--
name|i
expr_stmt|;
block|}
name|dex
operator|=
operator|(
expr|struct
name|unicosmk_dex
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unicosmk_dex
argument_list|)
argument_list|)
expr_stmt|;
name|dex
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|dex
operator|->
name|next
operator|=
name|unicosmk_dex_list
expr_stmt|;
name|unicosmk_dex_list
operator|=
name|dex
expr_stmt|;
operator|++
name|unicosmk_dex_count
expr_stmt|;
return|return
name|unicosmk_dex_count
return|;
block|}
end_function

begin_comment
comment|/* Output the DEX definitions for this file.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_dex
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|unicosmk_dex
modifier|*
name|dex
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unicosmk_dex_list
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.dexstart\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|unicosmk_dex_count
expr_stmt|;
for|for
control|(
name|dex
operator|=
name|unicosmk_dex_list
init|;
name|dex
condition|;
name|dex
operator|=
name|dex
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tDEX (%d) = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|dex
operator|->
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.dexend\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|unicosmk_output_deferred_case_vectors
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{}
end_function

begin_function
specifier|static
name|void
name|unicosmk_gen_dsib
parameter_list|(
name|imaskP
parameter_list|)
name|unsigned
name|long
modifier|*
name|imaskP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{}
end_function

begin_function
specifier|static
name|void
name|unicosmk_output_ssib
parameter_list|(
name|file
parameter_list|,
name|fnname
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{}
end_function

begin_function
name|rtx
name|unicosmk_add_call_info_word
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unicosmk_need_dex
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_ABI_UNICOSMK */
end_comment

end_unit

