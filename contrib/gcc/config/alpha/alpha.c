begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on the DEC Alpha.    Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.     Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* External data.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify which cpu to schedule for. */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|alpha_cpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|alpha_cpu_name
index|[]
init|=
block|{
literal|"ev4"
block|,
literal|"ev5"
block|,
literal|"ev6"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify how accurate floating-point traps need to be.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_trap_precision
name|alpha_tp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify the floating-point rounding mode.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_fp_rounding_mode
name|alpha_fprm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify which things cause traps.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_fp_trap_mode
name|alpha_fptm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings decoded into the above options.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_cpu_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mcpu= */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_tp_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mtrap-precision=[p|s|i] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_fprm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mfp-rounding-mode=[n|m|c|d] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_fptm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mfp-trap-mode=[n|u|su|sui] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_mlat_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mmemory-latency= */
end_comment

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|alpha_compare_op0
decl_stmt|,
name|alpha_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alpha_compare_fp_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the information needed to modify the epilogue for EH.  */
end_comment

begin_decl_stmt
name|rtx
name|alpha_eh_epilogue_sp_ofs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if inside of a function, because the Alpha asm can't    handle .files inside of functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inside_function
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-null, this rtx holds the return address for the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|alpha_return_addr_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of cycles of latency we should assume on memory reads.  */
end_comment

begin_decl_stmt
name|int
name|alpha_memory_latency
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the function needs the GP.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_function_needs_gp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The alias set for prologue/epilogue register save/restore.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_sr_alias_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declarations of static functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|alpha_set_memflags_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alpha_emit_set_const_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_expand_unaligned_load_words
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
name|out_regs
operator|,
name|rtx
name|smem
operator|,
name|HOST_WIDE_INT
name|words
operator|,
name|HOST_WIDE_INT
name|ofs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_expand_unaligned_store_words
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
name|out_regs
operator|,
name|rtx
name|smem
operator|,
name|HOST_WIDE_INT
name|words
operator|,
name|HOST_WIDE_INT
name|ofs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_sa_mask
name|PROTO
argument_list|(
operator|(
name|unsigned
name|long
operator|*
name|imaskP
operator|,
name|unsigned
name|long
operator|*
name|fmaskP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_does_function_need_gp
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zap_mask
name|PROTO
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|alpha_emit_set_long_const
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|alpha_expand_unaligned_load
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|alpha_expand_unaligned_store
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the number of args of a function in one of two ways.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPEN_VMS
end_ifdef

begin_define
define|#
directive|define
name|NUM_ARGS
value|current_function_args_info.num_args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUM_ARGS
value|current_function_args_info
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REG_PV
value|27
end_define

begin_define
define|#
directive|define
name|REG_RA
value|26
end_define

begin_escape
end_escape

begin_comment
comment|/* Parse target option strings. */
end_comment

begin_function
name|void
name|override_options
parameter_list|()
block|{
name|alpha_tp
operator|=
name|ALPHA_TP_PROG
expr_stmt|;
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_N
expr_stmt|;
if|if
condition|(
name|TARGET_IEEE
condition|)
block|{
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IEEE_WITH_INEXACT
condition|)
block|{
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SUI
expr_stmt|;
block|}
if|if
condition|(
name|alpha_tp_string
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"p"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_PROG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"f"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_FUNC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"i"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mtrap-precision switch"
argument_list|,
name|alpha_tp_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fprm_string
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"n"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"m"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_MINF
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"c"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_CHOP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"d"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_DYN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mfp-rounding-mode switch"
argument_list|,
name|alpha_fprm_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fptm_string
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_N
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"u"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_U
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"su"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"sui"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SUI
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mfp-trap-mode switch"
argument_list|,
name|alpha_fptm_string
argument_list|)
expr_stmt|;
block|}
name|alpha_cpu
operator|=
name|TARGET_CPU_DEFAULT
operator|&
name|MASK_CPU_EV6
condition|?
name|PROCESSOR_EV6
else|:
operator|(
name|TARGET_CPU_DEFAULT
operator|&
name|MASK_CPU_EV5
condition|?
name|PROCESSOR_EV5
else|:
name|PROCESSOR_EV4
operator|)
expr_stmt|;
if|if
condition|(
name|alpha_cpu_string
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"ev4"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"21064"
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|PROCESSOR_EV4
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_BWX
operator||
name|MASK_MAX
operator||
name|MASK_FIX
operator||
name|MASK_CIX
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"ev5"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"21164"
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|PROCESSOR_EV5
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_BWX
operator||
name|MASK_MAX
operator||
name|MASK_FIX
operator||
name|MASK_CIX
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"ev56"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"21164a"
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|PROCESSOR_EV5
expr_stmt|;
name|target_flags
operator||=
name|MASK_BWX
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_MAX
operator||
name|MASK_FIX
operator||
name|MASK_CIX
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"pca56"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"21164PC"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"21164pc"
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|PROCESSOR_EV5
expr_stmt|;
name|target_flags
operator||=
name|MASK_BWX
operator||
name|MASK_MAX
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_FIX
operator||
name|MASK_CIX
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"ev6"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
literal|"21264"
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|PROCESSOR_EV6
expr_stmt|;
name|target_flags
operator||=
name|MASK_BWX
operator||
name|MASK_MAX
operator||
name|MASK_FIX
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_CIX
operator|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mcpu switch"
argument_list|,
name|alpha_cpu_string
argument_list|)
expr_stmt|;
block|}
comment|/* Do some sanity checks on the above options. */
if|if
condition|(
operator|(
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SU
operator|||
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SUI
operator|)
operator|&&
name|alpha_tp
operator|!=
name|ALPHA_TP_INSN
operator|&&
name|alpha_cpu
operator|!=
name|PROCESSOR_EV6
condition|)
block|{
name|warning
argument_list|(
literal|"fp software completion requires -mtrap-precision=i"
argument_list|)
expr_stmt|;
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_FLOAT_VAX
condition|)
block|{
if|if
condition|(
name|alpha_fprm
operator|==
name|ALPHA_FPRM_MINF
operator|||
name|alpha_fprm
operator|==
name|ALPHA_FPRM_DYN
condition|)
block|{
name|warning
argument_list|(
literal|"rounding mode not supported for VAX floats"
argument_list|)
expr_stmt|;
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SUI
condition|)
block|{
name|warning
argument_list|(
literal|"trap mode not supported for VAX floats"
argument_list|)
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
block|}
block|}
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|lat
decl_stmt|;
if|if
condition|(
operator|!
name|alpha_mlat_string
condition|)
name|alpha_mlat_string
operator|=
literal|"L1"
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|alpha_mlat_string
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|lat
operator|=
name|strtol
argument_list|(
name|alpha_mlat_string
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
operator|,
operator|*
name|end
operator|==
literal|'\0'
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|alpha_mlat_string
index|[
literal|0
index|]
operator|==
literal|'L'
operator|||
name|alpha_mlat_string
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|alpha_mlat_string
index|[
literal|1
index|]
argument_list|)
operator|&&
name|alpha_mlat_string
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|static
name|int
specifier|const
name|cache_latency
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|3
block|,
literal|30
block|,
operator|-
literal|1
block|}
block|,
comment|/* ev4 -- Bcache is a guess */
block|{
literal|2
block|,
literal|12
block|,
literal|38
block|}
block|,
comment|/* ev5 -- Bcache from PC164 LMbench numbers */
block|{
literal|3
block|,
literal|13
block|,
operator|-
literal|1
block|}
block|,
comment|/* ev6 -- Ho hum, doesn't exist yet */
block|}
decl_stmt|;
name|lat
operator|=
name|alpha_mlat_string
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|lat
operator|<
literal|0
operator|||
name|lat
operator|>
literal|3
operator|||
name|cache_latency
index|[
name|alpha_cpu
index|]
index|[
name|lat
operator|-
literal|1
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"L%d cache latency unknown for %s"
argument_list|,
name|lat
argument_list|,
name|alpha_cpu_name
index|[
name|alpha_cpu
index|]
argument_list|)
expr_stmt|;
name|lat
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|lat
operator|=
name|cache_latency
index|[
name|alpha_cpu
index|]
index|[
name|lat
operator|-
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_mlat_string
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
comment|/* Most current memories have about 370ns latency.  This is 	   a reasonable guess for a fast cpu.  */
name|lat
operator|=
literal|150
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"bad value `%s' for -mmemory-latency"
argument_list|,
name|alpha_mlat_string
argument_list|)
expr_stmt|;
name|lat
operator|=
literal|3
expr_stmt|;
block|}
name|alpha_memory_latency
operator|=
name|lat
expr_stmt|;
block|}
comment|/* Default the definition of "small data" to 8 bytes.  */
if|if
condition|(
operator|!
name|g_switch_set
condition|)
name|g_switch_value
operator|=
literal|8
expr_stmt|;
comment|/* Acquire a unique set number for our register saves and restores.  */
name|alpha_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */
end_comment

begin_function
name|int
name|zap_mask
parameter_list|(
name|value
parameter_list|)
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0xff
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either the constant zero or a register.  If a    register, it must be in the proper mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant in the range of 0-63 (for a shift) or    any register.  */
end_comment

begin_function
name|int
name|reg_or_6bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant or any register.  */
end_comment

begin_function
name|int
name|reg_or_8bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant.  */
end_comment

begin_function
name|int
name|cint8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to an add insn.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/* Constraints I, J, O and P are covered by K.  */
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to a sign-extending    add insn.  */
end_comment

begin_function
name|int
name|sext_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'O'
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant 4 or 8.  */
end_comment

begin_function
name|int
name|const48_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an AND insn.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
operator|(
name|zap_mask
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
name|zap_mask
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an IOR or XOR insn.  */
end_comment

begin_function
name|int
name|or_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width, in bits, of an integral    mode smaller than DImode.  */
end_comment

begin_function
name|int
name|mode_width_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|32
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|64
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width of an integral machine mode    smaller than an integer.  */
end_comment

begin_function
name|int
name|mode_mask_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xff
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xffff
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a multiple of 8 less than 64.  */
end_comment

begin_function
name|int
name|mul8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|7
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant zero in floating-point.  */
end_comment

begin_function
name|int
name|fp0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the floating-point constant zero or a register.  */
end_comment

begin_function
name|int
name|reg_or_fp0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|fp0_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a hard floating-point register.  */
end_comment

begin_function
name|int
name|hard_fp_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|FLOAT_REGS
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|hard_fp_register_operand
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register or a constant integer.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is something that can be reloaded into a register;    if it is a MEM, it need not be valid.  */
end_comment

begin_function
name|int
name|some_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|MEM
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
return|return
name|some_operand
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the source of a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
comment|/* This handles both the Windows/NT and OSF cases.  */
return|return
name|mode
operator|==
name|ptr_mode
operator|||
name|mode
operator|==
name|DImode
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ... fall through ... */
case|case
name|MEM
case|:
return|return
operator|(
operator|(
name|TARGET_BWX
operator|||
operator|(
name|mode
operator|!=
name|HImode
operator|&&
name|mode
operator|!=
name|QImode
operator|)
operator|)
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
case|case
name|CONST_DOUBLE
case|:
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|add_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONSTANT_P_RTX
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a SYMBOL_REF for a function known to be in this    file.  */
end_comment

begin_function
name|int
name|current_file_function_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|profile_flag
operator|&&
operator|!
name|profile_block_flag
operator|&&
operator|(
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
operator|||
name|op
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|Pmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|TARGET_OPEN_VMS
operator|||
name|TARGET_WINDOWS_NT
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
literal|27
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha comparison operator.  Here we know which    comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
operator|(
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha swapped comparison operator.  */
end_comment

begin_function
name|int
name|alpha_swapped_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
operator|(
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a signed comparison operation.  */
end_comment

begin_function
name|int
name|signed_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a divide or modulus operator.  */
end_comment

begin_function
name|int
name|divmod_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this memory address is a known aligned register plus    a constant.  It must be a valid address.  This means that we can do    this as an aligned reference plus some offset.     Take into account what reload will do.  */
end_comment

begin_function
name|int
name|aligned_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)      sorts of constructs.  Dig for the real base register.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|base
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|op
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|>=
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but return 1 if OP is a MEM which is not alignable.  */
end_comment

begin_function
name|int
name|unaligned_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)      sorts of constructs.  Dig for the real base register.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|base
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|op
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|<
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is either a register or an unaligned memory location.  */
end_comment

begin_function
name|int
name|reg_or_unaligned_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|unaligned_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is any memory location.  During reload a pseudo matches.  */
end_comment

begin_function
name|int
name|any_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is not an eliminable register.     This exists to cure a pathological abort in the s8addq (et al) patterns,  	long foo () { long t; bar(); return (long)&t * 26107; }     which run afoul of a hack in reload to cure a (presumably) similar    problem with lea-type instructions on other targets.  But there is    one of us and many of them, so work around the problem by selectively    preventing combine from making the optimization.  */
end_comment

begin_function
name|int
name|reg_not_elim_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|inner
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|==
name|frame_pointer_rtx
operator|||
name|inner
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is OP is a memory location that is not a reference (using    an AND) to an unaligned location.  Take into account what reload    will do.  */
end_comment

begin_function
name|int
name|normal_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
comment|/* This may not have been assigned an equivalent address if it will 	     be eliminated.  In that case, it doesn't matter what we do.  */
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|AND
return|;
block|}
end_function

begin_comment
comment|/* Accept a register, but not a subreg of any kind.  This allows us to    avoid pathological cases in reload wrt data movement common in     int->fp conversion.  */
end_comment

begin_function
name|int
name|reg_no_subreg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
literal|0
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if this function can directly return via $26.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|()
block|{
return|return
operator|(
operator|!
name|TARGET_OPEN_VMS
operator|&&
name|reload_completed
operator|&&
name|alpha_sa_size
argument_list|()
operator|==
literal|0
operator|&&
name|get_frame_size
argument_list|()
operator|==
literal|0
operator|&&
name|current_function_outgoing_args_size
operator|==
literal|0
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* REF is an alignable memory location.  Place an aligned SImode    reference into *PALIGNED_MEM and the number of bits to shift into    *PBITNUM.  SCRATCH is a free register for use in reloading out    of range stack slots.  */
end_comment

begin_function
name|void
name|get_aligned_mem
parameter_list|(
name|ref
parameter_list|,
name|paligned_mem
parameter_list|,
name|pbitnum
parameter_list|)
name|rtx
name|ref
decl_stmt|;
name|rtx
modifier|*
name|paligned_mem
decl_stmt|,
decl|*
name|pbitnum
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|paligned_mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|&
operator|~
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
operator|*
name|paligned_mem
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
operator|*
name|paligned_mem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* Sadly, we cannot use alias sets here because we may overlap other      data in a different alias set.  */
comment|/* MEM_ALIAS_SET (*paligned_mem) = MEM_ALIAS_SET (ref); */
operator|*
name|pbitnum
operator|=
name|GEN_INT
argument_list|(
operator|(
name|offset
operator|&
literal|3
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Similar, but just get the address.  Handle the two reload cases.      Add EXTRA_OFFSET to the address we return.  */
end_comment

begin_function
name|rtx
name|get_unaligned_address
parameter_list|(
name|ref
parameter_list|,
name|extra_offset
parameter_list|)
name|rtx
name|ref
decl_stmt|;
name|int
name|extra_offset
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
name|extra_offset
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subfunction of the following function.  Update the flags of any MEM    found in part of X.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_set_memflags_1
parameter_list|(
name|x
parameter_list|,
name|in_struct_p
parameter_list|,
name|volatile_p
parameter_list|,
name|unchanging_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|in_struct_p
decl_stmt|,
name|volatile_p
decl_stmt|,
name|unchanging_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SEQUENCE
case|:
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|alpha_set_memflags_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|alpha_set_memflags_1
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|alpha_set_memflags_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
name|alpha_set_memflags_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|volatile_p
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
comment|/* Sadly, we cannot use alias sets because the extra aliasing 	 produced by the AND interferes.  Given that two-byte quantities 	 are the only thing we would be able to differentiate anyway, 	 there does not seem to be any point in convoluting the early 	 out of the alias check.  */
comment|/* MEM_ALIAS_SET (x) = alias_set; */
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given INSN, which is either an INSN or a SEQUENCE generated to    perform a memory operation, look for any MEMs in either a SET_DEST or    a SET_SRC and copy the in-struct, unchanging, and volatile flags from    REF into each of the MEMs found.  If REF is not a MEM, don't do    anything.  */
end_comment

begin_function
name|void
name|alpha_set_memflags
parameter_list|(
name|insn
parameter_list|,
name|ref
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ref
decl_stmt|;
block|{
name|int
name|in_struct_p
decl_stmt|,
name|volatile_p
decl_stmt|,
name|unchanging_p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|in_struct_p
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|volatile_p
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|unchanging_p
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* This is only called from alpha.md, after having had something       generated from one of the insn patterns.  So if everything is      zero, the pattern is already up-to-date.  */
if|if
condition|(
operator|!
name|in_struct_p
operator|&&
operator|!
name|volatile_p
operator|&&
operator|!
name|unchanging_p
condition|)
return|return;
name|alpha_set_memflags_1
argument_list|(
name|insn
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to output insns to set TARGET equal to the constant C if it can be    done in less than N insns.  Do all computations in MODE.  Returns the place    where the output has been placed if it can be done and the insns have been    emitted.  If it would take more than N insns, zero is returned and no    insns and emitted.  */
end_comment

begin_function
name|rtx
name|alpha_emit_set_const
parameter_list|(
name|target
parameter_list|,
name|mode
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Try 1 insn, then 2, then up to N. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|pat
operator|=
name|alpha_emit_set_const_1
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|pat
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internal routine for the above to check for N or below insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|alpha_emit_set_const_1
parameter_list|(
name|target
parameter_list|,
name|mode
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|new
init|=
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
comment|/* Use a pseudo if highly optimizing and still generating RTL.  */
name|rtx
name|subtarget
init|=
operator|(
name|flag_expensive_optimizations
operator|&&
name|rtx_equal_function_value_matters
condition|?
literal|0
else|:
name|target
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
comment|/* We are only called for SImode and DImode.  If this is SImode, ensure that      we are sign extended to a full word.  This does not make any sense when      cross-compiling on a narrow machine.  */
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|c
operator|=
operator|(
name|c
operator|&
literal|0xffffffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|c
operator|&
literal|0x80000000
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is a sign-extended 32-bit constant, we can do this in at most      three insns, so do it if we have enough insns left.  We always have      a sign-extended 32-bit constant when compiling on a narrow machine.   */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
operator|||
name|c
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|c
operator|>>
literal|31
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
name|c
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|c
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|c
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|extra
init|=
literal|0
decl_stmt|;
comment|/* If HIGH will be interpreted as negative but the constant is 	 positive, we must adjust it to do two ldha insns.  */
if|if
condition|(
operator|(
name|high
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|low
operator|||
operator|(
name|low
operator|==
literal|0
operator|&&
name|extra
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* We used to use copy_to_suggested_reg (GEN_INT (c), target, mode) 	     but that meant that we can't handle INT_MIN on 32-bit machines 	     (like NT/Alpha), because we recurse indefinitely through  	     emit_move_insn to gen_movdi.  So instead, since we know exactly 	     what we want, create it explicitly.  */
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
literal|2
operator|+
operator|(
name|extra
operator|!=
literal|0
operator|)
condition|)
block|{
name|temp
operator|=
name|copy_to_suggested_reg
argument_list|(
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|extra
operator|<<
literal|16
argument_list|)
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|high
operator|<<
literal|16
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
block|}
block|}
comment|/* If we couldn't do it that way, try some other methods.  But if we have      no instructions left, don't bother.  Likewise, if this is SImode and      we can't make pseudos, we can't do anything since the expand_binop      and expand_unop calls will widen and try to make pseudos.  */
if|if
condition|(
name|n
operator|==
literal|1
operator|||
operator|(
name|mode
operator|==
name|SImode
operator|&&
operator|!
name|rtx_equal_function_value_matters
operator|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
comment|/* First, see if can load a value into the target that is the same as the      constant except that all bytes that are 0 are changed to be 0xff.  If we      can, then we can do a ZAPNOT to obtain the desired constant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|+=
literal|8
control|)
if|if
condition|(
operator|(
name|new
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|new
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
expr_stmt|;
comment|/* We are only called for SImode and DImode.  If this is SImode, ensure that      we are sign extended to a full word.  */
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|new
operator|=
operator|(
name|new
operator|&
literal|0xffffffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|new
operator|&
literal|0x80000000
operator|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|c
operator|&&
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|new
argument_list|,
name|n
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|c
operator||
operator|~
name|new
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
endif|#
directive|endif
comment|/* Next, see if we can load a related constant and then shift and possibly      negate it to get the constant we want.  Try this once each increasing      numbers of insns.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* First try complementing.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|~
name|c
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|temp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Next try to form a constant and do a left shift.  We can do this 	 if some low-order bits are zero; the exact_log2 call below tells 	 us that information.  The bits we are shifting out could be any 	 value, but here we'll just try the 0- and sign-extended forms of 	 the constant.  To try to increase the chance of having the same 	 constant in more than one insn, start at the highest number of 	 bits to shift, but try all possibilities in case a ZAPNOT will 	 be useful.  */
if|if
condition|(
operator|(
name|bits
operator|=
name|exact_log2
argument_list|(
name|c
operator|&
operator|-
name|c
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|c
operator|>>
name|bits
argument_list|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|c
operator|)
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashl_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Now try high-order zero bits.  Here we try the shifted-in bits as 	 all zero and all ones.  Be careful to avoid shifting outside the 	 mode and to avoid shifting outside the host wide int size.  */
comment|/* On narrow hosts, don't shift a 1 into the high bit, since we'll 	 confuse the recursive call and set all of the high 32 bits.  */
if|if
condition|(
operator|(
name|bits
operator|=
operator|(
name|MIN
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
literal|8
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|c
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|)
operator|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|lshr_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Now try high-order 1 bits.  We get that with a sign-extension. 	 But one bit isn't enough here.  Be careful to avoid shifting outside 	 the mode and to avoid shifting outside the host wide int size. */
if|if
condition|(
operator|(
name|bits
operator|=
operator|(
name|MIN
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
literal|8
argument_list|)
operator|-
name|floor_log2
argument_list|(
operator|~
name|c
argument_list|)
operator|-
literal|2
operator|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Having failed to find a 3 insn sequence in alpha_emit_set_const,    fall back to a straight forward decomposition.  We do this to avoid    exponential run times encountered when looking for longer sequences    with alpha_emit_set_const.  */
end_comment

begin_function
name|rtx
name|alpha_emit_set_long_const
parameter_list|(
name|target
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|HOST_WIDE_INT
name|c1
decl_stmt|,
name|c2
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|;
comment|/* Decompose the entire word */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|c2
operator|!=
operator|-
operator|(
name|c1
operator|<
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|d1
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d1
expr_stmt|;
name|d2
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
name|c1
operator|=
operator|(
name|c1
operator|-
name|d2
operator|)
operator|>>
literal|32
expr_stmt|;
name|d3
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d3
expr_stmt|;
name|d4
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|d4
condition|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|d1
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d1
expr_stmt|;
name|d2
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|d2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|c2
operator|+=
operator|(
name|d2
operator|<
literal|0
operator|)
expr_stmt|;
name|d3
operator|=
operator|(
operator|(
name|c2
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c2
operator|-=
name|d3
expr_stmt|;
name|d4
operator|=
operator|(
operator|(
name|c2
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c2
operator|!=
name|d4
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Construct the high word */
if|if
condition|(
name|d4
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d3
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shift it into place */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add in the low bits.  */
if|if
condition|(
name|d2
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Generate the comparison for a conditional branch.  */
end_comment

begin_function
name|rtx
name|alpha_emit_conditional_branch
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|cmp_code
decl_stmt|,
name|branch_code
decl_stmt|;
name|enum
name|machine_mode
name|cmp_mode
decl_stmt|,
name|branch_mode
init|=
name|VOIDmode
decl_stmt|;
name|rtx
name|op0
init|=
name|alpha_compare_op0
decl_stmt|,
name|op1
init|=
name|alpha_compare_op1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* The general case: fold the comparison code to the types of compares      that we have, choosing the branch as necessary.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
comment|/* We have these compares: */
name|cmp_code
operator|=
name|code
operator|,
name|branch_code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
comment|/* This must be reversed. */
name|cmp_code
operator|=
name|EQ
operator|,
name|branch_code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* For FP, we swap them, for INT, we reverse them.  */
if|if
condition|(
name|alpha_compare_fp_p
condition|)
block|{
name|cmp_code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|branch_code
operator|=
name|NE
expr_stmt|;
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
else|else
block|{
name|cmp_code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|branch_code
operator|=
name|EQ
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|alpha_compare_fp_p
condition|)
block|{
name|cmp_mode
operator|=
name|DFmode
expr_stmt|;
if|if
condition|(
name|flag_fast_math
condition|)
block|{
comment|/* When we are not as concerned about non-finite values, and we 	     are comparing against zero, we can branch directly.  */
if|if
condition|(
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
condition|)
name|cmp_code
operator|=
name|NIL
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
condition|)
block|{
comment|/* Undo the swap we probably did just above.  */
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|branch_code
operator|=
name|swap_condition
argument_list|(
name|cmp_code
argument_list|)
expr_stmt|;
name|cmp_code
operator|=
name|NIL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ??? We mark the the branch mode to be CCmode to prevent the 	     compare and branch from being combined, since the compare  	     insn follows IEEE rules that the branch does not.  */
name|branch_mode
operator|=
name|CCmode
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmp_mode
operator|=
name|DImode
expr_stmt|;
comment|/* The following optimizations are only for signed compares.  */
if|if
condition|(
name|code
operator|!=
name|LEU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|GTU
condition|)
block|{
comment|/* Whee.  Compare and branch against 0 directly.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
name|cmp_code
operator|=
name|NIL
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
comment|/* We want to use cmpcc/bcc when we can, since there is a zero delay 	     bypass between logicals and br/cmov on EV5.  But we don't want to 	     force valid immediate constants into registers needlessly.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|v
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|,
name|n
init|=
operator|-
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|v
argument_list|,
literal|'I'
argument_list|)
operator|&&
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|n
argument_list|,
literal|'K'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|n
argument_list|,
literal|'L'
argument_list|)
operator|)
condition|)
block|{
name|cmp_code
operator|=
name|PLUS
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Force op0 into a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|cmp_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* Emit an initial compare instruction, if necessary.  */
name|tem
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|cmp_code
operator|!=
name|NIL
condition|)
block|{
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|cmp_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|cmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return the branch comparison.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|branch_code
argument_list|,
name|branch_mode
argument_list|,
name|tem
argument_list|,
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rewrite a comparison against zero CMP of the form    (CODE (cc0) (const_int 0)) so it can be written validly in    a conditional move (if_then_else CMP ...).    If both of the operands that set cc0 are non-zero we must emit    an insn to perform the compare (it can't be done within    the conditional move). */
end_comment

begin_function
name|rtx
name|alpha_emit_conditional_move
parameter_list|(
name|cmp
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|cmp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|cmp
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|cmov_code
init|=
name|NE
decl_stmt|;
name|rtx
name|op0
init|=
name|alpha_compare_op0
decl_stmt|;
name|rtx
name|op1
init|=
name|alpha_compare_op1
decl_stmt|;
name|enum
name|machine_mode
name|cmp_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|cmp_op_mode
init|=
name|alpha_compare_fp_p
condition|?
name|DFmode
else|:
name|DImode
decl_stmt|;
name|enum
name|machine_mode
name|cmov_mode
init|=
name|VOIDmode
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|alpha_compare_fp_p
operator|!=
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We may be able to use a conditional move directly.      This avoids emitting spurious compares. */
if|if
condition|(
name|signed_comparison_operator
argument_list|(
name|cmp
argument_list|,
name|cmp_op_mode
argument_list|)
operator|&&
operator|(
operator|!
name|alpha_compare_fp_p
operator|||
name|flag_fast_math
operator|)
operator|&&
operator|(
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
operator|||
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* We can't put the comparison insides a conditional move;      emit a compare instruction and put that inside the      conditional move.  Make sure we emit only comparisons we have;      swap or reverse as necessary.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
comment|/* We have these compares: */
break|break;
case|case
name|NE
case|:
comment|/* This must be reversed. */
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|cmov_code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* These must be swapped.  Make sure the new first operand is in 	 a register.  */
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|cmp_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* ??? We mark the branch mode to be CCmode to prevent the compare      and cmov from being combined, since the compare insn follows IEEE      rules that the cmov does not.  */
if|if
condition|(
name|alpha_compare_fp_p
operator|&&
operator|!
name|flag_fast_math
condition|)
name|cmov_mode
operator|=
name|CCmode
expr_stmt|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|cmp_op_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|cmp_op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|cmov_code
argument_list|,
name|cmov_mode
argument_list|,
name|tem
argument_list|,
name|CONST0_RTX
argument_list|(
name|cmp_op_mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use ext[wlq][lh] as the Architecture Handbook describes for extracting    unaligned data:             unsigned:                       signed:    word:   ldq_u  r1,X(r11)                ldq_u  r1,X(r11)            ldq_u  r2,X+1(r11)              ldq_u  r2,X+1(r11)            lda    r3,X(r11)                lda    r3,X+2(r11)            extwl  r1,r3,r1                 extql  r1,r3,r1            extwh  r2,r3,r2                 extqh  r2,r3,r2            or     r1.r2.r1                 or     r1,r2,r1                                            sra    r1,48,r1     long:   ldq_u  r1,X(r11)                ldq_u  r1,X(r11)            ldq_u  r2,X+3(r11)              ldq_u  r2,X+3(r11)            lda    r3,X(r11)                lda    r3,X(r11)            extll  r1,r3,r1                 extll  r1,r3,r1            extlh  r2,r3,r2                 extlh  r2,r3,r2            or     r1.r2.r1                 addl   r1,r2,r1     quad:   ldq_u  r1,X(r11)            ldq_u  r2,X+7(r11)            lda    r3,X(r11)            extql  r1,r3,r1            extqh  r2,r3,r2            or     r1.r2.r1 */
end_comment

begin_function
name|void
name|alpha_expand_unaligned_load
parameter_list|(
name|tgt
parameter_list|,
name|mem
parameter_list|,
name|size
parameter_list|,
name|ofs
parameter_list|,
name|sign
parameter_list|)
name|rtx
name|tgt
decl_stmt|,
name|mem
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|ofs
decl_stmt|;
name|int
name|sign
decl_stmt|;
block|{
name|rtx
name|meml
decl_stmt|,
name|memh
decl_stmt|,
name|addr
decl_stmt|,
name|extl
decl_stmt|,
name|exth
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|meml
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|memh
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|extl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|exth
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|meml
argument_list|,
name|change_address
argument_list|(
name|mem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memh
argument_list|,
name|change_address
argument_list|(
name|mem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
operator|&&
name|size
operator|==
literal|2
condition|)
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|GEN_INT
argument_list|(
literal|64
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extqh
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must use tgt here for the target.  Alpha-vms port fails if we use 	 addr for the target, because addr is marked as a pointer and combine 	 knows that pointers are always sign-extended 32 bit values.  */
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|extl
argument_list|,
name|exth
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ashr_optab
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
literal|48
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_extwh
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_extlh
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_extqh
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|addr
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|extl
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|exth
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|tgt
argument_list|)
argument_list|,
name|sign
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
name|tgt
condition|)
name|emit_move_insn
argument_list|(
name|tgt
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|tgt
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, use ins and msk instructions to perform unaligned stores.  */
end_comment

begin_function
name|void
name|alpha_expand_unaligned_store
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|,
name|ofs
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|ofs
decl_stmt|;
block|{
name|rtx
name|dstl
decl_stmt|,
name|dsth
decl_stmt|,
name|addr
decl_stmt|,
name|insl
decl_stmt|,
name|insh
decl_stmt|,
name|meml
decl_stmt|,
name|memh
decl_stmt|;
name|dstl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|dsth
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|insl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|insh
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|meml
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memh
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dsth
argument_list|,
name|memh
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dstl
argument_list|,
name|meml
argument_list|)
expr_stmt|;
name|addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_inswl
argument_list|(
name|insl
argument_list|,
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_insll
argument_list|(
name|insl
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_insql
argument_list|(
name|insl
argument_list|,
name|src
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_mskxl
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffff
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_mskxl
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffffffff
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|rtx
name|msk
init|=
name|immed_double_const
argument_list|(
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|msk
init|=
name|immed_double_const
argument_list|(
literal|0xffffffffffffffff
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|emit_insn
argument_list|(
name|gen_mskxl
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|msk
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
name|dsth
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|insh
argument_list|,
name|dsth
argument_list|,
name|dsth
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|dstl
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|insl
argument_list|,
name|dstl
argument_list|,
name|dstl
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Must store high before low for degenerate case of aligned.  */
name|emit_move_insn
argument_list|(
name|memh
argument_list|,
name|dsth
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|meml
argument_list|,
name|dstl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The block move code tries to maximize speed by separating loads and    stores at the expense of register pressure: we load all of the data    before we store it back out.  There are two secondary effects worth    mentioning, that this speeds copying to/from aligned and unaligned    buffers, and that it makes the code significantly easier to write.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MOVE_WORDS
value|8
end_define

begin_comment
comment|/* Load an integral number of consecutive unaligned quadwords.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_expand_unaligned_load_words
parameter_list|(
name|out_regs
parameter_list|,
name|smem
parameter_list|,
name|words
parameter_list|,
name|ofs
parameter_list|)
name|rtx
modifier|*
name|out_regs
decl_stmt|;
name|rtx
name|smem
decl_stmt|;
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|ofs
decl_stmt|;
block|{
name|rtx
specifier|const
name|im8
init|=
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
decl_stmt|;
name|rtx
specifier|const
name|i64
init|=
name|GEN_INT
argument_list|(
literal|64
argument_list|)
decl_stmt|;
name|rtx
name|ext_tmps
index|[
name|MAX_MOVE_WORDS
index|]
decl_stmt|,
name|data_regs
index|[
name|MAX_MOVE_WORDS
operator|+
literal|1
index|]
decl_stmt|;
name|rtx
name|sreg
decl_stmt|,
name|areg
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
comment|/* Generate all the tmp registers we need.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|data_regs
index|[
name|i
index|]
operator|=
name|out_regs
index|[
name|i
index|]
expr_stmt|;
name|ext_tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
name|data_regs
index|[
name|words
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
name|smem
operator|=
name|change_address
argument_list|(
name|smem
argument_list|,
name|GET_MODE
argument_list|(
name|smem
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|smem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load up all of the source data.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|change_address
argument_list|(
name|smem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|smem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
operator|*
name|i
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|words
index|]
argument_list|,
name|change_address
argument_list|(
name|smem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|smem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
operator|*
name|words
operator|-
literal|1
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the half-word fragments.  Unfortunately DEC decided to make      extxh with offset zero a noop instead of zeroing the register, so       we must take care of that edge condition ourselves with cmov.  */
name|sreg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|smem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|areg
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|and_optab
argument_list|,
name|sreg
argument_list|,
name|GEN_INT
argument_list|(
literal|7
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|emit_insn
argument_list|(
name|gen_extxl
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|i64
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extqh
argument_list|(
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_EQ
argument_list|(
name|DImode
argument_list|,
name|areg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the half-words into whole words.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|out_regs
index|[
name|i
index|]
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store an integral number of consecutive unaligned quadwords.  DATA_REGS    may be NULL to store zeros.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_expand_unaligned_store_words
parameter_list|(
name|data_regs
parameter_list|,
name|dmem
parameter_list|,
name|words
parameter_list|,
name|ofs
parameter_list|)
name|rtx
modifier|*
name|data_regs
decl_stmt|;
name|rtx
name|dmem
decl_stmt|;
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|ofs
decl_stmt|;
block|{
name|rtx
specifier|const
name|im8
init|=
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
decl_stmt|;
name|rtx
specifier|const
name|i64
init|=
name|GEN_INT
argument_list|(
literal|64
argument_list|)
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|rtx
specifier|const
name|im1
init|=
name|immed_double_const
argument_list|(
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
specifier|const
name|im1
init|=
name|immed_double_const
argument_list|(
literal|0xffffffffffffffff
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|rtx
name|ins_tmps
index|[
name|MAX_MOVE_WORDS
index|]
decl_stmt|;
name|rtx
name|st_tmp_1
decl_stmt|,
name|st_tmp_2
decl_stmt|,
name|dreg
decl_stmt|;
name|rtx
name|st_addr_1
decl_stmt|,
name|st_addr_2
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
comment|/* Generate all the tmp registers we need.  */
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|ins_tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|st_tmp_1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|st_tmp_2
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
name|dmem
operator|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|GET_MODE
argument_list|(
name|dmem
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|dmem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|st_addr_2
operator|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|dmem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|words
operator|*
literal|8
operator|-
literal|1
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|st_addr_1
operator|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|XEXP
argument_list|(
name|dmem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load up the destination end bits.  */
name|emit_move_insn
argument_list|(
name|st_tmp_2
argument_list|,
name|st_addr_2
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|st_tmp_1
argument_list|,
name|st_addr_1
argument_list|)
expr_stmt|;
comment|/* Shift the input data into place.  */
name|dreg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|dmem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|ins_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_insql
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Split and merge the ends with the destination data.  */
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|st_tmp_2
argument_list|,
name|st_tmp_2
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mskxl
argument_list|(
name|st_tmp_1
argument_list|,
name|st_tmp_1
argument_list|,
name|im1
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
block|{
name|st_tmp_2
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|st_tmp_2
argument_list|,
name|ins_tmps
index|[
name|words
operator|-
literal|1
index|]
argument_list|,
name|st_tmp_2
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|st_tmp_1
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|st_tmp_1
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|,
name|st_tmp_1
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Store it all.  */
name|emit_move_insn
argument_list|(
name|st_addr_2
argument_list|,
name|st_tmp_2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|dmem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
operator|*
literal|8
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
argument_list|,
name|data_regs
condition|?
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
else|:
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|st_addr_1
argument_list|,
name|st_tmp_1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand string/block move operations.     operands[0] is the pointer to the destination.    operands[1] is the pointer to the source.    operands[2] is the number of bytes to move.    operands[3] is the alignment.  */
end_comment

begin_function
name|int
name|alpha_expand_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|orig_bytes
init|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bytes
init|=
name|orig_bytes
decl_stmt|;
name|HOST_WIDE_INT
name|src_align
init|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|dst_align
init|=
name|src_align
decl_stmt|;
name|rtx
name|orig_src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|orig_dst
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|data_regs
index|[
literal|2
operator|*
name|MAX_MOVE_WORDS
operator|+
literal|16
index|]
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|words
decl_stmt|,
name|ofs
decl_stmt|,
name|nregs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bytes
operator|>
name|MAX_MOVE_WORDS
operator|*
literal|8
condition|)
return|return
literal|0
return|;
comment|/* Look for additional alignment information from recorded register info.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|>
name|src_align
condition|)
name|src_align
operator|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|src_align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|8
operator|&&
name|c
operator|%
literal|8
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|4
operator|&&
name|c
operator|%
literal|4
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|2
operator|&&
name|c
operator|%
literal|2
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|>
name|dst_align
condition|)
name|dst_align
operator|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|dst_align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|8
operator|&&
name|c
operator|%
literal|8
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|4
operator|&&
name|c
operator|%
literal|4
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|2
operator|&&
name|c
operator|%
literal|2
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/*    * Load the entire block into registers.    */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't use the existing register if we're reading more than 	 is held in the register.  Nor if there is not a mode that 	 handles the exact size.  */
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|>=
name|bytes
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
block|{
name|data_regs
index|[
name|nregs
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|data_regs
index|[
name|nregs
operator|+
literal|1
index|]
operator|=
name|gen_highpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|nregs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|src_done
goto|;
block|}
comment|/* No appropriate mode; fall back on memory.  */
name|orig_src
operator|=
name|change_address
argument_list|(
name|orig_src
argument_list|,
name|GET_MODE
argument_list|(
name|orig_src
argument_list|)
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ofs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|src_align
operator|>=
literal|8
operator|&&
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
argument_list|,
name|change_address
argument_list|(
name|orig_src
argument_list|,
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|src_align
operator|>=
literal|4
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
argument_list|,
name|change_address
argument_list|(
name|orig_src
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|4
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|16
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load_words
argument_list|(
name|data_regs
operator|+
name|nregs
argument_list|,
name|orig_src
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_BWX
operator|&&
name|bytes
operator|>=
literal|8
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load
argument_list|(
name|tmp
argument_list|,
name|orig_src
argument_list|,
literal|8
argument_list|,
name|ofs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|8
expr_stmt|;
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_BWX
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load
argument_list|(
name|tmp
argument_list|,
name|orig_src
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|src_align
operator|>=
literal|2
condition|)
block|{
do|do
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|change_address
argument_list|(
name|orig_src
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|bytes
operator|>=
literal|2
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_BWX
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load
argument_list|(
name|tmp
argument_list|,
name|orig_src
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|change_address
argument_list|(
name|orig_src
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|1
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
name|src_done
label|:
if|if
condition|(
name|nregs
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|data_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|data_regs
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/*    * Now save it back out again.    */
name|i
operator|=
literal|0
operator|,
name|ofs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|orig_bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|mode
condition|)
block|{
if|if
condition|(
name|nregs
operator|==
literal|1
condition|)
block|{
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
goto|goto
name|dst_done
goto|;
block|}
elseif|else
if|if
condition|(
name|nregs
operator|==
literal|2
operator|&&
name|mode
operator|==
name|TImode
condition|)
block|{
comment|/* Undo the subregging done above when copying between 		 two TImode registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|TImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|SUBREG_REG
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|data_regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|seq
argument_list|,
name|tmp
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|,
name|data_regs
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|2
expr_stmt|;
goto|goto
name|dst_done
goto|;
block|}
block|}
comment|/* ??? If nregs> 1, consider reconstructing the word in regs.  */
comment|/* ??? Optimize mode< dst_mode with strict_low_part.  */
comment|/* No appropriate mode; fall back on memory.  We can speed things 	 up by recognizing extra alignment information.  */
name|orig_dst
operator|=
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dst_align
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the data in whatever chunks reading the source allowed.  */
if|if
condition|(
name|dst_align
operator|>=
literal|8
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|8
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dst_align
operator|>=
literal|4
condition|)
block|{
comment|/* If the source has remaining DImode regs, write them out in 	 two pieces.  */
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|tmp
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|lshr_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
operator|+
literal|4
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|8
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
comment|/* Write out a remaining block of words using unaligned methods.  */
for|for
control|(
name|words
operator|=
literal|1
init|;
name|i
operator|+
name|words
operator|<
name|nregs
condition|;
operator|++
name|words
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
operator|+
name|words
index|]
argument_list|)
operator|!=
name|DImode
condition|)
break|break;
if|if
condition|(
name|words
operator|==
literal|1
condition|)
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|8
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
else|else
name|alpha_expand_unaligned_store_words
argument_list|(
name|data_regs
operator|+
name|i
argument_list|,
name|orig_dst
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|i
operator|+=
name|words
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
comment|/* Due to the above, this won't be aligned.  */
comment|/* ??? If we have more than one of these, consider constructing full      words in registers and using alpha_expand_unaligned_store_words.  */
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dst_align
operator|>=
literal|2
condition|)
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|HImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|HImode
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
name|dst_done
label|:
if|if
condition|(
name|i
operator|!=
name|nregs
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|alpha_expand_block_clear
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|bytes
init|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
decl_stmt|;
name|rtx
name|orig_dst
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|,
name|words
decl_stmt|,
name|ofs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bytes
operator|>
name|MAX_MOVE_WORDS
operator|*
literal|8
condition|)
return|return
literal|0
return|;
comment|/* Look for stricter alignment.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|>
name|align
condition|)
name|align
operator|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|8
operator|&&
name|c
operator|%
literal|8
operator|==
literal|0
condition|)
name|align
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|4
operator|&&
name|c
operator|%
literal|4
operator|==
literal|0
condition|)
name|align
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|2
operator|&&
name|c
operator|%
literal|2
operator|==
literal|0
condition|)
name|align
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* No appropriate mode; fall back on memory.  */
name|orig_dst
operator|=
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|GET_MODE
argument_list|(
name|orig_dst
argument_list|)
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a block of contiguous words first.  */
if|if
condition|(
name|align
operator|>=
literal|8
operator|&&
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|8
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>=
literal|4
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|4
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|-=
name|words
operator|*
literal|4
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|16
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
name|alpha_expand_unaligned_store_words
argument_list|(
name|NULL
argument_list|,
name|orig_dst
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
comment|/* Next clean up any trailing pieces.  We know from the contiguous      block move that there are no aligned SImode or DImode hunks left.  */
if|if
condition|(
operator|!
name|TARGET_BWX
operator|&&
name|bytes
operator|>=
literal|8
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|const0_rtx
argument_list|,
literal|8
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|8
expr_stmt|;
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_BWX
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|const0_rtx
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|align
operator|>=
literal|2
condition|)
block|{
do|do
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|bytes
operator|>=
literal|2
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_BWX
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|const0_rtx
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ofs
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|1
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
name|int
name|alpha_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|,
name|set_src
decl_stmt|;
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_insn_type
decl_stmt|;
comment|/* If the dependence is an anti-dependence, there is no cost.  For an      output dependence, there is sometimes a cost, but it doesn't seem      worth handling those few cases.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_insn_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* Bring in the user-defined memory latency.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_ILD
operator|||
name|dep_insn_type
operator|==
name|TYPE_FLD
operator|||
name|dep_insn_type
operator|==
name|TYPE_LDSYM
condition|)
name|cost
operator|+=
name|alpha_memory_latency
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|alpha_cpu
condition|)
block|{
case|case
name|PROCESSOR_EV4
case|:
comment|/* On EV4, if INSN is a store insn and DEP_INSN is setting the data 	 being stored, we can sometimes lower the cost.  */
if|if
condition|(
operator|(
name|insn_type
operator|==
name|TYPE_IST
operator|||
name|insn_type
operator|==
name|TYPE_FST
operator|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|dep_insn_type
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_FLD
case|:
comment|/* No savings here.  */
return|return
name|cost
return|;
case|case
name|TYPE_IMUL
case|:
comment|/* In these cases, we save one cycle.  */
return|return
name|cost
operator|-
literal|1
return|;
default|default:
comment|/* In all other cases, we save two cycles.  */
return|return
name|MAX
argument_list|(
literal|0
argument_list|,
name|cost
operator|-
literal|2
argument_list|)
return|;
block|}
block|}
comment|/* Another case that needs adjustment is an arithmetic or logical 	 operation.  It's cost is usually one cycle, but we default it to 	 two in the MD file.  The only case that it is actually two is 	 for the address in loads, stores, and jumps.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IADD
operator|||
name|dep_insn_type
operator|==
name|TYPE_ILOG
condition|)
block|{
switch|switch
condition|(
name|insn_type
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_IST
case|:
case|case
name|TYPE_FLD
case|:
case|case
name|TYPE_FST
case|:
case|case
name|TYPE_JSR
case|:
return|return
name|cost
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
comment|/* The final case is when a compare feeds into an integer branch; 	 the cost is only one cycle in that case.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_ICMP
operator|&&
name|insn_type
operator|==
name|TYPE_IBR
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|PROCESSOR_EV5
case|:
comment|/* And the lord DEC saith:  "A special bypass provides an effective 	 latency of 0 cycles for an ICMP or ILOG insn producing the test 	 operand of an IBR or ICMOV insn." */
if|if
condition|(
operator|(
name|dep_insn_type
operator|==
name|TYPE_ICMP
operator|||
name|dep_insn_type
operator|==
name|TYPE_ILOG
operator|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* A branch only has one input.  This must be it.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IBR
condition|)
return|return
literal|0
return|;
comment|/* A conditional move has three, make sure it is the test.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_ICMOV
operator|&&
name|GET_CODE
argument_list|(
name|set_src
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set_src
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* "The multiplier is unable to receive data from IEU bypass paths. 	 The instruction issues at the expected time, but its latency is 	 increased by the time it takes for the input data to become 	 available to the multiplier" -- which happens in pipeline stage 	 six, when results are comitted to the register file.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IMUL
condition|)
block|{
switch|switch
condition|(
name|dep_insn_type
condition|)
block|{
comment|/* These insns produce their results in pipeline stage five.  */
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_ICMOV
case|:
case|case
name|TYPE_IMUL
case|:
case|case
name|TYPE_MVI
case|:
return|return
name|cost
operator|+
literal|1
return|;
comment|/* Other integer insns produce results in pipeline stage four.  */
default|default:
return|return
name|cost
operator|+
literal|2
return|;
block|}
block|}
break|break;
case|case
name|PROCESSOR_EV6
case|:
comment|/* There is additional latency to move the result of (most) FP           operations anywhere but the FP register file.  */
if|if
condition|(
operator|(
name|insn_type
operator|==
name|TYPE_FST
operator|||
name|insn_type
operator|==
name|TYPE_FTOI
operator|)
operator|&&
operator|(
name|dep_insn_type
operator|==
name|TYPE_FADD
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMUL
operator|||
name|dep_insn_type
operator|==
name|TYPE_FCMOV
operator|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
break|break;
block|}
comment|/* Otherwise, return the default cost. */
return|return
name|cost
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to save and restore alpha_return_addr_rtx.  */
end_comment

begin_struct
struct|struct
name|machine_function
block|{
name|rtx
name|ra_rtx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|alpha_save_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
operator|(
expr|struct
name|machine_function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|machine
operator|=
name|machine
expr_stmt|;
name|machine
operator|->
name|ra_rtx
operator|=
name|alpha_return_addr_rtx
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alpha_restore_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|p
operator|->
name|machine
decl_stmt|;
name|alpha_return_addr_rtx
operator|=
name|machine
operator|->
name|ra_rtx
expr_stmt|;
name|free
argument_list|(
name|machine
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|=
operator|(
expr|struct
name|machine_function
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do anything needed before RTL is emitted for each function.  */
end_comment

begin_function
name|void
name|alpha_init_expanders
parameter_list|()
block|{
name|alpha_return_addr_rtx
operator|=
name|NULL_RTX
expr_stmt|;
name|alpha_eh_epilogue_sp_ofs
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Arrange to save and restore machine status around nested functions.  */
name|save_machine_status
operator|=
name|alpha_save_machine_status
expr_stmt|;
name|restore_machine_status
operator|=
name|alpha_restore_machine_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start the ball rolling with RETURN_ADDR_RTX.  */
end_comment

begin_function
name|rtx
name|alpha_return_addr
parameter_list|(
name|count
parameter_list|,
name|frame
parameter_list|)
name|int
name|count
decl_stmt|;
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|init
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|alpha_return_addr_rtx
condition|)
return|return
name|alpha_return_addr_rtx
return|;
comment|/* No rtx yet.  Invent one, and initialize it from $26 in the prologue.  */
name|alpha_return_addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|init
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|alpha_return_addr_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REG_RA
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the insn to the prologue with the other argument copies.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|init
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|alpha_return_addr_rtx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_ra_ever_killed
parameter_list|()
block|{
name|rtx
name|top
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
name|current_function_is_thunk
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|alpha_return_addr_rtx
condition|)
return|return
name|regs_ever_live
index|[
name|REG_RA
index|]
return|;
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|top
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|reg_set_between_p
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REG_RA
argument_list|)
argument_list|,
name|top
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'&'
case|:
comment|/* Generates fp-rounding mode suffix: nothing for normal, 'c' for 	 chopped, 'm' for minus-infinity, and 'd' for dynamic rounding 	 mode.  alpha_fprm controls which suffix is generated.  */
switch|switch
condition|(
name|alpha_fprm
condition|)
block|{
case|case
name|ALPHA_FPRM_NORM
case|:
break|break;
case|case
name|ALPHA_FPRM_MINF
case|:
name|fputc
argument_list|(
literal|'m'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_FPRM_CHOP
case|:
name|fputc
argument_list|(
literal|'c'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_FPRM_DYN
case|:
name|fputc
argument_list|(
literal|'d'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'\''
case|:
comment|/* Generates trap-mode suffix for instructions that accept the su 	 suffix only (cmpt et al).  */
if|if
condition|(
name|alpha_tp
operator|==
name|ALPHA_TP_INSN
condition|)
name|fputs
argument_list|(
literal|"su"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
comment|/* Generates trap-mode suffix for instructions that accept the 	 v and sv suffix.  The only instruction that needs this is cvtql.  */
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
break|break;
case|case
name|ALPHA_FPTM_U
case|:
name|fputs
argument_list|(
literal|"v"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_FPTM_SU
case|:
case|case
name|ALPHA_FPTM_SUI
case|:
name|fputs
argument_list|(
literal|"sv"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'('
case|:
comment|/* Generates trap-mode suffix for instructions that accept the 	 v, sv, and svi suffix.  The only instruction that needs this 	 is cvttq.  */
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
break|break;
case|case
name|ALPHA_FPTM_U
case|:
name|fputs
argument_list|(
literal|"v"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_FPTM_SU
case|:
name|fputs
argument_list|(
literal|"sv"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_FPTM_SUI
case|:
name|fputs
argument_list|(
literal|"svi"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|')'
case|:
comment|/* Generates trap-mode suffix for instructions that accept the u, su, 	 and sui suffix.  This is the bulk of the IEEE floating point 	 instructions (addt et al).  */
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
break|break;
case|case
name|ALPHA_FPTM_U
case|:
name|fputc
argument_list|(
literal|'u'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_FPTM_SU
case|:
name|fputs
argument_list|(
literal|"su"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_FPTM_SUI
case|:
name|fputs
argument_list|(
literal|"sui"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'+'
case|:
comment|/* Generates trap-mode suffix for instructions that accept the sui 	 suffix (cvtqt and cvtqs).  */
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
case|case
name|ALPHA_FPTM_U
case|:
case|case
name|ALPHA_FPTM_SU
case|:
comment|/* cvtqt/cvtqs can't cause underflow */
break|break;
case|case
name|ALPHA_FPTM_SUI
case|:
name|fputs
argument_list|(
literal|"sui"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|','
case|:
comment|/* Generates single precision instruction suffix.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c"
argument_list|,
operator|(
name|TARGET_FLOAT_VAX
condition|?
literal|'f'
else|:
literal|'s'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* Generates double precision instruction suffix.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c"
argument_list|,
operator|(
name|TARGET_FLOAT_VAX
condition|?
literal|'g'
else|:
literal|'t'
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* If this operand is the constant zero, write it as "$31".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%r value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Similar, but for floating-point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$f31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Write the 1's complement of a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Write 1<< C, for a constant C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Write the high-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%h value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Write the low-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%L value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x8000
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Write mask for ZAP insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|value
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|value
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|mask
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|,
name|value
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* 'b', 'w', 'l', or 'q' as the value of the constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|8
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|16
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|32
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|64
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|8
condition|?
literal|"b"
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|16
condition|?
literal|"w"
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|32
condition|?
literal|"l"
else|:
literal|"q"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Similar, except do it from the mask.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffffffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%U value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Write the constant value divided by 8.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|8
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Same, except compute (64 - c) / 8 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|8
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
literal|64
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
comment|/* Write out comparison name.  */
block|{
name|enum
name|rtx_code
name|c
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|c
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%C value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'D'
condition|)
name|c
operator|=
name|reverse_condition
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'c'
condition|)
name|c
operator|=
name|swap_condition
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'d'
condition|)
name|c
operator|=
name|swap_condition
argument_list|(
name|reverse_condition
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|LEU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ule"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|LTU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ult"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
comment|/* Write the divide or modulus operator.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/* Write "_u" for unaligned access.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_u"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|int
name|basereg
init|=
literal|31
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|AND
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"($%d)"
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline at    TRAMP. FNADDR is an RTX for the address of the function's pure    code.  CXT is an RTX for the static chain value for the function.     The three offset parameters are for the individual template's    layout.  A JMPOFS< 0 indicates that the trampoline does not     contain instructions at all.     We assume here that a function will be called many more times than    its address is taken (e.g., it might be passed to qsort), so we    take the trouble to initialize the "hint" field in the JMP insn.    Note that the hint field is PC (new) + 4 * bits 13:0.  */
end_comment

begin_function
name|void
name|alpha_initialize_trampoline
parameter_list|(
name|tramp
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|,
name|fnofs
parameter_list|,
name|cxtofs
parameter_list|,
name|jmpofs
parameter_list|)
name|rtx
name|tramp
decl_stmt|,
name|fnaddr
decl_stmt|,
name|cxt
decl_stmt|;
name|int
name|fnofs
decl_stmt|,
name|cxtofs
decl_stmt|,
name|jmpofs
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|,
name|temp1
decl_stmt|,
name|addr
decl_stmt|;
comment|/* VMS really uses DImode pointers in memory at this point.  */
name|enum
name|machine_mode
name|mode
init|=
name|TARGET_OPEN_VMS
condition|?
name|Pmode
else|:
name|ptr_mode
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|fnaddr
operator|=
name|convert_memory_address
argument_list|(
name|mode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|cxt
operator|=
name|convert_memory_address
argument_list|(
name|mode
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Store function address and CXT.  */
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|fnofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|cxtofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
comment|/* This has been disabled since the hint only has a 32k range, and in      no existing OS is the stack within 32k of the text segment. */
if|if
condition|(
literal|0
operator|&&
name|jmpofs
operator|>=
literal|0
condition|)
block|{
comment|/* Compute hint value.  */
name|temp
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|jmpofs
operator|+
literal|4
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|sub_optab
argument_list|,
name|fnaddr
argument_list|,
name|temp
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|Pmode
argument_list|,
name|temp
argument_list|,
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_and
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3fff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge in the hint.  */
name|addr
operator|=
name|memory_address
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|jmpofs
argument_list|)
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_and
argument_list|(
name|temp1
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffffc000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|temp1
argument_list|,
name|temp
argument_list|,
name|temp1
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRANSFER_FROM_TRAMPOLINE
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|jmpofs
operator|>=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_imb
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do what is necessary for `va_start'.  The argument is ignored;    We look at the current function to determine if stdarg or varargs    is used and fill in an initial va_list.  A pointer to this constructor    is returned.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|alpha_builtin_saveregs
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|block
decl_stmt|,
name|addr
decl_stmt|,
name|dest
decl_stmt|,
name|argsize
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|int
name|stdarg
init|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
decl_stmt|;
comment|/* Compute the current position into the args, taking into account      both registers and memory.  Both of these are already included in      NUM_ARGS.  */
name|argsize
operator|=
name|GEN_INT
argument_list|(
name|NUM_ARGS
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* For Unix, SETUP_INCOMING_VARARGS moves the starting address base up by 48,      storing fp arg registers in the first 48 bytes, and the integer arg      registers in the next 48 bytes.  This is only done, however, if any      integer registers need to be stored.       If no integer registers need be stored, then we must subtract 48 in      order to account for the integer arg registers which are counted in      argsize above, but which are not actually stored on the stack.  */
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|NUM_ARGS
operator|<=
literal|5
operator|+
name|stdarg
condition|?
name|UNITS_PER_WORD
else|:
operator|-
literal|6
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
operator|(
name|NUM_ARGS
operator|<=
literal|5
operator|+
name|stdarg
condition|?
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
literal|6
operator|*
name|UNITS_PER_WORD
argument_list|)
else|:
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
operator|-
operator|(
literal|6
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
operator|)
expr_stmt|;
comment|/* For VMS, we include the argsize, while on Unix, it's handled as      a separate field.  */
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|INTVAL
argument_list|(
name|argsize
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_operand
argument_list|(
name|addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
return|return
name|addr
return|;
else|else
block|{
comment|/* Allocate the va_list constructor */
name|block
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Store the address of the first integer register in the __base 	 member.  */
name|dest
operator|=
name|change_address
argument_list|(
name|block
argument_list|,
name|ptr_mode
argument_list|,
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_set_right_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|dest
argument_list|,
name|ptr_mode
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|ptr_mode
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_RW
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the argsize as the __va_offset member.  */
name|dest
operator|=
name|change_address
argument_list|(
name|block
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|argsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_check_memory_usage
condition|)
name|emit_library_call
argument_list|(
name|chkr_set_right_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|dest
argument_list|,
name|ptr_mode
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_RW
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the address of the va_list constructor, but don't put it in a 	 register.  Doing so would fail when not optimizing and produce worse 	 code when optimizing.  */
return|return
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the function    prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/* Compute the size of the save area in the stack.  */
end_comment

begin_comment
comment|/* These variables are used for communication between the following functions.    They indicate various things about the current function being compiled    that are used to tell what kind of prologue, epilogue and procedure    descriptior to generate. */
end_comment

begin_comment
comment|/* Nonzero if we need a stack procedure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_is_stack_procedure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number (either FP or SP) that is used to unwind the frame.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_unwind_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number used to save FP.  We need not have one for RA since    we don't modify it for register procedures.  This is only defined    for register frame procedures.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_save_fp_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number used to reference objects off our PV.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_base_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute register masks for saved registers.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_sa_mask
parameter_list|(
name|imaskP
parameter_list|,
name|fmaskP
parameter_list|)
name|unsigned
name|long
modifier|*
name|imaskP
decl_stmt|;
name|unsigned
name|long
modifier|*
name|fmaskP
decl_stmt|;
block|{
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
operator|!
name|current_function_is_thunk
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|TARGET_OPEN_VMS
operator|&&
name|vms_is_stack_procedure
condition|)
name|imask
operator||=
operator|(
literal|1L
operator|<<
name|HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
comment|/* One for every register we have to save.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|REG_RA
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|32
condition|)
name|imask
operator||=
operator|(
literal|1L
operator|<<
name|i
operator|)
expr_stmt|;
else|else
name|fmask
operator||=
operator|(
literal|1L
operator|<<
operator|(
name|i
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|imask
operator|||
name|fmask
operator|||
name|alpha_ra_ever_killed
argument_list|()
condition|)
name|imask
operator||=
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
expr_stmt|;
block|}
operator|*
name|imaskP
operator|=
name|imask
expr_stmt|;
operator|*
name|fmaskP
operator|=
name|fmask
expr_stmt|;
block|}
end_function

begin_function
name|int
name|alpha_sa_size
parameter_list|()
block|{
name|int
name|sa_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
name|current_function_is_thunk
condition|)
name|sa_size
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* One for every register we have to save.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|REG_RA
condition|)
name|sa_size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
block|{
comment|/* Start by assuming we can use a register procedure if we don't 	 make any calls (REG_RA not used) or need to save any 	 registers and a stack procedure if we do.  */
name|vms_is_stack_procedure
operator|=
name|sa_size
operator|!=
literal|0
operator|||
name|alpha_ra_ever_killed
argument_list|()
expr_stmt|;
comment|/* Decide whether to refer to objects off our PV via FP or PV. 	 If we need FP for something else or if we receive a nonlocal 	 goto (which expects PV to contain the value), we must use PV. 	 Otherwise, start by assuming we can use FP.  */
name|vms_base_regno
operator|=
operator|(
name|frame_pointer_needed
operator|||
name|current_function_has_nonlocal_label
operator|||
name|vms_is_stack_procedure
operator|||
name|current_function_outgoing_args_size
condition|?
name|REG_PV
else|:
name|HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
comment|/* If we want to copy PV into FP, we need to find some register 	 in which to save FP.  */
name|vms_save_fp_regno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vms_base_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|vms_save_fp_regno
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|vms_save_fp_regno
operator|==
operator|-
literal|1
condition|)
name|vms_base_regno
operator|=
name|REG_PV
operator|,
name|vms_is_stack_procedure
operator|=
literal|1
expr_stmt|;
comment|/* Stack unwinding should be done via FP unless we use it for PV.  */
name|vms_unwind_regno
operator|=
operator|(
name|vms_base_regno
operator|==
name|REG_PV
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
expr_stmt|;
comment|/* If this is a stack procedure, allow space for saving FP and RA.  */
if|if
condition|(
name|vms_is_stack_procedure
condition|)
name|sa_size
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* If some registers were saved but not RA, RA must also be saved, 	 so leave space for it.  */
if|if
condition|(
name|sa_size
operator|!=
literal|0
operator|||
name|alpha_ra_ever_killed
argument_list|()
condition|)
name|sa_size
operator|++
expr_stmt|;
comment|/* Our size must be even (multiple of 16 bytes).  */
if|if
condition|(
name|sa_size
operator|&
literal|1
condition|)
name|sa_size
operator|++
expr_stmt|;
block|}
return|return
name|sa_size
operator|*
literal|8
return|;
block|}
end_function

begin_function
name|int
name|alpha_pv_save_size
parameter_list|()
block|{
name|alpha_sa_size
argument_list|()
expr_stmt|;
return|return
name|vms_is_stack_procedure
condition|?
literal|8
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|alpha_using_fp
parameter_list|()
block|{
name|alpha_sa_size
argument_list|()
expr_stmt|;
return|return
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
return|;
block|}
end_function

begin_function
name|int
name|vms_valid_decl_attribute_p
parameter_list|(
name|decl
parameter_list|,
name|attributes
parameter_list|,
name|identifier
parameter_list|,
name|args
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|attributes
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"overlaid"
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
operator|(
name|args
operator|==
name|NULL_TREE
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_does_function_need_gp
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* We never need a GP for Windows/NT or VMS.  */
if|if
condition|(
name|TARGET_WINDOWS_NT
operator|||
name|TARGET_OPEN_VMS
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|TARGET_PROFILING_NEEDS_GP
if|if
condition|(
name|profile_flag
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
name|current_function_is_thunk
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first.       Even if we are a static function, we still need to do this in case      our address is taken and passed to something like qsort.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|enum
name|attr_type
name|type
init|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_LDSYM
operator|||
name|type
operator|==
name|TYPE_JSR
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write a version stamp.  Don't write anything if we are running as a    cross-compiler.  Otherwise, use the versions in /usr/include/stamp.h.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STAMP_H
end_ifdef

begin_include
include|#
directive|include
file|<stamp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|alpha_write_verstamp
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MS_STAMP
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.verstamp %d %d\n"
argument_list|,
name|MS_STAMP
argument_list|,
name|LS_STAMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function to set RTX_FRAME_RELATED_P on instructions, including    sequences.  */
end_comment

begin_function
specifier|static
name|rtx
name|set_frame_related_p
parameter_list|()
block|{
name|rtx
name|seq
init|=
name|gen_sequence
argument_list|()
decl_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|emit_insn
argument_list|(
name|seq
argument_list|)
return|;
block|}
else|else
block|{
name|seq
operator|=
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|seq
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|seq
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|FRP
parameter_list|(
name|exp
parameter_list|)
value|(start_sequence (), exp, set_frame_related_p ())
end_define

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_comment
comment|/* On vms we have two kinds of functions:     - stack frame (PROC_STACK) 	these are 'normal' functions with local vars and which are 	calling other functions    - register frame (PROC_REGISTER) 	keeps all data in registers, needs no stack     We must pass this to the assembler so it can generate the    proper pdsc (procedure descriptor)    This is done with the '.pdesc' command.     On not-vms, we don't really differentiate between the two, as we can    simply allocate stack without saving registers.  */
end_comment

begin_function
name|void
name|alpha_expand_prologue
parameter_list|()
block|{
comment|/* Registers to save.  */
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|rtx
name|sa_reg
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|vms_is_stack_procedure
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
comment|/* Adjust the stack by the frame size.  If the frame size is> 4096      bytes, we need to be sure we probe somewhere in the first and last      4096 bytes (we can probably get away without the latter test) and      every 8192 bytes in between.  If the frame size is> 32768, we      do this in a loop.  Otherwise, we generate the explicit probe      instructions.        Note that we are only allowed to adjust sp once in the prologue.  */
if|if
condition|(
name|frame_size
operator|<=
literal|32768
condition|)
block|{
if|if
condition|(
name|frame_size
operator|>
literal|4096
condition|)
block|{
name|int
name|probed
init|=
literal|4096
decl_stmt|;
do|do
name|emit_insn
argument_list|(
name|gen_probe_stack
argument_list|(
name|GEN_INT
argument_list|(
operator|-
name|probed
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|probed
operator|+=
literal|8192
operator|)
operator|<
name|frame_size
condition|)
do|;
comment|/* We only have to do this probe if we aren't saving registers.  */
if|if
condition|(
name|sa_size
operator|==
literal|0
operator|&&
name|probed
operator|+
literal|4096
operator|<
name|frame_size
condition|)
name|emit_insn
argument_list|(
name|gen_probe_stack
argument_list|(
name|GEN_INT
argument_list|(
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_size
operator|!=
literal|0
condition|)
block|{
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Here we generate code to set R22 to SP + 4096 and set R23 to the 	 number of 8192 byte blocks to probe.  We then probe each block 	 in the loop and then set SP to the proper location.  If the 	 amount remaining is> 4096, we have to do one more probe if we 	 are not saving any registers.  */
name|HOST_WIDE_INT
name|blocks
init|=
operator|(
name|frame_size
operator|+
literal|4096
operator|)
operator|/
literal|8192
decl_stmt|;
name|HOST_WIDE_INT
name|leftover
init|=
name|frame_size
operator|+
literal|4096
operator|-
name|blocks
operator|*
literal|8192
decl_stmt|;
name|rtx
name|ptr
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|22
argument_list|)
decl_stmt|;
name|rtx
name|count
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|GEN_INT
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|ptr
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|4096
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because of the difficulty in emitting a new basic block this 	 late in the compilation, generate the loop as a single insn.  */
name|emit_insn
argument_list|(
name|gen_prologue_stack_probe_loop
argument_list|(
name|count
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftover
operator|>
literal|4096
operator|&&
name|sa_size
operator|==
literal|0
condition|)
block|{
name|rtx
name|last
init|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|ptr
argument_list|,
operator|-
name|leftover
argument_list|)
argument_list|)
decl_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|last
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|last
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_WINDOWS_NT
condition|)
block|{
comment|/* For NT stack unwind (done by 'reverse execution'), it's 	     not OK to take the result of a loop, even though the value 	     is already in ptr, so we reload it via a single operation 	     and subtract it to sp.   	     Yes, that's correct -- we have to reload the whole constant 	     into a temporary via ldah+lda then subtract from sp.  To 	     ensure we get ldah+lda, we use a special pattern.  */
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
operator|(
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|hi
operator|=
name|frame_size
operator|-
name|lo
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_nt_lda
argument_list|(
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
name|lo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|leftover
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* This alternative is special, because the DWARF code cannot          possibly intuit through the loop above.  So we invent this          note it looks at instead.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|seq
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|seq
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|seq
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Cope with very large offsets to the register save area.  */
name|sa_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|reg_offset
operator|+
name|sa_size
operator|>
literal|0x8000
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|reg_offset
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|bias
decl_stmt|;
if|if
condition|(
name|low
operator|+
name|sa_size
operator|<=
literal|0x8000
condition|)
name|bias
operator|=
name|reg_offset
operator|-
name|low
operator|,
name|reg_offset
operator|=
name|low
expr_stmt|;
else|else
name|bias
operator|=
name|reg_offset
operator|,
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|sa_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|sa_reg
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|bias
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save regs in stack order.  Beginning with VMS PV.  */
if|if
condition|(
name|TARGET_OPEN_VMS
operator|&&
name|vms_is_stack_procedure
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
operator|=
name|alpha_sr_alias_set
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_PV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save register RA next.  */
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
operator|=
name|alpha_sr_alias_set
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|imask
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Now save any other registers required to be saved.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
operator|=
name|alpha_sr_alias_set
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
operator|=
name|alpha_sr_alias_set
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
operator|+
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
block|{
if|if
condition|(
operator|!
name|vms_is_stack_procedure
condition|)
block|{
comment|/* Register frame procedures fave the fp.  */
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vms_base_regno
operator|!=
name|REG_PV
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_base_regno
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_PV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have to allocate space for outgoing args, do it now.  */
if|if
condition|(
name|current_function_outgoing_args_size
operator|!=
literal|0
condition|)
block|{
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we need a frame pointer, set it from the stack pointer.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|TARGET_CAN_FAULT_IN_PROLOGUE
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This must always be the last instruction in the 		 prologue, thus we emit a special move + clobber.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_init_fp
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sa_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The ABIs for VMS and OSF/1 say that while we can schedule insns into      the prologue, for exception handling reasons, we cannot do this for      any insn that might fault.  We could prevent this for mems with a      (clobber:BLK (scratch)), but this doesn't work for fp insns.  So we      have to prevent all such scheduling with a blockage.       Linux, on the other hand, never bothered to implement OSF/1's       exception handling, and so doesn't care about such things.  Anyone      planning to use dwarf2 frame-unwind info can also omit the blockage.  */
if|if
condition|(
operator|!
name|TARGET_CAN_FAULT_IN_PROLOGUE
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the textual info surrounding the prologue.  */
end_comment

begin_function
name|void
name|alpha_start_function
parameter_list|(
name|file
parameter_list|,
name|fnname
parameter_list|,
name|decl
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|char
modifier|*
name|entry_label
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fnname
argument_list|)
operator|+
literal|6
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|vms_is_stack_procedure
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
comment|/* Ecoff can handle multiple .file directives, so put out file and lineno.      We have to do that before the .ent directive as we cannot switch      files within procedures with native ecoff because line numbers are      linked to procedure descriptors.      Outputting the lineno helps debugging of one line functions as they      would otherwise get no line number at all. Please note that we would      like to put out last_linenum from final.c, but it is not accessible.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
block|{
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
condition|)
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Issue function start and label.  */
if|if
condition|(
name|TARGET_OPEN_VMS
operator|||
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.ent "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|entry_label
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|strcat
argument_list|(
name|entry_label
argument_list|,
literal|"..en"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|entry_label
argument_list|)
expr_stmt|;
name|inside_function
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.base $%d\n"
argument_list|,
name|vms_base_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_OPEN_VMS
operator|&&
name|TARGET_IEEE_CONFORMANT
operator|&&
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
comment|/* Set flags in procedure descriptor to request IEEE-conformant 	 math-library routines.  The value we set it to is PDSC_EXC_IEEE 	 (/usr/include/pdsc.h). */
name|fputs
argument_list|(
literal|"\t.eflag 48\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Set up offsets to alpha virtual arg/local debugging pointer.  */
name|alpha_auto_offset
operator|=
operator|-
name|frame_size
operator|+
name|current_function_pretend_args_size
expr_stmt|;
name|alpha_arg_offset
operator|=
operator|-
name|frame_size
operator|+
literal|48
expr_stmt|;
comment|/* Describe our frame.  If the frame size is larger than an integer,      print it as zero to avoid an assembler error.  We won't be      properly describing such a frame, but that's the best we can do.  */
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $%d,"
argument_list|,
name|vms_unwind_regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1l
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|frame_size
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",$26,"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $%d,"
argument_list|,
operator|(
name|frame_pointer_needed
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1l
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|frame_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",$26,%d\n"
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
block|}
comment|/* Describe which registers were spilled.  */
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
block|{
if|if
condition|(
name|imask
condition|)
comment|/* ??? Does VMS care if mask contains ra?  The old code did'nt            set it, so I don't here.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask 0x%lx,0\n"
argument_list|,
name|imask
operator|&
operator|~
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask 0x%lx,0\n"
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vms_is_stack_procedure
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fp_save $%d\n"
argument_list|,
name|vms_save_fp_regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
if|if
condition|(
name|imask
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask 0x%lx,"
argument_list|,
name|imask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1l
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|reg_offset
operator|-
name|frame_size
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|fmask
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask 0x%lx,"
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1l
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|reg_offset
operator|-
name|frame_size
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit GP related things.  It is rather unfortunate about the alignment      issues surrounding a CODE_LABEL that forces us to do the label in       plain text.  */
if|if
condition|(
operator|!
name|TARGET_OPEN_VMS
operator|&&
operator|!
name|TARGET_WINDOWS_NT
condition|)
block|{
name|alpha_function_needs_gp
operator|=
name|alpha_does_function_need_gp
argument_list|()
expr_stmt|;
if|if
condition|(
name|alpha_function_needs_gp
condition|)
name|fputs
argument_list|(
literal|"\tldgp $29,0($27)\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..ng:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPEN_VMS
comment|/* Ifdef'ed cause readonly_section and link_section are only      available then.  */
name|readonly_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align 3\n"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..na:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.ascii \""
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\\0\"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|link_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align 3\n"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.name "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..na\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.pdesc "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"..en,%s\n"
argument_list|,
name|vms_is_stack_procedure
condition|?
literal|"stack"
else|:
literal|"reg"
argument_list|)
expr_stmt|;
name|alpha_need_linkage
argument_list|(
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit the .prologue note at the scheduled end of the prologue.  */
end_comment

begin_function
name|void
name|output_end_prologue
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|fputs
argument_list|(
literal|"\t.prologue\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_WINDOWS_NT
condition|)
name|fputs
argument_list|(
literal|"\t.prologue 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.prologue %d\n"
argument_list|,
name|alpha_function_needs_gp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_comment
comment|/* ??? At some point we will want to support full unwind, and so will     need to mark the epilogue as well.  At the moment, we just confuse    dwarf2out.  */
end_comment

begin_undef
undef|#
directive|undef
name|FRP
end_undef

begin_define
define|#
directive|define
name|FRP
parameter_list|(
name|exp
parameter_list|)
value|exp
end_define

begin_function
name|void
name|alpha_expand_epilogue
parameter_list|()
block|{
comment|/* Registers to save.  */
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|int
name|fp_is_frame_pointer
decl_stmt|,
name|fp_offset
decl_stmt|;
name|rtx
name|sa_reg
decl_stmt|,
name|sa_reg_exp
init|=
name|NULL
decl_stmt|;
name|rtx
name|sp_adj1
decl_stmt|,
name|sp_adj2
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|vms_is_stack_procedure
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
name|fp_is_frame_pointer
operator|=
operator|(
operator|(
name|TARGET_OPEN_VMS
operator|&&
name|vms_is_stack_procedure
operator|)
operator|||
operator|(
operator|!
name|TARGET_OPEN_VMS
operator|&&
name|frame_pointer_needed
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sa_size
condition|)
block|{
comment|/* If we have a frame pointer, restore SP from it.  */
if|if
condition|(
operator|(
name|TARGET_OPEN_VMS
operator|&&
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
operator|(
operator|!
name|TARGET_OPEN_VMS
operator|&&
name|frame_pointer_needed
operator|)
condition|)
block|{
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Cope with very large offsets to the register save area.  */
name|sa_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|reg_offset
operator|+
name|sa_size
operator|>
literal|0x8000
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|reg_offset
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|bias
decl_stmt|;
if|if
condition|(
name|low
operator|+
name|sa_size
operator|<=
literal|0x8000
condition|)
name|bias
operator|=
name|reg_offset
operator|-
name|low
operator|,
name|reg_offset
operator|=
name|low
expr_stmt|;
else|else
name|bias
operator|=
name|reg_offset
operator|,
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|sa_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|sa_reg_exp
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|bias
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|sa_reg
argument_list|,
name|sa_reg_exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore registers in order, excepting a true frame pointer. */
if|if
condition|(
operator|!
name|alpha_eh_epilogue_sp_ofs
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
operator|=
name|alpha_sr_alias_set
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reg_offset
operator|+=
literal|8
expr_stmt|;
name|imask
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|REG_RA
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|fp_is_frame_pointer
condition|)
name|fp_offset
operator|=
name|reg_offset
expr_stmt|;
else|else
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
operator|=
name|alpha_sr_alias_set
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
operator|=
name|alpha_sr_alias_set
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
operator|+
literal|32
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frame_size
operator|||
name|alpha_eh_epilogue_sp_ofs
condition|)
block|{
name|sp_adj1
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|alpha_eh_epilogue_sp_ofs
condition|)
block|{
name|sp_adj1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|sp_adj1
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|alpha_eh_epilogue_sp_ofs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the stack size is large, begin computation into a temporary 	 register so as not to interfere with a potential fp restore, 	 which must be consecutive with an SP restore.  */
if|if
condition|(
name|frame_size
operator|<
literal|32768
condition|)
name|sp_adj2
operator|=
name|GEN_INT
argument_list|(
name|frame_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_size
operator|<
literal|0x40007fffL
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|sp_adj2
operator|=
name|plus_constant
argument_list|(
name|sp_adj1
argument_list|,
name|frame_size
operator|-
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_reg_exp
operator|&&
name|rtx_equal_p
argument_list|(
name|sa_reg_exp
argument_list|,
name|sp_adj2
argument_list|)
condition|)
name|sp_adj1
operator|=
name|sa_reg
expr_stmt|;
else|else
block|{
name|sp_adj1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|sp_adj1
argument_list|,
name|sp_adj2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp_adj2
operator|=
name|GEN_INT
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
decl_stmt|;
name|FRP
argument_list|(
name|sp_adj2
operator|=
name|alpha_emit_set_const
argument_list|(
name|tmp
argument_list|,
name|DImode
argument_list|,
name|frame_size
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp_adj2
condition|)
block|{
comment|/* We can't drop new things to memory this late, afaik, 		 so build it up by pieces.  */
name|FRP
argument_list|(
name|sp_adj2
operator|=
name|alpha_emit_set_long_const
argument_list|(
name|tmp
argument_list|,
name|frame_size
argument_list|,
operator|-
operator|(
name|frame_size
operator|<
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp_adj2
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* From now on, things must be in order.  So emit blockages.  */
comment|/* Restore the frame pointer.  */
if|if
condition|(
name|fp_is_frame_pointer
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|fp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|mem
argument_list|)
operator|=
name|alpha_sr_alias_set
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_OPEN_VMS
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the stack pointer.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|sp_adj1
argument_list|,
name|sp_adj2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_OPEN_VMS
operator|&&
operator|!
name|vms_is_stack_procedure
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return.  */
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the rest of the textual info surrounding the epilogue.  */
end_comment

begin_function
name|void
name|alpha_end_function
parameter_list|(
name|file
parameter_list|,
name|fnname
parameter_list|,
name|decl
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* End the function.  */
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.end "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|inside_function
operator|=
name|FALSE
expr_stmt|;
comment|/* Show that we know this function if it is called again.        Don't do this for global functions in object files destined for a      shared library because the function may be overridden by the application      or other libraries.  Similarly, don't do this for weak functions.  */
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|)
name|SYMBOL_REF_FLAG
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debugging support.  */
end_comment

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* Count the number of sdb related labels are generated (to find block    start and end boundaries).  */
end_comment

begin_decl_stmt
name|int
name|sdb_label_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next label # for each statement.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sym_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of .file directives, so that .loc is up to date.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_source_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file containing the current function.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_function_file
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offsets to alpha virtual arg/local debugging pointers.  */
end_comment

begin_decl_stmt
name|long
name|alpha_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|alpha_auto_offset
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Emit a new filename to a stream.  */
end_comment

begin_function
name|void
name|alpha_output_filename
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|int
name|first_time
init|=
name|TRUE
decl_stmt|;
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|first_time
operator|=
name|FALSE
expr_stmt|;
operator|++
name|num_source_filenames
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_GAS
operator|&&
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#@stabs\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|",%d,0,0,%s\n"
argument_list|,
name|N_SOL
argument_list|,
operator|&
name|ltext_label_name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|current_function_file
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|current_function_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inside_function
operator|&&
operator|!
name|TARGET_GAS
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|num_source_filenames
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
block|}
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a linenumber to a stream.  */
end_comment

begin_function
name|void
name|alpha_output_lineno
parameter_list|(
name|stream
parameter_list|,
name|line
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
comment|/* mips-tfile doesn't understand .stabd directives.  */
operator|++
name|sym_lineno
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$LM%d:\n\t%s %d,0,%d,$LM%d\n"
argument_list|,
name|sym_lineno
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_SLINE
argument_list|,
name|line
argument_list|,
name|sym_lineno
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n\t.loc\t%d %d\n"
argument_list|,
name|num_source_filenames
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure to show the current status of registers and memory.  */
end_comment

begin_struct
struct|struct
name|shadow_summary
block|{
struct|struct
block|{
name|unsigned
name|long
name|i
range|:
literal|31
decl_stmt|;
comment|/* Mask of int regs */
name|unsigned
name|long
name|fp
range|:
literal|31
decl_stmt|;
comment|/* Mask of fp regs */
name|unsigned
name|long
name|mem
range|:
literal|1
decl_stmt|;
comment|/* mem == imem | fpmem */
block|}
name|used
struct|,
name|defd
struct|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|summarize_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|shadow_summary
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_handle_trap_shadows
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Summary the effects of expression X on the machine.  Update SUM, a pointer    to the summary structure.  SET is nonzero if the insn is setting the    object, otherwise zero.  */
end_comment

begin_function
specifier|static
name|void
name|summarize_insn
parameter_list|(
name|x
parameter_list|,
name|sum
parameter_list|,
name|set
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|shadow_summary
modifier|*
name|sum
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* ??? Note that this case would be incorrect if the Alpha had a 	 ZERO_EXTRACT in SET_DEST.  */
case|case
name|SET
case|:
name|summarize_insn
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|summarize_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|summarize_insn
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|summarize_insn
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
name|summarize_insn
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
literal|1UL
operator|<<
operator|(
name|regno
operator|%
literal|32
operator|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
literal|31
operator|||
name|regno
operator|==
literal|63
condition|)
break|break;
if|if
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
name|sum
operator|->
name|defd
operator|.
name|i
operator||=
name|mask
expr_stmt|;
else|else
name|sum
operator|->
name|defd
operator|.
name|fp
operator||=
name|mask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
name|sum
operator|->
name|used
operator|.
name|i
operator||=
name|mask
expr_stmt|;
else|else
name|sum
operator|->
name|used
operator|.
name|fp
operator||=
name|mask
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MEM
case|:
if|if
condition|(
name|set
condition|)
name|sum
operator|->
name|defd
operator|.
name|mem
operator|=
literal|1
expr_stmt|;
else|else
name|sum
operator|->
name|used
operator|.
name|mem
operator|=
literal|1
expr_stmt|;
comment|/* Find the regs used in memory address computation: */
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
break|break;
comment|/* Handle common unary and binary ops for efficiency.  */
case|case
name|COMPARE
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|summarize_insn
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Ensure a sufficient number of `trapb' insns are in the code when    the user requests code with a trap precision of functions or    instructions.     In naive mode, when the user requests a trap-precision of    "instruction", a trapb is needed after every instruction that may    generate a trap.  This ensures that the code is resumption safe but    it is also slow.     When optimizations are turned on, we delay issuing a trapb as long    as possible.  In this context, a trap shadow is the sequence of    instructions that starts with a (potentially) trap generating    instruction and extends to the next trapb or call_pal instruction    (but GCC never generates call_pal by itself).  We can delay (and    therefore sometimes omit) a trapb subject to the following    conditions:     (a) On entry to the trap shadow, if any Alpha register or memory    location contains a value that is used as an operand value by some    instruction in the trap shadow (live on entry), then no instruction    in the trap shadow may modify the register or memory location.     (b) Within the trap shadow, the computation of the base register    for a memory load or store instruction may not involve using the    result of an instruction that might generate an UNPREDICTABLE    result.     (c) Within the trap shadow, no register may be used more than once    as a destination register.  (This is to make life easier for the    trap-handler.)     (d) The trap shadow may not include any branch instructions.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_handle_trap_shadows
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
name|struct
name|shadow_summary
name|shadow
decl_stmt|;
name|int
name|trap_pending
decl_stmt|,
name|exception_nesting
decl_stmt|;
name|rtx
name|i
decl_stmt|,
name|n
decl_stmt|;
name|trap_pending
operator|=
literal|0
expr_stmt|;
name|exception_nesting
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|defd
operator|=
name|shadow
operator|.
name|used
expr_stmt|;
for|for
control|(
name|i
operator|=
name|insns
init|;
name|i
condition|;
name|i
operator|=
name|NEXT_INSN
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|NOTE
condition|)
block|{
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
name|exception_nesting
operator|++
expr_stmt|;
if|if
condition|(
name|trap_pending
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_END
case|:
name|exception_nesting
operator|--
expr_stmt|;
if|if
condition|(
name|trap_pending
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
case|case
name|NOTE_INSN_EPILOGUE_BEG
case|:
if|if
condition|(
name|trap_pending
operator|&&
name|alpha_tp
operator|>=
name|ALPHA_TP_FUNC
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|trap_pending
condition|)
block|{
if|if
condition|(
name|alpha_tp
operator|==
name|ALPHA_TP_FUNC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
goto|goto
name|close_shadow
goto|;
block|}
elseif|else
if|if
condition|(
name|alpha_tp
operator|==
name|ALPHA_TP_INSN
condition|)
block|{
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|struct
name|shadow_summary
name|sum
decl_stmt|;
name|sum
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|defd
operator|=
name|sum
operator|.
name|used
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
comment|/* Annoyingly, get_attr_trap will abort on these.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
name|summarize_insn
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|shadow
operator|.
name|defd
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|shadow
operator|.
name|defd
operator|.
name|fp
operator|)
condition|)
block|{
comment|/* (c) would be violated */
goto|goto
name|close_shadow
goto|;
block|}
comment|/* Combine shadow with summary of current insn: */
name|shadow
operator|.
name|used
operator|.
name|i
operator||=
name|sum
operator|.
name|used
operator|.
name|i
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator||=
name|sum
operator|.
name|used
operator|.
name|fp
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator||=
name|sum
operator|.
name|used
operator|.
name|mem
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|i
operator||=
name|sum
operator|.
name|defd
operator|.
name|i
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|fp
operator||=
name|sum
operator|.
name|defd
operator|.
name|fp
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|mem
operator||=
name|sum
operator|.
name|defd
operator|.
name|mem
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|shadow
operator|.
name|used
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|shadow
operator|.
name|used
operator|.
name|fp
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|mem
operator|&
name|shadow
operator|.
name|used
operator|.
name|mem
operator|)
condition|)
block|{
comment|/* (a) would be violated (also takes care of (b))  */
if|if
condition|(
name|get_attr_trap
argument_list|(
name|i
argument_list|)
operator|==
name|TRAP_YES
operator|&&
operator|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|sum
operator|.
name|used
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|sum
operator|.
name|used
operator|.
name|fp
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
goto|goto
name|close_shadow
goto|;
block|}
break|break;
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
goto|goto
name|close_shadow
goto|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|close_shadow
label|:
name|n
operator|=
name|emit_insn_before
argument_list|(
name|gen_trapb
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|n
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|i
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
name|trap_pending
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|defd
operator|=
name|shadow
operator|.
name|used
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|exception_nesting
operator|>
literal|0
operator|||
name|alpha_tp
operator|>=
name|ALPHA_TP_FUNC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|get_attr_trap
argument_list|(
name|i
argument_list|)
operator|==
name|TRAP_YES
condition|)
block|{
if|if
condition|(
name|optimize
operator|&&
operator|!
name|trap_pending
condition|)
name|summarize_insn
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|shadow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trap_pending
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAIFA
end_ifdef

begin_comment
comment|/* Alpha can only issue instruction groups simultaneously if they are    suitibly aligned.  This is very processor-specific.  */
end_comment

begin_enum
enum|enum
name|alphaev4_pipe
block|{
name|EV4_STOP
init|=
literal|0
block|,
name|EV4_IB0
init|=
literal|1
block|,
name|EV4_IB1
init|=
literal|2
block|,
name|EV4_IBX
init|=
literal|4
block|}
enum|;
end_enum

begin_enum
enum|enum
name|alphaev5_pipe
block|{
name|EV5_STOP
init|=
literal|0
block|,
name|EV5_NONE
init|=
literal|1
block|,
name|EV5_E01
init|=
literal|2
block|,
name|EV5_E0
init|=
literal|4
block|,
name|EV5_E1
init|=
literal|8
block|,
name|EV5_FAM
init|=
literal|16
block|,
name|EV5_FA
init|=
literal|32
block|,
name|EV5_FM
init|=
literal|64
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|alphaev4_pipe
name|alphaev4_insn_pipe
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|alphaev5_pipe
name|alphaev5_insn_pipe
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alphaev4_next_group
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alphaev5_next_group
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alphaev4_next_nop
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alphaev5_next_nop
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_align_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|int
operator|*
argument_list|,
name|int
operator|*
argument_list|)
operator|,
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
operator|*
argument_list|)
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|enum
name|alphaev4_pipe
name|alphaev4_insn_pipe
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EV4_STOP
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|EV4_STOP
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_FLD
case|:
return|return
name|EV4_IBX
return|;
case|case
name|TYPE_LDSYM
case|:
case|case
name|TYPE_IADD
case|:
case|case
name|TYPE_ILOG
case|:
case|case
name|TYPE_ICMOV
case|:
case|case
name|TYPE_ICMP
case|:
case|case
name|TYPE_IST
case|:
case|case
name|TYPE_FST
case|:
case|case
name|TYPE_SHIFT
case|:
case|case
name|TYPE_IMUL
case|:
case|case
name|TYPE_FBR
case|:
return|return
name|EV4_IB0
return|;
case|case
name|TYPE_MISC
case|:
case|case
name|TYPE_IBR
case|:
case|case
name|TYPE_JSR
case|:
case|case
name|TYPE_FCPYS
case|:
case|case
name|TYPE_FCMOV
case|:
case|case
name|TYPE_FADD
case|:
case|case
name|TYPE_FDIV
case|:
case|case
name|TYPE_FMUL
case|:
return|return
name|EV4_IB1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|alphaev5_pipe
name|alphaev5_insn_pipe
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EV5_STOP
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|EV5_STOP
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_FLD
case|:
case|case
name|TYPE_LDSYM
case|:
case|case
name|TYPE_IADD
case|:
case|case
name|TYPE_ILOG
case|:
case|case
name|TYPE_ICMOV
case|:
case|case
name|TYPE_ICMP
case|:
return|return
name|EV5_E01
return|;
case|case
name|TYPE_IST
case|:
case|case
name|TYPE_FST
case|:
case|case
name|TYPE_SHIFT
case|:
case|case
name|TYPE_IMUL
case|:
case|case
name|TYPE_MISC
case|:
case|case
name|TYPE_MVI
case|:
return|return
name|EV5_E0
return|;
case|case
name|TYPE_IBR
case|:
case|case
name|TYPE_JSR
case|:
return|return
name|EV5_E1
return|;
case|case
name|TYPE_FCPYS
case|:
return|return
name|EV5_FAM
return|;
case|case
name|TYPE_FBR
case|:
case|case
name|TYPE_FCMOV
case|:
case|case
name|TYPE_FADD
case|:
case|case
name|TYPE_FDIV
case|:
return|return
name|EV5_FA
return|;
case|case
name|TYPE_FMUL
case|:
return|return
name|EV5_FM
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* IN_USE is a mask of the slots currently filled within the insn group.     The mask bits come from alphaev4_pipe above.  If EV4_IBX is set, then    the insn in EV4_IB0 can be swapped by the hardware into EV4_IB1.      LEN is, of course, the length of the group in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|alphaev4_next_group
parameter_list|(
name|insn
parameter_list|,
name|pin_use
parameter_list|,
name|plen
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|pin_use
decl_stmt|,
decl|*
name|plen
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|,
name|in_use
decl_stmt|;
name|len
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next_and_done
goto|;
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|alphaev4_pipe
name|pipe
decl_stmt|;
name|pipe
operator|=
name|alphaev4_insn_pipe
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
name|EV4_STOP
case|:
comment|/* Force complex instructions to start new groups.  */
if|if
condition|(
name|in_use
condition|)
goto|goto
name|done
goto|;
comment|/* If this is a completely unrecognized insn, its an asm. 	     We don't know how long it is, so record length as -1 to 	     signal a needed realignment.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
goto|goto
name|next_and_done
goto|;
case|case
name|EV4_IBX
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB0
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV4_IB1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV4_IB0
operator||
name|EV4_IBX
expr_stmt|;
break|break;
case|case
name|EV4_IB0
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV4_IBX
operator|)
operator|||
operator|(
name|in_use
operator|&
name|EV4_IB1
operator|)
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
block|}
name|in_use
operator||=
name|EV4_IB0
expr_stmt|;
break|break;
case|case
name|EV4_IB1
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|+=
literal|4
expr_stmt|;
comment|/* Haifa doesn't do well scheduling branches.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
goto|goto
name|next_and_done
goto|;
name|next
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
goto|goto
name|done
goto|;
comment|/* Let Haifa tell us where it thinks insn group boundaries are.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next
goto|;
block|}
name|next_and_done
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|done
label|:
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|insn
return|;
block|}
end_block

begin_comment
comment|/* IN_USE is a mask of the slots currently filled within the insn group.     The mask bits come from alphaev5_pipe above.  If EV5_E01 is set, then    the insn in EV5_E0 can be swapped by the hardware into EV5_E1.      LEN is, of course, the length of the group in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|alphaev5_next_group
parameter_list|(
name|insn
parameter_list|,
name|pin_use
parameter_list|,
name|plen
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|pin_use
decl_stmt|,
decl|*
name|plen
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|,
name|in_use
decl_stmt|;
name|len
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next_and_done
goto|;
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|alphaev5_pipe
name|pipe
decl_stmt|;
name|pipe
operator|=
name|alphaev5_insn_pipe
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
name|EV5_STOP
case|:
comment|/* Force complex instructions to start new groups.  */
if|if
condition|(
name|in_use
condition|)
goto|goto
name|done
goto|;
comment|/* If this is a completely unrecognized insn, its an asm. 	     We don't know how long it is, so record length as -1 to 	     signal a needed realignment.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
goto|goto
name|next_and_done
goto|;
comment|/* ??? Most of the places below, we would like to abort, as  	   it would indicate an error either in Haifa, or in the  	   scheduling description.  Unfortunately, Haifa never  	   schedules the last instruction of the BB, so we don't 	   have an accurate TI bit to go off.  */
case|case
name|EV5_E01
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E0
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV5_E1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV5_E0
operator||
name|EV5_E01
expr_stmt|;
break|break;
case|case
name|EV5_E0
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV5_E01
operator|)
operator|||
operator|(
name|in_use
operator|&
name|EV5_E1
operator|)
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
block|}
name|in_use
operator||=
name|EV5_E0
expr_stmt|;
break|break;
case|case
name|EV5_E1
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
break|break;
case|case
name|EV5_FAM
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FA
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV5_FM
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV5_FA
operator||
name|EV5_FAM
expr_stmt|;
break|break;
case|case
name|EV5_FA
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FA
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FA
expr_stmt|;
break|break;
case|case
name|EV5_FM
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FM
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
break|break;
case|case
name|EV5_NONE
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|+=
literal|4
expr_stmt|;
comment|/* Haifa doesn't do well scheduling branches.  */
comment|/* ??? If this is predicted not-taken, slotting continues, except 	 that no more IBR, FBR, or JSR insns may be slotted.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
goto|goto
name|next_and_done
goto|;
name|next
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
goto|goto
name|done
goto|;
comment|/* Let Haifa tell us where it thinks insn group boundaries are.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next
goto|;
block|}
name|next_and_done
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|done
label|:
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|insn
return|;
block|}
end_block

begin_function
specifier|static
name|rtx
name|alphaev4_next_nop
parameter_list|(
name|pin_use
parameter_list|)
name|int
modifier|*
name|pin_use
decl_stmt|;
block|{
name|int
name|in_use
init|=
operator|*
name|pin_use
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV4_IB0
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV4_IB0
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|in_use
operator|&
operator|(
name|EV4_IBX
operator||
name|EV4_IB1
operator|)
operator|)
operator|==
name|EV4_IBX
condition|)
block|{
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV4_IB1
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
else|else
name|nop
operator|=
name|gen_unop
argument_list|()
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|nop
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|alphaev5_next_nop
parameter_list|(
name|pin_use
parameter_list|)
name|int
modifier|*
name|pin_use
decl_stmt|;
block|{
name|int
name|in_use
init|=
operator|*
name|pin_use
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV5_E1
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV5_FA
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_FA
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV5_FM
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
else|else
name|nop
operator|=
name|gen_unop
argument_list|()
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|nop
return|;
block|}
end_function

begin_comment
comment|/* The instruction group alignment main loop.  */
end_comment

begin_function_decl
specifier|static
name|void
name|alpha_align_insns
parameter_list|(
name|insns
parameter_list|,
name|max_align
parameter_list|,
name|next_group
parameter_list|,
name|next_nop
parameter_list|,
name|gp_in_use
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|int
name|max_align
decl_stmt|;
function_decl|rtx
parameter_list|(
function_decl|*next_group
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|rtx
argument_list|(
argument|*next_nop
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|gp_in_use
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* ALIGN is the known alignment for the insn group.  */
name|int
name|align
decl_stmt|;
comment|/* OFS is the offset of the current insn in the insn group.  */
name|int
name|ofs
decl_stmt|;
name|int
name|prev_in_use
decl_stmt|,
name|in_use
decl_stmt|,
name|len
decl_stmt|;
name|rtx
name|i
decl_stmt|,
name|next
decl_stmt|;
comment|/* Let shorten branches care for assigning alignments to code labels.  */
name|shorten_branches
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|align
operator|=
operator|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|<
name|max_align
condition|?
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
else|:
name|max_align
operator|)
expr_stmt|;
comment|/* Account for the initial GP load, which happens before the scheduled      prologue we emitted as RTL.  */
name|ofs
operator|=
name|prev_in_use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alpha_does_function_need_gp
argument_list|()
condition|)
block|{
name|ofs
operator|=
literal|8
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|prev_in_use
operator|=
name|gp_in_use
expr_stmt|;
block|}
name|i
operator|=
name|insns
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|NOTE
condition|)
name|i
operator|=
name|next_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|next
operator|=
call|(
modifier|*
name|next_group
call|)
argument_list|(
name|i
argument_list|,
operator|&
name|in_use
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* When we see a label, resync alignment etc.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|int
name|new_align
init|=
literal|1
operator|<<
name|label_to_alignment
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_align
operator|>=
name|align
condition|)
block|{
name|align
operator|=
name|new_align
operator|<
name|max_align
condition|?
name|new_align
else|:
name|max_align
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ofs
operator|&
operator|(
name|new_align
operator|-
literal|1
operator|)
condition|)
name|ofs
operator|=
operator|(
name|ofs
operator||
operator|(
name|new_align
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Handle complex instructions special.  */
elseif|else
if|if
condition|(
name|in_use
operator|==
literal|0
condition|)
block|{
comment|/* Asms will have length< 0.  This is a signal that we have 	     lost alignment knowledge.  Assume, however, that the asm 	     will not mis-align instructions.  */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|ofs
operator|=
literal|0
expr_stmt|;
name|align
operator|=
literal|4
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the known alignment is smaller than the recognized insn group, 	 realign the output.  */
elseif|else
if|if
condition|(
name|align
operator|<
name|len
condition|)
block|{
name|int
name|new_log_align
init|=
name|len
operator|>
literal|8
condition|?
literal|4
else|:
literal|3
decl_stmt|;
name|rtx
name|where
decl_stmt|;
name|where
operator|=
name|prev_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|where
operator|||
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|where
operator|=
name|i
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_realign
argument_list|(
name|GEN_INT
argument_list|(
name|new_log_align
argument_list|)
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|new_log_align
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the group won't fit in the same INT16 as the previous, 	 we need to add padding to keep the group together.  Rather 	 than simply leaving the insn filling to the assembler, we 	 can make use of the knowledge of what sorts of instructions 	 were issued in the previous group to make sure that all of 	 the added nops are really free.  */
elseif|else
if|if
condition|(
name|ofs
operator|+
name|len
operator|>
name|align
condition|)
block|{
name|int
name|nop_count
init|=
operator|(
name|align
operator|-
name|ofs
operator|)
operator|/
literal|4
decl_stmt|;
name|rtx
name|where
decl_stmt|;
comment|/* Insert nops before labels and branches to truely merge the 	     execution of the nops with the previous instruction group.  */
name|where
operator|=
name|prev_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|where2
init|=
name|prev_nonnote_insn
argument_list|(
name|where
argument_list|)
decl_stmt|;
if|if
condition|(
name|where2
operator|&&
name|GET_CODE
argument_list|(
name|where2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|where
operator|=
name|where2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
name|where
operator|=
name|i
expr_stmt|;
block|}
else|else
name|where
operator|=
name|i
expr_stmt|;
do|do
name|emit_insn_before
argument_list|(
call|(
modifier|*
name|next_nop
call|)
argument_list|(
operator|&
name|prev_in_use
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|nop_count
condition|)
do|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
name|ofs
operator|=
operator|(
name|ofs
operator|+
name|len
operator|)
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|prev_in_use
operator|=
name|in_use
expr_stmt|;
name|i
operator|=
name|next
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAIFA */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Machine dependant reorg pass.  */
end_comment

begin_function
name|void
name|alpha_reorg
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
if|if
condition|(
name|alpha_tp
operator|!=
name|ALPHA_TP_PROG
operator|||
name|flag_exceptions
condition|)
name|alpha_handle_trap_shadows
argument_list|(
name|insns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAIFA
comment|/* Due to the number of extra trapb insns, don't bother fixing up      alignment when trap precision is instruction.  Moreover, we can      only do our job when sched2 is run and Haifa is our scheduler.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|optimize_size
operator|&&
name|alpha_tp
operator|!=
name|ALPHA_TP_INSN
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
if|if
condition|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV4
condition|)
name|alpha_align_insns
argument_list|(
name|insns
argument_list|,
literal|8
argument_list|,
name|alphaev4_next_group
argument_list|,
name|alphaev4_next_nop
argument_list|,
name|EV4_IB0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV5
condition|)
name|alpha_align_insns
argument_list|(
name|insns
argument_list|,
literal|16
argument_list|,
name|alphaev5_next_group
argument_list|,
name|alphaev5_next_nop
argument_list|,
name|EV5_E01
operator||
name|EV5_E0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check a floating-point value for validity for a particular machine mode.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|const
name|float_strings
index|[]
init|=
block|{
comment|/* These are for FLOAT_VAX.  */
literal|"1.70141173319264430e+38"
block|,
comment|/* 2^127 (2^24 - 1) / 2^24 */
literal|"-1.70141173319264430e+38"
block|,
literal|"2.93873587705571877e-39"
block|,
comment|/* 2^-128 */
literal|"-2.93873587705571877e-39"
block|,
comment|/* These are for the default broken IEEE mode, which traps      on infinity or denormal numbers.  */
literal|"3.402823466385288598117e+38"
block|,
comment|/* 2^128 (1 - 2^-24) */
literal|"-3.402823466385288598117e+38"
block|,
literal|"1.1754943508222875079687e-38"
block|,
comment|/* 2^-126 */
literal|"-1.1754943508222875079687e-38"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|REAL_VALUE_TYPE
name|float_values
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inited_float_values
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|check_float_value
parameter_list|(
name|mode
parameter_list|,
name|d
parameter_list|,
name|overflow
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|d
decl_stmt|;
name|int
name|overflow
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_IEEE
operator|||
name|TARGET_IEEE_CONFORMANT
operator|||
name|TARGET_IEEE_WITH_INEXACT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|inited_float_values
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|float_values
index|[
name|i
index|]
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|float_strings
index|[
name|i
index|]
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|inited_float_values
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|fvptr
decl_stmt|;
if|if
condition|(
name|TARGET_FLOAT_VAX
condition|)
name|fvptr
operator|=
operator|&
name|float_values
index|[
literal|0
index|]
expr_stmt|;
else|else
name|fvptr
operator|=
operator|&
name|float_values
index|[
literal|4
index|]
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|fvptr
index|[
literal|0
index|]
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fvptr
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|r
argument_list|,
name|fvptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fvptr
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|dconst0
argument_list|,
name|r
argument_list|)
operator|&&
name|REAL_VALUES_LESS
argument_list|(
name|r
argument_list|,
name|fvptr
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dconst0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|r
argument_list|,
name|dconst0
argument_list|)
operator|&&
name|REAL_VALUES_LESS
argument_list|(
name|fvptr
index|[
literal|3
index|]
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dconst0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|OPEN_VMS
end_if

begin_comment
comment|/* Return the VMS argument type corresponding to MODE.  */
end_comment

begin_function
name|enum
name|avms_arg_type
name|alpha_arg_type
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
return|return
name|TARGET_FLOAT_VAX
condition|?
name|FF
else|:
name|FS
return|;
case|case
name|DFmode
case|:
return|return
name|TARGET_FLOAT_VAX
condition|?
name|FD
else|:
name|FT
return|;
default|default:
return|return
name|I64
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return an rtx for an integer representing the VMS Argument Information    register value.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|alpha_arg_info_reg_val
parameter_list|(
name|cum
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|regval
init|=
name|cum
operator|.
name|num_args
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|regval
operator||=
operator|(
operator|(
name|int
operator|)
name|cum
operator|.
name|atypes
index|[
name|i
index|]
operator|)
operator|<<
operator|(
name|i
operator|*
literal|3
operator|+
literal|8
operator|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|regval
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure to collect function names for final output    in link section.  */
end_comment

begin_enum
enum|enum
name|links_kind
block|{
name|KIND_UNUSED
block|,
name|KIND_LOCAL
block|,
name|KIND_EXTERN
block|}
enum|;
end_enum

begin_struct
struct|struct
name|alpha_links
block|{
name|struct
name|alpha_links
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|links_kind
name|kind
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|alpha_links
modifier|*
name|alpha_links_base
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make (or fake) .linkage entry for function call.     IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.  */
end_comment

begin_function
name|void
name|alpha_need_linkage
parameter_list|(
name|name
parameter_list|,
name|is_local
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|is_local
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|struct
name|alpha_links
modifier|*
name|lptr
decl_stmt|,
modifier|*
name|nptr
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|name
operator|++
expr_stmt|;
comment|/* Is this name already defined ?  */
for|for
control|(
name|lptr
operator|=
name|alpha_links_base
init|;
name|lptr
condition|;
name|lptr
operator|=
name|lptr
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|lptr
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_local
condition|)
block|{
comment|/* Defined here but external assumed.  */
if|if
condition|(
name|lptr
operator|->
name|kind
operator|==
name|KIND_EXTERN
condition|)
name|lptr
operator|->
name|kind
operator|=
name|KIND_LOCAL
expr_stmt|;
block|}
else|else
block|{
comment|/* Used here but unused assumed.  */
if|if
condition|(
name|lptr
operator|->
name|kind
operator|==
name|KIND_UNUSED
condition|)
name|lptr
operator|->
name|kind
operator|=
name|KIND_LOCAL
expr_stmt|;
block|}
return|return;
block|}
name|nptr
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_links
argument_list|)
argument_list|)
expr_stmt|;
name|nptr
operator|->
name|next
operator|=
name|alpha_links_base
expr_stmt|;
name|nptr
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Assume external if no definition.  */
name|nptr
operator|->
name|kind
operator|=
operator|(
name|is_local
condition|?
name|KIND_UNUSED
else|:
name|KIND_EXTERN
operator|)
expr_stmt|;
comment|/* Ensure we have an IDENTIFIER so assemble_name can mark is used.  */
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|alpha_links_base
operator|=
name|nptr
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|alpha_write_linkage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|alpha_links
modifier|*
name|lptr
decl_stmt|,
modifier|*
name|nptr
decl_stmt|;
name|readonly_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.align 3\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|lptr
operator|=
name|alpha_links_base
init|;
name|lptr
condition|;
name|lptr
operator|=
name|nptr
control|)
block|{
name|nptr
operator|=
name|lptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lptr
operator|->
name|kind
operator|==
name|KIND_UNUSED
operator|||
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|get_identifier
argument_list|(
name|lptr
operator|->
name|name
argument_list|)
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%s..lk:\n"
argument_list|,
name|lptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lptr
operator|->
name|kind
operator|==
name|KIND_LOCAL
condition|)
block|{
comment|/*  Local and used, build linkage pair.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.quad %s..en\n"
argument_list|,
name|lptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.quad %s\n"
argument_list|,
name|lptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* External and used, request linkage pair.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.linkage %s\n"
argument_list|,
name|lptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|alpha_need_linkage
parameter_list|(
name|name
parameter_list|,
name|is_local
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|is_local
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPEN_VMS */
end_comment

end_unit

