begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on the DEC Alpha.    Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|alpha_compare_op0
decl_stmt|,
name|alpha_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alpha_compare_fp_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save the name of the current function as used by the assembler.  This    is used by the epilogue.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|alpha_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if inside of a function, because the Alpha asm can't    handle .files inside of functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inside_function
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function needs gp.  */
end_comment

begin_decl_stmt
name|int
name|alpha_function_needs_gp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declarations of static functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|alpha_set_memflags_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_long_const
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */
end_comment

begin_function
name|int
name|zap_mask
parameter_list|(
name|value
parameter_list|)
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0xff
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either the constant zero or a register.  If a    register, it must be in the proper mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant in the range of 0-63 (for a shift) or    any register.  */
end_comment

begin_function
name|int
name|reg_or_6bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant or any register.  */
end_comment

begin_function
name|int
name|reg_or_8bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant.  */
end_comment

begin_function
name|int
name|cint8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to an add insn.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'O'
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to a sign-extending    add insn.  */
end_comment

begin_function
name|int
name|sext_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|255
operator|||
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
literal|255
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant 4 or 8.  */
end_comment

begin_function
name|int
name|const48_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an AND insn.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
operator|(
name|zap_mask
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
name|zap_mask
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an IOR or XOR insn.  */
end_comment

begin_function
name|int
name|or_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width, in bits, of an integral    mode smaller than DImode.  */
end_comment

begin_function
name|int
name|mode_width_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|32
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width of an integral machine mode    smaller than an integer.  */
end_comment

begin_function
name|int
name|mode_mask_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
return|;
endif|#
directive|endif
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xff
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xffff
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xffffffff
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a multiple of 8 less than 64.  */
end_comment

begin_function
name|int
name|mul8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|7
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant zero in floating-point.  */
end_comment

begin_function
name|int
name|fp0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the floating-point constant zero or a register.  */
end_comment

begin_function
name|int
name|reg_or_fp0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|fp0_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register or a constant integer.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is something that can be reloaded into a register;    if it is a MEM, it need not be valid.  */
end_comment

begin_function
name|int
name|some_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|MEM
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
return|return
name|some_operand
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the source of a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
comment|/* This handles both the Windows/NT and OSF cases.  */
return|return
name|mode
operator|==
name|ptr_mode
operator|||
name|mode
operator|==
name|DImode
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ... fall through ... */
case|case
name|MEM
case|:
return|return
name|mode
operator|!=
name|HImode
operator|&&
name|mode
operator|!=
name|QImode
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|add_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a SYMBOL_REF for a function known to be in this    file.  */
end_comment

begin_function
name|int
name|current_file_function_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|profile_flag
operator|&&
operator|!
name|profile_block_flag
operator|&&
operator|(
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
operator|||
name|op
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|Pmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha comparison operator.  Here we know which    comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
operator|(
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a signed comparison operation.  */
end_comment

begin_function
name|int
name|signed_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a divide or modulus operator.  */
end_comment

begin_function
name|int
name|divmod_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this memory address is a known aligned register plus    a constant.  It must be a valid address.  This means that we can do    this as an aligned reference plus some offset.     Take into account what reload will do.     We could say that out-of-range stack slots are alignable, but that would    complicate get_aligned_mem and it isn't worth the trouble since few    functions have large stack space.  */
end_comment

begin_function
name|int
name|aligned_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|op
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|||
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|op
operator|==
name|hard_frame_pointer_rtx
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but return 1 if OP is a MEM which is not alignable.  */
end_comment

begin_function
name|int
name|unaligned_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|op
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|op
operator|!=
name|hard_frame_pointer_rtx
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is any memory location.  During reload a pseudo matches.  */
end_comment

begin_function
name|int
name|any_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* REF is an alignable memory location.  Place an aligned SImode    reference into *PALIGNED_MEM and the number of bits to shift into    *PBITNUM.  */
end_comment

begin_function
name|void
name|get_aligned_mem
parameter_list|(
name|ref
parameter_list|,
name|paligned_mem
parameter_list|,
name|pbitnum
parameter_list|)
name|rtx
name|ref
decl_stmt|;
name|rtx
modifier|*
name|paligned_mem
decl_stmt|,
decl|*
name|pbitnum
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_WORD
argument_list|(
name|ref
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|paligned_mem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|&
operator|~
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
operator|*
name|paligned_mem
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
operator|*
name|paligned_mem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
operator|*
name|paligned_mem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
operator|*
name|pbitnum
operator|=
name|GEN_INT
argument_list|(
operator|(
name|offset
operator|&
literal|3
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Similar, but just get the address.  Handle the two reload cases.  */
end_comment

begin_function
name|rtx
name|get_unaligned_address
parameter_list|(
name|ref
parameter_list|)
name|rtx
name|ref
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_WORD
argument_list|(
name|ref
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subfunction of the following function.  Update the flags of any MEM    found in part of X.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_set_memflags_1
parameter_list|(
name|x
parameter_list|,
name|in_struct_p
parameter_list|,
name|volatile_p
parameter_list|,
name|unchanging_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|in_struct_p
decl_stmt|,
name|volatile_p
decl_stmt|,
name|unchanging_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SEQUENCE
case|:
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|alpha_set_memflags_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|alpha_set_memflags_1
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|alpha_set_memflags_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
name|alpha_set_memflags_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|volatile_p
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given INSN, which is either an INSN or a SEQUENCE generated to    perform a memory operation, look for any MEMs in either a SET_DEST or    a SET_SRC and copy the in-struct, unchanging, and volatile flags from    REF into each of the MEMs found.  If REF is not a MEM, don't do    anything.  */
end_comment

begin_function
name|void
name|alpha_set_memflags
parameter_list|(
name|insn
parameter_list|,
name|ref
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ref
decl_stmt|;
block|{
comment|/* Note that it is always safe to get these flags, though they won't      be what we think if REF is not a MEM.  */
name|int
name|in_struct_p
init|=
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|int
name|volatile_p
init|=
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|int
name|unchanging_p
init|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
operator|||
operator|(
operator|!
name|in_struct_p
operator|&&
operator|!
name|volatile_p
operator|&&
operator|!
name|unchanging_p
operator|)
condition|)
return|return;
name|alpha_set_memflags_1
argument_list|(
name|insn
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to output insns to set TARGET equal to the constant C if it can be    done in less than N insns.  Do all computations in MODE.  Returns the place    where the output has been placed if it can be done and the insns have been    emitted.  If it would take more than N insns, zero is returned and no    insns and emitted.  */
end_comment

begin_function
name|rtx
name|alpha_emit_set_const
parameter_list|(
name|target
parameter_list|,
name|mode
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|new
init|=
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
comment|/* Use a pseudo if highly optimizing and still generating RTL.  */
name|rtx
name|subtarget
init|=
operator|(
name|flag_expensive_optimizations
operator|&&
name|rtx_equal_function_value_matters
condition|?
literal|0
else|:
name|target
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
comment|/* We are only called for SImode and DImode.  If this is SImode, ensure that      we are sign extended to a full word.  This does not make any sense when      cross-compiling on a narrow machine.  */
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|c
operator|=
operator|(
name|c
operator|&
literal|0xffffffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|c
operator|&
literal|0x80000000
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is a sign-extended 32-bit constant, we can do this in at most      three insns, so do it if we have enough insns left.  We always have      a sign-extended 32-bit constant when compiling on a narrow machine.       Note that we cannot handle the constant 0x80000000.  */
if|if
condition|(
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
operator|||
name|c
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|c
operator|>>
literal|31
operator|==
literal|0
operator|)
operator|&&
name|c
operator|!=
literal|0x80000000U
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
name|c
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|c
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|c
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|extra
init|=
literal|0
decl_stmt|;
comment|/* If HIGH will be interpreted as negative but the constant is 	 positive, we must adjust it to do two ldha insns.  */
if|if
condition|(
operator|(
name|high
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|low
operator|||
operator|(
name|low
operator|==
literal|0
operator|&&
name|extra
operator|==
literal|0
operator|)
condition|)
return|return
name|copy_to_suggested_reg
argument_list|(
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|,
name|target
argument_list|,
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n
operator|>=
literal|2
operator|+
operator|(
name|extra
operator|!=
literal|0
operator|)
comment|/* We can't do this when SImode if HIGH required adjustment. 		  This is because the code relies on an implicit overflow 		  which is invisible to the RTL.  We can thus get incorrect 		  code if the two ldah instructions are combined.  */
operator|&&
operator|!
operator|(
name|mode
operator|==
name|SImode
operator|&&
name|extra
operator|!=
literal|0
operator|)
condition|)
block|{
name|temp
operator|=
name|copy_to_suggested_reg
argument_list|(
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|extra
operator|<<
literal|16
argument_list|)
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|high
operator|<<
literal|16
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
block|}
block|}
comment|/* If we couldn't do it that way, try some other methods.  But if we have      no instructions left, don't bother.  Likewise, if this is SImode and      we can't make pseudos, we can't do anything since the expand_binop      and expand_unop calls will widen and try to make pseudos.  */
if|if
condition|(
name|n
operator|==
literal|1
operator|||
operator|(
name|mode
operator|==
name|SImode
operator|&&
operator|!
name|rtx_equal_function_value_matters
operator|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
comment|/* First, see if can load a value into the target that is the same as the      constant except that all bytes that are 0 are changed to be 0xff.  If we      can, then we can do a ZAPNOT to obtain the desired constant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|+=
literal|8
control|)
if|if
condition|(
operator|(
name|new
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|new
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
expr_stmt|;
comment|/* We are only called for SImode and DImode.  If this is SImode, ensure that      we are sign extended to a full word.  */
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|new
operator|=
operator|(
name|new
operator|&
literal|0xffffffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|new
operator|&
literal|0x80000000
operator|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|c
operator|&&
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|new
argument_list|,
name|n
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|c
operator||
operator|~
name|new
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
endif|#
directive|endif
comment|/* Next, see if we can load a related constant and then shift and possibly      negate it to get the constant we want.  Try this once each increasing      numbers of insns.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* First try complementing.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|~
name|c
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|temp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Next try to form a constant and do a left shift.  We can do this 	 if some low-order bits are zero; the exact_log2 call below tells 	 us that information.  The bits we are shifting out could be any 	 value, but here we'll just try the 0- and sign-extended forms of 	 the constant.  To try to increase the chance of having the same 	 constant in more than one insn, start at the highest number of 	 bits to shift, but try all possibilities in case a ZAPNOT will 	 be useful.  */
if|if
condition|(
operator|(
name|bits
operator|=
name|exact_log2
argument_list|(
name|c
operator|&
operator|-
name|c
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|c
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|c
operator|)
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashl_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Now try high-order zero bits.  Here we try the shifted-in bits as 	 all zero and all ones.  Be careful to avoid shifting outside the 	 mode and to avoid shifting outside the host wide int size.  */
if|if
condition|(
operator|(
name|bits
operator|=
operator|(
name|MIN
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
literal|8
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|c
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|lshr_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Now try high-order 1 bits.  We get that with a sign-extension. 	 But one bit isn't enough here.  Be careful to avoid shifting outside 	 the mode and to avoid shifting outside the host wide int size. */
if|if
condition|(
operator|(
name|bits
operator|=
operator|(
name|MIN
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
literal|8
argument_list|)
operator|-
name|floor_log2
argument_list|(
operator|~
name|c
argument_list|)
operator|-
literal|2
operator|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
name|int
name|alpha_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
comment|/* If the dependence is an anti-dependence, there is no cost.  For an      output dependence, there is sometimes a cost, but it doesn't seem      worth handling those few cases.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If INSN is a store insn and DEP_INSN is setting the data being stored,      we can sometimes lower the cost.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_ST
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_LD
case|:
comment|/* No savings here.  */
return|return
name|cost
return|;
case|case
name|TYPE_IMULL
case|:
case|case
name|TYPE_IMULQ
case|:
comment|/* In these cases, we save one cycle.  */
return|return
name|cost
operator|-
literal|2
return|;
default|default:
comment|/* In all other cases, we save two cycles.  */
return|return
name|MAX
argument_list|(
literal|0
argument_list|,
name|cost
operator|-
literal|4
argument_list|)
return|;
block|}
comment|/* Another case that needs adjustment is an arithmetic or logical      operation.  It's cost is usually one cycle, but we default it to      two in the MD file.  The only case that it is actually two is      for the address in loads and stores.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_IADDLOG
condition|)
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_LD
case|:
case|case
name|TYPE_ST
case|:
return|return
name|cost
return|;
default|default:
return|return
literal|2
return|;
block|}
comment|/* The final case is when a compare feeds into an integer branch.  The cost      is only one cycle in that case.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_ICMP
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_IBR
condition|)
return|return
literal|2
return|;
comment|/* Otherwise, return the default cost. */
return|return
name|cost
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* If this operand is the constant zero, write it as "$31".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%r value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Similar, but for floating-point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$f31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Write the 1's complement of a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Write 1<< C, for a constant C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Write the high-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%h value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Write the low-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%L value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x8000
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Write mask for ZAP insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|value
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|value
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
name|mask
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|,
name|value
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* 'b', 'w', or 'l' as the value of the constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|8
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|16
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|32
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|8
condition|?
literal|"b"
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|16
condition|?
literal|"w"
else|:
literal|"l"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Similar, except do it from the mask.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffffffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%U value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Write the constant value divided by 8.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|8
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Same, except compute (64 - c) / 8 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|8
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|(
literal|64
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Write out comparison name.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%C value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LEU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ule"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LTU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ult"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Similar, but write reversed code.  We can't get an unsigned code 	 here.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%D value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Similar to `c', but swap.  We can't get unsigned here either.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%D value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Similar, but reverse and swap.  We can't get unsigned here either.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%D value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|swap_condition
argument_list|(
name|reverse_condition
argument_list|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Write the divide or modulus operator.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/* Write "_u" for unaligned access.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_u"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do what is necessary for `va_start'.  The argument is ignored;    We look at the current function to determine if stdarg or varargs    is used and fill in an initial va_list.  A pointer to this constructor    is returned.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|alpha_builtin_saveregs
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|block
decl_stmt|,
name|addr
decl_stmt|,
name|argsize
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|int
name|stdarg
init|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
decl_stmt|;
comment|/* Compute the current position into the args, taking into account      both registers and memory.  Both of these are already included in      current_function_args_info.  */
name|argsize
operator|=
name|GEN_INT
argument_list|(
name|current_function_args_info
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* SETUP_INCOMING_VARARGS moves the starting address base up by 48,      storing fp arg registers in the first 48 bytes, and the integer arg      registers in the next 48 bytes.  This is only done, however, if any      integer registers need to be stored.       If no integer registers need be stored, then we must subtract 48 in      order to account for the integer arg registers which are counted in      argsize above, but which are not actually stored on the stack.  */
name|addr
operator|=
operator|(
name|current_function_args_info
operator|<=
literal|5
operator|+
name|stdarg
condition|?
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
literal|6
operator|*
name|UNITS_PER_WORD
argument_list|)
else|:
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
operator|-
operator|(
literal|6
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
operator|)
expr_stmt|;
name|addr
operator|=
name|force_operand
argument_list|(
name|addr
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Allocate the va_list constructor */
name|block
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Store the address of the first integer register in the __base member.  */
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|ptr_mode
argument_list|,
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Store the argsize as the __va_offset member.  */
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|,
name|argsize
argument_list|)
expr_stmt|;
comment|/* Return the address of the va_list constructor, but don't put it in a      register.  Doing so would fail when not optimizing and produce worse      code when optimizing.  */
return|return
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the function    prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/* Compute the size of the save area in the stack.  */
end_comment

begin_function
name|int
name|alpha_sa_size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|size
operator|++
expr_stmt|;
comment|/* If some registers were saved but not reg 26, reg 26 must also      be saved, so leave space for it.  */
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
operator|!
name|regs_ever_live
index|[
literal|26
index|]
condition|)
name|size
operator|++
expr_stmt|;
comment|/* Our size must be even (multiple of 16 bytes).  */
if|if
condition|(
name|size
operator|&
literal|1
condition|)
name|size
operator|++
expr_stmt|;
return|return
name|size
operator|*
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this function can directly return via $26.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|()
block|{
return|return
operator|(
name|reload_completed
operator|&&
name|alpha_sa_size
argument_list|()
operator|==
literal|0
operator|&&
name|get_frame_size
argument_list|()
operator|==
literal|0
operator|&&
name|current_function_outgoing_args_size
operator|==
literal|0
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write a version stamp.  Don't write anything if we are running as a    cross-compiler.  Otherwise, use the versions in /usr/include/stamp.h.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CROSS_COMPILE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stamp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|alpha_write_verstamp
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MS_STAMP
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.verstamp %d %d\n"
argument_list|,
name|MS_STAMP
argument_list|,
name|LS_STAMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write code to add constant C to register number IN_REG (possibly 31)    and put the result into OUT_REG.  Use TEMP_REG as a scratch register;    usually this will be OUT_REG, but should not be if OUT_REG is     STACK_POINTER_REGNUM, since it must be updated in a single instruction.    Write the code to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|add_long_const
parameter_list|(
name|file
parameter_list|,
name|c
parameter_list|,
name|in_reg
parameter_list|,
name|out_reg
parameter_list|,
name|temp_reg
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
name|int
name|in_reg
decl_stmt|,
name|out_reg
decl_stmt|,
name|temp_reg
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
name|c
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|c
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|c
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|extra
init|=
literal|0
decl_stmt|;
comment|/* We don't have code to write out constants larger than 32 bits.  */
if|#
directive|if
name|HOST_BITS_PER_LONG_INT
operator|==
literal|64
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|c
operator|>>
literal|32
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If HIGH will be interpreted as negative, we must adjust it to do two      ldha insns.  Note that we will never be building a negative constant      here.  */
if|if
condition|(
name|high
operator|&
literal|0x8000
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|low
operator|!=
literal|0
condition|)
block|{
name|int
name|result_reg
init|=
operator|(
name|extra
operator|==
literal|0
operator|&&
name|high
operator|==
literal|0
operator|)
condition|?
name|out_reg
else|:
name|temp_reg
decl_stmt|;
if|if
condition|(
name|low
operator|>=
literal|0
operator|&&
name|low
operator|<
literal|255
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddq $%d,%d,$%d\n"
argument_list|,
name|in_reg
argument_list|,
name|low
argument_list|,
name|result_reg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $%d,%d($%d)\n"
argument_list|,
name|result_reg
argument_list|,
name|low
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|in_reg
operator|=
name|result_reg
expr_stmt|;
block|}
if|if
condition|(
name|extra
condition|)
block|{
name|int
name|result_reg
init|=
operator|(
name|high
operator|==
literal|0
operator|)
condition|?
name|out_reg
else|:
name|temp_reg
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldah $%d,%d($%d)\n"
argument_list|,
name|result_reg
argument_list|,
name|extra
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|in_reg
operator|=
name|result_reg
expr_stmt|;
block|}
if|if
condition|(
name|high
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldah $%d,%d($%d)\n"
argument_list|,
name|out_reg
argument_list|,
name|high
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_function
name|void
name|output_prolog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|out_args_size
init|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|sa_size
init|=
name|alpha_sa_size
argument_list|()
decl_stmt|;
name|HOST_WIDE_INT
name|frame_size
init|=
operator|(
name|out_args_size
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|reg_offset
init|=
name|out_args_size
decl_stmt|;
name|HOST_WIDE_INT
name|start_reg_offset
init|=
name|reg_offset
decl_stmt|;
name|HOST_WIDE_INT
name|actual_start_reg_offset
init|=
name|start_reg_offset
decl_stmt|;
name|int
name|int_reg_save_area_size
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|reg_mask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Ecoff can handle multiple .file directives, so put out file and lineno.      We have to do that before the .ent directive as we cannot switch      files within procedures with native ecoff because line numbers are      linked to procedure descriptors.      Outputting the lineno helps debugging of one line functions as they      would otherwise get no line number at all. Please note that we would      like to put out last_linenum from final.c, but it is not accessible.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
block|{
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
condition|)
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The assembly language programmer's guide states that the second argument      to the .ent directive, the lex_level, is ignored by the assembler,      so we might as well omit it.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ent "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|alpha_function_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|alpha_function_name
argument_list|)
expr_stmt|;
name|inside_function
operator|=
name|TRUE
expr_stmt|;
comment|/* Set up offsets to alpha virtual arg/local debugging pointer.  */
name|alpha_auto_offset
operator|=
operator|-
name|frame_size
operator|+
name|current_function_pretend_args_size
expr_stmt|;
name|alpha_arg_offset
operator|=
operator|-
name|frame_size
operator|+
literal|48
expr_stmt|;
comment|/* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first.       Even if we are a static function, we still need to do this in case      our address is taken and passed to something like qsort.       We never need a GP for Windows/NT.  */
name|alpha_function_needs_gp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
operator|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_LDSYM
operator|||
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_ISUBR
operator|)
operator|)
condition|)
block|{
name|alpha_function_needs_gp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|WINDOWS_NT
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|alpha_function_needs_gp
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldgp $29,0($27)\n"
argument_list|)
expr_stmt|;
comment|/* Put a label after the GP load so we can enter the function at it.  */
name|assemble_name
argument_list|(
name|file
argument_list|,
name|alpha_function_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"..ng:\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the stack by the frame size.  If the frame size is> 4096      bytes, we need to be sure we probe somewhere in the first and last      4096 bytes (we can probably get away without the latter test) and      every 8192 bytes in between.  If the frame size is> 32768, we      do this in a loop.  Otherwise, we generate the explicit probe      instructions.        Note that we are only allowed to adjust sp once in the prologue.  */
if|if
condition|(
name|frame_size
operator|<
literal|32768
condition|)
block|{
if|if
condition|(
name|frame_size
operator|>
literal|4096
condition|)
block|{
name|int
name|probed
init|=
literal|4096
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $31,-%d($30)\n"
argument_list|,
name|probed
argument_list|)
expr_stmt|;
while|while
condition|(
name|probed
operator|+
literal|8192
operator|<
name|frame_size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $31,-%d($30)\n"
argument_list|,
name|probed
operator|+=
literal|8192
argument_list|)
expr_stmt|;
comment|/* We only have to do this probe if we aren't saving registers.  */
if|if
condition|(
name|sa_size
operator|==
literal|0
operator|&&
name|probed
operator|+
literal|4096
operator|<
name|frame_size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $31,-%d($30)\n"
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_size
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $30,-%d($30)\n"
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we generate code to set R4 to SP + 4096 and set R5 to the 	 number of 8192 byte blocks to probe.  We then probe each block 	 in the loop and then set SP to the proper location.  If the 	 amount remaining is> 4096, we have to do one more probe if we 	 are not saving any registers.  */
name|HOST_WIDE_INT
name|blocks
init|=
operator|(
name|frame_size
operator|+
literal|4096
operator|)
operator|/
literal|8192
decl_stmt|;
name|HOST_WIDE_INT
name|leftover
init|=
name|frame_size
operator|+
literal|4096
operator|-
name|blocks
operator|*
literal|8192
decl_stmt|;
name|add_long_const
argument_list|(
name|file
argument_list|,
name|blocks
argument_list|,
literal|31
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $4,4096($30)\n"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|alpha_function_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"..sc:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $31,-8192($4)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsubq $5,1,$5\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $4,-8192($4)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbne $5,"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|alpha_function_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"..sc\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftover
operator|>
literal|4096
operator|&&
name|sa_size
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $31,-%d($4)\n"
argument_list|,
name|leftover
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $30,-%d($4)\n"
argument_list|,
name|leftover
argument_list|)
expr_stmt|;
block|}
comment|/* Describe our frame.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $%d,%d,$26,%d\n"
argument_list|,
operator|(
name|frame_pointer_needed
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
argument_list|,
name|frame_size
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
comment|/* Save register 26 if any other register needs to be saved.  */
if|if
condition|(
name|sa_size
operator|!=
literal|0
condition|)
block|{
name|reg_mask
operator||=
literal|1
operator|<<
literal|26
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $26,%d($30)\n"
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
name|int_reg_save_area_size
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Now save any other used integer registers required to be saved.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
operator|&&
name|i
operator|!=
literal|26
condition|)
block|{
name|reg_mask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $%d,%d($30)\n"
argument_list|,
name|i
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
name|int_reg_save_area_size
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Print the register mask and do floating-point saves.  */
if|if
condition|(
name|reg_mask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask 0x%x,%d\n"
argument_list|,
name|reg_mask
argument_list|,
name|actual_start_reg_offset
operator|-
name|frame_size
argument_list|)
expr_stmt|;
name|start_reg_offset
operator|=
name|reg_offset
expr_stmt|;
name|reg_mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
operator|+
literal|32
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|32
index|]
operator|&&
name|regs_ever_live
index|[
name|i
operator|+
literal|32
index|]
condition|)
block|{
name|reg_mask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstt $f%d,%d($30)\n"
argument_list|,
name|i
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Print the floating-point mask, if we've saved any fp register.  */
if|if
condition|(
name|reg_mask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask 0x%x,%d\n"
argument_list|,
name|reg_mask
argument_list|,
name|actual_start_reg_offset
operator|-
name|frame_size
operator|+
name|int_reg_save_area_size
argument_list|)
expr_stmt|;
comment|/* If we need a frame pointer, set it from the stack pointer.  Note that      this must always be the last instruction in the prologue.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbis $30,$30,$15\n"
argument_list|)
expr_stmt|;
comment|/* End the prologue and say if we used gp.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.prologue %d\n"
argument_list|,
name|alpha_function_needs_gp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_function
name|void
name|output_epilog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|HOST_WIDE_INT
name|out_args_size
init|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|sa_size
init|=
name|alpha_sa_size
argument_list|()
decl_stmt|;
name|HOST_WIDE_INT
name|frame_size
init|=
operator|(
name|out_args_size
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|reg_offset
init|=
name|out_args_size
decl_stmt|;
name|HOST_WIDE_INT
name|frame_size_from_reg_save
init|=
name|frame_size
operator|-
name|reg_offset
decl_stmt|;
name|int
name|restore_fp
init|=
name|frame_pointer_needed
operator|&&
name|regs_ever_live
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write anything except      the .end pseudo-op.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|int
name|fp_offset
init|=
literal|0
decl_stmt|;
comment|/* If we have a frame pointer, restore SP from it.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbis $15,$15,$30\n"
argument_list|)
expr_stmt|;
comment|/* Restore all the registers, starting with the return address 	 register.  */
if|if
condition|(
name|sa_size
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldq $26,%d($30)\n"
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Now restore any other used integer registers that that we saved, 	 except for FP if it is being used as FP, since it must be 	 restored last.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
operator|&&
name|i
operator|!=
literal|26
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|frame_pointer_needed
condition|)
name|fp_offset
operator|=
name|reg_offset
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldq $%d,%d($30)\n"
argument_list|,
name|i
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
operator|+
literal|32
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|32
index|]
operator|&&
name|regs_ever_live
index|[
name|i
operator|+
literal|32
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldt $f%d,%d($30)\n"
argument_list|,
name|i
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* If the stack size is large and we have a frame pointer, compute the 	 size of the stack into a register because the old FP restore, stack 	 pointer adjust, and return are required to be consecutive 	 instructions.   */
if|if
condition|(
name|frame_size
operator|>
literal|32767
operator|&&
name|restore_fp
condition|)
name|add_long_const
argument_list|(
name|file
argument_list|,
name|frame_size
argument_list|,
literal|31
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we needed a frame pointer and we have to restore it, do it 	 now.  This must be done in one instruction immediately 	 before the SP update.  */
if|if
condition|(
name|restore_fp
operator|&&
name|fp_offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldq $15,%d($30)\n"
argument_list|,
name|fp_offset
argument_list|)
expr_stmt|;
comment|/* Now update the stack pointer, if needed.  Only one instruction must 	 modify the stack pointer.  It must be the last instruction in the 	 sequence and must be an ADDQ or LDA instruction.  If the frame 	 pointer was loaded above, we may only put one instruction here.  */
if|if
condition|(
name|frame_size
operator|>
literal|32768
operator|&&
name|restore_fp
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddq $1,$30,$30\n"
argument_list|)
expr_stmt|;
else|else
name|add_long_const
argument_list|(
name|file
argument_list|,
name|frame_size
argument_list|,
literal|30
argument_list|,
literal|30
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Finally return to the caller.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tret $31,($26),1\n"
argument_list|)
expr_stmt|;
block|}
comment|/* End the function.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.end "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|alpha_function_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|inside_function
operator|=
name|FALSE
expr_stmt|;
comment|/* Show that we know this function if it is called again.  */
name|SYMBOL_REF_FLAG
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debugging support.  */
end_comment

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* Count the number of sdb related labels are generated (to find block    start and end boundaries).  */
end_comment

begin_decl_stmt
name|int
name|sdb_label_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next label # for each statement.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sym_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of .file directives, so that .loc is up to date.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_source_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file containing the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_function_file
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offsets to alpha virtual arg/local debugging pointers.  */
end_comment

begin_decl_stmt
name|long
name|alpha_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|alpha_auto_offset
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Emit a new filename to a stream.  */
end_comment

begin_function
name|void
name|alpha_output_filename
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|int
name|first_time
init|=
name|TRUE
decl_stmt|;
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|first_time
operator|=
name|FALSE
expr_stmt|;
operator|++
name|num_source_filenames
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_GAS
operator|&&
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#@stabs\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_GAS
operator|&&
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|",%d,0,0,%s\n"
argument_list|,
name|N_SOL
argument_list|,
operator|&
name|ltext_label_name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|current_function_file
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|current_function_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inside_function
operator|&&
operator|!
name|TARGET_GAS
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|num_source_filenames
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
block|}
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a linenumber to a stream.  */
end_comment

begin_function
name|void
name|alpha_output_lineno
parameter_list|(
name|stream
parameter_list|,
name|line
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_GAS
operator|&&
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
comment|/* mips-tfile doesn't understand .stabd directives.  */
operator|++
name|sym_lineno
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$LM%d:\n\t%s %d,0,%d,$LM%d\n"
argument_list|,
name|sym_lineno
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_SLINE
argument_list|,
name|line
argument_list|,
name|sym_lineno
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n\t.loc\t%d %d\n"
argument_list|,
name|num_source_filenames
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

