begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on the DEC Alpha.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|<splay-tree.h>
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_comment
comment|/* Specify which cpu to schedule for.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|alpha_cpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|alpha_cpu_name
index|[]
init|=
block|{
literal|"ev4"
block|,
literal|"ev5"
block|,
literal|"ev6"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify how accurate floating-point traps need to be.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_trap_precision
name|alpha_tp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify the floating-point rounding mode.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_fp_rounding_mode
name|alpha_fprm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify which things cause traps.  */
end_comment

begin_decl_stmt
name|enum
name|alpha_fp_trap_mode
name|alpha_fptm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify bit size of immediate TLS offsets.  */
end_comment

begin_decl_stmt
name|int
name|alpha_tls_size
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings decoded into the above options.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_cpu_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mcpu= */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_tune_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mtune= */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_tp_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mtrap-precision=[p|s|i] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_fprm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mfp-rounding-mode=[n|m|c|d] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_fptm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mfp-trap-mode=[n|u|su|sui] */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_mlat_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mmemory-latency= */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|alpha_tls_size_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mtls-size=[16|32|64] */
end_comment

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|struct
name|alpha_compare
name|alpha_compare
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if inside of a function, because the Alpha asm can't    handle .files inside of functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inside_function
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of cycles of latency we should assume on memory reads.  */
end_comment

begin_decl_stmt
name|int
name|alpha_memory_latency
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the function needs the GP.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alpha_function_needs_gp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The alias set for prologue/epilogue register save/restore.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|alpha_sr_alias_set
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The assembler name of the current function.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|alpha_fnname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next explicit relocation sequence number.  */
end_comment

begin_extern
extern|extern GTY((
end_extern

begin_decl_stmt
unit|))
name|int
name|alpha_next_sequence_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alpha_next_sequence_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The literal and gpdisp sequence numbers for this insn, as printed    by %# and %* respectively.  */
end_comment

begin_extern
extern|extern GTY((
end_extern

begin_decl_stmt
unit|))
name|int
name|alpha_this_literal_sequence_number
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern GTY((
end_extern

begin_decl_stmt
unit|))
name|int
name|alpha_this_gpdisp_sequence_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alpha_this_literal_sequence_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alpha_this_gpdisp_sequence_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Costs of various operations on the different architectures.  */
end_comment

begin_struct
struct|struct
name|alpha_rtx_cost_data
block|{
name|unsigned
name|char
name|fp_add
decl_stmt|;
name|unsigned
name|char
name|fp_mult
decl_stmt|;
name|unsigned
name|char
name|fp_div_sf
decl_stmt|;
name|unsigned
name|char
name|fp_div_df
decl_stmt|;
name|unsigned
name|char
name|int_mult_si
decl_stmt|;
name|unsigned
name|char
name|int_mult_di
decl_stmt|;
name|unsigned
name|char
name|int_shift
decl_stmt|;
name|unsigned
name|char
name|int_cmov
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|alpha_rtx_cost_data
specifier|const
name|alpha_rtx_cost_data
index|[
name|PROCESSOR_MAX
index|]
init|=
block|{
block|{
comment|/* EV4 */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_mult */
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|63
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int_shift */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int_cmov */
block|}
block|,
block|{
comment|/* EV5 */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult */
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|22
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
block|,
comment|/* int_shift */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int_cmov */
block|}
block|,
block|{
comment|/* EV6 */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int_shift */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int_cmov */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the number of args of a function in one of two ways.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
operator|||
name|TARGET_ABI_UNICOSMK
end_if

begin_define
define|#
directive|define
name|NUM_ARGS
value|current_function_args_info.num_args
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUM_ARGS
value|current_function_args_info
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REG_PV
value|27
end_define

begin_define
define|#
directive|define
name|REG_RA
value|26
end_define

begin_comment
comment|/* Declarations of static functions.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|alpha_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|alpha_emit_xfloating_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
end_if

begin_function_decl
specifier|static
name|void
name|alpha_write_linkage
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|unicosmk_output_deferred_case_vectors
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unicosmk_gen_dsib
parameter_list|(
name|unsigned
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unicosmk_output_ssib
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unicosmk_need_dex
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Parse target option strings.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
name|cpu_table
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
name|int
name|flags
decl_stmt|;
block|}
name|cpu_table
index|[]
init|=
block|{
define|#
directive|define
name|EV5_MASK
value|(MASK_CPU_EV5)
define|#
directive|define
name|EV6_MASK
value|(MASK_CPU_EV6|MASK_BWX|MASK_MAX|MASK_FIX)
block|{
literal|"ev4"
block|,
name|PROCESSOR_EV4
block|,
literal|0
block|}
block|,
block|{
literal|"ev45"
block|,
name|PROCESSOR_EV4
block|,
literal|0
block|}
block|,
block|{
literal|"21064"
block|,
name|PROCESSOR_EV4
block|,
literal|0
block|}
block|,
block|{
literal|"ev5"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
block|}
block|,
block|{
literal|"21164"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
block|}
block|,
block|{
literal|"ev56"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
block|}
block|,
block|{
literal|"21164a"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
block|}
block|,
block|{
literal|"pca56"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
operator||
name|MASK_MAX
block|}
block|,
block|{
literal|"21164PC"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
operator||
name|MASK_MAX
block|}
block|,
block|{
literal|"21164pc"
block|,
name|PROCESSOR_EV5
block|,
name|EV5_MASK
operator||
name|MASK_BWX
operator||
name|MASK_MAX
block|}
block|,
block|{
literal|"ev6"
block|,
name|PROCESSOR_EV6
block|,
name|EV6_MASK
block|}
block|,
block|{
literal|"21264"
block|,
name|PROCESSOR_EV6
block|,
name|EV6_MASK
block|}
block|,
block|{
literal|"ev67"
block|,
name|PROCESSOR_EV6
block|,
name|EV6_MASK
operator||
name|MASK_CIX
block|}
block|,
block|{
literal|"21264a"
block|,
name|PROCESSOR_EV6
block|,
name|EV6_MASK
operator||
name|MASK_CIX
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
comment|/* Unicos/Mk doesn't have shared libraries.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|flag_pic
condition|)
block|{
name|warning
argument_list|(
literal|"-f%s ignored for Unicos/Mk (not supported)"
argument_list|,
operator|(
name|flag_pic
operator|>
literal|1
operator|)
condition|?
literal|"PIC"
else|:
literal|"pic"
argument_list|)
expr_stmt|;
name|flag_pic
operator|=
literal|0
expr_stmt|;
block|}
comment|/* On Unicos/Mk, the native compiler consistently generates /d suffices for       floating-point instructions.  Make that the default for this target.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_DYN
expr_stmt|;
else|else
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
name|alpha_tp
operator|=
name|ALPHA_TP_PROG
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_N
expr_stmt|;
comment|/* We cannot use su and sui qualifiers for conversion instructions on       Unicos/Mk.  I'm not sure if this is due to assembler or hardware      limitations.  Right now, we issue a warning if -mieee is specified      and then ignore it; eventually, we should either get it right or      disable the option altogether.  */
if|if
condition|(
name|TARGET_IEEE
condition|)
block|{
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|warning
argument_list|(
literal|"-mieee not supported on Unicos/Mk"
argument_list|)
expr_stmt|;
else|else
block|{
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_IEEE_WITH_INEXACT
condition|)
block|{
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|warning
argument_list|(
literal|"-mieee-with-inexact not supported on Unicos/Mk"
argument_list|)
expr_stmt|;
else|else
block|{
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SUI
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alpha_tp_string
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"p"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_PROG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"f"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_FUNC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tp_string
argument_list|,
literal|"i"
argument_list|)
condition|)
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mtrap-precision switch"
argument_list|,
name|alpha_tp_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fprm_string
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"n"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"m"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_MINF
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"c"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_CHOP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_fprm_string
argument_list|,
literal|"d"
argument_list|)
condition|)
name|alpha_fprm
operator|=
name|ALPHA_FPRM_DYN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mfp-rounding-mode switch"
argument_list|,
name|alpha_fprm_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fptm_string
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_N
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"u"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_U
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"su"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_fptm_string
argument_list|,
literal|"sui"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SUI
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mfp-trap-mode switch"
argument_list|,
name|alpha_fptm_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_tls_size_string
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_tls_size_string
argument_list|,
literal|"16"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_tls_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_tls_size_string
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_tls_size
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|alpha_tls_size_string
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
name|alpha_tls_size
operator|=
literal|64
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mtls-size switch"
argument_list|,
name|alpha_tls_size_string
argument_list|)
expr_stmt|;
block|}
name|alpha_cpu
operator|=
name|TARGET_CPU_DEFAULT
operator|&
name|MASK_CPU_EV6
condition|?
name|PROCESSOR_EV6
else|:
operator|(
name|TARGET_CPU_DEFAULT
operator|&
name|MASK_CPU_EV5
condition|?
name|PROCESSOR_EV5
else|:
name|PROCESSOR_EV4
operator|)
expr_stmt|;
if|if
condition|(
name|alpha_cpu_string
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_cpu_string
argument_list|,
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|cpu_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_BWX
operator||
name|MASK_MAX
operator||
name|MASK_FIX
operator||
name|MASK_CIX
operator||
name|MASK_CPU_EV5
operator||
name|MASK_CPU_EV6
operator|)
expr_stmt|;
name|target_flags
operator||=
name|cpu_table
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
condition|)
name|error
argument_list|(
literal|"bad value `%s' for -mcpu switch"
argument_list|,
name|alpha_cpu_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_tune_string
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_tune_string
argument_list|,
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|alpha_cpu
operator|=
name|cpu_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|cpu_table
index|[
name|i
index|]
operator|.
name|name
condition|)
name|error
argument_list|(
literal|"bad value `%s' for -mcpu switch"
argument_list|,
name|alpha_tune_string
argument_list|)
expr_stmt|;
block|}
comment|/* Do some sanity checks on the above options.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|alpha_fptm
operator|!=
name|ALPHA_FPTM_N
condition|)
block|{
name|warning
argument_list|(
literal|"trap mode not supported on Unicos/Mk"
argument_list|)
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_N
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SU
operator|||
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SUI
operator|)
operator|&&
name|alpha_tp
operator|!=
name|ALPHA_TP_INSN
operator|&&
operator|!
name|TARGET_CPU_EV6
condition|)
block|{
name|warning
argument_list|(
literal|"fp software completion requires -mtrap-precision=i"
argument_list|)
expr_stmt|;
name|alpha_tp
operator|=
name|ALPHA_TP_INSN
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_CPU_EV6
condition|)
block|{
comment|/* Except for EV6 pass 1 (not released), we always have precise 	 arithmetic traps.  Which means we can do software completion 	 without minding trap shadows.  */
name|alpha_tp
operator|=
name|ALPHA_TP_PROG
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_FLOAT_VAX
condition|)
block|{
if|if
condition|(
name|alpha_fprm
operator|==
name|ALPHA_FPRM_MINF
operator|||
name|alpha_fprm
operator|==
name|ALPHA_FPRM_DYN
condition|)
block|{
name|warning
argument_list|(
literal|"rounding mode not supported for VAX floats"
argument_list|)
expr_stmt|;
name|alpha_fprm
operator|=
name|ALPHA_FPRM_NORM
expr_stmt|;
block|}
if|if
condition|(
name|alpha_fptm
operator|==
name|ALPHA_FPTM_SUI
condition|)
block|{
name|warning
argument_list|(
literal|"trap mode not supported for VAX floats"
argument_list|)
expr_stmt|;
name|alpha_fptm
operator|=
name|ALPHA_FPTM_SU
expr_stmt|;
block|}
if|if
condition|(
name|target_flags_explicit
operator|&
name|MASK_LONG_DOUBLE_128
condition|)
name|warning
argument_list|(
literal|"128-bit long double not supported for VAX floats"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_LONG_DOUBLE_128
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|lat
decl_stmt|;
if|if
condition|(
operator|!
name|alpha_mlat_string
condition|)
name|alpha_mlat_string
operator|=
literal|"L1"
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|alpha_mlat_string
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|lat
operator|=
name|strtol
argument_list|(
name|alpha_mlat_string
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
operator|,
operator|*
name|end
operator|==
literal|'\0'
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|alpha_mlat_string
index|[
literal|0
index|]
operator|==
literal|'L'
operator|||
name|alpha_mlat_string
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|alpha_mlat_string
index|[
literal|1
index|]
argument_list|)
operator|&&
name|alpha_mlat_string
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|static
name|int
specifier|const
name|cache_latency
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|3
block|,
literal|30
block|,
operator|-
literal|1
block|}
block|,
comment|/* ev4 -- Bcache is a guess */
block|{
literal|2
block|,
literal|12
block|,
literal|38
block|}
block|,
comment|/* ev5 -- Bcache from PC164 LMbench numbers */
block|{
literal|3
block|,
literal|12
block|,
literal|30
block|}
block|,
comment|/* ev6 -- Bcache from DS20 LMbench.  */
block|}
decl_stmt|;
name|lat
operator|=
name|alpha_mlat_string
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|lat
operator|<=
literal|0
operator|||
name|lat
operator|>
literal|3
operator|||
name|cache_latency
index|[
name|alpha_cpu
index|]
index|[
name|lat
operator|-
literal|1
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"L%d cache latency unknown for %s"
argument_list|,
name|lat
argument_list|,
name|alpha_cpu_name
index|[
name|alpha_cpu
index|]
argument_list|)
expr_stmt|;
name|lat
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|lat
operator|=
name|cache_latency
index|[
name|alpha_cpu
index|]
index|[
name|lat
operator|-
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|alpha_mlat_string
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
comment|/* Most current memories have about 370ns latency.  This is 	   a reasonable guess for a fast cpu.  */
name|lat
operator|=
literal|150
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"bad value `%s' for -mmemory-latency"
argument_list|,
name|alpha_mlat_string
argument_list|)
expr_stmt|;
name|lat
operator|=
literal|3
expr_stmt|;
block|}
name|alpha_memory_latency
operator|=
name|lat
expr_stmt|;
block|}
comment|/* Default the definition of "small data" to 8 bytes.  */
if|if
condition|(
operator|!
name|g_switch_set
condition|)
name|g_switch_value
operator|=
literal|8
expr_stmt|;
comment|/* Infer TARGET_SMALL_DATA from -fpic/-fPIC.  */
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
name|target_flags
operator||=
name|MASK_SMALL_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_SMALL_DATA
expr_stmt|;
comment|/* Align labels and loops for optimal branching.  */
comment|/* ??? Kludge these by not doing anything if we don't optimize and also if      we are writing ECOFF symbols to work around a bug in DEC's assembler.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|write_symbols
operator|!=
name|SDB_DEBUG
condition|)
block|{
if|if
condition|(
name|align_loops
operator|<=
literal|0
condition|)
name|align_loops
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|<=
literal|0
condition|)
name|align_jumps
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|align_functions
operator|<=
literal|0
condition|)
name|align_functions
operator|=
literal|16
expr_stmt|;
comment|/* Acquire a unique set number for our register saves and restores.  */
name|alpha_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
comment|/* Register variables and functions with the garbage collector.  */
comment|/* Set up function hooks.  */
name|init_machine_status
operator|=
name|alpha_init_machine_status
expr_stmt|;
comment|/* Tell the compiler when we're using VAX floating point.  */
if|if
condition|(
name|TARGET_FLOAT_VAX
condition|)
block|{
name|REAL_MODE_FORMAT
argument_list|(
name|SFmode
argument_list|)
operator|=
operator|&
name|vax_f_format
expr_stmt|;
name|REAL_MODE_FORMAT
argument_list|(
name|DFmode
argument_list|)
operator|=
operator|&
name|vax_g_format
expr_stmt|;
name|REAL_MODE_FORMAT
argument_list|(
name|TFmode
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */
end_comment

begin_function
name|int
name|zap_mask
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0xff
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either the constant zero or a register.  If a    register, it must be in the proper mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant in the range of 0-63 (for a shift) or    any register.  */
end_comment

begin_function
name|int
name|reg_or_6bit_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant or any register.  */
end_comment

begin_function
name|int
name|reg_or_8bit_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant or any register.  */
end_comment

begin_function
name|int
name|reg_or_const_int_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant.  */
end_comment

begin_function
name|int
name|cint8_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to an add insn.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/* Constraints I, J, O and P are covered by K.  */
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to a sign-extending    add insn.  */
end_comment

begin_function
name|int
name|sext_add_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'O'
argument_list|)
operator|)
return|;
return|return
name|reg_not_elim_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant 4 or 8.  */
end_comment

begin_function
name|int
name|const48_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an AND insn.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
operator|(
name|zap_mask
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
name|zap_mask
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an IOR or XOR insn.  */
end_comment

begin_function
name|int
name|or_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width, in bits, of an integral    mode smaller than DImode.  */
end_comment

begin_function
name|int
name|mode_width_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|32
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|64
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width of an integral machine mode    smaller than an integer.  */
end_comment

begin_function
name|int
name|mode_mask_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0xff
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|value
operator|==
literal|0xffff
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|value
operator|==
literal|0xffffffff
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
literal|0xffffffff
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a multiple of 8 less than 64.  */
end_comment

begin_function
name|int
name|mul8_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|7
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the zero constant for MODE.  */
end_comment

begin_function
name|int
name|const0_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a hard floating-point register.  */
end_comment

begin_function
name|int
name|hard_fp_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|FLOAT_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a hard general register.  */
end_comment

begin_function
name|int
name|hard_int_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|GENERAL_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register or a constant integer.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is something that can be reloaded into a register;    if it is a MEM, it need not be valid.  */
end_comment

begin_function
name|int
name|some_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|MEM
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|HIGH
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
return|return
name|some_operand
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but don't accept constants.  */
end_comment

begin_function
name|int
name|some_ni_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the source of a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
comment|/* We don't split symbolic operands into something unintelligable 	     until after reload, but we do not wish non-small, non-global 	     symbolic operands to be reconstructed from their high/lo_sum 	     form.  */
return|return
operator|(
name|small_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|global_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|gotdtp_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|gottp_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
comment|/* This handles both the Windows/NT and OSF cases.  */
return|return
name|mode
operator|==
name|ptr_mode
operator|||
name|mode
operator|==
name|DImode
return|;
case|case
name|HIGH
case|:
return|return
operator|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|local_symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
return|;
case|case
name|REG
case|:
case|case
name|ADDRESSOF
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ... fall through ...  */
case|case
name|MEM
case|:
return|return
operator|(
operator|(
name|TARGET_BWX
operator|||
operator|(
name|mode
operator|!=
name|HImode
operator|&&
name|mode
operator|!=
name|QImode
operator|)
operator|)
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|add_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONSTANT_P_RTX
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a SYMBOL_REF for a function known to be in this    file, and in the same section as the current function.  */
end_comment

begin_function
name|int
name|samegp_function_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|false
return|;
comment|/* Easy test for recursion.  */
if|if
condition|(
name|op
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Functions that are not local can be overridden, and thus may      not share the same gp.  */
if|if
condition|(
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If -msmall-data is in effect, assume that there is only one GP      for the module, and so any local symbol has this property.  We      need explicit relocations to be able to enforce this for symbols      not defined in this unit of translation, however.  */
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|TARGET_SMALL_DATA
condition|)
return|return
name|true
return|;
comment|/* Functions that are not external are defined in this UoT,      and thus must share the same gp.  */
return|return
operator|!
name|SYMBOL_REF_EXTERNAL_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a SYMBOL_REF for which we can make a call via bsr.  */
end_comment

begin_function
name|int
name|direct_call_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|tree
name|op_decl
decl_stmt|,
name|cfun_sec
decl_stmt|,
name|op_sec
decl_stmt|;
comment|/* Must share the same GP.  */
if|if
condition|(
operator|!
name|samegp_function_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If profiling is implemented via linker tricks, we can't jump      to the nogp alternate entry point.  Note that current_function_profile      would not be correct, since that doesn't indicate if the target      function uses profiling.  */
comment|/* ??? TARGET_PROFILING_NEEDS_GP isn't really the right test,      but is approximately correct for the OSF ABIs.  Don't know      what to do for VMS, NT, or UMK.  */
if|if
condition|(
operator|!
name|TARGET_PROFILING_NEEDS_GP
operator|&&
name|profile_flag
condition|)
return|return
name|false
return|;
comment|/* Must be a function.  In some cases folks create thunks in static      data structures and then make calls to them.  If we allow the      direct call, we'll get an error from the linker about !samegp reloc      against a symbol without a .prologue directive.  */
if|if
condition|(
operator|!
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Must be "near" so that the branch is assumed to reach.  With      -msmall-text, this is assumed true of all local symbols.  Since      we've already checked samegp, locality is already assured.  */
if|if
condition|(
name|TARGET_SMALL_TEXT
condition|)
return|return
name|true
return|;
comment|/* Otherwise, a decl is "near" if it is defined in the same section.  */
if|if
condition|(
name|flag_function_sections
condition|)
return|return
name|false
return|;
name|op_decl
operator|=
name|SYMBOL_REF_DECL
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|current_function_decl
argument_list|)
operator|||
operator|(
name|op_decl
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|op_decl
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|cfun_sec
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|op_sec
operator|=
name|op_decl
condition|?
name|DECL_SECTION_NAME
argument_list|(
name|op_decl
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
operator|(
operator|(
operator|!
name|cfun_sec
operator|&&
operator|!
name|op_sec
operator|)
operator|||
operator|(
name|cfun_sec
operator|&&
name|op_sec
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|cfun_sec
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|op_sec
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing    a (non-tls) variable known to be defined in this file.  */
end_comment

begin_function
name|int
name|local_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a SYMBOL_REF or CONST referencing a variable    known to be defined in this file in the small data area.  */
end_comment

begin_function
name|int
name|small_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_SMALL_DATA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
comment|/* ??? There's no encode_section_info equivalent for the rtl      constant pool, so SYMBOL_FLAG_SMALL never gets set.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<=
name|g_switch_value
return|;
return|return
operator|(
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
operator|&&
name|SYMBOL_REF_SMALL_P
argument_list|(
name|op
argument_list|)
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a SYMBOL_REF or CONST referencing a variable    not known (or known not) to be defined in this file.  */
end_comment

begin_function
name|int
name|global_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|Pmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|TARGET_ABI_OSF
condition|)
block|{
comment|/* Disallow virtual registers to cope with pathological test cases 	     such as compile/930117-1.c in which the virtual reg decomposes 	     to the frame pointer.  Which is a hard reg that is not $27.  */
return|return
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
literal|27
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,    possibly with an offset.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is valid for a particular TLS relocation.  */
end_comment

begin_function
specifier|static
name|int
name|tls_symbolic_operand_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|unspec
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|!=
name|unspec
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|alpha_tls_size
operator|>
name|size
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|!=
literal|64
condition|)
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
return|return
name|unspec
operator|==
name|UNSPEC_DTPREL
return|;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
return|return
name|unspec
operator|==
name|UNSPEC_TPREL
operator|&&
name|size
operator|==
literal|64
return|;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
return|return
name|unspec
operator|==
name|UNSPEC_TPREL
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if OP is valid for 16-bit DTP relative relocations.  */
end_comment

begin_function
name|int
name|dtp16_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|16
argument_list|,
name|UNSPEC_DTPREL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is valid for 32-bit DTP relative relocations.  */
end_comment

begin_function
name|int
name|dtp32_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|32
argument_list|,
name|UNSPEC_DTPREL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is valid for 64-bit DTP relative relocations.  */
end_comment

begin_function
name|int
name|gotdtp_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|64
argument_list|,
name|UNSPEC_DTPREL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is valid for 16-bit TP relative relocations.  */
end_comment

begin_function
name|int
name|tp16_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|16
argument_list|,
name|UNSPEC_TPREL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is valid for 32-bit TP relative relocations.  */
end_comment

begin_function
name|int
name|tp32_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|32
argument_list|,
name|UNSPEC_TPREL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is valid for 64-bit TP relative relocations.  */
end_comment

begin_function
name|int
name|gottp_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|64
argument_list|,
name|UNSPEC_TPREL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha comparison operator.  Here we know which    comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha comparison operator against zero.     Here we know which comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_zero_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha swapped comparison operator.  */
end_comment

begin_function
name|int
name|alpha_swapped_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|)
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a signed comparison operation.  */
end_comment

begin_function
name|int
name|signed_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha floating point comparison operator.    Here we know which comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_fp_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|UNORDERED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a divide or modulus operator.  */
end_comment

begin_function
name|int
name|divmod_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|DIV
operator|||
name|code
operator|==
name|MOD
operator|||
name|code
operator|==
name|UDIV
operator|||
name|code
operator|==
name|UMOD
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a float->int conversion operator.  */
end_comment

begin_function
name|int
name|fix_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|FIX
operator|||
name|code
operator|==
name|UNSIGNED_FIX
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this memory address is a known aligned register plus    a constant.  It must be a valid address.  This means that we can do    this as an aligned reference plus some offset.     Take into account what reload will do.  */
end_comment

begin_function
name|int
name|aligned_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|op
argument_list|)
operator|>=
literal|32
condition|)
return|return
literal|1
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)      sorts of constructs.  Dig for the real base register.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|base
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|op
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|>=
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but return 1 if OP is a MEM which is not alignable.  */
end_comment

begin_function
name|int
name|unaligned_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|op
argument_list|)
operator|>=
literal|32
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* LEGITIMIZE_RELOAD_ADDRESS creates (plus (plus reg const_hi) const_lo)      sorts of constructs.  Dig for the real base register.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|base
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|?
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
else|:
name|op
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|<
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is either a register or an unaligned memory location.  */
end_comment

begin_function
name|int
name|reg_or_unaligned_mem_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|unaligned_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is any memory location.  During reload a pseudo matches.  */
end_comment

begin_function
name|int
name|any_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is not an eliminable register.     This exists to cure a pathological abort in the s8addq (et al) patterns,  	long foo () { long t; bar(); return (long)&t * 26107; }     which run afoul of a hack in reload to cure a (presumably) similar    problem with lea-type instructions on other targets.  But there is    one of us and many of them, so work around the problem by selectively    preventing combine from making the optimization.  */
end_comment

begin_function
name|int
name|reg_not_elim_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|inner
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|==
name|frame_pointer_rtx
operator|||
name|inner
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is OP is a memory location that is not a reference (using    an AND) to an unaligned location.  Take into account what reload    will do.  */
end_comment

begin_function
name|int
name|normal_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
comment|/* This may not have been assigned an equivalent address if it will 	     be eliminated.  In that case, it doesn't matter what we do.  */
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|AND
return|;
block|}
end_function

begin_comment
comment|/* Accept a register, but not a subreg of any kind.  This allows us to    avoid pathological cases in reload wrt data movement common in     int->fp conversion.  */
end_comment

begin_function
name|int
name|reg_no_subreg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recognize an addition operation that includes a constant.  Used to    convince reload to canonize (plus (plus reg c1) c2) during register    elimination.  */
end_comment

begin_function
name|int
name|addition_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Implements CONST_OK_FOR_LETTER_P.  Return true if the value matches    the range defined for C in [I-P].  */
end_comment

begin_function
name|bool
name|alpha_const_ok_for_letter_p
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|,
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
comment|/* An unsigned 8 bit constant.  */
return|return
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|value
operator|<
literal|0x100
return|;
case|case
literal|'J'
case|:
comment|/* The constant zero.  */
return|return
name|value
operator|==
literal|0
return|;
case|case
literal|'K'
case|:
comment|/* A signed 16 bit constant.  */
return|return
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|value
operator|+
literal|0x8000
argument_list|)
operator|<
literal|0x10000
return|;
case|case
literal|'L'
case|:
comment|/* A shifted signed 16 bit constant appropriate for LDAH.  */
return|return
operator|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|value
operator|)
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|value
operator|>>
literal|31
operator|==
literal|0
operator|)
operator|)
return|;
case|case
literal|'M'
case|:
comment|/* A constant that can be AND'ed with using a ZAP insn.  */
return|return
name|zap_mask
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'N'
case|:
comment|/* A complemented unsigned 8 bit constant.  */
return|return
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|~
name|value
argument_list|)
operator|<
literal|0x100
return|;
case|case
literal|'O'
case|:
comment|/* A negated unsigned 8 bit constant.  */
return|return
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
name|value
argument_list|)
operator|<
literal|0x100
return|;
case|case
literal|'P'
case|:
comment|/* The constant 1, 2 or 3.  */
return|return
name|value
operator|==
literal|1
operator|||
name|value
operator|==
literal|2
operator|||
name|value
operator|==
literal|3
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implements CONST_DOUBLE_OK_FOR_LETTER_P.  Return true if VALUE    matches for C in [GH].  */
end_comment

begin_function
name|bool
name|alpha_const_double_ok_for_letter_p
parameter_list|(
name|rtx
name|value
parameter_list|,
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'G'
case|:
comment|/* The floating point zero constant.  */
return|return
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|value
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'H'
case|:
comment|/* A valid operand of a ZAP insn.  */
return|return
operator|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implements CONST_DOUBLE_OK_FOR_LETTER_P.  Return true if VALUE    matches for C.  */
end_comment

begin_function
name|bool
name|alpha_extra_constraint
parameter_list|(
name|rtx
name|value
parameter_list|,
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
return|return
name|normal_memory_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
literal|'R'
case|:
return|return
name|direct_call_operand
argument_list|(
name|value
argument_list|,
name|Pmode
argument_list|)
return|;
case|case
literal|'S'
case|:
return|return
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<
literal|64
operator|)
return|;
case|case
literal|'T'
case|:
return|return
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|HIGH
return|;
case|case
literal|'U'
case|:
return|return
name|TARGET_ABI_UNICOSMK
operator|&&
name|symbolic_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
literal|'W'
case|:
return|return
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|value
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if this function can directly return via $26.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|!
name|TARGET_ABI_OPEN_VMS
operator|&&
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
name|reload_completed
operator|&&
name|alpha_sa_size
argument_list|()
operator|==
literal|0
operator|&&
name|get_frame_size
argument_list|()
operator|==
literal|0
operator|&&
name|current_function_outgoing_args_size
operator|==
literal|0
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the ADDR_VEC associated with a tablejump insn.  */
end_comment

begin_function
name|rtx
name|alpha_tablejump_addr_vec
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|NULL_RTX
return|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
return|return
name|PATTERN
argument_list|(
name|tmp
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return the label of the predicted edge, or CONST0_RTX if we don't know.  */
end_comment

begin_function
name|rtx
name|alpha_tablejump_best_label
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|jump_table
init|=
name|alpha_tablejump_addr_vec
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|best_label
init|=
name|NULL_RTX
decl_stmt|;
comment|/* ??? Once the CFG doesn't keep getting completely rebuilt, look      there for edge frequency counts from profile data.  */
if|if
condition|(
name|jump_table
condition|)
block|{
name|int
name|n_labels
init|=
name|XVECLEN
argument_list|(
name|jump_table
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|best_count
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_labels
condition|;
name|i
operator|++
control|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_labels
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|jump_table
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|jump_table
argument_list|,
literal|1
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|best_count
condition|)
name|best_count
operator|=
name|count
operator|,
name|best_label
operator|=
name|XVECEXP
argument_list|(
name|jump_table
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|best_label
condition|?
name|best_label
else|:
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return the TLS model to use for SYMBOL.  */
end_comment

begin_function
specifier|static
name|enum
name|tls_model
name|tls_symbolic_operand_type
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
name|enum
name|tls_model
name|model
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|symbol
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
name|model
operator|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
comment|/* Local-exec with a 64-bit size is the same code as initial-exec.  */
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_LOCAL_EXEC
operator|&&
name|alpha_tls_size
operator|==
literal|64
condition|)
name|model
operator|=
name|TLS_MODEL_INITIAL_EXEC
expr_stmt|;
return|return
name|model
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the function DECL will share the same GP as any    function in the current unit of translation.  */
end_comment

begin_function
specifier|static
name|bool
name|decl_has_samegp
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Functions that are not local can be overridden, and thus may      not share the same gp.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If -msmall-data is in effect, assume that there is only one GP      for the module, and so any local symbol has this property.  We      need explicit relocations to be able to enforce this for symbols      not defined in this unit of translation, however.  */
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|TARGET_SMALL_DATA
condition|)
return|return
name|true
return|;
comment|/* Functions that are not external are defined in this UoT.  */
comment|/* ??? Irritatingly, static functions not yet emitted are still      marked "external".  Apply this to non-static functions only.  */
return|return
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if EXP should be placed in the small data section.  */
end_comment

begin_function
specifier|static
name|bool
name|alpha_in_small_data_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
comment|/* We want to merge strings, so we never consider them small data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|false
return|;
comment|/* Functions are never in the small data area.  Duh.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this is an incomplete type with size 0, then we can't put it 	 in sdata because it might be too big when completed.  */
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|size
operator|<=
name|g_switch_value
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
end_if

begin_function
specifier|static
name|bool
name|alpha_linkage_symbol_p
parameter_list|(
specifier|const
name|char
modifier|*
name|symname
parameter_list|)
block|{
name|int
name|symlen
init|=
name|strlen
argument_list|(
name|symname
argument_list|)
decl_stmt|;
if|if
condition|(
name|symlen
operator|>
literal|4
condition|)
return|return
name|strcmp
argument_list|(
operator|&
name|symname
index|[
name|symlen
operator|-
literal|4
index|]
argument_list|,
literal|"..lk"
argument_list|)
operator|==
literal|0
return|;
return|return
name|false
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LINKAGE_SYMBOL_REF_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((GET_CODE (X) == SYMBOL_REF   \&& alpha_linkage_symbol_p (XSTR (X, 0))) \    || (GET_CODE (X) == CONST                 \&& GET_CODE (XEXP (X, 0)) == PLUS     \&& GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF \&& alpha_linkage_symbol_p (XSTR (XEXP (XEXP (X, 0), 0), 0))))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* legitimate_address_p recognizes an RTL expression that is a valid    memory address for an instruction.  The MODE argument is the    machine mode for the MEM expression that wants to use this address.     For Alpha, we have either a constant address or the sum of a    register and a constant address, or just a register.  For DImode,    any of those forms can be surrounded with an AND that clear the    low-order three bits; this is an "unaligned" access.  */
end_comment

begin_function
name|bool
name|alpha_legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
comment|/* If this is an ldq_u type address, discard the outer AND.  */
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|8
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard non-paradoxical subregs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Unadorned general registers are valid.  */
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|strict
condition|?
name|STRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
else|:
name|NONSTRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* Constant addresses (i.e. +/- 32k) are valid.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
if|if
condition|(
name|LINKAGE_SYMBOL_REF_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
endif|#
directive|endif
comment|/* Register plus a small constant offset is valid.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|ofs
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard non-paradoxical subregs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strict
operator|&&
name|NONSTRICT_REG_OK_FP_BASE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|ofs
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|strict
condition|?
name|STRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
else|:
name|NONSTRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|ofs
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESSOF
operator|&&
name|GET_CODE
argument_list|(
name|ofs
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|true
return|;
block|}
comment|/* If we're managing explicit relocations, LO_SUM is valid, as      are small data symbols.  */
elseif|else
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
if|if
condition|(
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
name|rtx
name|ofs
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard non-paradoxical subregs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Must have a valid base register.  */
if|if
condition|(
operator|!
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|strict
condition|?
name|STRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
else|:
name|NONSTRICT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* The symbol must be local.  */
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|ofs
argument_list|,
name|Pmode
argument_list|)
operator|||
name|dtp32_symbolic_operand
argument_list|(
name|ofs
argument_list|,
name|Pmode
argument_list|)
operator|||
name|tp32_symbolic_operand
argument_list|(
name|ofs
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Build the SYMBOL_REF for __tls_get_addr.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|tls_get_addr_libfunc
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|get_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tls_get_addr_libfunc
condition|)
name|tls_get_addr_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
return|return
name|tls_get_addr_libfunc
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.  */
end_comment

begin_function
name|rtx
name|alpha_legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|scratch
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|addend
decl_stmt|;
comment|/* If the address is (plus reg const_int) and the CONST_INT is not a      valid offset, compute the high part of the constant and add it to      the register.  Then our address is (plus temp low-part-const).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|addend
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|split_addend
goto|;
block|}
comment|/* If the address is (const (plus FOO const_int)), find the low-order      part of the CONST_INT.  Then load FOO plus any high-order part of the      CONST_INT into a register.  Our address is (plus reg low-part-const).      This is done to reduce the number of GOT entries.  */
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addend
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|split_addend
goto|;
block|}
comment|/* If we have a (plus reg const), emit the load as in (2), then add      the two registers, and finally generate (plus reg low-part-const) as      our address.  */
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addend
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
goto|goto
name|split_addend
goto|;
block|}
comment|/* If this is a local symbol, split the address into HIGH/LO_SUM parts.  */
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|rtx
name|r0
decl_stmt|,
name|r16
decl_stmt|,
name|eqv
decl_stmt|,
name|tga
decl_stmt|,
name|tp
decl_stmt|,
name|insn
decl_stmt|,
name|dest
decl_stmt|,
name|seq
decl_stmt|;
switch|switch
condition|(
name|tls_symbolic_operand_type
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|r0
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r16
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|tga
operator|=
name|get_tls_get_addr
argument_list|()
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|seq
operator|=
name|GEN_INT
argument_list|(
name|alpha_next_sequence_number
operator|++
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movdi_er_tlsgd
argument_list|(
name|r16
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|x
argument_list|,
name|seq
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_call_value_osf_tlsgd
argument_list|(
name|r0
argument_list|,
name|tga
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|r16
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|,
name|r0
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|r0
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r16
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|tga
operator|=
name|get_tls_get_addr
argument_list|()
expr_stmt|;
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|seq
operator|=
name|GEN_INT
argument_list|(
name|alpha_next_sequence_number
operator|++
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movdi_er_tlsldm
argument_list|(
name|r16
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|seq
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_call_value_osf_tlsldm
argument_list|(
name|r0
argument_list|,
name|tga
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|r16
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLDM_CALL
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|scratch
argument_list|,
name|r0
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
name|eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
name|UNSPEC_DTPREL
argument_list|)
expr_stmt|;
name|eqv
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_tls_size
operator|==
literal|64
condition|)
block|{
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|eqv
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|dest
argument_list|,
name|dest
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
if|if
condition|(
name|alpha_tls_size
operator|==
literal|32
condition|)
block|{
name|insn
operator|=
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|scratch
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|scratch
argument_list|,
name|eqv
argument_list|)
return|;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
name|eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
name|UNSPEC_TPREL
argument_list|)
expr_stmt|;
name|eqv
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
name|tp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_tp
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|eqv
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|dest
argument_list|,
name|tp
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
name|eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
name|UNSPEC_TPREL
argument_list|)
expr_stmt|;
name|eqv
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
name|tp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_tp
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_tls_size
operator|==
literal|32
condition|)
block|{
name|insn
operator|=
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tp
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|tp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tp
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|tp
argument_list|,
name|eqv
argument_list|)
return|;
block|}
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|x
return|;
else|else
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|scratch
argument_list|,
name|x
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
name|split_addend
label|:
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|low
operator|=
operator|(
operator|(
name|addend
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|addend
operator|-=
name|low
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|addend
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
name|addend
operator|-=
name|high
expr_stmt|;
if|if
condition|(
name|addend
condition|)
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|addend
argument_list|)
argument_list|,
operator|(
name|no_new_pseudos
condition|?
name|scratch
else|:
name|NULL_RTX
operator|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
condition|)
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|high
argument_list|)
argument_list|,
operator|(
name|no_new_pseudos
condition|?
name|scratch
else|:
name|NULL_RTX
operator|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|x
argument_list|,
name|low
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Primarily this is required for TLS symbols, but given that our move    patterns *ought* to be able to handle any symbol at any time, we    should never be spilling symbolic operands to the constant pool, ever.  */
end_comment

begin_function
specifier|static
name|bool
name|alpha_cannot_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
return|return
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
operator|||
name|code
operator|==
name|CONST
return|;
block|}
end_function

begin_comment
comment|/* We do not allow indirect calls to be optimized into sibling calls, nor    can we allow a call to a function with a different GP to be optimized    into a sibcall.  */
end_comment

begin_function
specifier|static
name|bool
name|alpha_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Can't do indirect tail calls, since we don't know if the target      uses the same GP.  */
if|if
condition|(
operator|!
name|decl
condition|)
return|return
name|false
return|;
comment|/* Otherwise, we can make a tail call if the target function shares      the same GP.  */
return|return
name|decl_has_samegp
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For TARGET_EXPLICIT_RELOCS, we don't obfuscate a SYMBOL_REF to a    small symbolic operand until after reload.  At which point we need    to replace (mem (symbol_ref)) with (mem (lo_sum $29 symbol_ref))    so that sched2 has the proper dependency information.  */
end_comment

begin_function
specifier|static
name|int
name|some_small_symbolic_operand_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
comment|/* Don't re-split.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|some_small_symbolic_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|some_small_symbolic_operand_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|split_small_symbolic_operand_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
comment|/* Don't re-split.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|x
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|rtx
name|split_small_symbolic_operand
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|x
operator|=
name|copy_insn
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|split_small_symbolic_operand_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Indicate that INSN cannot be duplicated.  This is true for any insn    that we've marked with gpdisp relocs, since those have to stay in    1-1 correspondence with one another.     Technically we could copy them if we could set up a mapping from one    sequence number to another, across the set of insns to be duplicated.    This seems overly complicated and error-prone since interblock motion    from sched-ebb could move one of the pair of insns to a different block.     Also cannot allow jsr insns to be duplicated.  If they throw exceptions,    then they'll be in a different block from their ldgp.  Which could lead    the bb reorder code to think that it would be ok to copy just the block    containing the call and branch to the block containing the ldgp.  */
end_comment

begin_function
specifier|static
name|bool
name|alpha_cannot_copy_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|reload_completed
operator|||
operator|!
name|TARGET_EXPLICIT_RELOCS
condition|)
return|return
name|false
return|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_cannot_copy
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Try a machine-dependent way of reloading an illegitimate address    operand.  If we find one, push the reload and return the new rtx.  */
end_comment

begin_function
name|rtx
name|alpha_legitimize_reload_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|opnum
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|ind_levels
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We must recognize output that we have already generated ourselves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* We wish to handle large displacements off a base register by      splitting the addend across an ldah and the mem insn.  This      cuts number of extra insns needed from 3 to 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
operator|(
name|val
operator|-
name|low
operator|)
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
decl_stmt|;
comment|/* Check for 32-bit overflow.  */
if|if
condition|(
name|high
operator|+
name|low
operator|!=
name|val
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Reload the high part into a base reg; leave the low part 	 in the mem directly.  */
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.  */
end_comment

begin_function
specifier|static
name|bool
name|alpha_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|bool
name|float_mode_p
init|=
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* If this is an 8-bit constant, return zero since it can be used 	 nearly anywhere with no cost.  If it is a valid operand for an 	 ADD or AND, likewise return 0 if we know it will be used in that 	 context.  Otherwise, return 2 since it might be used there later. 	 All other constants take at least two insns.  */
case|case
name|CONST_INT
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* FALLTHRU */
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|outer_code
operator|==
name|PLUS
operator|&&
name|add_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|||
operator|(
name|outer_code
operator|==
name|AND
operator|&&
name|and_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|add_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|||
name|and_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|2
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|small_symbolic_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|outer_code
operator|!=
name|MEM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|local_symbolic_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
operator|+
operator|(
name|outer_code
operator|!=
name|MEM
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_symbolic_operand_type
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Estimate of cost for call_pal rduniq.  */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise we do a load from the GOT.  */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|alpha_memory_latency
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|fp_add
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|const48_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
operator|(
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|fp_mult
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|int_mult_di
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|int_mult_si
expr_stmt|;
return|return
name|false
return|;
case|case
name|ASHIFT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|3
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|int_shift
expr_stmt|;
return|return
name|false
return|;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|fp_add
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|int_cmov
expr_stmt|;
return|return
name|false
return|;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
if|if
condition|(
operator|!
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|70
argument_list|)
expr_stmt|;
comment|/* ??? */
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|fp_div_sf
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|fp_div_df
expr_stmt|;
return|return
name|false
return|;
case|case
name|MEM
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|alpha_memory_latency
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|NEG
case|:
if|if
condition|(
operator|!
name|float_mode_p
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|ABS
case|:
if|if
condition|(
operator|!
name|float_mode_p
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|int_cmov
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|FLOAT
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
operator|*
name|total
operator|=
name|alpha_rtx_cost_data
index|[
name|alpha_cpu
index|]
operator|.
name|fp_add
expr_stmt|;
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* REF is an alignable memory location.  Place an aligned SImode    reference into *PALIGNED_MEM and the number of bits to shift into    *PBITNUM.  SCRATCH is a free register for use in reloading out    of range stack slots.  */
end_comment

begin_function
name|void
name|get_aligned_mem
parameter_list|(
name|rtx
name|ref
parameter_list|,
name|rtx
modifier|*
name|paligned_mem
parameter_list|,
name|rtx
modifier|*
name|pbitnum
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|paligned_mem
operator|=
name|widen_memory_access
argument_list|(
name|ref
argument_list|,
name|SImode
argument_list|,
operator|(
name|offset
operator|&
operator|~
literal|3
operator|)
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
operator|*
name|pbitnum
operator|=
name|GEN_INT
argument_list|(
literal|32
operator|-
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|+
operator|(
name|offset
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|pbitnum
operator|=
name|GEN_INT
argument_list|(
operator|(
name|offset
operator|&
literal|3
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar, but just get the address.  Handle the two reload cases.      Add EXTRA_OFFSET to the address we return.  */
end_comment

begin_function
name|rtx
name|get_unaligned_address
parameter_list|(
name|rtx
name|ref
parameter_list|,
name|int
name|extra_offset
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
name|extra_offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* On the Alpha, all (non-symbolic) constants except zero go into    a floating-point register via memory.  Note that we cannot     return anything that is not a subset of CLASS, and that some    symbolic constants cannot be dropped to memory.  */
end_comment

begin_function
name|enum
name|reg_class
name|alpha_preferred_reload_class
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
comment|/* Zero is present in any register class.  */
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|class
return|;
comment|/* These sorts of constants we can easily drop to memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|FLOAT_REGS
condition|)
return|return
name|NO_REGS
return|;
if|if
condition|(
name|class
operator|==
name|ALL_REGS
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
name|class
return|;
block|}
comment|/* All other kinds of constants should not (and in the case of HIGH      cannot) be dropped to memory -- instead we use a GENERAL_REGS      secondary reload.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|class
operator|==
name|ALL_REGS
condition|?
name|GENERAL_REGS
else|:
name|class
operator|)
return|;
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* Loading and storing HImode or QImode values to and from memory    usually requires a scratch register.  The exceptions are loading    QImode and HImode from an aligned address to a general register    unless byte instructions are permitted.      We also cannot load an unaligned address or a paradoxical SUBREG    into an FP register.      We also cannot do integral arithmetic into FP regs, as might result    from register elimination into a DImode fp register.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|in
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|)
operator|&&
operator|!
name|TARGET_BWX
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|in
operator|||
operator|!
name|aligned_memory_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|GENERAL_REGS
return|;
block|}
block|}
if|if
condition|(
name|class
operator|==
name|FLOAT_REGS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
return|return
name|GENERAL_REGS
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|GENERAL_REGS
return|;
if|if
condition|(
name|in
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
operator|(
name|memory_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|||
name|x
operator|==
name|const0_rtx
operator|)
condition|)
return|return
name|GENERAL_REGS
return|;
block|}
return|return
name|NO_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subfunction of the following function.  Update the flags of any MEM    found in part of X.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_set_memflags_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|in_struct_p
parameter_list|,
name|int
name|volatile_p
parameter_list|,
name|int
name|unchanging_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SEQUENCE
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|alpha_set_memflags_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|alpha_set_memflags_1
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|alpha_set_memflags_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
name|alpha_set_memflags_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|volatile_p
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
comment|/* Sadly, we cannot use alias sets because the extra aliasing 	 produced by the AND interferes.  Given that two-byte quantities 	 are the only thing we would be able to differentiate anyway, 	 there does not seem to be any point in convoluting the early 	 out of the alias check.  */
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given INSN, which is an INSN list or the PATTERN of a single insn    generated to perform a memory operation, look for any MEMs in either    a SET_DEST or a SET_SRC and copy the in-struct, unchanging, and    volatile flags from REF into each of the MEMs found.  If REF is not    a MEM, don't do anything.  */
end_comment

begin_function
name|void
name|alpha_set_memflags
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|ref
parameter_list|)
block|{
name|int
name|in_struct_p
decl_stmt|,
name|volatile_p
decl_stmt|,
name|unchanging_p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|in_struct_p
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|volatile_p
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|unchanging_p
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* This is only called from alpha.md, after having had something       generated from one of the insn patterns.  So if everything is      zero, the pattern is already up-to-date.  */
if|if
condition|(
operator|!
name|in_struct_p
operator|&&
operator|!
name|volatile_p
operator|&&
operator|!
name|unchanging_p
condition|)
return|return;
name|alpha_set_memflags_1
argument_list|(
name|insn
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal routine for alpha_emit_set_const to check for N or below insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|alpha_emit_set_const_1
parameter_list|(
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|c
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|HOST_WIDE_INT
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
comment|/* Use a pseudo if highly optimizing and still generating RTL.  */
name|rtx
name|subtarget
init|=
operator|(
name|flag_expensive_optimizations
operator|&&
operator|!
name|no_new_pseudos
condition|?
literal|0
else|:
name|target
operator|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|insn
decl_stmt|;
comment|/* If this is a sign-extended 32-bit constant, we can do this in at most      three insns, so do it if we have enough insns left.  We always have      a sign-extended 32-bit constant when compiling on a narrow machine.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
operator|||
name|c
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|c
operator|>>
literal|31
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|c
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|c
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|extra
init|=
literal|0
decl_stmt|;
comment|/* If HIGH will be interpreted as negative but the constant is 	 positive, we must adjust it to do two ldha insns.  */
if|if
condition|(
operator|(
name|high
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|low
operator|||
operator|(
name|low
operator|==
literal|0
operator|&&
name|extra
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* We used to use copy_to_suggested_reg (GEN_INT (c), target, mode) 	     but that meant that we can't handle INT_MIN on 32-bit machines 	     (like NT/Alpha), because we recurse indefinitely through  	     emit_move_insn to gen_movdi.  So instead, since we know exactly 	     what we want, create it explicitly.  */
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
literal|2
operator|+
operator|(
name|extra
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|high
operator|<<
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|target
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|copy_to_suggested_reg
argument_list|(
name|GEN_INT
argument_list|(
name|high
operator|<<
literal|16
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* As of 2002-02-23, addsi3 is only available when not optimizing. 	     This means that if we go through expand_binop, we'll try to 	     generate extensions, etc, which will require new pseudos, which 	     will fail during some split phases.  The SImode add patterns 	     still exist, but are not named.  So build the insns by hand.  */
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|subtarget
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|extra
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|subtarget
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|temp
operator|=
name|subtarget
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
comment|/* If we couldn't do it that way, try some other methods.  But if we have      no instructions left, don't bother.  Likewise, if this is SImode and      we can't make pseudos, we can't do anything since the expand_binop      and expand_unop calls will widen and try to make pseudos.  */
if|if
condition|(
name|n
operator|==
literal|1
operator|||
operator|(
name|mode
operator|==
name|SImode
operator|&&
name|no_new_pseudos
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Next, see if we can load a related constant and then shift and possibly      negate it to get the constant we want.  Try this once each increasing      numbers of insns.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* First, see if minus some low bits, we've an easy load of 	 high bits.  */
name|new
operator|=
operator|(
operator|(
name|c
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|-
name|new
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|new
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Next try complementing.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|~
name|c
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|temp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Next try to form a constant and do a left shift.  We can do this 	 if some low-order bits are zero; the exact_log2 call below tells 	 us that information.  The bits we are shifting out could be any 	 value, but here we'll just try the 0- and sign-extended forms of 	 the constant.  To try to increase the chance of having the same 	 constant in more than one insn, start at the highest number of 	 bits to shift, but try all possibilities in case a ZAPNOT will 	 be useful.  */
if|if
condition|(
operator|(
name|bits
operator|=
name|exact_log2
argument_list|(
name|c
operator|&
operator|-
name|c
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|c
operator|)
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashl_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Now try high-order zero bits.  Here we try the shifted-in bits as 	 all zero and all ones.  Be careful to avoid shifting outside the 	 mode and to avoid shifting outside the host wide int size.  */
comment|/* On narrow hosts, don't shift a 1 into the high bit, since we'll 	 confuse the recursive call and set all of the high 32 bits.  */
if|if
condition|(
operator|(
name|bits
operator|=
operator|(
name|MIN
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
literal|8
argument_list|)
operator|-
name|floor_log2
argument_list|(
name|c
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|)
operator|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|lshr_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
comment|/* Now try high-order 1 bits.  We get that with a sign-extension. 	 But one bit isn't enough here.  Be careful to avoid shifting outside 	 the mode and to avoid shifting outside the host wide int size.  */
if|if
condition|(
operator|(
name|bits
operator|=
operator|(
name|MIN
argument_list|(
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|*
literal|8
argument_list|)
operator|-
name|floor_log2
argument_list|(
operator|~
name|c
argument_list|)
operator|-
literal|2
operator|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|temp
operator|=
operator|(
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
block|}
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
comment|/* Finally, see if can load a value into the target that is the same as the      constant except that all bytes that are 0 are changed to be 0xff.  If we      can, then we can do a ZAPNOT to obtain the desired constant.  */
name|new
operator|=
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|+=
literal|8
control|)
if|if
condition|(
operator|(
name|new
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|new
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
expr_stmt|;
comment|/* We are only called for SImode and DImode.  If this is SImode, ensure that      we are sign extended to a full word.  */
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|new
operator|=
operator|(
operator|(
name|new
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|c
operator|&&
name|new
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|subtarget
argument_list|,
name|mode
argument_list|,
name|new
argument_list|,
name|n
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|c
operator||
operator|~
name|new
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to output insns to set TARGET equal to the constant C if it can be    done in less than N insns.  Do all computations in MODE.  Returns the place    where the output has been placed if it can be done and the insns have been    emitted.  If it would take more than N insns, zero is returned and no    insns and emitted.  */
end_comment

begin_function
name|rtx
name|alpha_emit_set_const
parameter_list|(
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|c
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|rtx
name|result
init|=
literal|0
decl_stmt|;
name|rtx
name|orig_target
init|=
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we can't make any pseudos, TARGET is an SImode hard register, we      can't load this constant in one insn, do this in DImode.  */
if|if
condition|(
name|no_new_pseudos
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|result
operator|=
name|alpha_emit_set_const_1
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|target
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
block|}
comment|/* Try 1 insn, then 2, then up to N.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|alpha_emit_set_const_1
argument_list|(
name|target
argument_list|,
name|mode
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|REG_EQUAL
argument_list|,
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Allow for the case where we changed the mode of TARGET.  */
if|if
condition|(
name|result
operator|==
name|target
condition|)
name|result
operator|=
name|orig_target
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Having failed to find a 3 insn sequence in alpha_emit_set_const,    fall back to a straight forward decomposition.  We do this to avoid    exponential run times encountered when looking for longer sequences    with alpha_emit_set_const.  */
end_comment

begin_function
name|rtx
name|alpha_emit_set_long_const
parameter_list|(
name|rtx
name|target
parameter_list|,
name|HOST_WIDE_INT
name|c1
parameter_list|,
name|HOST_WIDE_INT
name|c2
parameter_list|)
block|{
name|HOST_WIDE_INT
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|;
comment|/* Decompose the entire word */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|c2
operator|!=
operator|-
operator|(
name|c1
operator|<
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|d1
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d1
expr_stmt|;
name|d2
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
name|c1
operator|=
operator|(
name|c1
operator|-
name|d2
operator|)
operator|>>
literal|32
expr_stmt|;
name|d3
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d3
expr_stmt|;
name|d4
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|d4
condition|)
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|d1
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c1
operator|-=
name|d1
expr_stmt|;
name|d2
operator|=
operator|(
operator|(
name|c1
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|d2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|c2
operator|+=
operator|(
name|d2
operator|<
literal|0
operator|)
expr_stmt|;
name|d3
operator|=
operator|(
operator|(
name|c2
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|c2
operator|-=
name|d3
expr_stmt|;
name|d4
operator|=
operator|(
operator|(
name|c2
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|c2
operator|!=
name|d4
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Construct the high word */
if|if
condition|(
name|d4
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d3
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shift it into place */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add in the low bits.  */
if|if
condition|(
name|d2
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|d1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a move instruction; return true if all work is done.    We don't handle non-bwx subword loads here.  */
end_comment

begin_function
name|bool
name|alpha_expand_mov
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
comment|/* If the output is not a register, the input must be.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|reg_or_0_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Allow legitimize_address to perform some simplifications.  */
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
name|symbolic_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* With RTL inlining, at -O3, rtl is generated, stored, then actually 	 compiled at the end of compilation.  In the meantime, someone can 	 re-encode-section-info on some symbol changing it e.g. from global 	 to local-not-small.  If this happens, we'd have emitted a plain 	 load rather than a high+losum load and not recognize the insn.  	 So if rtl inlining is in effect, we delay the global/not-global 	 decision until rest_of_compilation by wrapping it in an 	 UNSPEC_SYMBOL.  */
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|flag_inline_functions
operator|&&
name|rtx_equal_function_value_matters
operator|&&
name|global_symbolic_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movdi_er_maybe_g
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|tmp
operator|=
name|alpha_legitimize_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
name|operands
index|[
literal|0
index|]
condition|)
return|return
name|true
return|;
name|operands
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Early out for non-constants and valid constants.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|input_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Split large integers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|i0
decl_stmt|,
name|i1
decl_stmt|;
name|rtx
name|temp
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|i0
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i1
operator|=
operator|-
operator|(
name|i0
operator|<
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
block|{
name|i0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i1
operator|=
operator|-
operator|(
name|i0
operator|<
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|i0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|i1
operator|==
operator|-
operator|(
name|i0
operator|<
literal|0
operator|)
condition|)
name|temp
operator|=
name|alpha_emit_set_const
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|,
name|i0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
operator|&&
name|TARGET_BUILD_CONSTANTS
condition|)
name|temp
operator|=
name|alpha_emit_set_long_const
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|temp
argument_list|)
condition|)
return|return
name|true
return|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Otherwise we've nothing left but to drop the thing to memory.  */
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|copy_rtx
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|operands
index|[
literal|1
index|]
operator|=
name|validize_mem
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Expand a non-bwx QImode or HImode move instruction;    return true if all work is done.  */
end_comment

begin_function
name|bool
name|alpha_expand_mov_nobwx
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
comment|/* If the output is not a register, the input must be.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Handle four memory cases, unaligned and aligned for either the input      or the output.  The only case where we can be called during reload is      for aligned loads; all other cases require temporaries.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
if|if
condition|(
name|aligned_memory_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|QImode
condition|?
name|gen_reload_inqi_help
else|:
name|gen_reload_inhi_help
operator|)
operator|(
name|operands
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|1
index|]
operator|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|aligned_mem
decl_stmt|,
name|bitnum
decl_stmt|;
name|rtx
name|scratch
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|;
name|bool
name|copyout
decl_stmt|;
name|get_aligned_mem
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|aligned_mem
argument_list|,
operator|&
name|bitnum
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|subtarget
argument_list|)
operator|==
name|REG
condition|)
name|subtarget
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|subtarget
argument_list|)
operator|,
name|copyout
operator|=
name|false
expr_stmt|;
else|else
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
operator|,
name|copyout
operator|=
name|true
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|QImode
condition|?
name|gen_aligned_loadqi
else|:
name|gen_aligned_loadhi
operator|)
operator|(
name|subtarget
operator|,
name|aligned_mem
operator|,
name|bitnum
operator|,
name|scratch
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|subtarget
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Don't pass these as parameters since that makes the generated 	     code depend on parameter evaluation order which will cause 	     bootstrap failures.  */
name|rtx
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|seq
decl_stmt|,
name|subtarget
decl_stmt|;
name|bool
name|copyout
decl_stmt|;
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|subtarget
argument_list|)
operator|==
name|REG
condition|)
name|subtarget
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|subtarget
argument_list|)
operator|,
name|copyout
operator|=
name|false
expr_stmt|;
else|else
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
operator|,
name|copyout
operator|=
name|true
expr_stmt|;
name|seq
operator|=
operator|(
operator|(
name|mode
operator|==
name|QImode
condition|?
name|gen_unaligned_loadqi
else|:
name|gen_unaligned_loadhi
operator|)
operator|(
name|subtarget
operator|,
name|get_unaligned_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|,
name|temp1
operator|,
name|temp2
operator|)
operator|)
expr_stmt|;
name|alpha_set_memflags
argument_list|(
name|seq
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|subtarget
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
if|if
condition|(
name|aligned_memory_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|aligned_mem
decl_stmt|,
name|bitnum
decl_stmt|;
name|rtx
name|temp1
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|temp2
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|get_aligned_mem
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
operator|&
name|aligned_mem
argument_list|,
operator|&
name|bitnum
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_aligned_store
argument_list|(
name|aligned_mem
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|bitnum
argument_list|,
name|temp1
argument_list|,
name|temp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|temp1
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp2
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp3
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|seq
init|=
operator|(
operator|(
name|mode
operator|==
name|QImode
condition|?
name|gen_unaligned_storeqi
else|:
name|gen_unaligned_storehi
operator|)
operator|(
name|get_unaligned_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr|,
name|operands
index|[
literal|1
index|]
expr|,
name|temp1
expr|,
name|temp2
expr|,
name|temp3
operator|)
operator|)
decl_stmt|;
name|alpha_set_memflags
argument_list|(
name|seq
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Generate an unsigned DImode to FP conversion.  This is the same code    optabs would emit if we didn't have TFmode patterns.     For SFmode, this is the only construction I've found that can pass    gcc.c-torture/execute/ieee/rbug.c.  No scenario that uses DFmode    intermediates will work, because you'll get intermediate rounding    that ruins the end result.  Some of this could be fixed by turning    on round-to-positive-infinity, but that requires diddling the fpsr,    which kills performance.  I tried turning this around and converting    to a negative number, so that I could turn on /m, but either I did    it wrong or there's something else cause I wound up with the exact    same single-bit error.  There is a branch-less form of this same code:  	srl     $16,1,$1 	and     $16,1,$2 	cmplt   $16,0,$3 	or      $1,$2,$2 	cmovge  $16,$16,$2 	itoft	$3,$f10 	itoft	$2,$f11 	cvtqs   $f11,$f11 	adds    $f11,$f11,$f0 	fcmoveq $f10,$f11,$f0     I'm not using it because it's the same number of instructions as    this branch-full form, and it has more serialized long latency    instructions on the critical path.     For DFmode, we can avoid rounding errors by breaking up the word    into two pieces, converting them separately, and adding them back:     LC0: .long 0,0x5f800000  	itoft	$16,$f11 	lda	$2,LC0 	cmplt	$16,0,$1 	cpyse	$f11,$f31,$f10 	cpyse	$f31,$f11,$f11 	s4addq	$1,$2,$1 	lds	$f12,0($1) 	cvtqt	$f10,$f10 	cvtqt	$f11,$f11 	addt	$f12,$f10,$f0 	addt	$f0,$f11,$f0     This doesn't seem to be a clear-cut win over the optabs form.    It probably all depends on the distribution of numbers being    converted -- in the optabs form, all but high-bit-set has a    much lower minimum execution time.  */
end_comment

begin_function
name|void
name|alpha_emit_floatuns
parameter_list|(
name|rtx
name|operands
index|[
literal|2
index|]
parameter_list|)
block|{
name|rtx
name|neglab
decl_stmt|,
name|donelab
decl_stmt|,
name|i0
decl_stmt|,
name|i1
decl_stmt|,
name|f0
decl_stmt|,
name|in
decl_stmt|,
name|out
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|in
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|neglab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|donelab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i0
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|i1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|f0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|in
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|const0_rtx
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|mode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|donelab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|i0
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|i1
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iordi3
argument_list|(
name|i0
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|f0
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|mode
argument_list|,
name|i0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|f0
argument_list|,
name|f0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|donelab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the comparison for a conditional branch.  */
end_comment

begin_function
name|rtx
name|alpha_emit_conditional_branch
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|rtx_code
name|cmp_code
decl_stmt|,
name|branch_code
decl_stmt|;
name|enum
name|machine_mode
name|cmp_mode
decl_stmt|,
name|branch_mode
init|=
name|VOIDmode
decl_stmt|;
name|rtx
name|op0
init|=
name|alpha_compare
operator|.
name|op0
decl_stmt|,
name|op1
init|=
name|alpha_compare
operator|.
name|op1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|alpha_compare
operator|.
name|fp_p
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAS_XFLOATING_LIBS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* X_floating library comparison functions return 	   -1  unordered 	    0  false 	    1  true 	 Convert the compare against the raw return value.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UNORDERED
case|:
name|cmp_code
operator|=
name|EQ
expr_stmt|;
name|code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|cmp_code
operator|=
name|EQ
expr_stmt|;
name|code
operator|=
name|GE
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|cmp_code
operator|=
name|NE
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
break|break;
default|default:
name|cmp_code
operator|=
name|code
expr_stmt|;
name|code
operator|=
name|GT
expr_stmt|;
break|break;
block|}
name|op0
operator|=
name|alpha_emit_xfloating_compare
argument_list|(
name|cmp_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|alpha_compare
operator|.
name|fp_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The general case: fold the comparison code to the types of compares      that we have, choosing the branch as necessary.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|UNORDERED
case|:
comment|/* We have these compares: */
name|cmp_code
operator|=
name|code
operator|,
name|branch_code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|ORDERED
case|:
comment|/* These must be reversed.  */
name|cmp_code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|branch_code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* For FP, we swap them, for INT, we reverse them.  */
if|if
condition|(
name|alpha_compare
operator|.
name|fp_p
condition|)
block|{
name|cmp_code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|branch_code
operator|=
name|NE
expr_stmt|;
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
else|else
block|{
name|cmp_code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|branch_code
operator|=
name|EQ
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|alpha_compare
operator|.
name|fp_p
condition|)
block|{
name|cmp_mode
operator|=
name|DFmode
expr_stmt|;
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
block|{
comment|/* When we are not as concerned about non-finite values, and we 	     are comparing against zero, we can branch directly.  */
if|if
condition|(
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
condition|)
name|cmp_code
operator|=
name|NIL
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
condition|)
block|{
comment|/* Undo the swap we probably did just above.  */
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
name|branch_code
operator|=
name|swap_condition
argument_list|(
name|cmp_code
argument_list|)
expr_stmt|;
name|cmp_code
operator|=
name|NIL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ??? We mark the branch mode to be CCmode to prevent the 	     compare and branch from being combined, since the compare  	     insn follows IEEE rules that the branch does not.  */
name|branch_mode
operator|=
name|CCmode
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmp_mode
operator|=
name|DImode
expr_stmt|;
comment|/* The following optimizations are only for signed compares.  */
if|if
condition|(
name|code
operator|!=
name|LEU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|GTU
condition|)
block|{
comment|/* Whee.  Compare and branch against 0 directly.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
name|cmp_code
operator|=
name|NIL
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
comment|/* If the constants doesn't fit into an immediate, but can  	     be generated by lda/ldah, we adjust the argument and  	     compare against zero, so we can use beq/bne directly.  */
comment|/* ??? Don't do this when comparing against symbols, otherwise 	     we'll reduce (&x == 0x1234) to (&x-0x1234 == 0), which will 	     be declared false out of hand (at least for non-weak).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
operator|!
operator|(
name|symbolic_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|op0
argument_list|)
operator|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|v
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|,
name|n
init|=
operator|-
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|v
argument_list|,
literal|'I'
argument_list|)
operator|&&
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|n
argument_list|,
literal|'K'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|n
argument_list|,
literal|'L'
argument_list|)
operator|)
condition|)
block|{
name|cmp_code
operator|=
name|PLUS
operator|,
name|branch_code
operator|=
name|code
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|reg_or_0_operand
argument_list|(
name|op0
argument_list|,
name|DImode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_code
operator|!=
name|PLUS
operator|&&
operator|!
name|reg_or_8bit_operand
argument_list|(
name|op1
argument_list|,
name|DImode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Emit an initial compare instruction, if necessary.  */
name|tem
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|cmp_code
operator|!=
name|NIL
condition|)
block|{
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|cmp_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|cmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Zero the operands.  */
name|memset
argument_list|(
operator|&
name|alpha_compare
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alpha_compare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the branch comparison.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|branch_code
argument_list|,
name|branch_mode
argument_list|,
name|tem
argument_list|,
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Certain simplifications can be done to make invalid setcc operations    valid.  Return the final comparison, or NULL if we can't work.  */
end_comment

begin_function
name|rtx
name|alpha_emit_setcc
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
name|rtx
name|op0
init|=
name|alpha_compare
operator|.
name|op0
decl_stmt|,
name|op1
init|=
name|alpha_compare
operator|.
name|op1
decl_stmt|;
name|int
name|fp_p
init|=
name|alpha_compare
operator|.
name|fp_p
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* Zero the operands.  */
name|memset
argument_list|(
operator|&
name|alpha_compare
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alpha_compare
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_p
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAS_XFLOATING_LIBS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* X_floating library comparison functions return 	   -1  unordered 	    0  false 	    1  true 	 Convert the compare against the raw return value.  */
if|if
condition|(
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|ORDERED
condition|)
name|cmp_code
operator|=
name|EQ
expr_stmt|;
else|else
name|cmp_code
operator|=
name|code
expr_stmt|;
name|op0
operator|=
name|alpha_emit_xfloating_compare
argument_list|(
name|cmp_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|fp_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNORDERED
condition|)
name|code
operator|=
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ORDERED
condition|)
name|code
operator|=
name|GE
expr_stmt|;
else|else
name|code
operator|=
name|GT
expr_stmt|;
block|}
if|if
condition|(
name|fp_p
operator|&&
operator|!
name|TARGET_FIX
condition|)
return|return
name|NULL_RTX
return|;
comment|/* The general case: fold the comparison code to the types of compares      that we have, choosing the branch as necessary.  */
name|cmp_code
operator|=
name|NIL
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|UNORDERED
case|:
comment|/* We have these compares.  */
if|if
condition|(
name|fp_p
condition|)
name|cmp_code
operator|=
name|code
operator|,
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
operator|!
name|fp_p
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|ORDERED
case|:
name|cmp_code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* These normally need swapping, but for integer zero we have 	 special patterns that recognize swapped operands.  */
if|if
condition|(
operator|!
name|fp_p
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
break|break;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_p
condition|)
name|cmp_code
operator|=
name|code
operator|,
name|code
operator|=
name|NE
expr_stmt|;
name|tmp
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fp_p
condition|)
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|DImode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_or_8bit_operand
argument_list|(
name|op1
argument_list|,
name|DImode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Emit an initial compare instruction, if necessary.  */
if|if
condition|(
name|cmp_code
operator|!=
name|NIL
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|fp_p
condition|?
name|DFmode
else|:
name|DImode
decl_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|fp_p
condition|?
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
else|:
name|tmp
expr_stmt|;
name|op1
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* Return the setcc comparison.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|DImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rewrite a comparison against zero CMP of the form    (CODE (cc0) (const_int 0)) so it can be written validly in    a conditional move (if_then_else CMP ...).    If both of the operands that set cc0 are nonzero we must emit    an insn to perform the compare (it can't be done within    the conditional move).  */
end_comment

begin_function
name|rtx
name|alpha_emit_conditional_move
parameter_list|(
name|rtx
name|cmp
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|cmp
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|cmov_code
init|=
name|NE
decl_stmt|;
name|rtx
name|op0
init|=
name|alpha_compare
operator|.
name|op0
decl_stmt|;
name|rtx
name|op1
init|=
name|alpha_compare
operator|.
name|op1
decl_stmt|;
name|int
name|fp_p
init|=
name|alpha_compare
operator|.
name|fp_p
decl_stmt|;
name|enum
name|machine_mode
name|cmp_mode
init|=
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|cmp_op_mode
init|=
name|fp_p
condition|?
name|DFmode
else|:
name|DImode
decl_stmt|;
name|enum
name|machine_mode
name|cmov_mode
init|=
name|VOIDmode
decl_stmt|;
name|int
name|local_fast_math
init|=
name|flag_unsafe_math_optimizations
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* Zero the operands.  */
name|memset
argument_list|(
operator|&
name|alpha_compare
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alpha_compare
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_p
operator|!=
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_FIX
condition|)
return|return
literal|0
return|;
comment|/* If we have fp<->int register move instructions, do a cmov by 	 performing the comparison in fp registers, and move the 	 zero/nonzero value to integer registers, where we can then 	 use a normal cmov, or vice-versa.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
comment|/* We have these compares.  */
name|cmp_code
operator|=
name|code
operator|,
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
comment|/* This must be reversed.  */
name|cmp_code
operator|=
name|EQ
operator|,
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* These normally need swapping, but for integer zero we have 	     special patterns that recognize swapped operands.  */
if|if
condition|(
operator|!
name|fp_p
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
name|cmp_code
operator|=
name|code
operator|,
name|code
operator|=
name|NE
expr_stmt|;
else|else
block|{
name|cmp_code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|cmp_op_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tem
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|cmp_op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cmp_mode
operator|=
name|cmp_op_mode
operator|=
name|fp_p
condition|?
name|DImode
else|:
name|DFmode
expr_stmt|;
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|cmp_op_mode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|cmp_op_mode
argument_list|)
expr_stmt|;
name|fp_p
operator|=
operator|!
name|fp_p
expr_stmt|;
name|local_fast_math
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We may be able to use a conditional move directly.      This avoids emitting spurious compares.  */
if|if
condition|(
name|signed_comparison_operator
argument_list|(
name|cmp
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|(
operator|!
name|fp_p
operator|||
name|local_fast_math
operator|)
operator|&&
operator|(
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
operator|||
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
operator|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* We can't put the comparison inside the conditional move;      emit a compare instruction and put that inside the      conditional move.  Make sure we emit only comparisons we have;      swap or reverse as necessary.  */
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|NULL_RTX
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
comment|/* We have these compares: */
break|break;
case|case
name|NE
case|:
comment|/* This must be reversed.  */
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|cmov_code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* These must be swapped.  */
if|if
condition|(
name|op1
operator|!=
name|CONST0_RTX
argument_list|(
name|cmp_mode
argument_list|)
condition|)
block|{
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fp_p
condition|)
block|{
if|if
condition|(
operator|!
name|reg_or_0_operand
argument_list|(
name|op0
argument_list|,
name|DImode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_or_8bit_operand
argument_list|(
name|op1
argument_list|,
name|DImode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* ??? We mark the branch mode to be CCmode to prevent the compare      and cmov from being combined, since the compare insn follows IEEE      rules that the cmov does not.  */
if|if
condition|(
name|fp_p
operator|&&
operator|!
name|local_fast_math
condition|)
name|cmov_mode
operator|=
name|CCmode
expr_stmt|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|cmp_op_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|cmp_op_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|cmov_code
argument_list|,
name|cmov_mode
argument_list|,
name|tem
argument_list|,
name|CONST0_RTX
argument_list|(
name|cmp_op_mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Simplify a conditional move of two constants into a setcc with    arithmetic.  This is done with a splitter since combine would    just undo the work if done during code generation.  It also catches    cases we wouldn't have before cse.  */
end_comment

begin_function
name|int
name|alpha_split_conditional_move
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|dest
parameter_list|,
name|rtx
name|cond
parameter_list|,
name|rtx
name|t_rtx
parameter_list|,
name|rtx
name|f_rtx
parameter_list|)
block|{
name|HOST_WIDE_INT
name|t
decl_stmt|,
name|f
decl_stmt|,
name|diff
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|subtarget
decl_stmt|,
name|tmp
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|t
operator|=
name|INTVAL
argument_list|(
name|t_rtx
argument_list|)
expr_stmt|;
name|f
operator|=
name|INTVAL
argument_list|(
name|f_rtx
argument_list|)
expr_stmt|;
name|diff
operator|=
name|t
operator|-
name|f
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|diff
operator|<
literal|0
operator|)
operator|||
operator|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GT
operator|)
condition|)
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|diff
operator|=
name|t
operator|,
name|t
operator|=
name|f
operator|,
name|f
operator|=
name|diff
expr_stmt|;
name|diff
operator|=
name|t
operator|-
name|f
expr_stmt|;
block|}
name|subtarget
operator|=
name|target
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DImode
condition|)
block|{
name|target
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
else|else
name|subtarget
operator|=
name|target
expr_stmt|;
block|}
comment|/* Below, we must be careful to use copy_rtx on target and subtarget      in intermediate insns, as they may be a subreg rtx, which may not      be shared.  */
if|if
condition|(
name|f
operator|==
literal|0
operator|&&
name|exact_log2
argument_list|(
name|diff
argument_list|)
operator|>
literal|0
comment|/* On EV6, we've got enough shifters to make non-arithmetic shifts 	 viable over a longer latency cmove.  On EV5, the E0 slot is a 	 scarce resource, and on EV4 shift has the same latency as a cmove.  */
operator|&&
operator|(
name|diff
operator|<=
literal|8
operator|||
name|alpha_cpu
operator|==
name|PROCESSOR_EV6
operator|)
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|DImode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|exact_log2
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
literal|0
operator|&&
name|t
operator|==
operator|-
literal|1
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|DImode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_negdi2
argument_list|(
name|target
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
literal|1
operator|||
name|diff
operator|==
literal|4
operator|||
name|diff
operator|==
literal|8
condition|)
block|{
name|rtx
name|add_op
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|DImode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|target
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|add_op
operator|=
name|GEN_INT
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|sext_add_operand
argument_list|(
name|add_op
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_MULT
argument_list|(
name|DImode
argument_list|,
name|copy_rtx
argument_list|(
name|subtarget
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|,
name|add_op
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up the function X_floating library function name for the    given operation.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alpha_lookup_xfloating_lib_func
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
struct|struct
name|xfloating_op
block|{
specifier|const
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|func
decl_stmt|;
block|}
struct|;
specifier|static
specifier|const
name|struct
name|xfloating_op
name|vms_xfloating_ops
index|[]
init|=
block|{
block|{
name|PLUS
block|,
literal|"OTS$ADD_X"
block|}
block|,
block|{
name|MINUS
block|,
literal|"OTS$SUB_X"
block|}
block|,
block|{
name|MULT
block|,
literal|"OTS$MUL_X"
block|}
block|,
block|{
name|DIV
block|,
literal|"OTS$DIV_X"
block|}
block|,
block|{
name|EQ
block|,
literal|"OTS$EQL_X"
block|}
block|,
block|{
name|NE
block|,
literal|"OTS$NEQ_X"
block|}
block|,
block|{
name|LT
block|,
literal|"OTS$LSS_X"
block|}
block|,
block|{
name|LE
block|,
literal|"OTS$LEQ_X"
block|}
block|,
block|{
name|GT
block|,
literal|"OTS$GTR_X"
block|}
block|,
block|{
name|GE
block|,
literal|"OTS$GEQ_X"
block|}
block|,
block|{
name|FIX
block|,
literal|"OTS$CVTXQ"
block|}
block|,
block|{
name|FLOAT
block|,
literal|"OTS$CVTQX"
block|}
block|,
block|{
name|UNSIGNED_FLOAT
block|,
literal|"OTS$CVTQUX"
block|}
block|,
block|{
name|FLOAT_EXTEND
block|,
literal|"OTS$CVT_FLOAT_T_X"
block|}
block|,
block|{
name|FLOAT_TRUNCATE
block|,
literal|"OTS$CVT_FLOAT_X_T"
block|}
block|,     }
decl_stmt|;
specifier|static
specifier|const
name|struct
name|xfloating_op
name|osf_xfloating_ops
index|[]
init|=
block|{
block|{
name|PLUS
block|,
literal|"_OtsAddX"
block|}
block|,
block|{
name|MINUS
block|,
literal|"_OtsSubX"
block|}
block|,
block|{
name|MULT
block|,
literal|"_OtsMulX"
block|}
block|,
block|{
name|DIV
block|,
literal|"_OtsDivX"
block|}
block|,
block|{
name|EQ
block|,
literal|"_OtsEqlX"
block|}
block|,
block|{
name|NE
block|,
literal|"_OtsNeqX"
block|}
block|,
block|{
name|LT
block|,
literal|"_OtsLssX"
block|}
block|,
block|{
name|LE
block|,
literal|"_OtsLeqX"
block|}
block|,
block|{
name|GT
block|,
literal|"_OtsGtrX"
block|}
block|,
block|{
name|GE
block|,
literal|"_OtsGeqX"
block|}
block|,
block|{
name|FIX
block|,
literal|"_OtsCvtXQ"
block|}
block|,
block|{
name|FLOAT
block|,
literal|"_OtsCvtQX"
block|}
block|,
block|{
name|UNSIGNED_FLOAT
block|,
literal|"_OtsCvtQUX"
block|}
block|,
block|{
name|FLOAT_EXTEND
block|,
literal|"_OtsConvertFloatTX"
block|}
block|,
block|{
name|FLOAT_TRUNCATE
block|,
literal|"_OtsConvertFloatXT"
block|}
block|,     }
decl_stmt|;
specifier|const
name|struct
name|xfloating_op
modifier|*
name|ops
decl_stmt|;
specifier|const
name|long
name|n
init|=
name|ARRAY_SIZE
argument_list|(
name|osf_xfloating_ops
argument_list|)
decl_stmt|;
name|long
name|i
decl_stmt|;
comment|/* How irritating.  Nothing to key off for the table.  Hardcode      knowledge of the G_floating routines.  */
if|if
condition|(
name|TARGET_FLOAT_VAX
condition|)
block|{
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|FLOAT_EXTEND
condition|)
return|return
literal|"OTS$CVT_FLOAT_G_X"
return|;
if|if
condition|(
name|code
operator|==
name|FLOAT_TRUNCATE
condition|)
return|return
literal|"OTS$CVT_FLOAT_X_G"
return|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|FLOAT_EXTEND
condition|)
return|return
literal|"_OtsConvertFloatGX"
return|;
if|if
condition|(
name|code
operator|==
name|FLOAT_TRUNCATE
condition|)
return|return
literal|"_OtsConvertFloatXG"
return|;
block|}
block|}
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|ops
operator|=
name|vms_xfloating_ops
expr_stmt|;
else|else
name|ops
operator|=
name|osf_xfloating_ops
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ops
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
name|ops
index|[
name|i
index|]
operator|.
name|func
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Most X_floating operations take the rounding mode as an argument.    Compute that here.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_compute_xfloating_mode_arg
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|alpha_fp_rounding_mode
name|round
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
switch|switch
condition|(
name|round
condition|)
block|{
case|case
name|ALPHA_FPRM_NORM
case|:
name|mode
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ALPHA_FPRM_MINF
case|:
name|mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ALPHA_FPRM_CHOP
case|:
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ALPHA_FPRM_DYN
case|:
name|mode
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* XXX For reference, round to +inf is mode = 3.  */
block|}
if|if
condition|(
name|code
operator|==
name|FLOAT_TRUNCATE
operator|&&
name|alpha_fptm
operator|==
name|ALPHA_FPTM_N
condition|)
name|mode
operator||=
literal|0x10000
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Emit an X_floating library function call.     Note that these functions do not follow normal calling conventions:    TFmode arguments are passed in two integer registers (as opposed to    indirect); TFmode return values appear in R16+R17.      FUNC is the function name to call.    TARGET is where the output belongs.    OPERANDS are the inputs.    NOPERANDS is the count of inputs.    EQUIV is the expression equivalent for the function. */
end_comment

begin_function
specifier|static
name|void
name|alpha_emit_xfloating_libcall
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|,
name|int
name|noperands
parameter_list|,
name|rtx
name|equiv
parameter_list|)
block|{
name|rtx
name|usage
init|=
name|NULL_RTX
decl_stmt|,
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|regno
init|=
literal|16
decl_stmt|,
name|i
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
name|TFmode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|TFmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regno
operator|+
literal|32
argument_list|)
expr_stmt|;
name|regno
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|VOIDmode
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|DImode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|usage
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|TFmode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|TFmode
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|init_one_libfunc
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_call_insn
argument_list|(
name|GEN_CALL_VALUE
argument_list|(
name|reg
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|tmp
argument_list|)
operator|=
name|usage
expr_stmt|;
name|tmp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|tmp
argument_list|,
name|target
argument_list|,
name|reg
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an X_floating library function call for arithmetic (+,-,*,/).  */
end_comment

begin_function
name|void
name|alpha_emit_xfloating_arith
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|rtx
name|out_operands
index|[
literal|3
index|]
decl_stmt|;
name|func
operator|=
name|alpha_lookup_xfloating_lib_func
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|mode
operator|=
name|alpha_compute_xfloating_mode_arg
argument_list|(
name|code
argument_list|,
name|alpha_fprm
argument_list|)
expr_stmt|;
name|out_operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|out_operands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|out_operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|alpha_emit_xfloating_libcall
argument_list|(
name|func
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|out_operands
argument_list|,
literal|3
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|TFmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an X_floating library function call for a comparison.  */
end_comment

begin_function
specifier|static
name|rtx
name|alpha_emit_xfloating_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|rtx
name|out
decl_stmt|,
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|func
operator|=
name|alpha_lookup_xfloating_lib_func
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|out
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
comment|/* ??? Strange mode for equiv because what's actually returned      is -1,0,1, not a proper boolean value.  */
name|alpha_emit_xfloating_libcall
argument_list|(
name|func
argument_list|,
name|out
argument_list|,
name|operands
argument_list|,
literal|2
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|CCmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/* Emit an X_floating library function call for a conversion.  */
end_comment

begin_function
name|void
name|alpha_emit_xfloating_cvt
parameter_list|(
name|enum
name|rtx_code
name|orig_code
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|int
name|noperands
init|=
literal|1
decl_stmt|,
name|mode
decl_stmt|;
name|rtx
name|out_operands
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|orig_code
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|UNSIGNED_FIX
condition|)
name|code
operator|=
name|FIX
expr_stmt|;
name|func
operator|=
name|alpha_lookup_xfloating_lib_func
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|out_operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FIX
case|:
name|mode
operator|=
name|alpha_compute_xfloating_mode_arg
argument_list|(
name|code
argument_list|,
name|ALPHA_FPRM_CHOP
argument_list|)
expr_stmt|;
name|out_operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|noperands
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|mode
operator|=
name|alpha_compute_xfloating_mode_arg
argument_list|(
name|code
argument_list|,
name|alpha_fprm
argument_list|)
expr_stmt|;
name|out_operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|noperands
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|alpha_emit_xfloating_libcall
argument_list|(
name|func
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|out_operands
argument_list|,
name|noperands
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|orig_code
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split a TFmode OP[1] into DImode OP[2,3] and likewise for    OP[0] into OP[0,1].  Naturally, output operand ordering is    little-endian.  */
end_comment

begin_function
name|void
name|alpha_split_tfmode_pair
parameter_list|(
name|rtx
name|operands
index|[
literal|4
index|]
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|operands
index|[
literal|3
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|operands
index|[
literal|3
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|CONST0_RTX
argument_list|(
name|TFmode
argument_list|)
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|3
index|]
operator|=
name|const0_rtx
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement negtf2 or abstf2.  Op0 is destination, op1 is source,     op2 is a register containing the sign bit, operation is the     logical operation to be performed.  */
end_comment

begin_function
name|void
name|alpha_split_tfmode_frobsign
parameter_list|(
name|rtx
name|operands
index|[
literal|3
index|]
parameter_list|,
name|rtx
function_decl|(
modifier|*
name|operation
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|)
block|{
name|rtx
name|high_bit
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|scratch
decl_stmt|;
name|int
name|move
decl_stmt|;
name|alpha_split_tfmode_pair
argument_list|(
name|operands
argument_list|)
expr_stmt|;
comment|/* Detect three flavors of operand overlap.  */
name|move
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
name|move
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|high_bit
argument_list|)
condition|)
name|move
operator|=
literal|2
expr_stmt|;
else|else
name|move
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|move
operator|<
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* ??? If the destination overlaps both source tf and high_bit, then      assume source tf is dead in its entirety and use the other half      for a scratch register.  Otherwise "scratch" is just the proper      destination register.  */
name|scratch
operator|=
name|operands
index|[
name|move
operator|<
literal|2
condition|?
literal|1
else|:
literal|3
index|]
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|operation
call|)
argument_list|(
name|scratch
argument_list|,
name|high_bit
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move
operator|>
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|move
operator|>
literal|1
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use ext[wlq][lh] as the Architecture Handbook describes for extracting    unaligned data:             unsigned:                       signed:    word:   ldq_u  r1,X(r11)                ldq_u  r1,X(r11)            ldq_u  r2,X+1(r11)              ldq_u  r2,X+1(r11)            lda    r3,X(r11)                lda    r3,X+2(r11)            extwl  r1,r3,r1                 extql  r1,r3,r1            extwh  r2,r3,r2                 extqh  r2,r3,r2            or     r1.r2.r1                 or     r1,r2,r1                                            sra    r1,48,r1     long:   ldq_u  r1,X(r11)                ldq_u  r1,X(r11)            ldq_u  r2,X+3(r11)              ldq_u  r2,X+3(r11)            lda    r3,X(r11)                lda    r3,X(r11)            extll  r1,r3,r1                 extll  r1,r3,r1            extlh  r2,r3,r2                 extlh  r2,r3,r2            or     r1.r2.r1                 addl   r1,r2,r1     quad:   ldq_u  r1,X(r11)            ldq_u  r2,X+7(r11)            lda    r3,X(r11)            extql  r1,r3,r1            extqh  r2,r3,r2            or     r1.r2.r1 */
end_comment

begin_function
name|void
name|alpha_expand_unaligned_load
parameter_list|(
name|rtx
name|tgt
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|HOST_WIDE_INT
name|ofs
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|rtx
name|meml
decl_stmt|,
name|memh
decl_stmt|,
name|addr
decl_stmt|,
name|extl
decl_stmt|,
name|exth
decl_stmt|,
name|tmp
decl_stmt|,
name|mema
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|meml
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|memh
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|extl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|exth
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|mema
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mema
argument_list|)
operator|==
name|LO_SUM
condition|)
name|mema
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mema
argument_list|)
expr_stmt|;
comment|/* AND addresses cannot be in any alias set, since they may implicitly      alias surrounding code.  Ideally we'd have some alias set that       covered all types except those with alignment 8 or higher.  */
name|tmp
operator|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|meml
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memh
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|sign
operator|&&
operator|(
name|size
operator|==
literal|2
operator|||
name|size
operator|==
literal|4
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extqh_be
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl_be
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|GEN_INT
argument_list|(
literal|64
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|extl
argument_list|,
name|exth
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ashr_optab
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
literal|64
operator|-
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sign
operator|&&
name|size
operator|==
literal|2
condition|)
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl_le
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|GEN_INT
argument_list|(
literal|64
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extqh_le
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must use tgt here for the target.  Alpha-vms port fails if we use 	 addr for the target, because addr is marked as a pointer and combine 	 knows that pointers are always sign-extended 32 bit values.  */
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|extl
argument_list|,
name|exth
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ashr_optab
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
literal|48
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_extwh_be
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_extlh_be
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_extqh_be
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_extxl_be
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|plus_constant
argument_list|(
name|mema
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl_le
argument_list|(
name|extl
argument_list|,
name|meml
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_extwh_le
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_extlh_le
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_extqh_le
argument_list|(
name|exth
argument_list|,
name|memh
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|addr
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|extl
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|exth
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|tgt
argument_list|)
argument_list|,
name|sign
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
name|tgt
condition|)
name|emit_move_insn
argument_list|(
name|tgt
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|tgt
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, use ins and msk instructions to perform unaligned stores.  */
end_comment

begin_function
name|void
name|alpha_expand_unaligned_store
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|,
name|HOST_WIDE_INT
name|ofs
parameter_list|)
block|{
name|rtx
name|dstl
decl_stmt|,
name|dsth
decl_stmt|,
name|addr
decl_stmt|,
name|insl
decl_stmt|,
name|insh
decl_stmt|,
name|meml
decl_stmt|,
name|memh
decl_stmt|,
name|dsta
decl_stmt|;
name|dstl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|dsth
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|insl
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|insh
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|dsta
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dsta
argument_list|)
operator|==
name|LO_SUM
condition|)
name|dsta
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|dsta
argument_list|)
expr_stmt|;
comment|/* AND addresses cannot be in any alias set, since they may implicitly      alias surrounding code.  Ideally we'd have some alias set that       covered all types except those with alignment 8 or higher.  */
name|meml
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|dsta
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|meml
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memh
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|dsta
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|memh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dsth
argument_list|,
name|memh
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dstl
argument_list|,
name|meml
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|dsta
argument_list|,
name|ofs
operator|+
name|size
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_inswl_be
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_insll_be
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_insql_be
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|insl
argument_list|,
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_mskxl_be
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffff
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
block|{
name|rtx
name|msk
init|=
name|immed_double_const
argument_list|(
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_mskxl_be
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|msk
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_mskxl_be
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|constm1_rtx
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|copy_addr_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|dsta
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|insh
argument_list|,
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_inswl_le
argument_list|(
name|insl
argument_list|,
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|gen_insll_le
argument_list|(
name|insl
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_insql_le
argument_list|(
name|insl
argument_list|,
name|src
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|dsth
argument_list|,
name|dsth
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|size
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_mskxl_le
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffff
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
block|{
name|rtx
name|msk
init|=
name|immed_double_const
argument_list|(
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_mskxl_le
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|msk
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|8
case|:
name|emit_insn
argument_list|(
name|gen_mskxl_le
argument_list|(
name|dstl
argument_list|,
name|dstl
argument_list|,
name|constm1_rtx
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
name|dsth
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|insh
argument_list|,
name|dsth
argument_list|,
name|dsth
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|dstl
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|insl
argument_list|,
name|dstl
argument_list|,
name|dstl
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_move_insn
argument_list|(
name|meml
argument_list|,
name|dstl
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memh
argument_list|,
name|dsth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Must store high before low for degenerate case of aligned.  */
name|emit_move_insn
argument_list|(
name|memh
argument_list|,
name|dsth
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|meml
argument_list|,
name|dstl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The block move code tries to maximize speed by separating loads and    stores at the expense of register pressure: we load all of the data    before we store it back out.  There are two secondary effects worth    mentioning, that this speeds copying to/from aligned and unaligned    buffers, and that it makes the code significantly easier to write.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MOVE_WORDS
value|8
end_define

begin_comment
comment|/* Load an integral number of consecutive unaligned quadwords.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_expand_unaligned_load_words
parameter_list|(
name|rtx
modifier|*
name|out_regs
parameter_list|,
name|rtx
name|smem
parameter_list|,
name|HOST_WIDE_INT
name|words
parameter_list|,
name|HOST_WIDE_INT
name|ofs
parameter_list|)
block|{
name|rtx
specifier|const
name|im8
init|=
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
decl_stmt|;
name|rtx
specifier|const
name|i64
init|=
name|GEN_INT
argument_list|(
literal|64
argument_list|)
decl_stmt|;
name|rtx
name|ext_tmps
index|[
name|MAX_MOVE_WORDS
index|]
decl_stmt|,
name|data_regs
index|[
name|MAX_MOVE_WORDS
operator|+
literal|1
index|]
decl_stmt|;
name|rtx
name|sreg
decl_stmt|,
name|areg
decl_stmt|,
name|tmp
decl_stmt|,
name|smema
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|smema
operator|=
name|XEXP
argument_list|(
name|smem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|smema
argument_list|)
operator|==
name|LO_SUM
condition|)
name|smema
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|smema
argument_list|)
expr_stmt|;
comment|/* Generate all the tmp registers we need.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|data_regs
index|[
name|i
index|]
operator|=
name|out_regs
index|[
name|i
index|]
expr_stmt|;
name|ext_tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
name|data_regs
index|[
name|words
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
name|smem
operator|=
name|adjust_address
argument_list|(
name|smem
argument_list|,
name|GET_MODE
argument_list|(
name|smem
argument_list|)
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
comment|/* Load up all of the source data.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|tmp
operator|=
name|change_address
argument_list|(
name|smem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|smema
argument_list|,
literal|8
operator|*
name|i
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|change_address
argument_list|(
name|smem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|smema
argument_list|,
literal|8
operator|*
name|words
operator|-
literal|1
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|words
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Extract the half-word fragments.  Unfortunately DEC decided to make      extxh with offset zero a noop instead of zeroing the register, so       we must take care of that edge condition ourselves with cmov.  */
name|sreg
operator|=
name|copy_addr_to_reg
argument_list|(
name|smema
argument_list|)
expr_stmt|;
name|areg
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|and_optab
argument_list|,
name|sreg
argument_list|,
name|GEN_INT
argument_list|(
literal|7
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|emit_move_insn
argument_list|(
name|sreg
argument_list|,
name|plus_constant
argument_list|(
name|sreg
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_extqh_be
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extxl_be
argument_list|(
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|i64
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_extxl_le
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|i64
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extqh_le
argument_list|(
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_EQ
argument_list|(
name|DImode
argument_list|,
name|areg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the half-words into whole words.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|out_regs
index|[
name|i
index|]
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|ext_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store an integral number of consecutive unaligned quadwords.  DATA_REGS    may be NULL to store zeros.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_expand_unaligned_store_words
parameter_list|(
name|rtx
modifier|*
name|data_regs
parameter_list|,
name|rtx
name|dmem
parameter_list|,
name|HOST_WIDE_INT
name|words
parameter_list|,
name|HOST_WIDE_INT
name|ofs
parameter_list|)
block|{
name|rtx
specifier|const
name|im8
init|=
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
decl_stmt|;
name|rtx
specifier|const
name|i64
init|=
name|GEN_INT
argument_list|(
literal|64
argument_list|)
decl_stmt|;
name|rtx
name|ins_tmps
index|[
name|MAX_MOVE_WORDS
index|]
decl_stmt|;
name|rtx
name|st_tmp_1
decl_stmt|,
name|st_tmp_2
decl_stmt|,
name|dreg
decl_stmt|;
name|rtx
name|st_addr_1
decl_stmt|,
name|st_addr_2
decl_stmt|,
name|dmema
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|dmema
operator|=
name|XEXP
argument_list|(
name|dmem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dmema
argument_list|)
operator|==
name|LO_SUM
condition|)
name|dmema
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|dmema
argument_list|)
expr_stmt|;
comment|/* Generate all the tmp registers we need.  */
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|ins_tmps
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|st_tmp_1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|st_tmp_2
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
name|dmem
operator|=
name|adjust_address
argument_list|(
name|dmem
argument_list|,
name|GET_MODE
argument_list|(
name|dmem
argument_list|)
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|st_addr_2
operator|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|dmema
argument_list|,
name|words
operator|*
literal|8
operator|-
literal|1
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|st_addr_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st_addr_1
operator|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|dmema
argument_list|,
name|im8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|st_addr_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Load up the destination end bits.  */
name|emit_move_insn
argument_list|(
name|st_tmp_2
argument_list|,
name|st_addr_2
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|st_tmp_1
argument_list|,
name|st_addr_1
argument_list|)
expr_stmt|;
comment|/* Shift the input data into place.  */
name|dreg
operator|=
name|copy_addr_to_reg
argument_list|(
name|dmema
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|emit_move_insn
argument_list|(
name|dreg
argument_list|,
name|plus_constant
argument_list|(
name|dreg
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_insql_be
argument_list|(
name|ins_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_insxh
argument_list|(
name|ins_tmps
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_insql_le
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Split and merge the ends with the destination data.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_mskxl_be
argument_list|(
name|st_tmp_2
argument_list|,
name|st_tmp_2
argument_list|,
name|constm1_rtx
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|st_tmp_1
argument_list|,
name|st_tmp_1
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_mskxh
argument_list|(
name|st_tmp_2
argument_list|,
name|st_tmp_2
argument_list|,
name|i64
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mskxl_le
argument_list|(
name|st_tmp_1
argument_list|,
name|st_tmp_1
argument_list|,
name|constm1_rtx
argument_list|,
name|dreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data_regs
operator|!=
name|NULL
condition|)
block|{
name|st_tmp_2
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|st_tmp_2
argument_list|,
name|ins_tmps
index|[
name|words
operator|-
literal|1
index|]
argument_list|,
name|st_tmp_2
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|st_tmp_1
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|ior_optab
argument_list|,
name|st_tmp_1
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|,
name|st_tmp_1
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* Store it all.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|emit_move_insn
argument_list|(
name|st_addr_1
argument_list|,
name|st_tmp_1
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|st_addr_2
argument_list|,
name|st_tmp_2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|words
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|tmp
init|=
name|change_address
argument_list|(
name|dmem
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|dmema
argument_list|,
name|WORDS_BIG_ENDIAN
condition|?
name|i
operator|*
literal|8
operator|-
literal|1
else|:
name|i
operator|*
literal|8
argument_list|)
argument_list|,
name|im8
argument_list|)
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|data_regs
condition|?
name|ins_tmps
index|[
name|i
operator|-
literal|1
index|]
else|:
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|emit_move_insn
argument_list|(
name|st_addr_2
argument_list|,
name|st_tmp_2
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|st_addr_1
argument_list|,
name|st_tmp_1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand string/block move operations.     operands[0] is the pointer to the destination.    operands[1] is the pointer to the source.    operands[2] is the number of bytes to move.    operands[3] is the alignment.  */
end_comment

begin_function
name|int
name|alpha_expand_block_move
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|orig_bytes
init|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bytes
init|=
name|orig_bytes
decl_stmt|;
name|HOST_WIDE_INT
name|src_align
init|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|dst_align
init|=
name|src_align
decl_stmt|;
name|rtx
name|orig_src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|orig_dst
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|data_regs
index|[
literal|2
operator|*
name|MAX_MOVE_WORDS
operator|+
literal|16
index|]
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|words
decl_stmt|,
name|ofs
decl_stmt|,
name|nregs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|orig_bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|orig_bytes
operator|>
name|MAX_MOVE_WORDS
operator|*
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
comment|/* Look for additional alignment information from recorded register info.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|src_align
operator|=
name|MAX
argument_list|(
name|src_align
argument_list|,
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|src_align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|64
operator|&&
name|c
operator|%
literal|8
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|32
operator|&&
name|c
operator|%
literal|4
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|16
operator|&&
name|c
operator|%
literal|2
operator|==
literal|0
condition|)
name|src_align
operator|=
literal|16
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|dst_align
operator|=
name|MAX
argument_list|(
name|dst_align
argument_list|,
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|dst_align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|64
operator|&&
name|c
operator|%
literal|8
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|32
operator|&&
name|c
operator|%
literal|4
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|16
operator|&&
name|c
operator|%
literal|2
operator|==
literal|0
condition|)
name|dst_align
operator|=
literal|16
expr_stmt|;
block|}
block|}
comment|/* Load the entire block into registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't use the existing register if we're reading more than 	 is held in the register.  Nor if there is not a mode that 	 handles the exact size.  */
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|mode
operator|!=
name|BLKmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|>=
name|bytes
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
block|{
name|data_regs
index|[
name|nregs
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|data_regs
index|[
name|nregs
operator|+
literal|1
index|]
operator|=
name|gen_highpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|nregs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|src_done
goto|;
block|}
comment|/* No appropriate mode; fall back on memory.  */
name|orig_src
operator|=
name|replace_equiv_address
argument_list|(
name|orig_src
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_align
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ofs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|src_align
operator|>=
literal|64
operator|&&
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
argument_list|,
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|DImode
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|src_align
operator|>=
literal|32
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|emit_move_insn
argument_list|(
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
argument_list|,
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|SImode
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|4
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|data_regs
index|[
name|nregs
operator|+
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load_words
argument_list|(
name|data_regs
operator|+
name|nregs
argument_list|,
name|orig_src
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|nregs
operator|+=
name|words
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_BWX
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load
argument_list|(
name|tmp
argument_list|,
name|orig_src
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|src_align
operator|>=
literal|16
condition|)
block|{
do|do
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|HImode
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|bytes
operator|>=
literal|2
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_BWX
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|alpha_expand_unaligned_load
argument_list|(
name|tmp
argument_list|,
name|orig_src
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|data_regs
index|[
name|nregs
operator|++
index|]
operator|=
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|QImode
argument_list|,
name|ofs
argument_list|)
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|1
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
name|src_done
label|:
if|if
condition|(
name|nregs
operator|>
name|ARRAY_SIZE
argument_list|(
name|data_regs
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now save it back out again.  */
name|i
operator|=
literal|0
operator|,
name|ofs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|orig_bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|mode
condition|)
block|{
if|if
condition|(
name|nregs
operator|==
literal|1
condition|)
block|{
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
goto|goto
name|dst_done
goto|;
block|}
elseif|else
if|if
condition|(
name|nregs
operator|==
literal|2
operator|&&
name|mode
operator|==
name|TImode
condition|)
block|{
comment|/* Undo the subregging done above when copying between 		 two TImode registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|TImode
condition|)
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|SUBREG_REG
argument_list|(
name|data_regs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|DImode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|data_regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|seq
argument_list|,
name|tmp
argument_list|,
name|data_regs
index|[
literal|0
index|]
argument_list|,
name|data_regs
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|2
expr_stmt|;
goto|goto
name|dst_done
goto|;
block|}
block|}
comment|/* ??? If nregs> 1, consider reconstructing the word in regs.  */
comment|/* ??? Optimize mode< dst_mode with strict_low_part.  */
comment|/* No appropriate mode; fall back on memory.  We can speed things 	 up by recognizing extra alignment information.  */
name|orig_dst
operator|=
name|replace_equiv_address
argument_list|(
name|orig_dst
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dst_align
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the data in whatever chunks reading the source allowed.  */
if|if
condition|(
name|dst_align
operator|>=
literal|64
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|8
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dst_align
operator|>=
literal|32
condition|)
block|{
comment|/* If the source has remaining DImode regs, write them out in 	 two pieces.  */
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|tmp
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|lshr_optab
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
operator|+
literal|4
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|8
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|DImode
condition|)
block|{
comment|/* Write out a remaining block of words using unaligned methods.  */
for|for
control|(
name|words
operator|=
literal|1
init|;
name|i
operator|+
name|words
operator|<
name|nregs
condition|;
name|words
operator|++
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
operator|+
name|words
index|]
argument_list|)
operator|!=
name|DImode
condition|)
break|break;
if|if
condition|(
name|words
operator|==
literal|1
condition|)
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|8
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
else|else
name|alpha_expand_unaligned_store_words
argument_list|(
name|data_regs
operator|+
name|i
argument_list|,
name|orig_dst
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|i
operator|+=
name|words
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
comment|/* Due to the above, this won't be aligned.  */
comment|/* ??? If we have more than one of these, consider constructing full      words in registers and using alpha_expand_unaligned_store_words.  */
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dst_align
operator|>=
literal|16
condition|)
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|HImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|HImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|HImode
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|nregs
operator|&&
name|GET_MODE
argument_list|(
name|data_regs
index|[
name|i
index|]
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|QImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|data_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
name|dst_done
label|:
if|if
condition|(
name|i
operator|!=
name|nregs
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|alpha_expand_block_clear
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|orig_bytes
init|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bytes
init|=
name|orig_bytes
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|alignofs
init|=
literal|0
decl_stmt|;
name|rtx
name|orig_dst
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|words
decl_stmt|,
name|ofs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|orig_bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|orig_bytes
operator|>
name|MAX_MOVE_WORDS
operator|*
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
comment|/* Look for stricter alignment.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|a
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|align
condition|)
block|{
if|if
condition|(
name|a
operator|>=
literal|64
condition|)
name|align
operator|=
name|a
operator|,
name|alignofs
operator|=
literal|8
operator|-
name|c
operator|%
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|32
condition|)
name|align
operator|=
name|a
operator|,
name|alignofs
operator|=
literal|4
operator|-
name|c
operator|%
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|16
condition|)
name|align
operator|=
name|a
operator|,
name|alignofs
operator|=
literal|2
operator|-
name|c
operator|%
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
block|{
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* No appropriate mode; fall back on memory.  */
name|orig_dst
operator|=
name|replace_equiv_address
argument_list|(
name|orig_dst
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle an unaligned prefix first.  */
if|if
condition|(
name|alignofs
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
comment|/* Given that alignofs is bounded by align, the only time BWX could 	 generate three stores is for a 7 byte fill.  Prefer two individual 	 stores over a load/mask/store sequence.  */
if|if
condition|(
operator|(
operator|!
name|TARGET_BWX
operator|||
name|alignofs
operator|==
literal|7
operator|)
operator|&&
name|align
operator|>=
literal|32
operator|&&
operator|!
operator|(
name|alignofs
operator|==
literal|4
operator|&&
name|bytes
operator|>=
literal|4
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
operator|(
name|align
operator|>=
literal|64
condition|?
name|DImode
else|:
name|SImode
operator|)
decl_stmt|;
name|int
name|inv_alignofs
init|=
operator|(
name|align
operator|>=
literal|64
condition|?
literal|8
else|:
literal|4
operator|)
operator|-
name|alignofs
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|tmp
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|mode
argument_list|,
name|ofs
operator|-
name|inv_alignofs
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|inv_alignofs
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
name|alignofs
condition|)
block|{
name|mask
operator||=
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
operator|(
name|inv_alignofs
operator|+
name|bytes
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|ofs
operator|+=
name|bytes
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bytes
operator|-=
name|alignofs
expr_stmt|;
name|ofs
operator|+=
name|alignofs
expr_stmt|;
block|}
name|alignofs
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|mem
argument_list|,
name|GEN_INT
argument_list|(
name|mask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TARGET_BWX
operator|&&
operator|(
name|alignofs
operator|&
literal|1
operator|)
operator|&&
name|bytes
operator|>=
literal|1
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|QImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|1
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
name|alignofs
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_BWX
operator|&&
name|align
operator|>=
literal|16
operator|&&
operator|(
name|alignofs
operator|&
literal|3
operator|)
operator|==
literal|2
operator|&&
name|bytes
operator|>=
literal|2
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|HImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
name|alignofs
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|alignofs
operator|==
literal|4
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|alignofs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we've not used the extra lead alignment information by now, 	 we won't be able to.  Downgrade align to match what's left over.  */
if|if
condition|(
name|alignofs
operator|>
literal|0
condition|)
block|{
name|alignofs
operator|=
name|alignofs
operator|&
operator|-
name|alignofs
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
name|alignofs
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle a block of contiguous long-words.  */
if|if
condition|(
name|align
operator|>=
literal|64
operator|&&
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|8
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
comment|/* If the block is large and appropriately aligned, emit a single      store followed by a sequence of stq_u insns.  */
if|if
condition|(
name|align
operator|>=
literal|32
operator|&&
name|bytes
operator|>
literal|16
condition|)
block|{
name|rtx
name|orig_dsta
decl_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
name|orig_dsta
operator|=
name|XEXP
argument_list|(
name|orig_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_dsta
argument_list|)
operator|==
name|LO_SUM
condition|)
name|orig_dsta
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|orig_dsta
argument_list|)
expr_stmt|;
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|mem
init|=
name|change_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_AND
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|orig_dsta
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|8
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Depending on the alignment, the first stq_u may have overlapped 	 with the initial stl, which means that the last stq_u didn't 	 write as much as it would appear.  Leave those questionable bytes 	 unaccounted for.  */
name|bytes
operator|-=
name|words
operator|*
literal|8
operator|-
literal|4
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
operator|-
literal|4
expr_stmt|;
block|}
comment|/* Handle a smaller block of aligned words.  */
if|if
condition|(
operator|(
name|align
operator|>=
literal|64
operator|&&
name|bytes
operator|==
literal|4
operator|)
operator|||
operator|(
name|align
operator|==
literal|32
operator|&&
name|bytes
operator|>=
literal|4
operator|)
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
operator|++
name|i
control|)
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
operator|+
name|i
operator|*
literal|4
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|4
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|4
expr_stmt|;
block|}
comment|/* An unaligned block uses stq_u stores for as many as possible.  */
if|if
condition|(
name|bytes
operator|>=
literal|8
condition|)
block|{
name|words
operator|=
name|bytes
operator|/
literal|8
expr_stmt|;
name|alpha_expand_unaligned_store_words
argument_list|(
name|NULL
argument_list|,
name|orig_dst
argument_list|,
name|words
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|words
operator|*
literal|8
expr_stmt|;
name|ofs
operator|+=
name|words
operator|*
literal|8
expr_stmt|;
block|}
comment|/* Next clean up any trailing pieces.  */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
comment|/* Count the number of bits in BYTES for which aligned stores could      be emitted.  */
name|words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|TARGET_BWX
condition|?
literal|1
else|:
literal|4
operator|)
init|;
name|i
operator|*
name|BITS_PER_UNIT
operator|<=
name|align
condition|;
name|i
operator|<<=
literal|1
control|)
if|if
condition|(
name|bytes
operator|&
name|i
condition|)
name|words
operator|+=
literal|1
expr_stmt|;
comment|/* If we have appropriate alignment (and it wouldn't take too many      instructions otherwise), mask out the bytes we need.  */
if|if
condition|(
name|TARGET_BWX
condition|?
name|words
operator|>
literal|2
else|:
name|bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|align
operator|>=
literal|64
condition|)
block|{
name|rtx
name|mem
decl_stmt|,
name|tmp
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|DImode
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|bytes
operator|*
literal|8
operator|)
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|and_optab
argument_list|,
name|mem
argument_list|,
name|GEN_INT
argument_list|(
name|mask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|align
operator|>=
literal|32
operator|&&
name|bytes
operator|<
literal|4
condition|)
block|{
name|rtx
name|mem
decl_stmt|,
name|tmp
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|mem
operator|=
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|SImode
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|bytes
operator|*
literal|8
operator|)
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|and_optab
argument_list|,
name|mem
argument_list|,
name|GEN_INT
argument_list|(
name|mask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|TARGET_BWX
operator|&&
name|bytes
operator|>=
literal|4
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|const0_rtx
argument_list|,
literal|4
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
name|ofs
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|align
operator|>=
literal|16
condition|)
block|{
do|do
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|HImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|bytes
operator|>=
literal|2
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_BWX
condition|)
block|{
name|alpha_expand_unaligned_store
argument_list|(
name|orig_dst
argument_list|,
name|const0_rtx
argument_list|,
literal|2
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
name|ofs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|orig_dst
argument_list|,
name|QImode
argument_list|,
name|ofs
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|1
expr_stmt|;
name|ofs
operator|+=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns a mask so that zap(x, value) == x& mask.  */
end_comment

begin_function
name|rtx
name|alpha_expand_zap_mask
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|mask
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|value
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
condition|)
name|mask
operator||=
literal|0xff
expr_stmt|;
block|}
name|result
operator|=
name|gen_int_mode
argument_list|(
name|mask
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
condition|)
block|{
name|HOST_WIDE_INT
name|mask_lo
init|=
literal|0
decl_stmt|,
name|mask_hi
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|4
condition|;
operator|--
name|i
control|)
block|{
name|mask_hi
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|value
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
condition|)
name|mask_hi
operator||=
literal|0xff
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|mask_lo
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|value
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
condition|)
name|mask_lo
operator||=
literal|0xff
expr_stmt|;
block|}
name|result
operator|=
name|immed_double_const
argument_list|(
name|mask_lo
argument_list|,
name|mask_hi
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|alpha_expand_builtin_vector_binop
parameter_list|(
name|rtx
function_decl|(
modifier|*
name|gen
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|==
name|const0_rtx
condition|)
name|op2
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|op2
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen
call|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_insn_type
decl_stmt|;
comment|/* If the dependence is an anti-dependence, there is no cost.  For an      output dependence, there is sometimes a cost, but it doesn't seem      worth handling those few cases.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|cost
return|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_insn_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* Bring in the user-defined memory latency.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_ILD
operator|||
name|dep_insn_type
operator|==
name|TYPE_FLD
operator|||
name|dep_insn_type
operator|==
name|TYPE_LDSYM
condition|)
name|cost
operator|+=
name|alpha_memory_latency
operator|-
literal|1
expr_stmt|;
comment|/* Everything else handled in DFA bypasses now.  */
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* The number of instructions that can be issued per cycle.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV4
condition|?
literal|2
else|:
literal|4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* How many alternative schedules to try.  This should be as wide as the    scheduling freedom in the DFA, but no wider.  Making this value too    large results extra work for the scheduler.     For EV4, loads can be issued to either IB0 or IB1, thus we have 2    alternative schedules.  For EV5, we can choose between E0/E1 and    FA/FM.  For EV6, an arithmetic insn can be issued to U0/U1/L0/L1.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV6
condition|?
literal|4
else|:
literal|2
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Machine-specific function data.  */
end_comment

begin_decl_stmt
name|struct
name|machine_function
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* For unicosmk.  */
comment|/* List of call information words for calls from this function.  */
name|struct
name|rtx_def
modifier|*
name|first_ciw
decl_stmt|;
name|struct
name|rtx_def
modifier|*
name|last_ciw
decl_stmt|;
name|int
name|ciw_count
decl_stmt|;
comment|/* List of deferred case vectors.  */
name|struct
name|rtx_def
modifier|*
name|addr_list
decl_stmt|;
comment|/* For OSF.  */
specifier|const
name|char
modifier|*
name|some_ld_name
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* How to allocate a 'struct machine_function'.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|alpha_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|machine_function
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Functions to save and restore alpha_return_addr_rtx.  */
end_comment

begin_comment
comment|/* Start the ball rolling with RETURN_ADDR_RTX.  */
end_comment

begin_function
name|rtx
name|alpha_return_addr
parameter_list|(
name|int
name|count
parameter_list|,
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|const0_rtx
return|;
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|REG_RA
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return or create a pseudo containing the gp value for the current    function.  Needed only if TARGET_LD_BUGGY_LDGP.  */
end_comment

begin_function
name|rtx
name|alpha_gp_save_rtx
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|r
init|=
name|get_hard_reg_initial_val
argument_list|(
name|DImode
argument_list|,
literal|29
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|!=
name|MEM
condition|)
name|r
operator|=
name|gen_mem_addressof
argument_list|(
name|r
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*rescan=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_ra_ever_killed
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|top
decl_stmt|;
if|if
condition|(
operator|!
name|has_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|REG_RA
argument_list|)
condition|)
return|return
name|regs_ever_live
index|[
name|REG_RA
index|]
return|;
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|top
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|reg_set_between_p
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REG_RA
argument_list|)
argument_list|,
name|top
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the trap mode suffix applicable to the current    instruction, or NULL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_trap_mode_suffix
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|attr_trap_suffix
name|s
init|=
name|get_attr_trap_suffix
argument_list|(
name|current_output_insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|TRAP_SUFFIX_NONE
case|:
return|return
name|NULL
return|;
case|case
name|TRAP_SUFFIX_SU
case|:
if|if
condition|(
name|alpha_fptm
operator|>=
name|ALPHA_FPTM_SU
condition|)
return|return
literal|"su"
return|;
return|return
name|NULL
return|;
case|case
name|TRAP_SUFFIX_SUI
case|:
if|if
condition|(
name|alpha_fptm
operator|>=
name|ALPHA_FPTM_SUI
condition|)
return|return
literal|"sui"
return|;
return|return
name|NULL
return|;
case|case
name|TRAP_SUFFIX_V_SV
case|:
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
return|return
name|NULL
return|;
case|case
name|ALPHA_FPTM_U
case|:
return|return
literal|"v"
return|;
case|case
name|ALPHA_FPTM_SU
case|:
case|case
name|ALPHA_FPTM_SUI
case|:
return|return
literal|"sv"
return|;
block|}
break|break;
case|case
name|TRAP_SUFFIX_V_SV_SVI
case|:
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
return|return
name|NULL
return|;
case|case
name|ALPHA_FPTM_U
case|:
return|return
literal|"v"
return|;
case|case
name|ALPHA_FPTM_SU
case|:
return|return
literal|"sv"
return|;
case|case
name|ALPHA_FPTM_SUI
case|:
return|return
literal|"svi"
return|;
block|}
break|break;
case|case
name|TRAP_SUFFIX_U_SU_SUI
case|:
switch|switch
condition|(
name|alpha_fptm
condition|)
block|{
case|case
name|ALPHA_FPTM_N
case|:
return|return
name|NULL
return|;
case|case
name|ALPHA_FPTM_U
case|:
return|return
literal|"u"
return|;
case|case
name|ALPHA_FPTM_SU
case|:
return|return
literal|"su"
return|;
case|case
name|ALPHA_FPTM_SUI
case|:
return|return
literal|"sui"
return|;
block|}
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the rounding mode suffix applicable to the current    instruction, or NULL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_round_mode_suffix
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|attr_round_suffix
name|s
init|=
name|get_attr_round_suffix
argument_list|(
name|current_output_insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|ROUND_SUFFIX_NONE
case|:
return|return
name|NULL
return|;
case|case
name|ROUND_SUFFIX_NORMAL
case|:
switch|switch
condition|(
name|alpha_fprm
condition|)
block|{
case|case
name|ALPHA_FPRM_NORM
case|:
return|return
name|NULL
return|;
case|case
name|ALPHA_FPRM_MINF
case|:
return|return
literal|"m"
return|;
case|case
name|ALPHA_FPRM_CHOP
case|:
return|return
literal|"c"
return|;
case|case
name|ALPHA_FPRM_DYN
case|:
return|return
literal|"d"
return|;
block|}
break|break;
case|case
name|ROUND_SUFFIX_C
case|:
return|return
literal|"c"
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in some movdi_er_tlsldm pattern.  */
end_comment

begin_function
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'~'
case|:
comment|/* Print the assembler name of the current function.  */
name|assemble_name
argument_list|(
name|file
argument_list|,
name|alpha_fnname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
block|{
specifier|const
name|char
modifier|*
name|trap
init|=
name|get_trap_mode_suffix
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|round
init|=
name|get_round_mode_suffix
argument_list|()
decl_stmt|;
if|if
condition|(
name|trap
operator|||
name|round
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
operator|(
name|TARGET_AS_SLASH_BEFORE_SUFFIX
condition|?
literal|"/%s%s"
else|:
literal|"%s%s"
operator|)
argument_list|,
operator|(
name|trap
condition|?
name|trap
else|:
literal|""
operator|)
argument_list|,
operator|(
name|round
condition|?
name|round
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|','
case|:
comment|/* Generates single precision instruction suffix.  */
name|fputc
argument_list|(
operator|(
name|TARGET_FLOAT_VAX
condition|?
literal|'f'
else|:
literal|'s'
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* Generates double precision instruction suffix.  */
name|fputc
argument_list|(
operator|(
name|TARGET_FLOAT_VAX
condition|?
literal|'g'
else|:
literal|'t'
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
comment|/* Generates a nop after a noreturn call at the very end of the 	 function.  */
if|if
condition|(
name|next_real_insn
argument_list|(
name|current_output_insn
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|alpha_this_literal_sequence_number
operator|==
literal|0
condition|)
name|alpha_this_literal_sequence_number
operator|=
name|alpha_next_sequence_number
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|alpha_this_literal_sequence_number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|alpha_this_gpdisp_sequence_number
operator|==
literal|0
condition|)
name|alpha_this_gpdisp_sequence_number
operator|=
name|alpha_next_sequence_number
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|alpha_this_gpdisp_sequence_number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%H value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
block|{
specifier|const
name|char
modifier|*
name|lituse
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSGD_CALL
condition|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lituse
operator|=
literal|"lituse_tlsgd"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSLDM_CALL
condition|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lituse
operator|=
literal|"lituse_tlsldm"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|lituse
operator|=
literal|"lituse_jsr"
expr_stmt|;
else|else
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid %%J value"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|x
operator|!=
name|const0_rtx
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t\t!%s!%d"
argument_list|,
name|lituse
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* If this operand is the constant zero, write it as "$31".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%r value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Similar, but for floating-point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$f31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Write the 1's complement of a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Write 1<< C, for a constant C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Write the high-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%h value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Write the low-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%L value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x8000
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Write mask for ZAP insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|value
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|value
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|mask
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|,
name|value
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* 'b', 'w', 'l', or 'q' as the value of the constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|8
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|16
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|32
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|64
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|8
condition|?
literal|"b"
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|16
condition|?
literal|"w"
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|32
condition|?
literal|"l"
else|:
literal|"q"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Similar, except do it from the mask.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0xff
condition|)
block|{
name|fputc
argument_list|(
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
operator|==
literal|0xffff
condition|)
block|{
name|fputc
argument_list|(
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
operator|==
literal|0xffffffff
condition|)
block|{
name|fputc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|fputc
argument_list|(
literal|'q'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffffffff
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fputc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
name|output_operand_lossage
argument_list|(
literal|"invalid %%U value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Write the constant value divided by 8 for little-endian mode or 	 (56 - value) / 8 for big-endian mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|56
else|:
literal|64
operator|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|WORDS_BIG_ENDIAN
condition|?
operator|(
literal|56
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|8
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Same, except compute (64 - c) / 8 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|8
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
literal|64
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
block|{
comment|/* On Unicos/Mk systems: use a DEX expression if the symbol 	   clashes with a register name.  */
name|int
name|dex
init|=
name|unicosmk_need_dex
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|dex
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"DEX(%d)"
argument_list|,
name|dex
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
comment|/* Write out comparison name.  */
block|{
name|enum
name|rtx_code
name|c
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|c
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%C value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'D'
condition|)
name|c
operator|=
name|reverse_condition
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'c'
condition|)
name|c
operator|=
name|swap_condition
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'d'
condition|)
name|c
operator|=
name|swap_condition
argument_list|(
name|reverse_condition
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|LEU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ule"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|LTU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ult"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|UNORDERED
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"un"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
comment|/* Write the divide or modulus operator.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/* Write "_u" for unaligned access.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_u"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
switch|switch
condition|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_DTPREL
case|:
case|case
name|UNSPEC_TPREL
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"unknown relocation unspec"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_operand_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|int
name|basereg
init|=
literal|31
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|AND
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
specifier|const
name|char
modifier|*
name|reloc16
decl_stmt|,
modifier|*
name|reloclo
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_DTPREL
case|:
name|reloc16
operator|=
name|NULL
expr_stmt|;
name|reloclo
operator|=
operator|(
name|alpha_tls_size
operator|==
literal|16
condition|?
literal|"dtprel"
else|:
literal|"dtprello"
operator|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TPREL
case|:
name|reloc16
operator|=
name|NULL
expr_stmt|;
name|reloclo
operator|=
operator|(
name|alpha_tls_size
operator|==
literal|16
condition|?
literal|"tprel"
else|:
literal|"tprello"
operator|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"unknown relocation unspec"
argument_list|)
expr_stmt|;
return|return;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reloc16
operator|=
literal|"gprel"
expr_stmt|;
name|reloclo
operator|=
literal|"gprellow"
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|subreg_regno
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"($%d)\t\t!%s"
argument_list|,
name|basereg
argument_list|,
operator|(
name|basereg
operator|==
literal|29
condition|?
name|reloc16
else|:
name|reloclo
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|subreg_regno
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|XSTR
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s+"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
literal|"($%d)"
argument_list|,
name|offset
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline at    TRAMP. FNADDR is an RTX for the address of the function's pure    code.  CXT is an RTX for the static chain value for the function.     The three offset parameters are for the individual template's    layout.  A JMPOFS< 0 indicates that the trampoline does not     contain instructions at all.     We assume here that a function will be called many more times than    its address is taken (e.g., it might be passed to qsort), so we    take the trouble to initialize the "hint" field in the JMP insn.    Note that the hint field is PC (new) + 4 * bits 13:0.  */
end_comment

begin_function
name|void
name|alpha_initialize_trampoline
parameter_list|(
name|rtx
name|tramp
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|,
name|int
name|fnofs
parameter_list|,
name|int
name|cxtofs
parameter_list|,
name|int
name|jmpofs
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|,
name|temp1
decl_stmt|,
name|addr
decl_stmt|;
comment|/* VMS really uses DImode pointers in memory at this point.  */
name|enum
name|machine_mode
name|mode
init|=
name|TARGET_ABI_OPEN_VMS
condition|?
name|Pmode
else|:
name|ptr_mode
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|fnaddr
operator|=
name|convert_memory_address
argument_list|(
name|mode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|cxt
operator|=
name|convert_memory_address
argument_list|(
name|mode
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Store function address and CXT.  */
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|fnofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|cxtofs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
comment|/* This has been disabled since the hint only has a 32k range, and in      no existing OS is the stack within 32k of the text segment.  */
if|if
condition|(
literal|0
operator|&&
name|jmpofs
operator|>=
literal|0
condition|)
block|{
comment|/* Compute hint value.  */
name|temp
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|jmpofs
operator|+
literal|4
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|DImode
argument_list|,
name|sub_optab
argument_list|,
name|fnaddr
argument_list|,
name|temp
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|Pmode
argument_list|,
name|temp
argument_list|,
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_and
argument_list|(
name|SImode
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|temp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3fff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge in the hint.  */
name|addr
operator|=
name|memory_address
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|jmpofs
argument_list|)
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_and
argument_list|(
name|SImode
argument_list|,
name|temp1
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffffc000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|temp1
argument_list|,
name|temp
argument_list|,
name|temp1
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_EXECUTE_STACK
name|emit_library_call
argument_list|(
name|init_one_libfunc
argument_list|(
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|tramp
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|jmpofs
operator|>=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_imb
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).     On Alpha the first 6 words of args are normally in registers    and the rest are pushed.  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
name|CUMULATIVE_ARGS
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|basereg
decl_stmt|;
name|int
name|num_args
decl_stmt|;
comment|/* Don't get confused and pass small structures in FP registers.  */
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|basereg
operator|=
literal|16
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* With alpha_split_complex_arg, we shouldn't see any raw complex 	 values here.  */
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Set up defaults for FP operands passed in FP registers, and 	 integral operands passed in integer registers.  */
if|if
condition|(
name|TARGET_FPREGS
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|basereg
operator|=
literal|32
operator|+
literal|16
expr_stmt|;
else|else
name|basereg
operator|=
literal|16
expr_stmt|;
block|}
comment|/* ??? Irritatingly, the definition of CUMULATIVE_ARGS is different for      the three platforms, so we can't avoid conditional compilation.  */
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
return|return
name|alpha_arg_info_reg_val
argument_list|(
name|cum
argument_list|)
return|;
name|num_args
operator|=
name|cum
operator|.
name|num_args
expr_stmt|;
if|if
condition|(
name|num_args
operator|>=
literal|6
operator|||
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
block|}
elif|#
directive|elif
name|TARGET_ABI_UNICOSMK
block|{
name|int
name|size
decl_stmt|;
comment|/* If this is the last argument, generate the call info word (CIW).  */
comment|/* ??? We don't include the caller's line number in the CIW because 	 I don't know how to determine it if debug infos are turned off.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|;
name|rtx
name|ciw
decl_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cum
operator|.
name|num_reg_words
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cum
operator|.
name|reg_args_type
index|[
name|i
index|]
condition|)
name|lo
operator||=
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
name|i
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|cum
operator|.
name|num_reg_words
operator|==
literal|6
operator|&&
name|cum
operator|.
name|reg_args_type
index|[
literal|5
index|]
condition|)
name|lo
operator||=
literal|7
expr_stmt|;
else|else
name|lo
operator||=
name|cum
operator|.
name|num_reg_words
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|hi
operator|=
operator|(
name|cum
operator|.
name|num_args
operator|<<
literal|20
operator|)
operator||
name|cum
operator|.
name|num_arg_words
expr_stmt|;
else|#
directive|else
name|lo
operator|=
name|lo
operator||
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|cum
operator|.
name|num_args
operator|<<
literal|52
operator|)
operator||
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|cum
operator|.
name|num_arg_words
operator|<<
literal|32
operator|)
expr_stmt|;
name|hi
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ciw
operator|=
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_UNSPEC
argument_list|(
name|DImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|ciw
argument_list|)
argument_list|,
name|UNSPEC_UMK_LOAD_CIW
argument_list|)
return|;
block|}
name|size
operator|=
name|ALPHA_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
expr_stmt|;
name|num_args
operator|=
name|cum
operator|.
name|num_reg_words
expr_stmt|;
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|||
name|cum
operator|.
name|num_reg_words
operator|+
name|size
operator|>
literal|6
operator|||
name|cum
operator|.
name|force_stack
condition|)
return|return
name|NULL_RTX
return|;
elseif|else
if|if
condition|(
name|type
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
name|reg1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|num_args
operator|+
literal|16
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|DImode
argument_list|,
name|reg1
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* The argument fits in two registers. Note that we still need to 	     reserve a register for empty structures.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|NULL_RTX
return|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|1
condition|)
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg1
argument_list|)
argument_list|)
return|;
else|else
block|{
name|reg2
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|num_args
operator|+
literal|17
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|DImode
argument_list|,
name|reg2
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
elif|#
directive|elif
name|TARGET_ABI_OSF
block|{
if|if
condition|(
name|cum
operator|>=
literal|6
condition|)
return|return
name|NULL_RTX
return|;
name|num_args
operator|=
name|cum
expr_stmt|;
comment|/* VOID is passed as a special flag for "last argument".  */
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
name|basereg
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
elseif|else
if|if
condition|(
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
condition|)
name|basereg
operator|=
literal|16
expr_stmt|;
block|}
else|#
directive|else
error|#
directive|error
error|Unhandled ABI
endif|#
directive|endif
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|num_args
operator|+
name|basereg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE must be returned in memory, instead of in registers.  */
end_comment

begin_function
specifier|static
name|bool
name|alpha_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|type
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* All aggregates are returned in memory.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
block|}
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_VECTOR_FLOAT
case|:
comment|/* Pass all float vectors in memory, like an aggregate.  */
return|return
name|true
return|;
case|case
name|MODE_COMPLEX_FLOAT
case|:
comment|/* We judge complex floats on the size of their element, 	 not the size of the whole type.  */
name|size
operator|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_COMPLEX_INT
case|:
case|case
name|MODE_VECTOR_INT
case|:
break|break;
default|default:
comment|/* ??? We get called on all sorts of random stuff from  	 aggregate_value_p.  We can't abort, but it's not clear 	 what's safe to return.  Pretend it's a struct I guess.  */
return|return
name|true
return|;
block|}
comment|/* Otherwise types must fit in one register.  */
return|return
name|size
operator|>
name|UNITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a function.  VALTYPE is the    data type of the value (as a tree).  If the precise function being    called is known, FUNC is its FUNCTION_DECL; otherwise, FUNC is 0.    MODE is set instead of VALTYPE for libcalls.     On Alpha the value is found in $0 for integer functions and    $f0 for floating-point functions.  */
end_comment

begin_function
name|rtx
name|function_value
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
name|func
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|regnum
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|valtype
operator|&&
name|alpha_return_in_memory
argument_list|(
name|valtype
argument_list|,
name|func
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|valtype
condition|)
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|MODE_INT
case|:
comment|/* Do the same thing as PROMOTE_MODE.  */
name|mode
operator|=
name|DImode
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|MODE_COMPLEX_INT
case|:
case|case
name|MODE_VECTOR_INT
case|:
name|regnum
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_FLOAT
case|:
name|regnum
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|MODE_COMPLEX_FLOAT
case|:
block|{
name|enum
name|machine_mode
name|cmode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|cmode
argument_list|,
literal|32
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|cmode
argument_list|,
literal|33
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|cmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* TCmode complex values are passed by invisible reference.  We     should not split these values.  */
end_comment

begin_function
specifier|static
name|bool
name|alpha_split_complex_arg
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TCmode
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|alpha_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|base
decl_stmt|,
name|ofs
decl_stmt|,
name|space
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|||
name|TARGET_ABI_UNICOSMK
condition|)
return|return
name|ptr_type_node
return|;
name|record
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
comment|/* C++? SET_IS_AGGR_TYPE (record, 1); */
comment|/* Dummy field to prevent alignment warnings.  */
name|space
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|space
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|space
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|space
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__offset"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|ofs
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|ofs
argument_list|)
operator|=
name|space
expr_stmt|;
name|base
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__base"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|base
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
operator|=
name|ofs
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|base
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
return|return
name|record
return|;
block|}
end_function

begin_comment
comment|/* Perform any needed actions needed for a function that is receiving a    variable number of arguments.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|pcum
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|pretend_size
parameter_list|,
name|int
name|no_rtl
parameter_list|)
block|{
if|#
directive|if
name|TARGET_ABI_UNICOSMK
comment|/* On Unicos/Mk, the standard subroutine __T3E_MISMATCH stores all register      arguments on the stack. Unfortunately, it doesn't always store the first      one (i.e. the one that arrives in $16 or $f16). This is not a problem      with stdargs as we always have at least one named argument there.  */
name|int
name|num_reg_words
init|=
name|pcum
operator|->
name|num_reg_words
decl_stmt|;
if|if
condition|(
name|num_reg_words
operator|<
literal|6
condition|)
block|{
if|if
condition|(
operator|!
name|no_rtl
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_umk_mismatch_args
argument_list|(
name|GEN_INT
argument_list|(
name|num_reg_words
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_arg_home_umk
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|*
name|pretend_size
operator|=
literal|0
expr_stmt|;
block|}
elif|#
directive|elif
name|TARGET_ABI_OPEN_VMS
comment|/* For VMS, we allocate space for all 6 arg registers plus a count.       However, if NO registers need to be saved, don't allocate any space.      This is not only because we won't need the space, but because AP      includes the current_pretend_args_size and we don't want to mess up      any ap-relative addresses already made.  */
if|if
condition|(
name|pcum
operator|->
name|num_args
operator|<
literal|6
condition|)
block|{
if|if
condition|(
operator|!
name|no_rtl
condition|)
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|1
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_arg_home
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|*
name|pretend_size
operator|=
literal|7
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|#
directive|else
comment|/* On OSF/1 and friends, we allocate space for all 12 arg registers, but      only push those that are remaining.  However, if NO registers need to      be saved, don't allocate any space.  This is not only because we won't      need the space, but because AP includes the current_pretend_args_size      and we don't want to mess up any ap-relative addresses already made.       If we are not to use the floating-point registers, save the integer      registers where we would put the floating-point registers.  This is      not the most efficient way to implement varargs with just one register      class, but it isn't worth doing anything more efficient in this rare      case.  */
name|CUMULATIVE_ARGS
name|cum
init|=
operator|*
name|pcum
decl_stmt|;
if|if
condition|(
name|cum
operator|>=
literal|6
condition|)
return|return;
if|if
condition|(
operator|!
name|no_rtl
condition|)
block|{
name|int
name|set
init|=
name|get_varargs_alias_set
argument_list|()
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
operator|(
name|cum
operator|+
literal|6
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|move_block_from_reg
argument_list|(
literal|16
operator|+
name|cum
argument_list|,
name|tmp
argument_list|,
literal|6
operator|-
name|cum
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|cum
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|move_block_from_reg
argument_list|(
literal|16
operator|+
operator|(
name|TARGET_FPREGS
condition|?
literal|32
else|:
literal|0
operator|)
operator|+
name|cum
argument_list|,
name|tmp
argument_list|,
literal|6
operator|-
name|cum
argument_list|)
expr_stmt|;
block|}
operator|*
name|pretend_size
operator|=
literal|12
operator|*
name|UNITS_PER_WORD
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|alpha_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|offset_field
decl_stmt|,
name|base_field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
comment|/* For Unix, SETUP_INCOMING_VARARGS moves the starting address base      up by 48, storing fp arg registers in the first 48 bytes, and the      integer arg registers in the next 48 bytes.  This is only done,      however, if any integer registers need to be stored.       If no integer registers need be stored, then we must subtract 48      in order to account for the integer arg registers which are counted      in argsize above, but which are not actually stored on the stack.      Must further be careful here about structures straddling the last      integer argument register; that futzes with pretend_args_size,       which changes the meaning of AP.  */
if|if
condition|(
name|NUM_ARGS
operator|<=
literal|6
condition|)
name|offset
operator|=
name|TARGET_ABI_OPEN_VMS
condition|?
name|UNITS_PER_WORD
else|:
literal|6
operator|*
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|offset
operator|=
operator|-
literal|6
operator|*
name|UNITS_PER_WORD
operator|+
name|current_function_pretend_args_size
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
name|nextarg
operator|=
name|plus_constant
argument_list|(
name|nextarg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|plus_constant
argument_list|(
name|nextarg
argument_list|,
name|NUM_ARGS
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|nextarg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_field
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
expr_stmt|;
name|offset_field
operator|=
name|TREE_CHAIN
argument_list|(
name|base_field
argument_list|)
expr_stmt|;
name|base_field
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_field
argument_list|)
argument_list|,
name|valist
argument_list|,
name|base_field
argument_list|)
expr_stmt|;
name|offset_field
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|valist
argument_list|,
name|offset_field
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_field
argument_list|)
argument_list|,
name|base_field
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|NUM_ARGS
operator|*
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|offset_field
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|rtx
name|alpha_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|type_size
decl_stmt|,
name|rounded_size
decl_stmt|;
name|tree
name|offset_field
decl_stmt|,
name|base_field
decl_stmt|,
name|addr_tree
decl_stmt|,
name|addend
decl_stmt|;
name|tree
name|wide_type
decl_stmt|,
name|wide_ofs
decl_stmt|;
name|int
name|indirect
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|||
name|TARGET_ABI_UNICOSMK
condition|)
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|(
name|type_size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|TREE_OVERFLOW
argument_list|(
name|type_size
argument_list|)
condition|)
name|rounded_size
operator|=
name|size_zero_node
expr_stmt|;
else|else
name|rounded_size
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|sizetype
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|type_size
argument_list|,
name|size_int
argument_list|(
literal|7
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base_field
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
expr_stmt|;
name|offset_field
operator|=
name|TREE_CHAIN
argument_list|(
name|base_field
argument_list|)
expr_stmt|;
name|base_field
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_field
argument_list|)
argument_list|,
name|valist
argument_list|,
name|base_field
argument_list|)
expr_stmt|;
name|offset_field
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|valist
argument_list|,
name|offset_field
argument_list|)
expr_stmt|;
comment|/* If the type could not be passed in registers, skip the block      reserved for the registers.  */
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|offset_field
argument_list|,
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|offset_field
argument_list|,
name|build_int_2
argument_list|(
literal|6
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
name|wide_type
operator|=
name|make_signed_type
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|wide_ofs
operator|=
name|save_expr
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|wide_type
argument_list|,
name|offset_field
argument_list|)
argument_list|)
expr_stmt|;
name|addend
operator|=
name|wide_ofs
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TCmode
condition|)
block|{
name|indirect
operator|=
literal|1
expr_stmt|;
name|rounded_size
operator|=
name|size_int
argument_list|(
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|rtx
name|real_part
decl_stmt|,
name|imag_part
decl_stmt|,
name|value
decl_stmt|,
name|tmp
decl_stmt|;
name|real_part
operator|=
name|alpha_va_arg
argument_list|(
name|valist
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|imag_part
operator|=
name|alpha_va_arg
argument_list|(
name|valist
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Most irritatingly, we're not returning the value here, 	 but the address.  Since real_part and imag_part are not 	 necessarily contiguous, we must copy to local storage.  */
name|real_part
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|real_part
argument_list|)
expr_stmt|;
name|imag_part
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|imag_part
argument_list|)
expr_stmt|;
name|value
operator|=
name|gen_rtx_CONCAT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|real_part
argument_list|,
name|imag_part
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|tree
name|fpaddend
decl_stmt|,
name|cond
decl_stmt|;
name|fpaddend
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addend
argument_list|)
argument_list|,
name|addend
argument_list|,
name|build_int_2
argument_list|(
operator|-
literal|6
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|wide_ofs
argument_list|,
name|build_int_2
argument_list|(
literal|6
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addend
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addend
argument_list|)
argument_list|,
name|cond
argument_list|,
name|fpaddend
argument_list|,
name|addend
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr_tree
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_field
argument_list|)
argument_list|,
name|base_field
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expand_expr
argument_list|(
name|addr_tree
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|copy_to_reg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|offset_field
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset_field
argument_list|)
argument_list|,
name|offset_field
argument_list|,
name|rounded_size
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
block|{
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Builtins.  */
end_comment

begin_enum
enum|enum
name|alpha_builtin
block|{
name|ALPHA_BUILTIN_CMPBGE
block|,
name|ALPHA_BUILTIN_EXTBL
block|,
name|ALPHA_BUILTIN_EXTWL
block|,
name|ALPHA_BUILTIN_EXTLL
block|,
name|ALPHA_BUILTIN_EXTQL
block|,
name|ALPHA_BUILTIN_EXTWH
block|,
name|ALPHA_BUILTIN_EXTLH
block|,
name|ALPHA_BUILTIN_EXTQH
block|,
name|ALPHA_BUILTIN_INSBL
block|,
name|ALPHA_BUILTIN_INSWL
block|,
name|ALPHA_BUILTIN_INSLL
block|,
name|ALPHA_BUILTIN_INSQL
block|,
name|ALPHA_BUILTIN_INSWH
block|,
name|ALPHA_BUILTIN_INSLH
block|,
name|ALPHA_BUILTIN_INSQH
block|,
name|ALPHA_BUILTIN_MSKBL
block|,
name|ALPHA_BUILTIN_MSKWL
block|,
name|ALPHA_BUILTIN_MSKLL
block|,
name|ALPHA_BUILTIN_MSKQL
block|,
name|ALPHA_BUILTIN_MSKWH
block|,
name|ALPHA_BUILTIN_MSKLH
block|,
name|ALPHA_BUILTIN_MSKQH
block|,
name|ALPHA_BUILTIN_UMULH
block|,
name|ALPHA_BUILTIN_ZAP
block|,
name|ALPHA_BUILTIN_ZAPNOT
block|,
name|ALPHA_BUILTIN_AMASK
block|,
name|ALPHA_BUILTIN_IMPLVER
block|,
name|ALPHA_BUILTIN_RPCC
block|,
name|ALPHA_BUILTIN_THREAD_POINTER
block|,
name|ALPHA_BUILTIN_SET_THREAD_POINTER
block|,
comment|/* TARGET_MAX */
name|ALPHA_BUILTIN_MINUB8
block|,
name|ALPHA_BUILTIN_MINSB8
block|,
name|ALPHA_BUILTIN_MINUW4
block|,
name|ALPHA_BUILTIN_MINSW4
block|,
name|ALPHA_BUILTIN_MAXUB8
block|,
name|ALPHA_BUILTIN_MAXSB8
block|,
name|ALPHA_BUILTIN_MAXUW4
block|,
name|ALPHA_BUILTIN_MAXSW4
block|,
name|ALPHA_BUILTIN_PERR
block|,
name|ALPHA_BUILTIN_PKLB
block|,
name|ALPHA_BUILTIN_PKWB
block|,
name|ALPHA_BUILTIN_UNPKBL
block|,
name|ALPHA_BUILTIN_UNPKBW
block|,
comment|/* TARGET_CIX */
name|ALPHA_BUILTIN_CTTZ
block|,
name|ALPHA_BUILTIN_CTLZ
block|,
name|ALPHA_BUILTIN_CTPOP
block|,
name|ALPHA_BUILTIN_max
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|unsigned
name|int
specifier|const
name|code_for_builtin
index|[
name|ALPHA_BUILTIN_max
index|]
init|=
block|{
name|CODE_FOR_builtin_cmpbge
block|,
name|CODE_FOR_builtin_extbl
block|,
name|CODE_FOR_builtin_extwl
block|,
name|CODE_FOR_builtin_extll
block|,
name|CODE_FOR_builtin_extql
block|,
name|CODE_FOR_builtin_extwh
block|,
name|CODE_FOR_builtin_extlh
block|,
name|CODE_FOR_builtin_extqh
block|,
name|CODE_FOR_builtin_insbl
block|,
name|CODE_FOR_builtin_inswl
block|,
name|CODE_FOR_builtin_insll
block|,
name|CODE_FOR_builtin_insql
block|,
name|CODE_FOR_builtin_inswh
block|,
name|CODE_FOR_builtin_inslh
block|,
name|CODE_FOR_builtin_insqh
block|,
name|CODE_FOR_builtin_mskbl
block|,
name|CODE_FOR_builtin_mskwl
block|,
name|CODE_FOR_builtin_mskll
block|,
name|CODE_FOR_builtin_mskql
block|,
name|CODE_FOR_builtin_mskwh
block|,
name|CODE_FOR_builtin_msklh
block|,
name|CODE_FOR_builtin_mskqh
block|,
name|CODE_FOR_umuldi3_highpart
block|,
name|CODE_FOR_builtin_zap
block|,
name|CODE_FOR_builtin_zapnot
block|,
name|CODE_FOR_builtin_amask
block|,
name|CODE_FOR_builtin_implver
block|,
name|CODE_FOR_builtin_rpcc
block|,
name|CODE_FOR_load_tp
block|,
name|CODE_FOR_set_tp
block|,
comment|/* TARGET_MAX */
name|CODE_FOR_builtin_minub8
block|,
name|CODE_FOR_builtin_minsb8
block|,
name|CODE_FOR_builtin_minuw4
block|,
name|CODE_FOR_builtin_minsw4
block|,
name|CODE_FOR_builtin_maxub8
block|,
name|CODE_FOR_builtin_maxsb8
block|,
name|CODE_FOR_builtin_maxuw4
block|,
name|CODE_FOR_builtin_maxsw4
block|,
name|CODE_FOR_builtin_perr
block|,
name|CODE_FOR_builtin_pklb
block|,
name|CODE_FOR_builtin_pkwb
block|,
name|CODE_FOR_builtin_unpkbl
block|,
name|CODE_FOR_builtin_unpkbw
block|,
comment|/* TARGET_CIX */
name|CODE_FOR_builtin_cttz
block|,
name|CODE_FOR_builtin_ctlz
block|,
name|CODE_FOR_builtin_ctpop
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|alpha_builtin_def
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|alpha_builtin
name|code
decl_stmt|;
name|unsigned
name|int
name|target_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|alpha_builtin_def
specifier|const
name|zero_arg_builtins
index|[]
init|=
block|{
block|{
literal|"__builtin_alpha_implver"
block|,
name|ALPHA_BUILTIN_IMPLVER
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_rpcc"
block|,
name|ALPHA_BUILTIN_RPCC
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|alpha_builtin_def
specifier|const
name|one_arg_builtins
index|[]
init|=
block|{
block|{
literal|"__builtin_alpha_amask"
block|,
name|ALPHA_BUILTIN_AMASK
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_pklb"
block|,
name|ALPHA_BUILTIN_PKLB
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_pkwb"
block|,
name|ALPHA_BUILTIN_PKWB
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_unpkbl"
block|,
name|ALPHA_BUILTIN_UNPKBL
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_unpkbw"
block|,
name|ALPHA_BUILTIN_UNPKBW
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_cttz"
block|,
name|ALPHA_BUILTIN_CTTZ
block|,
name|MASK_CIX
block|}
block|,
block|{
literal|"__builtin_alpha_ctlz"
block|,
name|ALPHA_BUILTIN_CTLZ
block|,
name|MASK_CIX
block|}
block|,
block|{
literal|"__builtin_alpha_ctpop"
block|,
name|ALPHA_BUILTIN_CTPOP
block|,
name|MASK_CIX
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|alpha_builtin_def
specifier|const
name|two_arg_builtins
index|[]
init|=
block|{
block|{
literal|"__builtin_alpha_cmpbge"
block|,
name|ALPHA_BUILTIN_CMPBGE
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_extbl"
block|,
name|ALPHA_BUILTIN_EXTBL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_extwl"
block|,
name|ALPHA_BUILTIN_EXTWL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_extll"
block|,
name|ALPHA_BUILTIN_EXTLL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_extql"
block|,
name|ALPHA_BUILTIN_EXTQL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_extwh"
block|,
name|ALPHA_BUILTIN_EXTWH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_extlh"
block|,
name|ALPHA_BUILTIN_EXTLH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_extqh"
block|,
name|ALPHA_BUILTIN_EXTQH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_insbl"
block|,
name|ALPHA_BUILTIN_INSBL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_inswl"
block|,
name|ALPHA_BUILTIN_INSWL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_insll"
block|,
name|ALPHA_BUILTIN_INSLL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_insql"
block|,
name|ALPHA_BUILTIN_INSQL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_inswh"
block|,
name|ALPHA_BUILTIN_INSWH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_inslh"
block|,
name|ALPHA_BUILTIN_INSLH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_insqh"
block|,
name|ALPHA_BUILTIN_INSQH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_mskbl"
block|,
name|ALPHA_BUILTIN_MSKBL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_mskwl"
block|,
name|ALPHA_BUILTIN_MSKWL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_mskll"
block|,
name|ALPHA_BUILTIN_MSKLL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_mskql"
block|,
name|ALPHA_BUILTIN_MSKQL
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_mskwh"
block|,
name|ALPHA_BUILTIN_MSKWH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_msklh"
block|,
name|ALPHA_BUILTIN_MSKLH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_mskqh"
block|,
name|ALPHA_BUILTIN_MSKQH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_umulh"
block|,
name|ALPHA_BUILTIN_UMULH
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_zap"
block|,
name|ALPHA_BUILTIN_ZAP
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_zapnot"
block|,
name|ALPHA_BUILTIN_ZAPNOT
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_alpha_minub8"
block|,
name|ALPHA_BUILTIN_MINUB8
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_minsb8"
block|,
name|ALPHA_BUILTIN_MINSB8
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_minuw4"
block|,
name|ALPHA_BUILTIN_MINUW4
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_minsw4"
block|,
name|ALPHA_BUILTIN_MINSW4
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_maxub8"
block|,
name|ALPHA_BUILTIN_MAXUB8
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_maxsb8"
block|,
name|ALPHA_BUILTIN_MAXSB8
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_maxuw4"
block|,
name|ALPHA_BUILTIN_MAXUW4
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_maxsw4"
block|,
name|ALPHA_BUILTIN_MAXSW4
block|,
name|MASK_MAX
block|}
block|,
block|{
literal|"__builtin_alpha_perr"
block|,
name|ALPHA_BUILTIN_PERR
block|,
name|MASK_MAX
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|alpha_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|alpha_builtin_def
modifier|*
name|p
decl_stmt|;
name|tree
name|ftype
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|p
operator|=
name|zero_arg_builtins
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|zero_arg_builtins
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
if|if
condition|(
operator|(
name|target_flags
operator|&
name|p
operator|->
name|target_mask
operator|)
operator|==
name|p
operator|->
name|target_mask
condition|)
name|builtin_function
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|ftype
argument_list|,
name|p
operator|->
name|code
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|long_integer_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|p
operator|=
name|one_arg_builtins
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|one_arg_builtins
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
if|if
condition|(
operator|(
name|target_flags
operator|&
name|p
operator|->
name|target_mask
operator|)
operator|==
name|p
operator|->
name|target_mask
condition|)
name|builtin_function
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|ftype
argument_list|,
name|p
operator|->
name|code
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|long_integer_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|p
operator|=
name|two_arg_builtins
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|two_arg_builtins
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
if|if
condition|(
operator|(
name|target_flags
operator|&
name|p
operator|->
name|target_mask
operator|)
operator|==
name|p
operator|->
name|target_mask
condition|)
name|builtin_function
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|ftype
argument_list|,
name|p
operator|->
name|code
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|ALPHA_BUILTIN_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_set_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|ALPHA_BUILTIN_SET_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|alpha_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
define|#
directive|define
name|MAX_ARGS
value|2
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|op
index|[
name|MAX_ARGS
index|]
decl_stmt|,
name|pat
decl_stmt|;
name|int
name|arity
decl_stmt|;
name|bool
name|nonvoid
decl_stmt|;
if|if
condition|(
name|fcode
operator|>=
name|ALPHA_BUILTIN_max
condition|)
name|internal_error
argument_list|(
literal|"bad builtin fcode"
argument_list|)
expr_stmt|;
name|icode
operator|=
name|code_for_builtin
index|[
name|fcode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
literal|0
condition|)
name|internal_error
argument_list|(
literal|"bad builtin fcode"
argument_list|)
expr_stmt|;
name|nonvoid
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
expr_stmt|;
for|for
control|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|arity
operator|=
literal|0
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|,
name|arity
operator|++
control|)
block|{
specifier|const
name|struct
name|insn_operand_data
modifier|*
name|insn_op
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|arity
operator|>
name|MAX_ARGS
condition|)
return|return
name|NULL_RTX
return|;
name|insn_op
operator|=
operator|&
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|arity
operator|+
name|nonvoid
index|]
expr_stmt|;
name|op
index|[
name|arity
index|]
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|insn_op
operator|->
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_op
operator|->
name|predicate
call|)
argument_list|(
name|op
index|[
name|arity
index|]
argument_list|,
name|insn_op
operator|->
name|mode
argument_list|)
condition|)
name|op
index|[
name|arity
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_op
operator|->
name|mode
argument_list|,
name|op
index|[
name|arity
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nonvoid
condition|)
block|{
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|arity
condition|)
block|{
case|case
literal|0
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|nonvoid
condition|)
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonvoid
condition|)
return|return
name|target
return|;
else|else
return|return
name|const0_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the function    prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/* Compute the size of the save area in the stack.  */
end_comment

begin_comment
comment|/* These variables are used for communication between the following functions.    They indicate various things about the current function being compiled    that are used to tell what kind of prologue, epilogue and procedure    descriptor to generate.  */
end_comment

begin_comment
comment|/* Nonzero if we need a stack procedure.  */
end_comment

begin_enum
enum|enum
name|alpha_procedure_types
block|{
name|PT_NULL
init|=
literal|0
block|,
name|PT_REGISTER
init|=
literal|1
block|,
name|PT_STACK
init|=
literal|2
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|alpha_procedure_types
name|alpha_procedure_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number (either FP or SP) that is used to unwind the frame.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_unwind_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number used to save FP.  We need not have one for RA since    we don't modify it for register procedures.  This is only defined    for register frame procedures.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_save_fp_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register number used to reference objects off our PV.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vms_base_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute register masks for saved registers.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_sa_mask
parameter_list|(
name|unsigned
name|long
modifier|*
name|imaskP
parameter_list|,
name|unsigned
name|long
modifier|*
name|fmaskP
parameter_list|)
block|{
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* When outputting a thunk, we don't have valid register life info,      but assemble_start_function wants to output .frame and .mask      directives.  */
if|if
condition|(
name|current_function_is_thunk
condition|)
block|{
operator|*
name|imaskP
operator|=
literal|0
expr_stmt|;
operator|*
name|fmaskP
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
name|imask
operator||=
operator|(
literal|1UL
operator|<<
name|HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
comment|/* One for every register we have to save.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|REG_RA
operator|&&
operator|(
operator|!
name|TARGET_ABI_UNICOSMK
operator|||
name|i
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|32
condition|)
name|imask
operator||=
operator|(
literal|1UL
operator|<<
name|i
operator|)
expr_stmt|;
else|else
name|fmask
operator||=
operator|(
literal|1UL
operator|<<
operator|(
name|i
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
block|}
comment|/* We need to restore these for the handler.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|regno
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|imask
operator||=
literal|1UL
operator|<<
name|regno
expr_stmt|;
block|}
block|}
comment|/* If any register spilled, then spill the return address also.  */
comment|/* ??? This is required by the Digital stack unwind specification      and isn't needed if we're doing Dwarf2 unwinding.  */
if|if
condition|(
name|imask
operator|||
name|fmask
operator|||
name|alpha_ra_ever_killed
argument_list|()
condition|)
name|imask
operator||=
operator|(
literal|1UL
operator|<<
name|REG_RA
operator|)
expr_stmt|;
operator|*
name|imaskP
operator|=
name|imask
expr_stmt|;
operator|*
name|fmaskP
operator|=
name|fmask
expr_stmt|;
block|}
end_function

begin_function
name|int
name|alpha_sa_size
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|mask
index|[
literal|2
index|]
decl_stmt|;
name|int
name|sa_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|mask
index|[
literal|0
index|]
argument_list|,
operator|&
name|mask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
if|if
condition|(
name|mask
index|[
literal|0
index|]
operator|||
name|mask
index|[
literal|1
index|]
condition|)
name|sa_size
operator|=
literal|14
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
operator|++
name|j
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|mask
index|[
name|j
index|]
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
name|sa_size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
comment|/* We might not need to generate a frame if we don't make any calls 	 (including calls to __T3E_MISMATCH if this is a vararg function), 	 don't have any local variables which require stack slots, don't 	 use alloca and have not determined that we need a frame for other 	 reasons.  */
name|alpha_procedure_type
operator|=
operator|(
name|sa_size
operator|||
name|get_frame_size
argument_list|()
operator|!=
literal|0
operator|||
name|current_function_outgoing_args_size
operator|||
name|current_function_stdarg
operator|||
name|current_function_calls_alloca
operator|||
name|frame_pointer_needed
operator|)
condition|?
name|PT_STACK
else|:
name|PT_REGISTER
expr_stmt|;
comment|/* Always reserve space for saving callee-saved registers if we 	 need a frame as required by the calling convention.  */
if|if
condition|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
name|sa_size
operator|=
literal|14
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
comment|/* Start by assuming we can use a register procedure if we don't 	 make any calls (REG_RA not used) or need to save any 	 registers and a stack procedure if we do.  */
if|if
condition|(
operator|(
name|mask
index|[
literal|0
index|]
operator|>>
name|REG_RA
operator|)
operator|&
literal|1
condition|)
name|alpha_procedure_type
operator|=
name|PT_STACK
expr_stmt|;
elseif|else
if|if
condition|(
name|get_frame_size
argument_list|()
operator|!=
literal|0
condition|)
name|alpha_procedure_type
operator|=
name|PT_REGISTER
expr_stmt|;
else|else
name|alpha_procedure_type
operator|=
name|PT_NULL
expr_stmt|;
comment|/* Don't reserve space for saving FP& RA yet.  Do that later after we've 	 made the final decision on stack procedure vs register procedure.  */
if|if
condition|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
name|sa_size
operator|-=
literal|2
expr_stmt|;
comment|/* Decide whether to refer to objects off our PV via FP or PV. 	 If we need FP for something else or if we receive a nonlocal 	 goto (which expects PV to contain the value), we must use PV. 	 Otherwise, start by assuming we can use FP.  */
name|vms_base_regno
operator|=
operator|(
name|frame_pointer_needed
operator|||
name|current_function_has_nonlocal_label
operator|||
name|alpha_procedure_type
operator|==
name|PT_STACK
operator|||
name|current_function_outgoing_args_size
operator|)
condition|?
name|REG_PV
else|:
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
comment|/* If we want to copy PV into FP, we need to find some register 	 in which to save FP.  */
name|vms_save_fp_regno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vms_base_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|vms_save_fp_regno
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|vms_save_fp_regno
operator|==
operator|-
literal|1
operator|&&
name|alpha_procedure_type
operator|==
name|PT_REGISTER
condition|)
name|vms_base_regno
operator|=
name|REG_PV
operator|,
name|alpha_procedure_type
operator|=
name|PT_STACK
expr_stmt|;
elseif|else
if|if
condition|(
name|alpha_procedure_type
operator|==
name|PT_NULL
condition|)
name|vms_base_regno
operator|=
name|REG_PV
expr_stmt|;
comment|/* Stack unwinding should be done via FP unless we use it for PV.  */
name|vms_unwind_regno
operator|=
operator|(
name|vms_base_regno
operator|==
name|REG_PV
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
expr_stmt|;
comment|/* If this is a stack procedure, allow space for saving FP and RA.  */
if|if
condition|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
name|sa_size
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Our size must be even (multiple of 16 bytes).  */
if|if
condition|(
name|sa_size
operator|&
literal|1
condition|)
name|sa_size
operator|++
expr_stmt|;
block|}
return|return
name|sa_size
operator|*
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Define the offset between two registers, one to be eliminated,    and the other its replacement, at the start of a routine.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|alpha_initial_elimination_offset
parameter_list|(
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|int
name|to
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|ret
decl_stmt|;
name|ret
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|ret
operator|+=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|ret
operator|+=
operator|(
name|ALPHA_ROUND
argument_list|(
name|get_frame_size
argument_list|()
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|-
name|current_function_pretend_args_size
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|alpha_pv_save_size
parameter_list|(
name|void
parameter_list|)
block|{
name|alpha_sa_size
argument_list|()
expr_stmt|;
return|return
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|?
literal|8
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|alpha_using_fp
parameter_list|(
name|void
parameter_list|)
block|{
name|alpha_sa_size
argument_list|()
expr_stmt|;
return|return
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
end_if

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|vms_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"overlaid"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"global"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"initialize"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|find_lo_sum_using_gp
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
operator|*
name|px
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|XEXP
argument_list|(
operator|*
name|px
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
return|;
block|}
end_function

begin_function
name|int
name|alpha_find_lo_sum_using_gp
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|find_lo_sum_using_gp
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_does_function_need_gp
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* The GP being variable is an OSF abi thing.  */
if|if
condition|(
operator|!
name|TARGET_ABI_OSF
condition|)
return|return
literal|0
return|;
comment|/* We need the gp to load the address of __mcount.  */
if|if
condition|(
name|TARGET_PROFILING_NEEDS_GP
operator|&&
name|current_function_profile
condition|)
return|return
literal|1
return|;
comment|/* The code emitted by alpha_output_mi_thunk_osf uses the gp.  */
if|if
condition|(
name|current_function_is_thunk
condition|)
return|return
literal|1
return|;
comment|/* The nonlocal receiver pattern assumes that the gp is valid for      the nested function.  Reasonable because it's almost always set      correctly already.  For the cases where that's wrong, make sure      the nested function loads its gp on entry.  */
if|if
condition|(
name|current_function_has_nonlocal_goto
condition|)
return|return
literal|1
return|;
comment|/* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first.       Even if we are a static function, we still need to do this in case      our address is taken and passed to something like qsort.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|get_attr_usegp
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function to set RTX_FRAME_RELATED_P on instructions, including    sequences.  */
end_comment

begin_function
specifier|static
name|rtx
name|set_frame_related_p
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|seq
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|seq
argument_list|)
condition|)
block|{
name|insn
operator|=
name|seq
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|seq
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|seq
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FRP
parameter_list|(
name|exp
parameter_list|)
value|(start_sequence (), exp, set_frame_related_p ())
end_define

begin_comment
comment|/* Generates a store with the proper unwind info attached.  VALUE is    stored at BASE_REG+BASE_OFS.  If FRAME_BIAS is non-zero, then BASE_REG    contains SP+FRAME_BIAS, and that is the unwind info that should be    generated.  If FRAME_REG != VALUE, then VALUE is being stored on    behalf of FRAME_REG, and FRAME_REG should be present in the unwind.  */
end_comment

begin_function
specifier|static
name|void
name|emit_frame_store_1
parameter_list|(
name|rtx
name|value
parameter_list|,
name|rtx
name|base_reg
parameter_list|,
name|HOST_WIDE_INT
name|frame_bias
parameter_list|,
name|HOST_WIDE_INT
name|base_ofs
parameter_list|,
name|rtx
name|frame_reg
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|,
name|insn
decl_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|base_reg
argument_list|,
name|base_ofs
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|frame_bias
operator|||
name|value
operator|!=
name|frame_reg
condition|)
block|{
if|if
condition|(
name|frame_bias
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_bias
operator|+
name|base_ofs
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|frame_reg
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_frame_store
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|rtx
name|base_reg
parameter_list|,
name|HOST_WIDE_INT
name|frame_bias
parameter_list|,
name|HOST_WIDE_INT
name|base_ofs
parameter_list|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|emit_frame_store_1
argument_list|(
name|reg
argument_list|,
name|base_reg
argument_list|,
name|frame_bias
argument_list|,
name|base_ofs
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_comment
comment|/* On vms we have two kinds of functions:     - stack frame (PROC_STACK) 	these are 'normal' functions with local vars and which are 	calling other functions    - register frame (PROC_REGISTER) 	keeps all data in registers, needs no stack     We must pass this to the assembler so it can generate the    proper pdsc (procedure descriptor)    This is done with the '.pdesc' command.     On not-vms, we don't really differentiate between the two, as we can    simply allocate stack without saving registers.  */
end_comment

begin_function
name|void
name|alpha_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Registers to save.  */
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|rtx
name|sa_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
comment|/* We have to allocate space for the DSIB if we generate a frame.  */
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|?
literal|48
else|:
literal|0
operator|)
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
comment|/* Emit an insn to reload GP, if needed.  */
if|if
condition|(
name|TARGET_ABI_OSF
condition|)
block|{
name|alpha_function_needs_gp
operator|=
name|alpha_does_function_need_gp
argument_list|()
expr_stmt|;
if|if
condition|(
name|alpha_function_needs_gp
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_ldgp
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* TARGET_PROFILING_NEEDS_GP actually implies that we need to insert      the call to mcount ourselves, rather than having the linker do it      magically in response to -pg.  Since _mcount has special linkage,      don't represent the call as a call.  */
if|if
condition|(
name|TARGET_PROFILING_NEEDS_GP
operator|&&
name|current_function_profile
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_mcount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|unicosmk_gen_dsib
argument_list|(
operator|&
name|imask
argument_list|)
expr_stmt|;
comment|/* Adjust the stack by the frame size.  If the frame size is> 4096      bytes, we need to be sure we probe somewhere in the first and last      4096 bytes (we can probably get away without the latter test) and      every 8192 bytes in between.  If the frame size is> 32768, we      do this in a loop.  Otherwise, we generate the explicit probe      instructions.        Note that we are only allowed to adjust sp once in the prologue.  */
if|if
condition|(
name|frame_size
operator|<=
literal|32768
condition|)
block|{
if|if
condition|(
name|frame_size
operator|>
literal|4096
condition|)
block|{
name|int
name|probed
init|=
literal|4096
decl_stmt|;
do|do
name|emit_insn
argument_list|(
name|gen_probe_stack
argument_list|(
name|GEN_INT
argument_list|(
name|TARGET_ABI_UNICOSMK
condition|?
operator|-
name|probed
operator|+
literal|64
else|:
operator|-
name|probed
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|probed
operator|+=
literal|8192
operator|)
operator|<
name|frame_size
condition|)
do|;
comment|/* We only have to do this probe if we aren't saving registers.  */
if|if
condition|(
name|sa_size
operator|==
literal|0
operator|&&
name|probed
operator|+
literal|4096
operator|<
name|frame_size
condition|)
name|emit_insn
argument_list|(
name|gen_probe_stack
argument_list|(
name|GEN_INT
argument_list|(
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_size
operator|!=
literal|0
condition|)
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_ABI_UNICOSMK
condition|?
operator|-
name|frame_size
operator|+
literal|64
else|:
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we generate code to set R22 to SP + 4096 and set R23 to the 	 number of 8192 byte blocks to probe.  We then probe each block 	 in the loop and then set SP to the proper location.  If the 	 amount remaining is> 4096, we have to do one more probe if we 	 are not saving any registers.  */
name|HOST_WIDE_INT
name|blocks
init|=
operator|(
name|frame_size
operator|+
literal|4096
operator|)
operator|/
literal|8192
decl_stmt|;
name|HOST_WIDE_INT
name|leftover
init|=
name|frame_size
operator|+
literal|4096
operator|-
name|blocks
operator|*
literal|8192
decl_stmt|;
name|rtx
name|ptr
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|22
argument_list|)
decl_stmt|;
name|rtx
name|count
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|GEN_INT
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|ptr
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_ABI_UNICOSMK
condition|?
literal|4096
operator|-
literal|64
else|:
literal|4096
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because of the difficulty in emitting a new basic block this 	 late in the compilation, generate the loop as a single insn.  */
name|emit_insn
argument_list|(
name|gen_prologue_stack_probe_loop
argument_list|(
name|count
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftover
operator|>
literal|4096
operator|&&
name|sa_size
operator|==
literal|0
condition|)
block|{
name|rtx
name|last
init|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|ptr
argument_list|,
operator|-
name|leftover
argument_list|)
argument_list|)
decl_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|last
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|last
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ABI_WINDOWS_NT
condition|)
block|{
comment|/* For NT stack unwind (done by 'reverse execution'), it's 	     not OK to take the result of a loop, even though the value 	     is already in ptr, so we reload it via a single operation 	     and subtract it to sp.   	     Yes, that's correct -- we have to reload the whole constant 	     into a temporary via ldah+lda then subtract from sp.  */
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
operator|(
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|hi
operator|=
name|frame_size
operator|-
name|lo
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|ptr
argument_list|,
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
name|lo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|ptr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|leftover
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* This alternative is special, because the DWARF code cannot          possibly intuit through the loop above.  So we invent this          note it looks at instead.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|seq
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|seq
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_ABI_UNICOSMK
condition|?
operator|-
name|frame_size
operator|+
literal|64
else|:
operator|-
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|seq
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|HOST_WIDE_INT
name|sa_bias
init|=
literal|0
decl_stmt|;
comment|/* Cope with very large offsets to the register save area.  */
name|sa_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|reg_offset
operator|+
name|sa_size
operator|>
literal|0x8000
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|reg_offset
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|rtx
name|sa_bias_rtx
decl_stmt|;
if|if
condition|(
name|low
operator|+
name|sa_size
operator|<=
literal|0x8000
condition|)
name|sa_bias
operator|=
name|reg_offset
operator|-
name|low
operator|,
name|reg_offset
operator|=
name|low
expr_stmt|;
else|else
name|sa_bias
operator|=
name|reg_offset
operator|,
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|sa_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|sa_bias_rtx
operator|=
name|GEN_INT
argument_list|(
name|sa_bias
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_operand
argument_list|(
name|sa_bias_rtx
argument_list|,
name|DImode
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|sa_reg
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sa_bias_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|sa_reg
argument_list|,
name|sa_bias_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|sa_reg
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sa_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save regs in stack order.  Beginning with VMS PV.  */
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
name|emit_frame_store
argument_list|(
name|REG_PV
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save register RA next.  */
if|if
condition|(
name|imask
operator|&
operator|(
literal|1UL
operator|<<
name|REG_RA
operator|)
condition|)
block|{
name|emit_frame_store
argument_list|(
name|REG_RA
argument_list|,
name|sa_reg
argument_list|,
name|sa_bias
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|imask
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|REG_RA
operator|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Now save any other registers required to be saved.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
block|{
name|emit_frame_store
argument_list|(
name|i
argument_list|,
name|sa_reg
argument_list|,
name|sa_bias
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
block|{
name|emit_frame_store
argument_list|(
name|i
operator|+
literal|32
argument_list|,
name|sa_reg
argument_list|,
name|sa_bias
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
block|{
comment|/* The standard frame on the T3E includes space for saving registers. 	 We just have to use it. We don't have to save the return address and 	 the old frame pointer here - they are saved in the DSIB.  */
name|reg_offset
operator|=
operator|-
literal|56
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
block|{
name|emit_frame_store
argument_list|(
name|i
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|-=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
block|{
name|emit_frame_store
argument_list|(
name|i
operator|+
literal|32
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|-=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
if|if
condition|(
name|alpha_procedure_type
operator|==
name|PT_REGISTER
condition|)
comment|/* Register frame procedures save the fp. 	   ?? Ought to have a dwarf2 save for this.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_procedure_type
operator|!=
name|PT_NULL
operator|&&
name|vms_base_regno
operator|!=
name|REG_PV
condition|)
name|emit_insn
argument_list|(
name|gen_force_movdi
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_base_regno
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_PV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_procedure_type
operator|!=
name|PT_NULL
operator|&&
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have to allocate space for outgoing args, do it now.  */
if|if
condition|(
name|current_function_outgoing_args_size
operator|!=
literal|0
condition|)
block|{
name|rtx
name|seq
init|=
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Only set FRAME_RELATED_P on the stack adjustment we just emitted 	     if ! frame_pointer_needed. Setting the bit will change the CFA 	     computation rule to use sp again, which would be wrong if we had 	     frame_pointer_needed, as this means sp might move unpredictably 	     later on.  	     Also, note that 	       frame_pointer_needed 	       => vms_unwind_regno == HARD_FRAME_POINTER_REGNUM 	     and 	       current_function_outgoing_args_size != 0 	       => alpha_procedure_type != PT_NULL,  	     so when we are not setting the bit here, we are guaranteed to 	     have emitted an FRP frame pointer update just before.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|seq
argument_list|)
operator|=
operator|!
name|frame_pointer_needed
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_ABI_UNICOSMK
condition|)
block|{
comment|/* If we need a frame pointer, set it from the stack pointer.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|TARGET_CAN_FAULT_IN_PROLOGUE
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* This must always be the last instruction in the 	       prologue, thus we emit a special move + clobber.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_init_fp
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sa_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The ABIs for VMS and OSF/1 say that while we can schedule insns into      the prologue, for exception handling reasons, we cannot do this for      any insn that might fault.  We could prevent this for mems with a      (clobber:BLK (scratch)), but this doesn't work for fp insns.  So we      have to prevent all such scheduling with a blockage.       Linux, on the other hand, never bothered to implement OSF/1's       exception handling, and so doesn't care about such things.  Anyone      planning to use dwarf2 frame-unwind info can also omit the blockage.  */
if|if
condition|(
operator|!
name|TARGET_CAN_FAULT_IN_PROLOGUE
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the textual info surrounding the prologue.  */
end_comment

begin_function
name|void
name|alpha_start_function
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fnname
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|unsigned
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|char
modifier|*
name|entry_label
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fnname
argument_list|)
operator|+
literal|6
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't emit an extern directive for functions defined in the same file.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|tree
name|name_tree
decl_stmt|;
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|alpha_fnname
operator|=
name|fnname
expr_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|?
literal|48
else|:
literal|0
operator|)
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
comment|/* Ecoff can handle multiple .file directives, so put out file and lineno.      We have to do that before the .ent directive as we cannot switch      files within procedures with native ecoff because line numbers are      linked to procedure descriptors.      Outputting the lineno helps debugging of one line functions as they      would otherwise get no line number at all. Please note that we would      like to put out last_linenum from final.c, but it is not accessible.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
condition|)
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Issue function start and label.  */
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|||
operator|(
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
operator|!
name|flag_inhibit_size_directive
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.ent "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* If the function needs GP, we'll write the "..ng" label there. 	 Otherwise, do it here.  */
if|if
condition|(
name|TARGET_ABI_OSF
operator|&&
operator|!
name|alpha_function_needs_gp
operator|&&
operator|!
name|current_function_is_thunk
condition|)
block|{
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..ng:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|entry_label
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|strcat
argument_list|(
name|entry_label
argument_list|,
literal|"..en"
argument_list|)
expr_stmt|;
comment|/* For public functions, the label must be globalized by appending an      additional colon.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|strcat
argument_list|(
name|entry_label
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|entry_label
argument_list|)
expr_stmt|;
name|inside_function
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.base $%d\n"
argument_list|,
name|vms_base_regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ABI_OPEN_VMS
operator|&&
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
name|TARGET_IEEE_CONFORMANT
operator|&&
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
comment|/* Set flags in procedure descriptor to request IEEE-conformant 	 math-library routines.  The value we set it to is PDSC_EXC_IEEE 	 (/usr/include/pdsc.h).  */
name|fputs
argument_list|(
literal|"\t.eflag 48\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Set up offsets to alpha virtual arg/local debugging pointer.  */
name|alpha_auto_offset
operator|=
operator|-
name|frame_size
operator|+
name|current_function_pretend_args_size
expr_stmt|;
name|alpha_arg_offset
operator|=
operator|-
name|frame_size
operator|+
literal|48
expr_stmt|;
comment|/* Describe our frame.  If the frame size is larger than an integer,      print it as zero to avoid an assembler error.  We won't be      properly describing such a frame, but that's the best we can do.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $%d,"
name|HOST_WIDE_INT_PRINT_DEC
literal|",$26,"
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|vms_unwind_regno
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1UL
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|frame_size
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $%d,"
name|HOST_WIDE_INT_PRINT_DEC
literal|",$26,%d\n"
argument_list|,
operator|(
name|frame_pointer_needed
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1UL
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|frame_size
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
comment|/* Describe which registers were spilled.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
if|if
condition|(
name|imask
condition|)
comment|/* ??? Does VMS care if mask contains ra?  The old code didn't            set it, so I don't here.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask 0x%lx,0\n"
argument_list|,
name|imask
operator|&
operator|~
operator|(
literal|1UL
operator|<<
name|REG_RA
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask 0x%lx,0\n"
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_procedure_type
operator|==
name|PT_REGISTER
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fp_save $%d\n"
argument_list|,
name|vms_save_fp_regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
if|if
condition|(
name|imask
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask 0x%lx,"
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|imask
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1UL
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|reg_offset
operator|-
name|frame_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|fmask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask 0x%lx,"
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|fmask
argument_list|,
name|frame_size
operator|>=
operator|(
literal|1UL
operator|<<
literal|31
operator|)
condition|?
literal|0
else|:
name|reg_offset
operator|-
name|frame_size
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
comment|/* Ifdef'ed cause link_section are only available then.  */
name|readonly_data_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align 3\n"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..na:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.ascii \""
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\\0\"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|alpha_need_linkage
argument_list|(
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit the .prologue note at the scheduled end of the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_output_function_end_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|fputs
argument_list|(
literal|"\t.prologue\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_WINDOWS_NT
condition|)
name|fputs
argument_list|(
literal|"\t.prologue 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.prologue %d\n"
argument_list|,
name|alpha_function_needs_gp
operator|||
name|current_function_is_thunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_comment
comment|/* ??? At some point we will want to support full unwind, and so will     need to mark the epilogue as well.  At the moment, we just confuse    dwarf2out.  */
end_comment

begin_undef
undef|#
directive|undef
name|FRP
end_undef

begin_define
define|#
directive|define
name|FRP
parameter_list|(
name|exp
parameter_list|)
value|exp
end_define

begin_function
name|void
name|alpha_expand_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Registers to save.  */
name|unsigned
name|long
name|imask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
literal|0
decl_stmt|;
comment|/* Stack space needed for pushing registers clobbered by us.  */
name|HOST_WIDE_INT
name|sa_size
decl_stmt|;
comment|/* Complete stack size needed.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Offset from base reg to register save area.  */
name|HOST_WIDE_INT
name|reg_offset
decl_stmt|;
name|int
name|fp_is_frame_pointer
decl_stmt|,
name|fp_offset
decl_stmt|;
name|rtx
name|sa_reg
decl_stmt|,
name|sa_reg_exp
init|=
name|NULL
decl_stmt|;
name|rtx
name|sp_adj1
decl_stmt|,
name|sp_adj2
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
name|eh_ofs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sa_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
name|frame_size
operator|=
name|ALPHA_ROUND
argument_list|(
name|sa_size
operator|+
operator|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|?
literal|48
else|:
literal|0
operator|)
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
else|else
name|frame_size
operator|=
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|sa_size
operator|+
name|ALPHA_ROUND
argument_list|(
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
if|if
condition|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
name|reg_offset
operator|=
literal|8
expr_stmt|;
else|else
name|reg_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|reg_offset
operator|=
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|alpha_sa_mask
argument_list|(
operator|&
name|imask
argument_list|,
operator|&
name|fmask
argument_list|)
expr_stmt|;
name|fp_is_frame_pointer
operator|=
operator|(
operator|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|alpha_procedure_type
operator|==
name|PT_STACK
operator|)
operator|||
operator|(
operator|!
name|TARGET_ABI_OPEN_VMS
operator|&&
name|frame_pointer_needed
operator|)
operator|)
expr_stmt|;
name|fp_offset
operator|=
literal|0
expr_stmt|;
name|sa_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|eh_ofs
operator|=
name|EH_RETURN_STACKADJ_RTX
expr_stmt|;
else|else
name|eh_ofs
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
name|sa_size
condition|)
block|{
comment|/* If we have a frame pointer, restore SP from it.  */
if|if
condition|(
operator|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|vms_unwind_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
operator|(
operator|!
name|TARGET_ABI_OPEN_VMS
operator|&&
name|frame_pointer_needed
operator|)
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cope with very large offsets to the register save area.  */
if|if
condition|(
name|reg_offset
operator|+
name|sa_size
operator|>
literal|0x8000
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|reg_offset
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|bias
decl_stmt|;
if|if
condition|(
name|low
operator|+
name|sa_size
operator|<=
literal|0x8000
condition|)
name|bias
operator|=
name|reg_offset
operator|-
name|low
operator|,
name|reg_offset
operator|=
name|low
expr_stmt|;
else|else
name|bias
operator|=
name|reg_offset
operator|,
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|sa_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|sa_reg_exp
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|bias
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|sa_reg
argument_list|,
name|sa_reg_exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore registers in order, excepting a true frame pointer.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eh_ofs
condition|)
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
name|imask
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|REG_RA
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|fp_is_frame_pointer
condition|)
name|fp_offset
operator|=
name|reg_offset
expr_stmt|;
else|else
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
operator|+
literal|32
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
block|{
comment|/* Restore callee-saved general-purpose registers.  */
name|reg_offset
operator|=
operator|-
literal|56
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|imask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|-=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmask
operator|&
operator|(
literal|1UL
operator|<<
name|i
operator|)
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|reg_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
operator|+
literal|32
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Restore the return address from the DSIB.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_size
operator|||
name|eh_ofs
condition|)
block|{
name|sp_adj1
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|eh_ofs
condition|)
block|{
name|sp_adj1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|sp_adj1
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|eh_ofs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the stack size is large, begin computation into a temporary 	 register so as not to interfere with a potential fp restore, 	 which must be consecutive with an SP restore.  */
if|if
condition|(
name|frame_size
operator|<
literal|32768
operator|&&
operator|!
operator|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|current_function_calls_alloca
operator|)
condition|)
name|sp_adj2
operator|=
name|GEN_INT
argument_list|(
name|frame_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|sp_adj1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|sp_adj1
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|sp_adj2
operator|=
name|const0_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_size
operator|<
literal|0x40007fffL
condition|)
block|{
name|int
name|low
init|=
operator|(
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|sp_adj2
operator|=
name|plus_constant
argument_list|(
name|sp_adj1
argument_list|,
name|frame_size
operator|-
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_reg_exp
operator|&&
name|rtx_equal_p
argument_list|(
name|sa_reg_exp
argument_list|,
name|sp_adj2
argument_list|)
condition|)
name|sp_adj1
operator|=
name|sa_reg
expr_stmt|;
else|else
block|{
name|sp_adj1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|sp_adj1
argument_list|,
name|sp_adj2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp_adj2
operator|=
name|GEN_INT
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|23
argument_list|)
decl_stmt|;
name|FRP
argument_list|(
name|sp_adj2
operator|=
name|alpha_emit_set_const
argument_list|(
name|tmp
argument_list|,
name|DImode
argument_list|,
name|frame_size
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp_adj2
condition|)
block|{
comment|/* We can't drop new things to memory this late, afaik, 		 so build it up by pieces.  */
name|FRP
argument_list|(
name|sp_adj2
operator|=
name|alpha_emit_set_long_const
argument_list|(
name|tmp
argument_list|,
name|frame_size
argument_list|,
operator|-
operator|(
name|frame_size
operator|<
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp_adj2
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* From now on, things must be in order.  So emit blockages.  */
comment|/* Restore the frame pointer.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp_is_frame_pointer
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|sa_reg
argument_list|,
name|fp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the stack pointer.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp_adj2
operator|==
name|const0_rtx
condition|)
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sp_adj1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|sp_adj1
argument_list|,
name|sp_adj2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
operator|&&
name|alpha_procedure_type
operator|==
name|PT_REGISTER
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|vms_save_fp_regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_UNICOSMK
operator|&&
name|alpha_procedure_type
operator|!=
name|PT_STACK
condition|)
block|{
comment|/* Decrement the frame pointer if the function does not have a 	     frame.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the rest of the textual info surrounding the epilogue.  */
end_comment

begin_function
name|void
name|alpha_end_function
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fnname
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* End the function.  */
if|if
condition|(
operator|!
name|TARGET_ABI_UNICOSMK
operator|&&
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.end "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|inside_function
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
name|alpha_write_linkage
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Output jump tables and the static subroutine information block.  */
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
name|unicosmk_output_ssib
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|unicosmk_output_deferred_case_vectors
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_ABI_OSF
end_if

begin_comment
comment|/* Emit a tail call to FUNCTION after adjusting THIS by DELTA.     In order to avoid the hordes of differences between generated code    with and without TARGET_EXPLICIT_RELOCS, and to avoid duplicating    lots of code loading up large constants, generate rtl and emit it    instead of going straight to text.     Not sure why this idea hasn't been explored before...  */
end_comment

begin_function
specifier|static
name|void
name|alpha_output_mi_thunk_osf
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk_fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|rtx
name|this
decl_stmt|,
name|insn
decl_stmt|,
name|funexp
decl_stmt|;
comment|/* We always require a valid GP.  */
name|emit_insn
argument_list|(
name|gen_prologue_ldgp
argument_list|()
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|)
expr_stmt|;
comment|/* Find the "this" pointer.  If the function returns a structure,      the structure return pointer is in $16.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|)
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|17
argument_list|)
expr_stmt|;
else|else
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Add DELTA.  When possible we use ldah+lda.  Otherwise load the      entire constant for the add.  */
name|lo
operator|=
operator|(
operator|(
name|delta
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
operator|(
name|delta
operator|-
name|lo
operator|)
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|hi
operator|+
name|lo
operator|==
name|delta
condition|)
block|{
if|if
condition|(
name|hi
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|GEN_INT
argument_list|(
name|lo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tmp
init|=
name|alpha_emit_set_long_const
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|delta
argument_list|,
operator|-
operator|(
name|delta
operator|<
literal|0
operator|)
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add a delta stored in the vtable at VCALL_OFFSET.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
name|vcall_offset
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
operator|(
name|vcall_offset
operator|-
name|lo
operator|)
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|hi
operator|+
name|lo
operator|==
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|hi
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp2
operator|=
name|alpha_emit_set_long_const
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
argument_list|,
name|vcall_offset
argument_list|,
operator|-
operator|(
name|vcall_offset
operator|<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lo
condition|)
name|tmp2
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|lo
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmp2
operator|=
name|tmp
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate a tail call to the target function.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funexp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_sibcall
argument_list|(
name|funexp
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Run just enough of rest_of_compilation to get the insns emitted.      There's not really enough bulk here to make other passes such as      instruction scheduling worth while.  Note that use_thunk calls      assemble_start_function and assemble_end_function.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|insn_locators_initialize
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_ABI_OSF */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Debugging support.  */
end_comment

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* Count the number of sdb related labels are generated (to find block    start and end boundaries).  */
end_comment

begin_decl_stmt
name|int
name|sdb_label_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next label # for each statement.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sym_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of .file directives, so that .loc is up to date.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_source_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file containing the current function.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_function_file
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offsets to alpha virtual arg/local debugging pointers.  */
end_comment

begin_decl_stmt
name|long
name|alpha_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|alpha_auto_offset
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Emit a new filename to a stream.  */
end_comment

begin_function
name|void
name|alpha_output_filename
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|int
name|first_time
init|=
name|TRUE
decl_stmt|;
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|first_time
condition|)
block|{
name|first_time
operator|=
name|FALSE
expr_stmt|;
operator|++
name|num_source_filenames
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_GAS
operator|&&
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#@stabs\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|",%d,0,0,%s\n"
argument_list|,
name|N_SOL
argument_list|,
operator|&
name|ltext_label_name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|current_function_file
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|current_function_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inside_function
operator|&&
operator|!
name|TARGET_GAS
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t#.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|num_source_filenames
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
block|}
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a linenumber to a stream.  */
end_comment

begin_function
name|void
name|alpha_output_lineno
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
comment|/* mips-tfile doesn't understand .stabd directives.  */
operator|++
name|sym_lineno
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$LM%d:\n%s%d,0,%d,$LM%d\n"
argument_list|,
name|sym_lineno
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_SLINE
argument_list|,
name|line
argument_list|,
name|sym_lineno
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n\t.loc\t%d %d\n"
argument_list|,
name|num_source_filenames
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure to show the current status of registers and memory.  */
end_comment

begin_struct
struct|struct
name|shadow_summary
block|{
struct|struct
block|{
name|unsigned
name|int
name|i
range|:
literal|31
decl_stmt|;
comment|/* Mask of int regs */
name|unsigned
name|int
name|fp
range|:
literal|31
decl_stmt|;
comment|/* Mask of fp regs */
name|unsigned
name|int
name|mem
range|:
literal|1
decl_stmt|;
comment|/* mem == imem | fpmem */
block|}
name|used
struct|,
name|defd
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* Summary the effects of expression X on the machine.  Update SUM, a pointer    to the summary structure.  SET is nonzero if the insn is setting the    object, otherwise zero.  */
end_comment

begin_function
specifier|static
name|void
name|summarize_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|shadow_summary
modifier|*
name|sum
parameter_list|,
name|int
name|set
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* ??? Note that this case would be incorrect if the Alpha had a 	 ZERO_EXTRACT in SET_DEST.  */
case|case
name|SET
case|:
name|summarize_insn
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|summarize_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|summarize_insn
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|summarize_insn
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
name|summarize_insn
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
operator|(
name|regno
operator|%
literal|32
operator|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
literal|31
operator|||
name|regno
operator|==
literal|63
condition|)
break|break;
if|if
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
name|sum
operator|->
name|defd
operator|.
name|i
operator||=
name|mask
expr_stmt|;
else|else
name|sum
operator|->
name|defd
operator|.
name|fp
operator||=
name|mask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
name|sum
operator|->
name|used
operator|.
name|i
operator||=
name|mask
expr_stmt|;
else|else
name|sum
operator|->
name|used
operator|.
name|fp
operator||=
name|mask
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MEM
case|:
if|if
condition|(
name|set
condition|)
name|sum
operator|->
name|defd
operator|.
name|mem
operator|=
literal|1
expr_stmt|;
else|else
name|sum
operator|->
name|used
operator|.
name|mem
operator|=
literal|1
expr_stmt|;
comment|/* Find the regs used in memory address computation: */
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|SCRATCH
case|:
case|case
name|ASM_INPUT
case|:
break|break;
comment|/* Handle common unary and binary ops for efficiency.  */
case|case
name|COMPARE
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|summarize_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|summarize_insn
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Ensure a sufficient number of `trapb' insns are in the code when    the user requests code with a trap precision of functions or    instructions.     In naive mode, when the user requests a trap-precision of    "instruction", a trapb is needed after every instruction that may    generate a trap.  This ensures that the code is resumption safe but    it is also slow.     When optimizations are turned on, we delay issuing a trapb as long    as possible.  In this context, a trap shadow is the sequence of    instructions that starts with a (potentially) trap generating    instruction and extends to the next trapb or call_pal instruction    (but GCC never generates call_pal by itself).  We can delay (and    therefore sometimes omit) a trapb subject to the following    conditions:     (a) On entry to the trap shadow, if any Alpha register or memory    location contains a value that is used as an operand value by some    instruction in the trap shadow (live on entry), then no instruction    in the trap shadow may modify the register or memory location.     (b) Within the trap shadow, the computation of the base register    for a memory load or store instruction may not involve using the    result of an instruction that might generate an UNPREDICTABLE    result.     (c) Within the trap shadow, no register may be used more than once    as a destination register.  (This is to make life easier for the    trap-handler.)     (d) The trap shadow may not include any branch instructions.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_handle_trap_shadows
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|shadow_summary
name|shadow
decl_stmt|;
name|int
name|trap_pending
decl_stmt|,
name|exception_nesting
decl_stmt|;
name|rtx
name|i
decl_stmt|,
name|n
decl_stmt|;
name|trap_pending
operator|=
literal|0
expr_stmt|;
name|exception_nesting
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|defd
operator|=
name|shadow
operator|.
name|used
expr_stmt|;
for|for
control|(
name|i
operator|=
name|get_insns
argument_list|()
init|;
name|i
condition|;
name|i
operator|=
name|NEXT_INSN
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|NOTE
condition|)
block|{
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
name|exception_nesting
operator|++
expr_stmt|;
if|if
condition|(
name|trap_pending
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_END
case|:
name|exception_nesting
operator|--
expr_stmt|;
if|if
condition|(
name|trap_pending
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
case|case
name|NOTE_INSN_EPILOGUE_BEG
case|:
if|if
condition|(
name|trap_pending
operator|&&
name|alpha_tp
operator|>=
name|ALPHA_TP_FUNC
condition|)
goto|goto
name|close_shadow
goto|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|trap_pending
condition|)
block|{
if|if
condition|(
name|alpha_tp
operator|==
name|ALPHA_TP_FUNC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
goto|goto
name|close_shadow
goto|;
block|}
elseif|else
if|if
condition|(
name|alpha_tp
operator|==
name|ALPHA_TP_INSN
condition|)
block|{
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|struct
name|shadow_summary
name|sum
decl_stmt|;
name|sum
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|sum
operator|.
name|defd
operator|=
name|sum
operator|.
name|used
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
comment|/* Annoyingly, get_attr_trap will abort on these.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
name|summarize_insn
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|shadow
operator|.
name|defd
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|shadow
operator|.
name|defd
operator|.
name|fp
operator|)
condition|)
block|{
comment|/* (c) would be violated */
goto|goto
name|close_shadow
goto|;
block|}
comment|/* Combine shadow with summary of current insn: */
name|shadow
operator|.
name|used
operator|.
name|i
operator||=
name|sum
operator|.
name|used
operator|.
name|i
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator||=
name|sum
operator|.
name|used
operator|.
name|fp
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator||=
name|sum
operator|.
name|used
operator|.
name|mem
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|i
operator||=
name|sum
operator|.
name|defd
operator|.
name|i
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|fp
operator||=
name|sum
operator|.
name|defd
operator|.
name|fp
expr_stmt|;
name|shadow
operator|.
name|defd
operator|.
name|mem
operator||=
name|sum
operator|.
name|defd
operator|.
name|mem
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|shadow
operator|.
name|used
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|shadow
operator|.
name|used
operator|.
name|fp
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|mem
operator|&
name|shadow
operator|.
name|used
operator|.
name|mem
operator|)
condition|)
block|{
comment|/* (a) would be violated (also takes care of (b))  */
if|if
condition|(
name|get_attr_trap
argument_list|(
name|i
argument_list|)
operator|==
name|TRAP_YES
operator|&&
operator|(
operator|(
name|sum
operator|.
name|defd
operator|.
name|i
operator|&
name|sum
operator|.
name|used
operator|.
name|i
operator|)
operator|||
operator|(
name|sum
operator|.
name|defd
operator|.
name|fp
operator|&
name|sum
operator|.
name|used
operator|.
name|fp
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
goto|goto
name|close_shadow
goto|;
block|}
break|break;
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|CODE_LABEL
case|:
goto|goto
name|close_shadow
goto|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|close_shadow
label|:
name|n
operator|=
name|emit_insn_before
argument_list|(
name|gen_trapb
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|n
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|i
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
name|trap_pending
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|fp
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|used
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|shadow
operator|.
name|defd
operator|=
name|shadow
operator|.
name|used
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|exception_nesting
operator|>
literal|0
operator|||
name|alpha_tp
operator|>=
name|ALPHA_TP_FUNC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|get_attr_trap
argument_list|(
name|i
argument_list|)
operator|==
name|TRAP_YES
condition|)
block|{
if|if
condition|(
name|optimize
operator|&&
operator|!
name|trap_pending
condition|)
name|summarize_insn
argument_list|(
name|PATTERN
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|shadow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trap_pending
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Alpha can only issue instruction groups simultaneously if they are    suitably aligned.  This is very processor-specific.  */
end_comment

begin_enum
enum|enum
name|alphaev4_pipe
block|{
name|EV4_STOP
init|=
literal|0
block|,
name|EV4_IB0
init|=
literal|1
block|,
name|EV4_IB1
init|=
literal|2
block|,
name|EV4_IBX
init|=
literal|4
block|}
enum|;
end_enum

begin_enum
enum|enum
name|alphaev5_pipe
block|{
name|EV5_STOP
init|=
literal|0
block|,
name|EV5_NONE
init|=
literal|1
block|,
name|EV5_E01
init|=
literal|2
block|,
name|EV5_E0
init|=
literal|4
block|,
name|EV5_E1
init|=
literal|8
block|,
name|EV5_FAM
init|=
literal|16
block|,
name|EV5_FA
init|=
literal|32
block|,
name|EV5_FM
init|=
literal|64
block|}
enum|;
end_enum

begin_function
specifier|static
name|enum
name|alphaev4_pipe
name|alphaev4_insn_pipe
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EV4_STOP
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|EV4_STOP
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_FLD
case|:
return|return
name|EV4_IBX
return|;
case|case
name|TYPE_LDSYM
case|:
case|case
name|TYPE_IADD
case|:
case|case
name|TYPE_ILOG
case|:
case|case
name|TYPE_ICMOV
case|:
case|case
name|TYPE_ICMP
case|:
case|case
name|TYPE_IST
case|:
case|case
name|TYPE_FST
case|:
case|case
name|TYPE_SHIFT
case|:
case|case
name|TYPE_IMUL
case|:
case|case
name|TYPE_FBR
case|:
return|return
name|EV4_IB0
return|;
case|case
name|TYPE_MISC
case|:
case|case
name|TYPE_IBR
case|:
case|case
name|TYPE_JSR
case|:
case|case
name|TYPE_CALLPAL
case|:
case|case
name|TYPE_FCPYS
case|:
case|case
name|TYPE_FCMOV
case|:
case|case
name|TYPE_FADD
case|:
case|case
name|TYPE_FDIV
case|:
case|case
name|TYPE_FMUL
case|:
return|return
name|EV4_IB1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|alphaev5_pipe
name|alphaev5_insn_pipe
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EV5_STOP
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|EV5_STOP
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_ILD
case|:
case|case
name|TYPE_FLD
case|:
case|case
name|TYPE_LDSYM
case|:
case|case
name|TYPE_IADD
case|:
case|case
name|TYPE_ILOG
case|:
case|case
name|TYPE_ICMOV
case|:
case|case
name|TYPE_ICMP
case|:
return|return
name|EV5_E01
return|;
case|case
name|TYPE_IST
case|:
case|case
name|TYPE_FST
case|:
case|case
name|TYPE_SHIFT
case|:
case|case
name|TYPE_IMUL
case|:
case|case
name|TYPE_MISC
case|:
case|case
name|TYPE_MVI
case|:
return|return
name|EV5_E0
return|;
case|case
name|TYPE_IBR
case|:
case|case
name|TYPE_JSR
case|:
case|case
name|TYPE_CALLPAL
case|:
return|return
name|EV5_E1
return|;
case|case
name|TYPE_FCPYS
case|:
return|return
name|EV5_FAM
return|;
case|case
name|TYPE_FBR
case|:
case|case
name|TYPE_FCMOV
case|:
case|case
name|TYPE_FADD
case|:
case|case
name|TYPE_FDIV
case|:
return|return
name|EV5_FA
return|;
case|case
name|TYPE_FMUL
case|:
return|return
name|EV5_FM
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* IN_USE is a mask of the slots currently filled within the insn group.     The mask bits come from alphaev4_pipe above.  If EV4_IBX is set, then    the insn in EV4_IB0 can be swapped by the hardware into EV4_IB1.      LEN is, of course, the length of the group in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|alphaev4_next_group
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
modifier|*
name|pin_use
parameter_list|,
name|int
modifier|*
name|plen
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|in_use
decl_stmt|;
name|len
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next_and_done
goto|;
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|alphaev4_pipe
name|pipe
decl_stmt|;
name|pipe
operator|=
name|alphaev4_insn_pipe
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
name|EV4_STOP
case|:
comment|/* Force complex instructions to start new groups.  */
if|if
condition|(
name|in_use
condition|)
goto|goto
name|done
goto|;
comment|/* If this is a completely unrecognized insn, its an asm. 	     We don't know how long it is, so record length as -1 to 	     signal a needed realignment.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
goto|goto
name|next_and_done
goto|;
case|case
name|EV4_IBX
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB0
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV4_IB1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV4_IB0
operator||
name|EV4_IBX
expr_stmt|;
break|break;
case|case
name|EV4_IB0
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV4_IBX
operator|)
operator|||
operator|(
name|in_use
operator|&
name|EV4_IB1
operator|)
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
block|}
name|in_use
operator||=
name|EV4_IB0
expr_stmt|;
break|break;
case|case
name|EV4_IB1
case|:
if|if
condition|(
name|in_use
operator|&
name|EV4_IB1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|+=
literal|4
expr_stmt|;
comment|/* Haifa doesn't do well scheduling branches.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
goto|goto
name|next_and_done
goto|;
name|next
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Let Haifa tell us where it thinks insn group boundaries are.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next
goto|;
block|}
name|next_and_done
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|done
label|:
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* IN_USE is a mask of the slots currently filled within the insn group.     The mask bits come from alphaev5_pipe above.  If EV5_E01 is set, then    the insn in EV5_E0 can be swapped by the hardware into EV5_E1.      LEN is, of course, the length of the group in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|alphaev5_next_group
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
modifier|*
name|pin_use
parameter_list|,
name|int
modifier|*
name|plen
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|in_use
decl_stmt|;
name|len
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next_and_done
goto|;
while|while
condition|(
literal|1
condition|)
block|{
name|enum
name|alphaev5_pipe
name|pipe
decl_stmt|;
name|pipe
operator|=
name|alphaev5_insn_pipe
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pipe
condition|)
block|{
case|case
name|EV5_STOP
case|:
comment|/* Force complex instructions to start new groups.  */
if|if
condition|(
name|in_use
condition|)
goto|goto
name|done
goto|;
comment|/* If this is a completely unrecognized insn, its an asm. 	     We don't know how long it is, so record length as -1 to 	     signal a needed realignment.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
goto|goto
name|next_and_done
goto|;
comment|/* ??? Most of the places below, we would like to abort, as  	   it would indicate an error either in Haifa, or in the  	   scheduling description.  Unfortunately, Haifa never  	   schedules the last instruction of the BB, so we don't 	   have an accurate TI bit to go off.  */
case|case
name|EV5_E01
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E0
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV5_E1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV5_E0
operator||
name|EV5_E01
expr_stmt|;
break|break;
case|case
name|EV5_E0
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV5_E01
operator|)
operator|||
operator|(
name|in_use
operator|&
name|EV5_E1
operator|)
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
block|}
name|in_use
operator||=
name|EV5_E0
expr_stmt|;
break|break;
case|case
name|EV5_E1
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_E1
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
break|break;
case|case
name|EV5_FAM
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FA
condition|)
block|{
if|if
condition|(
name|in_use
operator|&
name|EV5_FM
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
block|}
else|else
name|in_use
operator||=
name|EV5_FA
operator||
name|EV5_FAM
expr_stmt|;
break|break;
case|case
name|EV5_FA
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FA
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FA
expr_stmt|;
break|break;
case|case
name|EV5_FM
case|:
if|if
condition|(
name|in_use
operator|&
name|EV5_FM
condition|)
goto|goto
name|done
goto|;
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
break|break;
case|case
name|EV5_NONE
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|+=
literal|4
expr_stmt|;
comment|/* Haifa doesn't do well scheduling branches.  */
comment|/* ??? If this is predicted not-taken, slotting continues, except 	 that no more IBR, FBR, or JSR insns may be slotted.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
goto|goto
name|next_and_done
goto|;
name|next
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* Let Haifa tell us where it thinks insn group boundaries are.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|USE
condition|)
goto|goto
name|next
goto|;
block|}
name|next_and_done
label|:
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|done
label|:
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|alphaev4_next_nop
parameter_list|(
name|int
modifier|*
name|pin_use
parameter_list|)
block|{
name|int
name|in_use
init|=
operator|*
name|pin_use
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV4_IB0
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV4_IB0
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|in_use
operator|&
operator|(
name|EV4_IBX
operator||
name|EV4_IB1
operator|)
operator|)
operator|==
name|EV4_IBX
condition|)
block|{
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV4_IB1
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV4_IB1
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
else|else
name|nop
operator|=
name|gen_unop
argument_list|()
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|nop
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|alphaev5_next_nop
parameter_list|(
name|int
modifier|*
name|pin_use
parameter_list|)
block|{
name|int
name|in_use
init|=
operator|*
name|pin_use
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|in_use
operator|&
name|EV5_E1
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_E1
expr_stmt|;
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV5_FA
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_FA
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_FP
operator|&&
operator|!
operator|(
name|in_use
operator|&
name|EV5_FM
operator|)
condition|)
block|{
name|in_use
operator||=
name|EV5_FM
expr_stmt|;
name|nop
operator|=
name|gen_fnop
argument_list|()
expr_stmt|;
block|}
else|else
name|nop
operator|=
name|gen_unop
argument_list|()
expr_stmt|;
operator|*
name|pin_use
operator|=
name|in_use
expr_stmt|;
return|return
name|nop
return|;
block|}
end_function

begin_comment
comment|/* The instruction group alignment main loop.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_align_insns
parameter_list|(
name|unsigned
name|int
name|max_align
parameter_list|,
name|rtx
function_decl|(
modifier|*
name|next_group
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
parameter_list|,
name|rtx
function_decl|(
modifier|*
name|next_nop
function_decl|)
parameter_list|(
name|int
modifier|*
parameter_list|)
parameter_list|)
block|{
comment|/* ALIGN is the known alignment for the insn group.  */
name|unsigned
name|int
name|align
decl_stmt|;
comment|/* OFS is the offset of the current insn in the insn group.  */
name|int
name|ofs
decl_stmt|;
name|int
name|prev_in_use
decl_stmt|,
name|in_use
decl_stmt|,
name|len
decl_stmt|;
name|rtx
name|i
decl_stmt|,
name|next
decl_stmt|;
comment|/* Let shorten branches care for assigning alignments to code labels.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_functions
operator|<
literal|4
condition|)
name|align
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|align_functions
operator|<
name|max_align
condition|)
name|align
operator|=
name|align_functions
expr_stmt|;
else|else
name|align
operator|=
name|max_align
expr_stmt|;
name|ofs
operator|=
name|prev_in_use
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|NOTE
condition|)
name|i
operator|=
name|next_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|next
operator|=
call|(
modifier|*
name|next_group
call|)
argument_list|(
name|i
argument_list|,
operator|&
name|in_use
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* When we see a label, resync alignment etc.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|unsigned
name|int
name|new_align
init|=
literal|1
operator|<<
name|label_to_alignment
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_align
operator|>=
name|align
condition|)
block|{
name|align
operator|=
name|new_align
operator|<
name|max_align
condition|?
name|new_align
else|:
name|max_align
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ofs
operator|&
operator|(
name|new_align
operator|-
literal|1
operator|)
condition|)
name|ofs
operator|=
operator|(
name|ofs
operator||
operator|(
name|new_align
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Handle complex instructions special.  */
elseif|else
if|if
condition|(
name|in_use
operator|==
literal|0
condition|)
block|{
comment|/* Asms will have length< 0.  This is a signal that we have 	     lost alignment knowledge.  Assume, however, that the asm 	     will not mis-align instructions.  */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|ofs
operator|=
literal|0
expr_stmt|;
name|align
operator|=
literal|4
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the known alignment is smaller than the recognized insn group, 	 realign the output.  */
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|align
operator|<
name|len
condition|)
block|{
name|unsigned
name|int
name|new_log_align
init|=
name|len
operator|>
literal|8
condition|?
literal|4
else|:
literal|3
decl_stmt|;
name|rtx
name|prev
decl_stmt|,
name|where
decl_stmt|;
name|where
operator|=
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|where
operator|||
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|where
operator|=
name|i
expr_stmt|;
comment|/* Can't realign between a call and its gp reload.  */
if|if
condition|(
operator|!
operator|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_realign
argument_list|(
name|GEN_INT
argument_list|(
name|new_log_align
argument_list|)
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|new_log_align
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the group won't fit in the same INT16 as the previous, 	 we need to add padding to keep the group together.  Rather 	 than simply leaving the insn filling to the assembler, we 	 can make use of the knowledge of what sorts of instructions 	 were issued in the previous group to make sure that all of 	 the added nops are really free.  */
elseif|else
if|if
condition|(
name|ofs
operator|+
name|len
operator|>
operator|(
name|int
operator|)
name|align
condition|)
block|{
name|int
name|nop_count
init|=
operator|(
name|align
operator|-
name|ofs
operator|)
operator|/
literal|4
decl_stmt|;
name|rtx
name|where
decl_stmt|;
comment|/* Insert nops before labels, branches, and calls to truly merge 	     the execution of the nops with the previous instruction group.  */
name|where
operator|=
name|prev_nonnote_insn
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|where2
init|=
name|prev_nonnote_insn
argument_list|(
name|where
argument_list|)
decl_stmt|;
if|if
condition|(
name|where2
operator|&&
name|GET_CODE
argument_list|(
name|where2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|where
operator|=
name|where2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|where
argument_list|)
operator|==
name|INSN
condition|)
name|where
operator|=
name|i
expr_stmt|;
block|}
else|else
name|where
operator|=
name|i
expr_stmt|;
do|do
name|emit_insn_before
argument_list|(
call|(
modifier|*
name|next_nop
call|)
argument_list|(
operator|&
name|prev_in_use
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|nop_count
condition|)
do|;
name|ofs
operator|=
literal|0
expr_stmt|;
block|}
name|ofs
operator|=
operator|(
name|ofs
operator|+
name|len
operator|)
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|prev_in_use
operator|=
name|in_use
expr_stmt|;
name|i
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Machine dependent reorg pass.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_reorg
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|alpha_tp
operator|!=
name|ALPHA_TP_PROG
operator|||
name|flag_exceptions
condition|)
name|alpha_handle_trap_shadows
argument_list|()
expr_stmt|;
comment|/* Due to the number of extra trapb insns, don't bother fixing up      alignment when trap precision is instruction.  Moreover, we can      only do our job when sched2 is run.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|optimize_size
operator|&&
name|alpha_tp
operator|!=
name|ALPHA_TP_INSN
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
if|if
condition|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV4
condition|)
name|alpha_align_insns
argument_list|(
literal|8
argument_list|,
name|alphaev4_next_group
argument_list|,
name|alphaev4_next_nop
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|alpha_cpu
operator|==
name|PROCESSOR_EV5
condition|)
name|alpha_align_insns
argument_list|(
literal|16
argument_list|,
name|alphaev5_next_group
argument_list|,
name|alphaev5_next_nop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|TARGET_ABI_UNICOSMK
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STAMP_H
end_ifdef

begin_include
include|#
directive|include
file|<stamp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|alpha_file_start
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
comment|/* If emitting dwarf2 debug information, we cannot generate a .file      directive to start the file, as it will conflict with dwarf2out      file numbers.  So it's only useful when emitting mdebug output.  */
name|targetm
operator|.
name|file_start_file_directive
operator|=
operator|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|)
expr_stmt|;
endif|#
directive|endif
name|default_file_start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MS_STAMP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.verstamp %d %d\n"
argument_list|,
name|MS_STAMP
argument_list|,
name|LS_STAMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\t.set noreorder\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.set volatile\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ABI_OPEN_VMS
condition|)
name|fputs
argument_list|(
literal|"\t.set noat\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
name|fputs
argument_list|(
literal|"\t.set nomacro\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SUPPORT_ARCH
operator||
name|TARGET_BWX
operator||
name|TARGET_MAX
operator||
name|TARGET_FIX
operator||
name|TARGET_CIX
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.arch %s\n"
argument_list|,
name|TARGET_CPU_EV6
condition|?
literal|"ev6"
else|:
operator|(
name|TARGET_CPU_EV5
condition|?
operator|(
name|TARGET_MAX
condition|?
literal|"pca56"
else|:
name|TARGET_BWX
condition|?
literal|"ev56"
else|:
literal|"ev5"
operator|)
else|:
literal|"ev4"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_comment
comment|/* Switch to the section to which we should output X.  The only thing    special we do here is to honor small data.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_elf_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
if|if
condition|(
name|TARGET_SMALL_DATA
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|g_switch_value
condition|)
comment|/* ??? Consider using mergeable sdata sections.  */
name|sdata_section
argument_list|()
expr_stmt|;
else|else
name|default_elf_select_rtx_section
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ELF */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Structure to collect function names for final output in link section.  */
end_comment

begin_comment
comment|/* Note that items marked with GTY can't be ifdef'ed out.  */
end_comment

begin_enum
enum|enum
name|links_kind
block|{
name|KIND_UNUSED
block|,
name|KIND_LOCAL
block|,
name|KIND_EXTERN
block|}
enum|;
end_enum

begin_enum
enum|enum
name|reloc_kind
block|{
name|KIND_LINKAGE
block|,
name|KIND_CODEADDR
block|}
enum|;
end_enum

begin_decl_stmt
name|struct
name|alpha_links
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|int
name|num
decl_stmt|;
name|rtx
name|linkage
decl_stmt|;
name|enum
name|links_kind
name|lkind
decl_stmt|;
name|enum
name|reloc_kind
name|rkind
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|alpha_funcs
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|int
name|num
decl_stmt|;
name|splay_tree
name|GTY
argument_list|(
operator|(
name|param1_is
argument_list|(
name|char
operator|*
argument_list|)
operator|,
name|param2_is
argument_list|(
expr|struct
name|alpha_links
operator|*
argument_list|)
operator|)
argument_list|)
name|links
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param1_is (char *), param2_is (struct alpha_links *))
argument_list|)
name|splay_tree
name|alpha_links_tree
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param1_is (tree), param2_is (struct alpha_funcs *))
argument_list|)
name|splay_tree
name|alpha_funcs_tree
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|alpha_funcs_num
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
end_if

begin_comment
comment|/* Return the VMS argument type corresponding to MODE.  */
end_comment

begin_function
name|enum
name|avms_arg_type
name|alpha_arg_type
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
return|return
name|TARGET_FLOAT_VAX
condition|?
name|FF
else|:
name|FS
return|;
case|case
name|DFmode
case|:
return|return
name|TARGET_FLOAT_VAX
condition|?
name|FD
else|:
name|FT
return|;
default|default:
return|return
name|I64
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return an rtx for an integer representing the VMS Argument Information    register value.  */
end_comment

begin_function
name|rtx
name|alpha_arg_info_reg_val
parameter_list|(
name|CUMULATIVE_ARGS
name|cum
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|regval
init|=
name|cum
operator|.
name|num_args
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|regval
operator||=
operator|(
operator|(
name|int
operator|)
name|cum
operator|.
name|atypes
index|[
name|i
index|]
operator|)
operator|<<
operator|(
name|i
operator|*
literal|3
operator|+
literal|8
operator|)
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|regval
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make (or fake) .linkage entry for function call.     IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.     Return an SYMBOL_REF rtx for the linkage.  */
end_comment

begin_function
name|rtx
name|alpha_need_linkage
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|is_local
parameter_list|)
block|{
name|splay_tree_node
name|node
decl_stmt|;
name|struct
name|alpha_links
modifier|*
name|al
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
block|{
name|struct
name|alpha_funcs
modifier|*
name|cfaf
decl_stmt|;
if|if
condition|(
operator|!
name|alpha_funcs_tree
condition|)
name|alpha_funcs_tree
operator|=
name|splay_tree_new_ggc
argument_list|(
operator|(
name|splay_tree_compare_fn
operator|)
name|splay_tree_compare_pointers
argument_list|)
expr_stmt|;
name|cfaf
operator|=
operator|(
expr|struct
name|alpha_funcs
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_funcs
argument_list|)
argument_list|)
expr_stmt|;
name|cfaf
operator|->
name|links
operator|=
literal|0
expr_stmt|;
name|cfaf
operator|->
name|num
operator|=
operator|++
name|alpha_funcs_num
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|alpha_funcs_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|current_function_decl
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|cfaf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alpha_links_tree
condition|)
block|{
comment|/* Is this name already defined?  */
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|alpha_links_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|al
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|node
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
block|{
comment|/* Defined here but external assumed.  */
if|if
condition|(
name|al
operator|->
name|lkind
operator|==
name|KIND_EXTERN
condition|)
name|al
operator|->
name|lkind
operator|=
name|KIND_LOCAL
expr_stmt|;
block|}
else|else
block|{
comment|/* Used here but unused assumed.  */
if|if
condition|(
name|al
operator|->
name|lkind
operator|==
name|KIND_UNUSED
condition|)
name|al
operator|->
name|lkind
operator|=
name|KIND_LOCAL
expr_stmt|;
block|}
return|return
name|al
operator|->
name|linkage
return|;
block|}
block|}
else|else
name|alpha_links_tree
operator|=
name|splay_tree_new_ggc
argument_list|(
operator|(
name|splay_tree_compare_fn
operator|)
name|strcmp
argument_list|)
expr_stmt|;
name|al
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_links
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|ggc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Assume external if no definition.  */
name|al
operator|->
name|lkind
operator|=
operator|(
name|is_local
condition|?
name|KIND_UNUSED
else|:
name|KIND_EXTERN
operator|)
expr_stmt|;
comment|/* Ensure we have an IDENTIFIER so assemble_name can mark it used.  */
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Construct a SYMBOL_REF for us to call.  */
block|{
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|linksym
init|=
name|alloca
argument_list|(
name|name_len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|linksym
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|memcpy
argument_list|(
name|linksym
operator|+
literal|1
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|linksym
operator|+
literal|1
operator|+
name|name_len
argument_list|,
literal|"..lk"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|al
operator|->
name|linkage
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_alloc_string
argument_list|(
name|linksym
argument_list|,
name|name_len
operator|+
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splay_tree_insert
argument_list|(
name|alpha_links_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|al
argument_list|)
expr_stmt|;
return|return
name|al
operator|->
name|linkage
return|;
block|}
end_function

begin_function
name|rtx
name|alpha_use_linkage
parameter_list|(
name|rtx
name|linkage
parameter_list|,
name|tree
name|cfundecl
parameter_list|,
name|int
name|lflag
parameter_list|,
name|int
name|rflag
parameter_list|)
block|{
name|splay_tree_node
name|cfunnode
decl_stmt|;
name|struct
name|alpha_funcs
modifier|*
name|cfaf
decl_stmt|;
name|struct
name|alpha_links
modifier|*
name|al
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|linkage
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|cfaf
operator|=
operator|(
expr|struct
name|alpha_funcs
operator|*
operator|)
literal|0
expr_stmt|;
name|al
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
literal|0
expr_stmt|;
name|cfunnode
operator|=
name|splay_tree_lookup
argument_list|(
name|alpha_funcs_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|cfundecl
argument_list|)
expr_stmt|;
name|cfaf
operator|=
operator|(
expr|struct
name|alpha_funcs
operator|*
operator|)
name|cfunnode
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|cfaf
operator|->
name|links
condition|)
block|{
name|splay_tree_node
name|lnode
decl_stmt|;
comment|/* Is this name already defined?  */
name|lnode
operator|=
name|splay_tree_lookup
argument_list|(
name|cfaf
operator|->
name|links
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnode
condition|)
name|al
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|lnode
operator|->
name|value
expr_stmt|;
block|}
else|else
name|cfaf
operator|->
name|links
operator|=
name|splay_tree_new_ggc
argument_list|(
operator|(
name|splay_tree_compare_fn
operator|)
name|strcmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|al
condition|)
block|{
name|size_t
name|name_len
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|linksym
decl_stmt|;
name|splay_tree_node
name|node
init|=
literal|0
decl_stmt|;
name|struct
name|alpha_links
modifier|*
name|anl
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|name
operator|++
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|al
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_links
argument_list|)
argument_list|)
expr_stmt|;
name|al
operator|->
name|num
operator|=
name|cfaf
operator|->
name|num
expr_stmt|;
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|alpha_links_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|anl
operator|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|node
operator|->
name|value
expr_stmt|;
name|al
operator|->
name|lkind
operator|=
name|anl
operator|->
name|lkind
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$%d..%s..lk"
argument_list|,
name|cfaf
operator|->
name|num
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|linksym
operator|=
name|alloca
argument_list|(
name|buflen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|linksym
argument_list|,
name|buf
argument_list|,
name|buflen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|al
operator|->
name|linkage
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_alloc_string
argument_list|(
name|linksym
argument_list|,
name|buflen
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|cfaf
operator|->
name|links
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|al
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rflag
condition|)
name|al
operator|->
name|rkind
operator|=
name|KIND_CODEADDR
expr_stmt|;
else|else
name|al
operator|->
name|rkind
operator|=
name|KIND_LINKAGE
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|al
operator|->
name|linkage
argument_list|,
literal|8
argument_list|)
argument_list|)
return|;
else|else
return|return
name|al
operator|->
name|linkage
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_write_one_linkage
parameter_list|(
name|splay_tree_node
name|node
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|node
operator|->
name|key
decl_stmt|;
name|struct
name|alpha_links
modifier|*
name|link
init|=
operator|(
expr|struct
name|alpha_links
operator|*
operator|)
name|node
operator|->
name|value
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
operator|(
name|FILE
operator|*
operator|)
name|data
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"$%d..%s..lk:\n"
argument_list|,
name|link
operator|->
name|num
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|rkind
operator|==
name|KIND_CODEADDR
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|lkind
operator|==
name|KIND_LOCAL
condition|)
block|{
comment|/* Local and used */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.quad %s..en\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* External and used, request code address.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.code_address %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|link
operator|->
name|lkind
operator|==
name|KIND_LOCAL
condition|)
block|{
comment|/* Local and used, build linkage pair.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.quad %s..en\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.quad %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* External and used, request linkage pair.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.linkage %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|alpha_write_linkage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|funname
parameter_list|,
name|tree
name|fundecl
parameter_list|)
block|{
name|splay_tree_node
name|node
decl_stmt|;
name|struct
name|alpha_funcs
modifier|*
name|func
decl_stmt|;
name|link_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.align 3\n"
argument_list|)
expr_stmt|;
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|alpha_funcs_tree
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|fundecl
argument_list|)
expr_stmt|;
name|func
operator|=
operator|(
expr|struct
name|alpha_funcs
operator|*
operator|)
name|node
operator|->
name|value
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.name "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|funname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"..na\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|stream
argument_list|,
name|funname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.pdesc "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|funname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"..en,%s\n"
argument_list|,
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|?
literal|"stack"
else|:
name|alpha_procedure_type
operator|==
name|PT_REGISTER
condition|?
literal|"reg"
else|:
literal|"null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|links
condition|)
block|{
name|splay_tree_foreach
argument_list|(
name|func
operator|->
name|links
argument_list|,
name|alpha_write_one_linkage
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* splay_tree_delete (func->links); */
block|}
block|}
end_function

begin_comment
comment|/* Given a decl, a section name, and whether the decl initializer    has relocs, choose attributes for the section.  */
end_comment

begin_define
define|#
directive|define
name|SECTION_VMS_OVERLAY
value|SECTION_FORGET
end_define

begin_define
define|#
directive|define
name|SECTION_VMS_GLOBAL
value|SECTION_MACH_DEP
end_define

begin_define
define|#
directive|define
name|SECTION_VMS_INITIALIZE
value|(SECTION_VMS_GLOBAL<< 1)
end_define

begin_function
specifier|static
name|unsigned
name|int
name|vms_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|unsigned
name|int
name|flags
init|=
name|default_section_type_flags
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"overlaid"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_VMS_OVERLAY
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"global"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_VMS_GLOBAL
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"initialize"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_VMS_INITIALIZE
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Switch to an arbitrary section NAME with attributes as specified    by FLAGS.  ALIGN specifies any known alignment requirements for    the section; 0 if the default should be used.  */
end_comment

begin_function
specifier|static
name|void
name|vms_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".section\t%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_VMS_OVERLAY
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",OVR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_VMS_GLOBAL
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",GBL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_VMS_INITIALIZE
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",NOMOD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_DEBUG
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",NOWRT"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an element in the table of global constructors.  SYMBOL is    a SYMBOL_REF of the function to be called; PRIORITY is a number    between 0 and MAX_INIT_PRIORITY.       Differs from default_ctors_section_asm_out_constructor in that the    width of the .ctors entry is always 64 bits, rather than the 32 bits    used by a normal pointer.  */
end_comment

begin_function
specifier|static
name|void
name|vms_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|ctors_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|UNITS_PER_WORD
argument_list|,
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vms_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|dtors_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|UNITS_PER_WORD
argument_list|,
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|rtx
name|alpha_need_linkage
parameter_list|(
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|is_local
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
name|rtx
name|alpha_use_linkage
parameter_list|(
name|rtx
name|linkage
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|cfundecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|lflag
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|rflag
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_ABI_OPEN_VMS */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|TARGET_ABI_UNICOSMK
end_if

begin_comment
comment|/* Define the offset between two registers, one to be eliminated, and the    other its replacement, at the start of a routine.  */
end_comment

begin_function
name|int
name|unicosmk_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|int
name|fixed_size
decl_stmt|;
name|fixed_size
operator|=
name|alpha_sa_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|fixed_size
operator|!=
literal|0
condition|)
name|fixed_size
operator|+=
literal|48
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
operator|-
name|fixed_size
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
operator|(
name|ALPHA_ROUND
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
operator|(
name|ALPHA_ROUND
argument_list|(
name|fixed_size
argument_list|)
operator|+
name|ALPHA_ROUND
argument_list|(
name|get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
argument_list|)
operator|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the module name for .ident and .end directives. We have to strip    directories and add make sure that the module name starts with a letter    or '$'.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_module_name
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|lbasename
argument_list|(
name|main_input_filename
argument_list|)
decl_stmt|;
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|clean_name
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|clean_name
decl_stmt|;
comment|/* CAM only accepts module names that start with a letter or '$'. We      prefix the module name with a '$' if necessary.  */
if|if
condition|(
operator|!
name|ISALPHA
argument_list|(
operator|*
name|name
argument_list|)
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|'$'
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|clean_symbol_name
argument_list|(
name|clean_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|clean_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the definition of a common variable.  */
end_comment

begin_function
name|void
name|unicosmk_output_common
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|tree
name|name_tree
decl_stmt|;
name|printf
argument_list|(
literal|"T3E__: common %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|common_section
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.endp\n\n\t.psect "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",%d,common\n"
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte\t0:%d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as defined in this module.  */
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SECTION_PUBLIC
value|SECTION_MACH_DEP
end_define

begin_define
define|#
directive|define
name|SECTION_MAIN
value|(SECTION_PUBLIC<< 1)
end_define

begin_decl_stmt
specifier|static
name|int
name|current_section_align
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|unicosmk_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|flags
init|=
name|default_section_type_flags
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
return|return
name|flags
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|current_section_align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_functions_log
operator|>
name|current_section_align
condition|)
name|current_section_align
operator|=
name|align_functions_log
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_MAIN
expr_stmt|;
block|}
else|else
name|current_section_align
operator|=
name|floor_log2
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_PUBLIC
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Generate a section name for decl and associate it with the    declaration.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
name|abort
argument_list|()
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|default_strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
comment|/* It is essential that we prefix the section name here because  	 otherwise the section names generated for constructors and  	 destructors confuse collect2.  */
name|string
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"code@%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
operator|+
literal|5
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"data@%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
operator|+
literal|5
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Switch to an arbitrary section NAME with attributes as specified    by FLAGS.  ALIGN specifies any known alignment requirements for    the section; 0 if the default should be used.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|kind
decl_stmt|;
comment|/* Close the previous section.  */
name|fputs
argument_list|(
literal|"\t.endp\n\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Find out what kind of section we are opening.  */
if|if
condition|(
name|flags
operator|&
name|SECTION_MAIN
condition|)
name|fputs
argument_list|(
literal|"\t.start\tmain\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
name|kind
operator|=
literal|"code"
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_PUBLIC
condition|)
name|kind
operator|=
literal|"common"
expr_stmt|;
else|else
name|kind
operator|=
literal|"data"
expr_stmt|;
if|if
condition|(
name|current_section_align
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.psect\t%s,%d,%s\n"
argument_list|,
name|name
argument_list|,
name|current_section_align
argument_list|,
name|kind
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.psect\t%s,%s\n"
argument_list|,
name|name
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unicosmk_insert_attributes
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
modifier|*
name|attr_ptr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
name|unicosmk_unique_section
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an alignment directive. We have to use the macro 'gcc@code@align'    in code sections because .align fill unused space with zeroes.  */
end_comment

begin_function
name|void
name|unicosmk_output_align
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|inside_function
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tgcc@code@align\t%d\n"
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align\t%d\n"
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a case vector to the current function's list of deferred case    vectors. Case vectors have to be put into a separate section because CAM    does not allow data definitions in code sections.  */
end_comment

begin_function
name|void
name|unicosmk_defer_case_vector
parameter_list|(
name|rtx
name|lab
parameter_list|,
name|rtx
name|vec
parameter_list|)
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|cfun
operator|->
name|machine
decl_stmt|;
name|vec
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|machine
operator|->
name|addr_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|,
name|machine
operator|->
name|addr_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a case vector.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_addr_vec
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|vec
parameter_list|)
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|body
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|vlen
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
name|ASM_OUTPUT_ADDR_VEC_ELT
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output current function's deferred case vectors.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_deferred_case_vectors
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|cfun
operator|->
name|machine
decl_stmt|;
name|rtx
name|t
decl_stmt|;
if|if
condition|(
name|machine
operator|->
name|addr_list
operator|==
name|NULL_RTX
condition|)
return|return;
name|data_section
argument_list|()
expr_stmt|;
for|for
control|(
name|t
operator|=
name|machine
operator|->
name|addr_list
init|;
name|t
condition|;
name|t
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
control|)
name|unicosmk_output_addr_vec
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the name of the SSIB section for the current function.  */
end_comment

begin_define
define|#
directive|define
name|SSIB_PREFIX
value|"__SSIB_"
end_define

begin_define
define|#
directive|define
name|SSIB_PREFIX_LEN
value|7
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|unicosmk_ssib_name
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This is ok since CAM won't be able to deal with names longer than that       anyway.  */
specifier|static
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|int
name|len
decl_stmt|;
name|x
operator|=
name|DECL_RTL
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|SSIB_PREFIX_LEN
operator|>
literal|255
condition|)
name|len
operator|=
literal|255
operator|-
name|SSIB_PREFIX_LEN
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|SSIB_PREFIX
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
operator|+
name|SSIB_PREFIX_LEN
argument_list|,
name|fnname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
operator|+
name|SSIB_PREFIX_LEN
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Set up the dynamic subprogram information block (DSIB) and update the     frame pointer register ($15) for subroutines which have a frame. If the     subroutine doesn't have a frame, simply increment $15.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_gen_dsib
parameter_list|(
name|unsigned
name|long
modifier|*
name|imaskP
parameter_list|)
block|{
if|if
condition|(
name|alpha_procedure_type
operator|==
name|PT_STACK
condition|)
block|{
specifier|const
name|char
modifier|*
name|ssib_name
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* Allocate 64 bytes for the DSIB.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|64
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Save the return address.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|56
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REG_RA
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|imaskP
operator|)
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|REG_RA
operator|)
expr_stmt|;
comment|/* Save the old frame pointer.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|48
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|imaskP
operator|)
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Store the SSIB pointer.  */
name|ssib_name
operator|=
name|ggc_strdup
argument_list|(
name|unicosmk_ssib_name
argument_list|()
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|5
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ssib_name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the CIW index.  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|alpha_sr_alias_set
argument_list|)
expr_stmt|;
name|FRP
argument_list|(
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|25
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set the new frame pointer.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|64
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Increment the frame pointer register to indicate that we do not          have a frame.  */
name|FRP
argument_list|(
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the static subroutine information block for the current    function.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_ssib
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fnname
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|ciw
decl_stmt|;
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|cfun
operator|->
name|machine
decl_stmt|;
name|ssib_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.endp\n\n\t.psect\t%s%s,data\n"
argument_list|,
name|user_label_prefix
argument_list|,
name|unicosmk_ssib_name
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Some required stuff and the function name length.  */
name|len
operator|=
name|strlen
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.quad\t^X20008%2.2X28\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Saved registers      ??? We don't do that yet.  */
name|fputs
argument_list|(
literal|"\t.quad\t0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Function address.  */
name|fputs
argument_list|(
literal|"\t.quad\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.quad\t0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.quad\t0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Function name.      ??? We do it the same way Cray CC does it but this could be      simplified.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte\t%d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fnname
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\t.quad\t0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.bits\t%d : 0\n"
argument_list|,
operator|(
literal|8
operator|-
operator|(
name|len
operator|%
literal|8
operator|)
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* All call information words used in the function.  */
for|for
control|(
name|x
operator|=
name|machine
operator|->
name|first_ciw
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ciw
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.quad\t"
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
literal|"\n"
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|ciw
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|ciw
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.quad\t"
name|HOST_WIDE_INT_PRINT_HEX
literal|"\n"
argument_list|,
name|INTVAL
argument_list|(
name|ciw
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Add a call information word (CIW) to the list of the current function's    CIWs and return its index.     X is a CONST_INT or CONST_DOUBLE representing the CIW.  */
end_comment

begin_function
name|rtx
name|unicosmk_add_call_info_word
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|node
decl_stmt|;
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|cfun
operator|->
name|machine
decl_stmt|;
name|node
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|machine
operator|->
name|first_ciw
operator|==
name|NULL_RTX
condition|)
name|machine
operator|->
name|first_ciw
operator|=
name|node
expr_stmt|;
else|else
name|XEXP
argument_list|(
name|machine
operator|->
name|last_ciw
argument_list|,
literal|1
argument_list|)
operator|=
name|node
expr_stmt|;
name|machine
operator|->
name|last_ciw
operator|=
name|node
expr_stmt|;
operator|++
name|machine
operator|->
name|ciw_count
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|machine
operator|->
name|ciw_count
operator|+
name|strlen
argument_list|(
name|current_function_name
argument_list|()
argument_list|)
operator|/
literal|8
operator|+
literal|5
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|unicosmk_section_buf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|unicosmk_text_section
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|unicosmk_section_buf
argument_list|,
literal|"\t.endp\n\n\t.psect\tgcc@text___%d,code"
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
return|return
name|unicosmk_section_buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unicosmk_data_section
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|count
init|=
literal|1
decl_stmt|;
name|sprintf
argument_list|(
name|unicosmk_section_buf
argument_list|,
literal|"\t.endp\n\n\t.psect\tgcc@data___%d,data"
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
return|return
name|unicosmk_section_buf
return|;
block|}
end_function

begin_comment
comment|/* The Cray assembler doesn't accept extern declarations for symbols which    are defined in the same file. We have to keep track of all global    symbols which are referenced and/or defined in a source file and output    extern declarations for those which are referenced but not defined at    the end of file.  */
end_comment

begin_comment
comment|/* List of identifiers for which an extern declaration might have to be    emitted.  */
end_comment

begin_comment
comment|/* FIXME: needs to use GC, so it can be saved and restored for PCH.  */
end_comment

begin_struct
struct|struct
name|unicosmk_extern_list
block|{
name|struct
name|unicosmk_extern_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|unicosmk_extern_list
modifier|*
name|unicosmk_extern_head
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output extern declarations which are required for every asm file.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_default_externs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|externs
index|[]
init|=
block|{
literal|"__T3E_MISMATCH"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
name|ARRAY_SIZE
argument_list|(
name|externs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.extern\t%s\n"
argument_list|,
name|externs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output extern declarations for global symbols which are have been    referenced but not defined.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_externs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|unicosmk_extern_list
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|name_tree
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|user_label_prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|unicosmk_extern_head
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* We have to strip the encoding and possibly remove user_label_prefix  	 from the identifier in order to handle -fleading-underscore and 	 explicit asm names correctly (cf. gcc.dg/asm-names-1.c).  */
name|real_name
operator|=
name|default_strip_name_encoding
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
operator|!
name|memcmp
argument_list|(
name|real_name
argument_list|,
name|user_label_prefix
argument_list|,
name|len
argument_list|)
condition|)
name|real_name
operator|+=
name|len
expr_stmt|;
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record an extern.  */
end_comment

begin_function
name|void
name|unicosmk_add_extern
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|unicosmk_extern_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|unicosmk_extern_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unicosmk_extern_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|unicosmk_extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|unicosmk_extern_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The Cray assembler generates incorrect code if identifiers which    conflict with register names are used as instruction operands. We have    to replace such identifiers with DEX expressions.  */
end_comment

begin_comment
comment|/* Structure to collect identifiers which have been replaced by DEX    expressions.  */
end_comment

begin_comment
comment|/* FIXME: needs to use GC, so it can be saved and restored for PCH.  */
end_comment

begin_struct
struct|struct
name|unicosmk_dex
block|{
name|struct
name|unicosmk_dex
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of identifiers which have been replaced by DEX expressions. The DEX     number is determined by the position in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unicosmk_dex
modifier|*
name|unicosmk_dex_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of elements in the DEX list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unicosmk_dex_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check if NAME must be replaced by a DEX expression.  */
end_comment

begin_function
specifier|static
name|int
name|unicosmk_special_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
operator|++
name|name
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
operator|++
name|name
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'r'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'f'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'R'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'F'
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
return|return
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|ISDIGIT
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
case|case
literal|'3'
case|:
return|return
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'0'
operator|||
name|name
index|[
literal|2
index|]
operator|==
literal|'1'
operator|)
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
default|default:
return|return
operator|(
name|ISDIGIT
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the DEX number if X must be replaced by a DEX expression and 0    otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|unicosmk_need_dex
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|unicosmk_dex
modifier|*
name|dex
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unicosmk_special_name
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
name|i
operator|=
name|unicosmk_dex_count
expr_stmt|;
for|for
control|(
name|dex
operator|=
name|unicosmk_dex_list
init|;
name|dex
condition|;
name|dex
operator|=
name|dex
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|dex
operator|->
name|name
argument_list|)
condition|)
return|return
name|i
return|;
operator|--
name|i
expr_stmt|;
block|}
name|dex
operator|=
operator|(
expr|struct
name|unicosmk_dex
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unicosmk_dex
argument_list|)
argument_list|)
expr_stmt|;
name|dex
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|dex
operator|->
name|next
operator|=
name|unicosmk_dex_list
expr_stmt|;
name|unicosmk_dex_list
operator|=
name|dex
expr_stmt|;
operator|++
name|unicosmk_dex_count
expr_stmt|;
return|return
name|unicosmk_dex_count
return|;
block|}
end_function

begin_comment
comment|/* Output the DEX definitions for this file.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_output_dex
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|unicosmk_dex
modifier|*
name|dex
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unicosmk_dex_list
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.dexstart\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|unicosmk_dex_count
expr_stmt|;
for|for
control|(
name|dex
operator|=
name|unicosmk_dex_list
init|;
name|dex
condition|;
name|dex
operator|=
name|dex
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tDEX (%d) = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|dex
operator|->
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.dexend\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output text that to appear at the beginning of an assembler file.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fputs
argument_list|(
literal|"\t.ident\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|unicosmk_output_module_name
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* The Unicos/Mk assembler uses different register names. Instead of trying      to support them, we simply use micro definitions.  */
comment|/* CAM has different register names: rN for the integer register N and fN      for the floating-point register N. Instead of trying to use these in      alpha.md, we define the symbols $N and $fN to refer to the appropriate      register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"$%d<- r%d\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"$f%d<- f%d\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* The .align directive fill unused space with zeroes which does not work      in code sections. We define the macro 'gcc@code@align' which uses nops      instead. Note that it assumes that code sections always have the      biggest possible alignment since . refers to the current offset from      the beginning of the section.  */
name|fputs
argument_list|(
literal|"\t.macro gcc@code@align n\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gcc@n@bytes = 1<< n\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gcc@here = . % gcc@n@bytes\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.if ne, gcc@here, 0\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.repeat (gcc@n@bytes - gcc@here) / 4\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tbis r31,r31,r31\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.endr\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.endif\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.endm gcc@code@align\n\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output extern declarations which should always be visible.  */
name|unicosmk_output_default_externs
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Open a dummy section. We always need to be inside a section for the      section-switching code to work correctly.      ??? This should be a module id or something like that. I still have to      figure out what the rules for those are.  */
name|fputs
argument_list|(
literal|"\n\t.psect\t$SG00000,data\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output text to appear at the end of an assembler file. This includes all    pending extern declarations and DEX expressions.  */
end_comment

begin_function
specifier|static
name|void
name|unicosmk_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"\t.endp\n\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output all pending externs.  */
name|unicosmk_output_externs
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output dex definitions used for functions whose names conflict with       register names.  */
name|unicosmk_output_dex
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.end\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|unicosmk_output_module_name
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|unicosmk_output_deferred_case_vectors
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|unicosmk_gen_dsib
parameter_list|(
name|unsigned
name|long
modifier|*
name|imaskP
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|unicosmk_output_ssib
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|fnname
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{}
end_function

begin_function
name|rtx
name|unicosmk_add_call_info_word
parameter_list|(
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unicosmk_need_dex
parameter_list|(
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_ABI_UNICOSMK */
end_comment

begin_function
specifier|static
name|void
name|alpha_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ABI_UNICOSMK
condition|)
block|{
comment|/* Prevent gcc from generating calls to __divsi3.  */
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use the functions provided by the system library 	 for DImode integer division.  */
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"$sldiv"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"$uldiv"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ABI_OPEN_VMS
condition|)
block|{
comment|/* Use the VMS runtime library functions for division and 	 remainder.  */
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$DIV_I"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$DIV_L"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$DIV_UI"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$DIV_UL"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$REM_I"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$REM_L"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$REM_UI"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$REM_UL"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ABI_OPEN_VMS
end_if

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|vms_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SECTION_TYPE_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SECTION_TYPE_FLAGS
value|vms_section_type_flags
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_IN_SMALL_DATA_P
end_undef

begin_define
define|#
directive|define
name|TARGET_IN_SMALL_DATA_P
value|alpha_in_small_data_p
end_define

begin_if
if|#
directive|if
name|TARGET_ABI_UNICOSMK
end_if

begin_undef
undef|#
directive|undef
name|TARGET_INSERT_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_INSERT_ATTRIBUTES
value|unicosmk_insert_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SECTION_TYPE_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SECTION_TYPE_FLAGS
value|unicosmk_section_type_flags
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNIQUE_SECTION
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNIQUE_SECTION
value|unicosmk_unique_section
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_GLOBALIZE_LABEL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_GLOBALIZE_LABEL
value|hook_void_FILEptr_constcharptr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\t.quad\t"
end_define

begin_comment
comment|/* Default unaligned ops are provided for ELF systems.  To get unaligned    data for non-ELF systems, we have to turn off auto alignment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
end_ifndef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.align 0\n\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.align 0\n\t.long\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\t.align 0\n\t.quad\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_SELECT_RTX_SECTION
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_SELECT_RTX_SECTION
value|alpha_elf_select_rtx_section
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_END_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_END_PROLOGUE
value|alpha_output_function_end_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_LIBFUNCS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_LIBFUNCS
value|alpha_init_libfuncs
end_define

begin_if
if|#
directive|if
name|TARGET_ABI_UNICOSMK
end_if

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|unicosmk_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_END
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_END
value|unicosmk_file_end
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|alpha_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START_FILE_DIRECTIVE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START_FILE_DIRECTIVE
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|alpha_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|alpha_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
define|\
value|alpha_use_dfa_pipeline_interface
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
define|\
value|alpha_multipass_dfa_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|HAVE_AS_TLS
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|alpha_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|alpha_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|alpha_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_COPY_INSN_P
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_COPY_INSN_P
value|alpha_cannot_copy_insn_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|alpha_cannot_force_const_mem
end_define

begin_if
if|#
directive|if
name|TARGET_ABI_OSF
end_if

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|alpha_output_mi_thunk_osf
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|alpha_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|hook_int_rtx_0
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|alpha_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_ARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_ARGS
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_RETURN
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_RETURN
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_PROTOTYPES
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_PROTOTYPES
value|hook_bool_tree_false
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRUCT_VALUE_RTX
end_undef

begin_define
define|#
directive|define
name|TARGET_STRUCT_VALUE_RTX
value|hook_rtx_tree_int_null
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MEMORY
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MEMORY
value|alpha_return_in_memory
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SETUP_INCOMING_VARARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SETUP_INCOMING_VARARGS
value|alpha_setup_incoming_varargs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRICT_ARGUMENT_NAMING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRICT_ARGUMENT_NAMING
value|hook_bool_CUMULATIVE_ARGS_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PRETEND_OUTGOING_VARARGS_NAMED
end_undef

begin_define
define|#
directive|define
name|TARGET_PRETEND_OUTGOING_VARARGS_NAMED
value|hook_bool_CUMULATIVE_ARGS_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SPLIT_COMPLEX_ARG
end_undef

begin_define
define|#
directive|define
name|TARGET_SPLIT_COMPLEX_ARG
value|alpha_split_complex_arg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BUILD_BUILTIN_VA_LIST
end_undef

begin_define
define|#
directive|define
name|TARGET_BUILD_BUILTIN_VA_LIST
value|alpha_build_builtin_va_list
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_include
include|#
directive|include
file|"gt-alpha.h"
end_include

end_unit

