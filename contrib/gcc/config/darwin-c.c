begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Darwin support needed only by C/C++ frontends.    Copyright (C) 2001    Free Software Foundation, Inc.    Contributed by Apple Computer Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* Pragmas.  */
end_comment

begin_define
define|#
directive|define
name|BAD
parameter_list|(
name|msgid
parameter_list|)
value|do { warning (msgid); return; } while (0)
end_define

begin_comment
comment|/* Maintain a small stack of alignments.  This is similar to pragma    pack's stack, but simpler.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|push_field_alignment
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_field_alignment
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|align_stack
block|{
name|int
name|alignment
decl_stmt|;
name|struct
name|align_stack
modifier|*
name|prev
decl_stmt|;
block|}
name|align_stack
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|align_stack
modifier|*
name|field_align_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_field_alignment
parameter_list|(
name|bit_alignment
parameter_list|)
name|int
name|bit_alignment
decl_stmt|;
block|{
name|align_stack
modifier|*
name|entry
init|=
operator|(
name|align_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|align_stack
argument_list|)
argument_list|)
decl_stmt|;
name|entry
operator|->
name|alignment
operator|=
name|maximum_field_alignment
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|field_align_stack
expr_stmt|;
name|field_align_stack
operator|=
name|entry
expr_stmt|;
name|maximum_field_alignment
operator|=
name|bit_alignment
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_field_alignment
parameter_list|()
block|{
if|if
condition|(
name|field_align_stack
condition|)
block|{
name|align_stack
modifier|*
name|entry
init|=
name|field_align_stack
decl_stmt|;
name|maximum_field_alignment
operator|=
name|entry
operator|->
name|alignment
expr_stmt|;
name|field_align_stack
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too many #pragma options align=reset"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handlers for Darwin-specific pragmas.  */
end_comment

begin_function
name|void
name|darwin_pragma_ignore
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Do nothing.  */
block|}
end_function

begin_comment
comment|/* #pragma options align={mac68k|power|reset} */
end_comment

begin_function
name|void
name|darwin_pragma_options
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma options', ignoring"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"align"
argument_list|)
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma options', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_EQ
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma options', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma options', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of '#pragma options'"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"mac68k"
argument_list|)
condition|)
name|push_field_alignment
argument_list|(
literal|16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"power"
argument_list|)
condition|)
name|push_field_alignment
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"reset"
argument_list|)
condition|)
name|pop_field_alignment
argument_list|()
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"malformed '#pragma options align={mac68k|power|reset}', ignoring"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* #pragma unused ([var {, var}*]) */
end_comment

begin_function
name|void
name|darwin_pragma_unused
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|x
decl_stmt|;
name|int
name|tok
decl_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
name|BAD
argument_list|(
literal|"missing '(' after '#pragma unused', ignoring"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tok
operator|=
name|c_lex
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|CPP_NAME
operator|&&
name|decl
condition|)
block|{
name|tree
name|local
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|local
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|local
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|local
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|TREE_USED
argument_list|(
name|local
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tok
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|CPP_COMMA
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|tok
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|BAD
argument_list|(
literal|"missing ')' after '#pragma unused', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of '#pragma unused'"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

