begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Solaris support needed only by C/C++ frontends.    Copyright (C) 2004, 2005  Free Software Foundation, Inc.    Contributed by CodeSourcery, LLC.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"c-format.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_comment
comment|/* cmn_err only accepts "l" and "ll".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|format_length_info
name|cmn_err_length_specs
index|[]
init|=
block|{
block|{
literal|"l"
block|,
name|FMT_LEN_l
block|,
name|STD_C89
block|,
literal|"ll"
block|,
name|FMT_LEN_ll
block|,
name|STD_C89
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_spec
name|cmn_err_flag_specs
index|[]
init|=
block|{
block|{
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"field width"
argument_list|)
block|,
name|N_
argument_list|(
literal|"field width in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|'L'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"length modifier"
argument_list|)
block|,
name|N_
argument_list|(
literal|"length modifier in printf format"
argument_list|)
block|,
name|STD_C89
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_flag_pair
name|cmn_err_flag_pairs
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|bitfield_string_type
init|=
block|{
literal|"b"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|""
block|,
literal|"cR"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|format_char_info
name|cmn_err_char_table
index|[]
init|=
block|{
comment|/* C89 conversion specifiers.  */
block|{
literal|"dD"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_L
block|,
name|T9L_LL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"w"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"oOxX"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"w"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_UI
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|T89_UL
block|,
name|T9L_ULL
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"w"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"w"
block|,
literal|""
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_V
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"w"
block|,
literal|"c"
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|STD_C89
block|,
block|{
name|T89_C
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"w"
block|,
literal|"cR"
block|,
name|NULL
block|}
block|,
block|{
literal|"b"
block|,
literal|0
block|,
name|STD_C89
block|,
block|{
name|T89_I
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|,
name|BADLEN
block|}
block|,
literal|"w"
block|,
literal|""
block|,
operator|&
name|bitfield_string_type
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NOLENGTHS
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|format_kind_info
name|solaris_format_types
index|[]
init|=
block|{
block|{
literal|"cmn_err"
block|,
name|cmn_err_length_specs
block|,
name|cmn_err_char_table
block|,
literal|""
block|,
name|NULL
block|,
name|cmn_err_flag_specs
block|,
name|cmn_err_flag_pairs
block|,
name|FMT_FLAG_ARG_CONVERT
operator||
name|FMT_FLAG_EMPTY_PREC_OK
block|,
literal|'w'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|'L'
block|,
operator|&
name|integer_type_node
block|,
operator|&
name|integer_type_node
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle #pragma align ALIGNMENT (VAR [, VAR]...)  */
end_comment

begin_function
specifier|static
name|void
name|solaris_pragma_align
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|ttype
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_NUMBER
operator|||
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma align%>, ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|low
operator|!=
literal|1
operator|&&
name|low
operator|!=
literal|2
operator|&&
name|low
operator|!=
literal|4
operator|&&
name|low
operator|!=
literal|8
operator|&&
name|low
operator|!=
literal|16
operator|&&
name|low
operator|!=
literal|32
operator|&&
name|low
operator|!=
literal|64
operator|&&
name|low
operator|!=
literal|128
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"invalid alignment for %<#pragma align%>, ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|!=
name|CPP_NAME
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma align%>, ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|decl
init|=
name|identifier_global_value
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<#pragma align%> must appear before the declaration of "
literal|"%D, ignoring"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|solaris_pending_aligns
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|build_tree_list
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|)
argument_list|,
name|solaris_pending_aligns
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
name|CPP_COMMA
condition|)
block|{
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|!=
name|CPP_NAME
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma align%>"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ttype
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"junk at end of %<#pragma align%>"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma align%>"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle #pragma init (function [, function]...)  */
end_comment

begin_function
specifier|static
name|void
name|solaris_pragma_init
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|enum
name|cpp_ttype
name|ttype
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma init%>, ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|!=
name|CPP_NAME
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma init%>, ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|decl
init|=
name|identifier_global_value
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|init_list
init|=
name|build_tree_list
argument_list|(
name|get_identifier
argument_list|(
literal|"init"
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|attrs
init|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"used"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|init_list
argument_list|)
decl_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|solaris_pending_inits
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|,
name|solaris_pending_inits
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
name|CPP_COMMA
condition|)
block|{
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|!=
name|CPP_NAME
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma init%>"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ttype
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"junk at end of %<#pragma init%>"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma init%>"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle #pragma fini (function [, function]...)  */
end_comment

begin_function
specifier|static
name|void
name|solaris_pragma_fini
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|enum
name|cpp_ttype
name|ttype
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma fini%>, ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|!=
name|CPP_NAME
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma fini%>, ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|decl
init|=
name|identifier_global_value
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|fini_list
init|=
name|build_tree_list
argument_list|(
name|get_identifier
argument_list|(
literal|"fini"
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|attrs
init|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"used"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|fini_list
argument_list|)
decl_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|solaris_pending_finis
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|,
name|solaris_pending_finis
argument_list|)
expr_stmt|;
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
name|CPP_COMMA
condition|)
block|{
name|ttype
operator|=
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|!=
name|CPP_NAME
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma fini%>"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ttype
operator|==
name|CPP_CLOSE_PAREN
condition|)
block|{
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"junk at end of %<#pragma fini%>"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"malformed %<#pragma fini%>"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Register Solaris-specific #pragma directives.  */
end_comment

begin_function
name|void
name|solaris_register_pragmas
parameter_list|(
name|void
parameter_list|)
block|{
name|c_register_pragma_with_expansion
argument_list|(
literal|0
argument_list|,
literal|"align"
argument_list|,
name|solaris_pragma_align
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"init"
argument_list|,
name|solaris_pragma_init
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"fini"
argument_list|,
name|solaris_pragma_fini
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

