begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 EH unwinding support for MIPS Linux.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file with other programs, and to distribute those programs without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into another program.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_comment
comment|/* Do code reading to identify a signal frame, and set the frame    state data appropriately.  See unwind-dw2.c for the structs.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<asm/unistd.h>
end_include

begin_comment
comment|/* The third parameter to the signal handler points to something with  * this structure defined in asm/ucontext.h, but the name clashes with  * struct ucontext from sys/ucontext.h so this private copy is used.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_sig_ucontext
block|{
name|unsigned
name|long
name|uc_flags
decl_stmt|;
name|struct
name|_sig_ucontext
modifier|*
name|uc_link
decl_stmt|;
name|stack_t
name|uc_stack
decl_stmt|;
name|struct
name|sigcontext
name|uc_mcontext
decl_stmt|;
name|sigset_t
name|uc_sigmask
decl_stmt|;
block|}
name|_sig_ucontext_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MD_FALLBACK_FRAME_STATE_FOR
value|mips_fallback_frame_state
end_define

begin_function
specifier|static
name|_Unwind_Reason_Code
name|mips_fallback_frame_state
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|pc
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|context
operator|->
name|ra
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
name|_Unwind_Ptr
name|new_cfa
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 24021061 li v0, 0x1061 (rt_sigreturn)*/
comment|/* 0000000c syscall    */
comment|/*    or */
comment|/* 24021017 li v0, 0x1017 (sigreturn) */
comment|/* 0000000c syscall  */
if|if
condition|(
name|pc
index|[
literal|1
index|]
operator|!=
literal|0x0000000c
condition|)
return|return
name|_URC_END_OF_STACK
return|;
if|#
directive|if
name|_MIPS_SIM
operator|==
name|_ABIO32
if|if
condition|(
name|pc
index|[
literal|0
index|]
operator|==
operator|(
literal|0x24020000
operator||
name|__NR_sigreturn
operator|)
condition|)
block|{
struct|struct
name|sigframe
block|{
name|u_int32_t
name|trampoline
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sigcontext
name|sigctx
decl_stmt|;
block|}
modifier|*
name|rt_
init|=
name|context
operator|->
name|ra
struct|;
name|sc
operator|=
operator|&
name|rt_
operator|->
name|sigctx
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|pc
index|[
literal|0
index|]
operator|==
operator|(
literal|0x24020000
operator||
name|__NR_rt_sigreturn
operator|)
condition|)
block|{
struct|struct
name|rt_sigframe
block|{
name|u_int32_t
name|trampoline
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|siginfo
name|info
decl_stmt|;
name|_sig_ucontext_t
name|uc
decl_stmt|;
block|}
modifier|*
name|rt_
init|=
name|context
operator|->
name|ra
struct|;
name|sc
operator|=
operator|&
name|rt_
operator|->
name|uc
operator|.
name|uc_mcontext
expr_stmt|;
block|}
else|else
return|return
name|_URC_END_OF_STACK
return|;
name|new_cfa
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|sc
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|new_cfa
operator|-
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|cfa
expr_stmt|;
if|#
directive|if
name|_MIPS_SIM
operator|==
name|_ABIO32
operator|&&
name|defined
name|__MIPSEB__
comment|/* On o32 Linux, the register save slots in the sigcontext are      eight bytes.  We need the lower half of each register slot,      so slide our view of the structure back four bytes.  */
name|new_cfa
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|_Unwind_Ptr
operator|)
operator|&
operator|(
name|sc
operator|->
name|sc_regs
index|[
name|i
index|]
operator|)
operator|-
name|new_cfa
expr_stmt|;
block|}
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|SIGNAL_UNWIND_RETURN_COLUMN
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|SIGNAL_UNWIND_RETURN_COLUMN
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|_Unwind_Ptr
operator|)
operator|&
operator|(
name|sc
operator|->
name|sc_pc
operator|)
operator|-
name|new_cfa
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
name|SIGNAL_UNWIND_RETURN_COLUMN
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

