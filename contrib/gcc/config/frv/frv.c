begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Red Hat, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FRV_INLINE
end_ifndef

begin_define
define|#
directive|define
name|FRV_INLINE
value|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Temporary register allocation support structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|frv_tmp_reg_struct
block|{
name|HARD_REG_SET
name|regs
decl_stmt|;
comment|/* possible registers to allocate */
name|int
name|next_reg
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* next register to allocate per class */
block|}
name|frv_tmp_reg_t
typedef|;
end_typedef

begin_comment
comment|/* Register state information for VLIW re-packing phase.  These values must fit    within an unsigned char.  */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_DEAD
value|0x00
end_define

begin_comment
comment|/* register is currently dead */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_CC_MASK
value|0x07
end_define

begin_comment
comment|/* Mask to isolate CCn for cond exec */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_LIVE
value|0x08
end_define

begin_comment
comment|/* register is live */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_MODIFIED
value|0x10
end_define

begin_comment
comment|/* reg modified in current VLIW insn */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_IF_TRUE
value|0x20
end_define

begin_comment
comment|/* reg modified in cond exec true */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_IF_FALSE
value|0x40
end_define

begin_comment
comment|/* reg modified in cond exec false */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_UNUSED
value|0x80
end_define

begin_comment
comment|/* bit for hire */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_MASK
value|0xff
end_define

begin_comment
comment|/* mask for the bits to set */
end_comment

begin_comment
comment|/* conditional expression used */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_IF_EITHER
value|(REGSTATE_IF_TRUE | REGSTATE_IF_FALSE)
end_define

begin_comment
comment|/* the following is not sure in the reg_state bytes, so can have a larger value    than 0xff.  */
end_comment

begin_define
define|#
directive|define
name|REGSTATE_CONDJUMP
value|0x100
end_define

begin_comment
comment|/* conditional jump done in VLIW insn */
end_comment

begin_comment
comment|/* Used in frv_frame_accessor_t to indicate the direction of a register-to-    memory move.  */
end_comment

begin_enum
enum|enum
name|frv_stack_op
block|{
name|FRV_LOAD
block|,
name|FRV_STORE
block|}
enum|;
end_enum

begin_comment
comment|/* Information required by frv_frame_access.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* This field is FRV_LOAD if registers are to be loaded from the stack and      FRV_STORE if they should be stored onto the stack.  FRV_STORE implies      the move is being done by the prologue code while FRV_LOAD implies it      is being done by the epilogue.  */
name|enum
name|frv_stack_op
name|op
decl_stmt|;
comment|/* The base register to use when accessing the stack.  This may be the      frame pointer, stack pointer, or a temporary.  The choice of register      depends on which part of the frame is being accessed and how big the      frame is.  */
name|rtx
name|base
decl_stmt|;
comment|/* The offset of BASE from the bottom of the current frame, in bytes.  */
name|int
name|base_offset
decl_stmt|;
block|}
name|frv_frame_accessor_t
typedef|;
end_typedef

begin_comment
comment|/* Define the information needed to generate branch and scc insns.  This is    stored from the compare operation.  */
end_comment

begin_decl_stmt
name|rtx
name|frv_compare_op0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|frv_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conditional execution support gathered together in one structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Linked list of insns to add if the conditional execution conversion was        successful.  Each link points to an EXPR_LIST which points to the pattern        of the insn to add, and the insn to be inserted before.  */
name|rtx
name|added_insns_list
decl_stmt|;
comment|/* Identify which registers are safe to allocate for if conversions to        conditional execution.  We keep the last allocated register in the        register classes between COND_EXEC statements.  This will mean we allocate        different registers for each different COND_EXEC group if we can.  This        might allow the scheduler to intermix two different COND_EXEC sections.  */
name|frv_tmp_reg_t
name|tmp_reg
decl_stmt|;
comment|/* For nested IFs, identify which CC registers are used outside of setting        via a compare isnsn, and using via a check insn.  This will allow us to        know if we can rewrite the register to use a different register that will        be paired with the CR register controlling the nested IF-THEN blocks.  */
name|HARD_REG_SET
name|nested_cc_ok_rewrite
decl_stmt|;
comment|/* Temporary registers allocated to hold constants during conditional        execution.  */
name|rtx
name|scratch_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
comment|/* Current number of temp registers available.  */
name|int
name|cur_scratch_regs
decl_stmt|;
comment|/* Number of nested conditional execution blocks */
name|int
name|num_nested_cond_exec
decl_stmt|;
comment|/* Map of insns that set up constants in scratch registers.  */
name|bitmap
name|scratch_insns_bitmap
decl_stmt|;
comment|/* Conditional execution test register (CC0..CC7) */
name|rtx
name|cr_reg
decl_stmt|;
comment|/* Conditional execution compare register that is paired with cr_reg, so that        nested compares can be done.  The csubcc and caddcc instructions don't        have enough bits to specify both a CC register to be set and a CR register        to do the test on, so the same bit number is used for both.  Needless to        say, this is rather inconvient for GCC.  */
name|rtx
name|nested_cc_reg
decl_stmt|;
comment|/* Extra CR registers used for&&, ||.  */
name|rtx
name|extra_int_cr
decl_stmt|;
name|rtx
name|extra_fp_cr
decl_stmt|;
comment|/* Previous CR used in nested if, to make sure we are dealing with the same        nested if as the previous statement. */
name|rtx
name|last_nested_if_cr
decl_stmt|;
block|}
name|frv_ifcvt_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
comment|/* GTY(()) */
name|frv_ifcvt_t
name|frv_ifcvt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map register number to smallest register class.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|regno_reg_class
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map class letter into register class */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_from_letter
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cached value of frv_stack_info */
end_comment

begin_decl_stmt
specifier|static
name|frv_stack_t
modifier|*
name|frv_stack_cache
init|=
operator|(
name|frv_stack_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mbranch-cost= support */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|frv_branch_cost_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|frv_branch_cost_int
init|=
name|DEFAULT_BRANCH_COST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mcpu= support */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|frv_cpu_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mcpu= option */
end_comment

begin_decl_stmt
name|frv_cpu_t
name|frv_cpu_type
init|=
name|CPU_TYPE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value of -mcpu= */
end_comment

begin_comment
comment|/* -mcond-exec-insns= support */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|frv_condexec_insns_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mcond-exec-insns= option */
end_comment

begin_decl_stmt
name|int
name|frv_condexec_insns
init|=
name|DEFAULT_CONDEXEC_INSNS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value of -mcond-exec-insns*/
end_comment

begin_comment
comment|/* -mcond-exec-temps= support */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|frv_condexec_temps_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mcond-exec-temps= option */
end_comment

begin_decl_stmt
name|int
name|frv_condexec_temps
init|=
name|DEFAULT_CONDEXEC_TEMPS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value of -mcond-exec-temps*/
end_comment

begin_comment
comment|/* -msched-lookahead=n */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|frv_sched_lookahead_str
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -msched-lookahead=n */
end_comment

begin_decl_stmt
name|int
name|frv_sched_lookahead
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -msched-lookahead=n */
end_comment

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frv_default_flags_for_cpu
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_string_begins_with
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FRV_INLINE
name|int
name|symbol_ref_small_data_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FRV_INLINE
name|int
name|const_small_data_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FRV_INLINE
name|int
name|plus_small_data_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_print_operand_memory_reference_reg
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_print_operand_memory_reference
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_print_operand_jump_hint
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FRV_INLINE
name|int
name|frv_regno_ok_for_base_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|single_set_pattern
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_function_contains_far_jump
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_alloc_temp_reg
name|PARAMS
argument_list|(
operator|(
name|frv_tmp_reg_t
operator|*
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_frame_offset_rtx
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_frame_mem
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_dwarf_store
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_frame_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_frame_access
name|PARAMS
argument_list|(
operator|(
name|frv_frame_accessor_t
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_frame_access_multi
name|PARAMS
argument_list|(
operator|(
name|frv_frame_accessor_t
operator|*
operator|,
name|frv_stack_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_frame_access_standard_regs
name|PARAMS
argument_list|(
operator|(
expr|enum
name|frv_stack_op
operator|,
name|frv_stack_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|machine_function
modifier|*
name|frv_init_machine_status
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_legitimate_memory_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_int_to_acc
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|frv_matching_accg_mode
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_read_argument
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_check_constant_argument
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_legitimize_target
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_legitimize_argument
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_set_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_unop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_binop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_cut_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_binopimm_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_voidbinop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_voidtriop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_voidaccop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_mclracc_builtin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_mrdacc_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_mwtacc_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_noargs_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_emit_comparison
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_clear_registers_used
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_ifcvt_add_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_ifcvt_rewrite_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_ifcvt_load_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_registers_update
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|char
index|[]
operator|,
name|int
index|[]
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_registers_used_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|char
index|[]
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frv_registers_set_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|char
index|[]
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_pack_insns
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_function_epilogue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|frv_assemble_integer
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|frv_strip_name_encoding
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_encode_section_info
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_init_builtins
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|frv_expand_builtin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|frv_in_small_data_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_asm_output_mi_thunk
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|frv_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|frv_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|frv_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRIP_NAME_ENCODING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRIP_NAME_ENCODING
value|frv_strip_name_encoding
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|frv_encode_section_info
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|frv_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|frv_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_IN_SMALL_DATA_P
end_undef

begin_define
define|#
directive|define
name|TARGET_IN_SMALL_DATA_P
value|frv_in_small_data_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|frv_asm_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|default_can_output_mi_thunk_no_vcall
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Given a SYMBOL_REF, return true if it points to small data.  */
end_comment

begin_function
specifier|static
name|FRV_INLINE
name|int
name|symbol_ref_small_data_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|SDATA_NAME_P
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a CONST, return true if the symbol_ref points to small data.  */
end_comment

begin_function
specifier|static
name|FRV_INLINE
name|int
name|const_small_data_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|x0
decl_stmt|,
name|x1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|FALSE
return|;
name|x0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|SDATA_NAME_P
argument_list|(
name|XSTR
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|x1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|!
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Given a PLUS, return true if this is a small data reference.  */
end_comment

begin_function
specifier|static
name|FRV_INLINE
name|int
name|plus_small_data_p
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|SDA_BASE_REG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|symbol_ref_small_data_p
argument_list|(
name|op1
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|const_small_data_p
argument_list|(
name|op1
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|frv_default_flags_for_cpu
parameter_list|()
block|{
switch|switch
condition|(
name|frv_cpu_type
condition|)
block|{
case|case
name|FRV_CPU_GENERIC
case|:
return|return
name|MASK_DEFAULT_FRV
return|;
case|case
name|FRV_CPU_FR500
case|:
case|case
name|FRV_CPU_TOMCAT
case|:
return|return
name|MASK_DEFAULT_FR500
return|;
case|case
name|FRV_CPU_FR400
case|:
return|return
name|MASK_DEFAULT_FR400
return|;
case|case
name|FRV_CPU_FR300
case|:
case|case
name|FRV_CPU_SIMPLE
case|:
return|return
name|MASK_DEFAULT_SIMPLE
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sometimes certain combinations of command options do not make    sense on a particular target machine.  You can define a macro    `OVERRIDE_OPTIONS' to take account of this.  This macro, if    defined, is executed once just after all the command options have    been parsed.     Don't use this macro to turn on various extra optimizations for    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
end_comment

begin_function
name|void
name|frv_override_options
parameter_list|()
block|{
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|;
comment|/* Set the cpu type */
if|if
condition|(
name|frv_cpu_string
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|frv_cpu_string
argument_list|,
literal|"simple"
argument_list|)
operator|==
literal|0
condition|)
name|frv_cpu_type
operator|=
name|FRV_CPU_SIMPLE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|frv_cpu_string
argument_list|,
literal|"tomcat"
argument_list|)
operator|==
literal|0
condition|)
name|frv_cpu_type
operator|=
name|FRV_CPU_TOMCAT
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|frv_cpu_string
argument_list|,
literal|"fr"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"fr"
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Unknown cpu: -mcpu=%s"
argument_list|,
name|frv_cpu_string
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|frv_cpu_string
operator|+
sizeof|sizeof
argument_list|(
literal|"fr"
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"500"
argument_list|)
operator|==
literal|0
condition|)
name|frv_cpu_type
operator|=
name|FRV_CPU_FR500
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"400"
argument_list|)
operator|==
literal|0
condition|)
name|frv_cpu_type
operator|=
name|FRV_CPU_FR400
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"300"
argument_list|)
operator|==
literal|0
condition|)
name|frv_cpu_type
operator|=
name|FRV_CPU_FR300
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"v"
argument_list|)
operator|==
literal|0
condition|)
name|frv_cpu_type
operator|=
name|FRV_CPU_GENERIC
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Unknown cpu: -mcpu=%s"
argument_list|,
name|frv_cpu_string
argument_list|)
expr_stmt|;
block|}
block|}
name|target_flags
operator||=
operator|(
name|frv_default_flags_for_cpu
argument_list|()
operator|&
operator|~
name|target_flags_explicit
operator|)
expr_stmt|;
comment|/* -mlibrary-pic sets -fPIC and -G0 and also suppresses warnings from the      linker about linking pic and non-pic code.  */
if|if
condition|(
name|TARGET_LIBPIC
condition|)
block|{
if|if
condition|(
operator|!
name|flag_pic
condition|)
comment|/* -fPIC */
name|flag_pic
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|g_switch_set
condition|)
comment|/* -G0 */
block|{
name|g_switch_set
operator|=
literal|1
expr_stmt|;
name|g_switch_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Both -fpic and -gdwarf want to use .previous and the assembler only keeps      one level.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
name|flag_pic
condition|)
name|error
argument_list|(
literal|"-fpic and -gdwarf are incompatible (-fpic and -g/-gdwarf-2 are fine)"
argument_list|)
expr_stmt|;
comment|/* Change the branch cost value */
if|if
condition|(
name|frv_branch_cost_string
condition|)
name|frv_branch_cost_int
operator|=
name|atoi
argument_list|(
name|frv_branch_cost_string
argument_list|)
expr_stmt|;
comment|/* Change the # of insns to be converted to conditional execution */
if|if
condition|(
name|frv_condexec_insns_str
condition|)
name|frv_condexec_insns
operator|=
name|atoi
argument_list|(
name|frv_condexec_insns_str
argument_list|)
expr_stmt|;
comment|/* Change # of temporary registers used to hold integer constants */
if|if
condition|(
name|frv_condexec_temps_str
condition|)
name|frv_condexec_temps
operator|=
name|atoi
argument_list|(
name|frv_condexec_temps_str
argument_list|)
expr_stmt|;
comment|/* Change scheduling look ahead. */
if|if
condition|(
name|frv_sched_lookahead_str
condition|)
name|frv_sched_lookahead
operator|=
name|atoi
argument_list|(
name|frv_sched_lookahead_str
argument_list|)
expr_stmt|;
comment|/* A C expression whose value is a register class containing hard      register REGNO.  In general there is more than one such class;      choose a class which is "minimal", meaning that no smaller class      also contains the register. */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
name|enum
name|reg_class
name|class
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|int
name|gpr_reg
init|=
name|regno
operator|-
name|GPR_FIRST
decl_stmt|;
if|if
condition|(
operator|(
name|gpr_reg
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
name|class
operator|=
name|QUAD_REGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|gpr_reg
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|class
operator|=
name|EVEN_REGS
expr_stmt|;
else|else
name|class
operator|=
name|GPR_REGS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|int
name|fpr_reg
init|=
name|regno
operator|-
name|GPR_FIRST
decl_stmt|;
if|if
condition|(
operator|(
name|fpr_reg
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
name|class
operator|=
name|QUAD_FPR_REGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fpr_reg
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|class
operator|=
name|FEVEN_REGS
expr_stmt|;
else|else
name|class
operator|=
name|FPR_REGS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|LR_REGNO
condition|)
name|class
operator|=
name|LR_REG
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|LCR_REGNO
condition|)
name|class
operator|=
name|LCR_REG
expr_stmt|;
elseif|else
if|if
condition|(
name|ICC_P
argument_list|(
name|regno
argument_list|)
condition|)
name|class
operator|=
name|ICC_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|FCC_P
argument_list|(
name|regno
argument_list|)
condition|)
name|class
operator|=
name|FCC_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|ICR_P
argument_list|(
name|regno
argument_list|)
condition|)
name|class
operator|=
name|ICR_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|FCR_P
argument_list|(
name|regno
argument_list|)
condition|)
name|class
operator|=
name|FCR_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|ACC_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|int
name|r
init|=
name|regno
operator|-
name|ACC_FIRST
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
name|class
operator|=
name|QUAD_ACC_REGS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|r
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|class
operator|=
name|EVEN_ACC_REGS
expr_stmt|;
else|else
name|class
operator|=
name|ACC_REGS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ACCG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|class
operator|=
name|ACCG_REGS
expr_stmt|;
else|else
name|class
operator|=
name|NO_REGS
expr_stmt|;
name|regno_reg_class
index|[
name|regno
index|]
operator|=
name|class
expr_stmt|;
block|}
comment|/* Check for small data option */
if|if
condition|(
operator|!
name|g_switch_set
condition|)
name|g_switch_value
operator|=
name|SDATA_DEFAULT_SIZE
expr_stmt|;
comment|/* A C expression which defines the machine-dependent operand      constraint letters for register classes.  If CHAR is such a      letter, the value should be the register class corresponding to      it.  Otherwise, the value should be `NO_REGS'.  The register      letter `r', corresponding to class `GENERAL_REGS', will not be      passed to this macro; you do not need to handle it.       The following letters are unavailable, due to being used as      constraints: 	'0'..'9' 	'<', '>' 	'E', 'F', 'G', 'H' 	'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P' 	'Q', 'R', 'S', 'T', 'U' 	'V', 'X' 	'g', 'i', 'm', 'n', 'o', 'p', 'r', 's' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|reg_class_from_letter
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'a'
index|]
operator|=
name|ACC_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'b'
index|]
operator|=
name|EVEN_ACC_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'c'
index|]
operator|=
name|CC_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'d'
index|]
operator|=
name|GPR_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'e'
index|]
operator|=
name|EVEN_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'f'
index|]
operator|=
name|FPR_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'h'
index|]
operator|=
name|FEVEN_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'l'
index|]
operator|=
name|LR_REG
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'q'
index|]
operator|=
name|QUAD_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'t'
index|]
operator|=
name|ICC_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'u'
index|]
operator|=
name|FCC_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'v'
index|]
operator|=
name|ICR_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'w'
index|]
operator|=
name|FCR_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'x'
index|]
operator|=
name|QUAD_FPR_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'y'
index|]
operator|=
name|LCR_REG
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'z'
index|]
operator|=
name|SPR_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'A'
index|]
operator|=
name|QUAD_ACC_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'B'
index|]
operator|=
name|ACCG_REGS
expr_stmt|;
name|reg_class_from_letter
index|[
literal|'C'
index|]
operator|=
name|CR_REGS
expr_stmt|;
comment|/* There is no single unaligned SI op for PIC code.  Sometimes we      need to use ".4byte" and sometimes we need to use ".picptr".      See frv_assemble_integer for details.  */
if|if
condition|(
name|flag_pic
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
operator|.
name|si
operator|=
literal|0
expr_stmt|;
name|init_machine_status
operator|=
name|frv_init_machine_status
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Some machines may desire to change what optimizations are performed for    various optimization levels.  This macro, if defined, is executed once just    after the optimization level is determined and before the remainder of the    command options have been parsed.  Values set in this macro are used as the    default values for the other command line options.     LEVEL is the optimization level specified; 2 if `-O2' is specified, 1 if    `-O' is specified, and 0 if neither is specified.     SIZE is nonzero if `-Os' is specified, 0 otherwise.     You should not use this macro to change options that are not    machine-specific.  These should uniformly selected by the same optimization    level on all supported machines.  Use this macro to enable machbine-specific    optimizations.     *Do not examine `write_symbols' in this macro!* The debugging options are    *not supposed to alter the generated code.  */
end_comment

begin_comment
comment|/* On the FRV, possibly disable VLIW packing which is done by the 2nd    scheduling pass at the current time.  */
end_comment

begin_function
name|void
name|frv_optimization_options
parameter_list|(
name|level
parameter_list|,
name|size
parameter_list|)
name|int
name|level
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|level
operator|>=
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|DISABLE_SCHED2
name|flag_schedule_insns_after_reload
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_RCSP
name|flag_rcsp
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if NAME (a STRING_CST node) begins with PREFIX.  */
end_comment

begin_function
specifier|static
name|int
name|frv_string_begins_with
parameter_list|(
name|name
parameter_list|,
name|prefix
parameter_list|)
name|tree
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|int
name|prefix_len
init|=
name|strlen
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
comment|/* Remember: NAME's length includes the null terminator.  */
return|return
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|name
argument_list|)
operator|>
name|prefix_len
operator|&&
name|strncmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Encode section information of DECL, which is either a VAR_DECL,    FUNCTION_DECL, STRING_CST, CONSTRUCTOR, or ???.     For the FRV we want to record:     - whether the object lives in .sdata/.sbss.      objects living in .sdata/.sbss are prefixed with SDATA_FLAG_CHAR  */
end_comment

begin_function
specifier|static
name|void
name|frv_encode_section_info
parameter_list|(
name|decl
parameter_list|,
name|first
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|first
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|first
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|section_name
init|=
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|is_small
init|=
literal|0
decl_stmt|;
comment|/* Don't apply the -G flag to internal compiler structures.  We 	 should leave such structures in the main data section, partly 	 for efficiency and partly because the size of some of them 	 (such as C++ typeinfos) is not known until later.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|g_switch_value
condition|)
name|is_small
operator|=
literal|1
expr_stmt|;
comment|/* If we already know which section the decl should be in, see if 	 it's a small data section.  */
if|if
condition|(
name|section_name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|section_name
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|frv_string_begins_with
argument_list|(
name|section_name
argument_list|,
literal|".sdata"
argument_list|)
condition|)
name|is_small
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|frv_string_begins_with
argument_list|(
name|section_name
argument_list|,
literal|".sbss"
argument_list|)
condition|)
name|is_small
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|is_small
condition|)
block|{
name|rtx
name|sym_ref
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|SDATA_FLAG_CHAR
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|str
index|[
literal|1
index|]
argument_list|,
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|str
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Zero or more C statements that may conditionally modify two variables    `fixed_regs' and `call_used_regs' (both of type `char []') after they have    been initialized from the two preceding macros.     This is necessary in case the fixed or call-clobbered registers depend on    target flags.     You need not define this macro if it has no work to do.     If the usage of an entire class of registers depends on the target flags,    you may indicate this to GCC by using this macro to modify `fixed_regs' and    `call_used_regs' to 1 for each of the registers in the classes which should    not be used by GCC.  Also define the macro `REG_CLASS_FROM_LETTER' to return    `NO_REGS' if it is called with a letter for a class that shouldn't be used.     (However, if this class is not included in `GENERAL_REGS' and all of the    insn patterns whose constraints permit this class are controlled by target    switches, then GCC will automatically avoid using these registers when the    target switches are opposed to them.)  */
end_comment

begin_function
name|void
name|frv_conditional_register_usage
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GPR_FIRST
operator|+
name|NUM_GPRS
init|;
name|i
operator|<=
name|GPR_LAST
condition|;
name|i
operator|++
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FPR_FIRST
operator|+
name|NUM_FPRS
init|;
name|i
operator|<=
name|FPR_LAST
condition|;
name|i
operator|++
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ACC_FIRST
operator|+
name|NUM_ACCS
init|;
name|i
operator|<=
name|ACC_LAST
condition|;
name|i
operator|++
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ACCG_FIRST
operator|+
name|NUM_ACCS
init|;
name|i
operator|<=
name|ACCG_LAST
condition|;
name|i
operator|++
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Reserve the registers used for conditional execution.  At present, we need      1 ICC and 1 ICR register.  */
name|fixed_regs
index|[
name|ICC_TEMP
index|]
operator|=
name|call_used_regs
index|[
name|ICC_TEMP
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
name|ICR_TEMP
index|]
operator|=
name|call_used_regs
index|[
name|ICR_TEMP
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_FIXED_CC
condition|)
block|{
name|fixed_regs
index|[
name|ICC_FIRST
index|]
operator|=
name|call_used_regs
index|[
name|ICC_FIRST
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
name|FCC_FIRST
index|]
operator|=
name|call_used_regs
index|[
name|FCC_FIRST
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
name|ICR_FIRST
index|]
operator|=
name|call_used_regs
index|[
name|ICR_FIRST
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
name|FCR_FIRST
index|]
operator|=
name|call_used_regs
index|[
name|FCR_FIRST
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* If -fpic, SDA_BASE_REG is the PIC register.  */
block|if (g_switch_value == 0&& !flag_pic)     fixed_regs[SDA_BASE_REG] = call_used_regs[SDA_BASE_REG] = 0;    if (!flag_pic)     fixed_regs[PIC_REGNO] = call_used_regs[PIC_REGNO] = 0;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Compute the stack frame layout  *  * Register setup:  * +---------------+-----------------------+-----------------------+  * |Register       |type                   |caller-save/callee-save|  * +---------------+-----------------------+-----------------------+  * |GR0            |Zero register          |        -              |  * |GR1            |Stack pointer(SP)      |        -              |  * |GR2            |Frame pointer(FP)      |        -              |  * |GR3            |Hidden parameter       |        caller save    |  * |GR4-GR7        |        -              |        caller save    |  * |GR8-GR13       |Argument register      |        caller save    |  * |GR14-GR15      |        -              |        caller save    |  * |GR16-GR31      |        -              |        callee save    |  * |GR32-GR47      |        -              |        caller save    |  * |GR48-GR63      |        -              |        callee save    |  * |FR0-FR15       |        -              |        caller save    |  * |FR16-FR31      |        -              |        callee save    |  * |FR32-FR47      |        -              |        caller save    |  * |FR48-FR63      |        -              |        callee save    |  * +---------------+-----------------------+-----------------------+  *  * Stack frame setup:  * Low  *     SP-> |-----------------------------------|  *	    |         Argument area		|  *	    |-----------------------------------|  *	    |	 Register save area		|  *	    |-----------------------------------|  *	    |	Local variable save area	|  *     FP-> |-----------------------------------|  *	    |	    Old FP			|  *	    |-----------------------------------|  *	    |    Hidden parameter save area     |  *	    |-----------------------------------|  *	    | Return address(LR) storage area   |  *	    |-----------------------------------|  *	    |     Padding for alignment         |  *	    |-----------------------------------|  *	    |     Register argument area	|  * OLD SP-> |-----------------------------------|  *          |       Parameter area		|  *          |-----------------------------------|  * High  *  * Argument area/Parameter area:  *  * When a function is called, this area is used for argument transfer.  When  * the argument is set up by the caller function, this area is referred to as  * the argument area.  When the argument is referenced by the callee function,  * this area is referred to as the parameter area.  The area is allocated when  * all arguments cannot be placed on the argument register at the time of  * argument transfer.  *  * Register save area:  *  * This is a register save area that must be guaranteed for the caller  * function.  This area is not secured when the register save operation is not  * needed.  *  * Local variable save area:  *  * This is the area for local variables and temporary variables.  *  * Old FP:  *  * This area stores the FP value of the caller function.  *  * Hidden parameter save area:  *  * This area stores the start address of the return value storage  * area for a struct/union return function.  * When a struct/union is used as the return value, the caller  * function stores the return value storage area start address in  * register GR3 and passes it to the caller function.  * The callee function interprets the address stored in the GR3  * as the return value storage area start address.  * When register GR3 needs to be saved into memory, the callee  * function saves it in the hidden parameter save area.  This  * area is not secured when the save operation is not needed.  *  * Return address(LR) storage area:  *  * This area saves the LR.  The LR stores the address of a return to the caller  * function for the purpose of function calling.  *  * Argument register area:  *  * This area saves the argument register.  This area is not secured when the  * save operation is not needed.  *  * Argument:  *  * Arguments, the count of which equals the count of argument registers (6  * words), are positioned in registers GR8 to GR13 and delivered to the callee  * function.  When a struct/union return function is called, the return value  * area address is stored in register GR3.  Arguments not placed in the  * argument registers will be stored in the stack argument area for transfer  * purposes.  When an 8-byte type argument is to be delivered using registers,  * it is divided into two and placed in two registers for transfer.  When  * argument registers must be saved to memory, the callee function secures an  * argument register save area in the stack.  In this case, a continuous  * argument register save area must be established in the parameter area.  The  * argument register save area must be allocated as needed to cover the size of  * the argument register to be saved.  If the function has a variable count of  * arguments, it saves all argument registers in the argument register save  * area.  *  * Argument Extension Format:  *  * When an argument is to be stored in the stack, its type is converted to an  * extended type in accordance with the individual argument type.  The argument  * is freed by the caller function after the return from the callee function is  * made.  *  * +-----------------------+---------------+------------------------+  * |    Argument Type      |Extended Type  |Stack Storage Size(byte)|  * +-----------------------+---------------+------------------------+  * |char                   |int            |        4		    |  * |signed char            |int            |        4		    |  * |unsigned char          |int            |        4		    |  * |[signed] short int     |int            |        4		    |  * |unsigned short int     |int            |        4		    |  * |[signed] int           |No extension   |        4		    |  * |unsigned int           |No extension   |        4		    |  * |[signed] long int      |No extension   |        4		    |  * |unsigned long int      |No extension   |        4		    |  * |[signed] long long int |No extension   |        8		    |  * |unsigned long long int |No extension   |        8		    |  * |float                  |double         |        8		    |  * |double                 |No extension   |        8		    |  * |long double            |No extension   |        8		    |  * |pointer                |No extension   |        4		    |  * |struct/union           |-              |        4 (*1)	    |  * +-----------------------+---------------+------------------------+  *  * When a struct/union is to be delivered as an argument, the caller copies it  * to the local variable area and delivers the address of that area.  *  * Return Value:  *  * +-------------------------------+----------------------+  * |Return Value Type              |Return Value Interface|  * +-------------------------------+----------------------+  * |void                           |None                  |  * |[signed|unsigned] char         |GR8                   |  * |[signed|unsigned] short int    |GR8                   |  * |[signed|unsigned] int          |GR8                   |  * |[signed|unsigned] long int     |GR8                   |  * |pointer                        |GR8                   |  * |[signed|unsigned] long long int|GR8& GR9             |  * |float                          |GR8                   |  * |double                         |GR8& GR9             |  * |long double                    |GR8& GR9             |  * |struct/union                   |(*1)                  |  * +-------------------------------+----------------------+  *  * When a struct/union is used as the return value, the caller function stores  * the start address of the return value storage area into GR3 and then passes  * it to the callee function.  The callee function interprets GR3 as the start  * address of the return value storage area.  When this address needs to be  * saved in memory, the callee function secures the hidden parameter save area  * and saves the address in that area.  */
end_comment

begin_function
name|frv_stack_t
modifier|*
name|frv_stack_info
parameter_list|()
block|{
specifier|static
name|frv_stack_t
name|info
decl_stmt|,
name|zero_info
decl_stmt|;
name|frv_stack_t
modifier|*
name|info_ptr
init|=
operator|&
name|info
decl_stmt|;
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|int
name|varargs_p
init|=
literal|0
decl_stmt|;
name|tree
name|cur_arg
decl_stmt|;
name|tree
name|next_arg
decl_stmt|;
name|int
name|range
decl_stmt|;
name|int
name|alignment
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* If we've already calculated the values and reload is complete, just return now */
if|if
condition|(
name|frv_stack_cache
condition|)
return|return
name|frv_stack_cache
return|;
comment|/* Zero all fields */
name|info
operator|=
name|zero_info
expr_stmt|;
comment|/* Set up the register range information */
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_GPR
index|]
operator|.
name|name
operator|=
literal|"gpr"
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_GPR
index|]
operator|.
name|first
operator|=
name|LAST_ARG_REGNUM
operator|+
literal|1
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_GPR
index|]
operator|.
name|last
operator|=
name|GPR_LAST
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_GPR
index|]
operator|.
name|dword_p
operator|=
name|TRUE
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FPR
index|]
operator|.
name|name
operator|=
literal|"fpr"
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FPR
index|]
operator|.
name|first
operator|=
name|FPR_FIRST
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FPR
index|]
operator|.
name|last
operator|=
name|FPR_LAST
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FPR
index|]
operator|.
name|dword_p
operator|=
name|TRUE
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LR
index|]
operator|.
name|name
operator|=
literal|"lr"
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LR
index|]
operator|.
name|first
operator|=
name|LR_REGNO
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LR
index|]
operator|.
name|last
operator|=
name|LR_REGNO
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LR
index|]
operator|.
name|special_p
operator|=
literal|1
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_CC
index|]
operator|.
name|name
operator|=
literal|"cc"
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_CC
index|]
operator|.
name|first
operator|=
name|CC_FIRST
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_CC
index|]
operator|.
name|last
operator|=
name|CC_LAST
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_CC
index|]
operator|.
name|field_p
operator|=
name|TRUE
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LCR
index|]
operator|.
name|name
operator|=
literal|"lcr"
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LCR
index|]
operator|.
name|first
operator|=
name|LCR_REGNO
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LCR
index|]
operator|.
name|last
operator|=
name|LCR_REGNO
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STDARG
index|]
operator|.
name|name
operator|=
literal|"stdarg"
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STDARG
index|]
operator|.
name|first
operator|=
name|FIRST_ARG_REGNUM
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STDARG
index|]
operator|.
name|last
operator|=
name|LAST_ARG_REGNUM
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STDARG
index|]
operator|.
name|dword_p
operator|=
literal|1
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STDARG
index|]
operator|.
name|special_p
operator|=
literal|1
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STRUCT
index|]
operator|.
name|name
operator|=
literal|"struct"
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STRUCT
index|]
operator|.
name|first
operator|=
name|STRUCT_VALUE_REGNUM
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STRUCT
index|]
operator|.
name|last
operator|=
name|STRUCT_VALUE_REGNUM
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STRUCT
index|]
operator|.
name|special_p
operator|=
literal|1
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FP
index|]
operator|.
name|name
operator|=
literal|"fp"
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FP
index|]
operator|.
name|first
operator|=
name|FRAME_POINTER_REGNUM
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FP
index|]
operator|.
name|last
operator|=
name|FRAME_POINTER_REGNUM
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FP
index|]
operator|.
name|special_p
operator|=
literal|1
expr_stmt|;
comment|/* Determine if this is a stdarg function.  If so, allocate space to store      the 6 arguments.  */
if|if
condition|(
name|cfun
operator|->
name|stdarg
condition|)
name|varargs_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Find the last argument, and see if it is __builtin_va_alist.  */
for|for
control|(
name|cur_arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|cur_arg
operator|!=
operator|(
name|tree
operator|)
literal|0
condition|;
name|cur_arg
operator|=
name|next_arg
control|)
block|{
name|next_arg
operator|=
name|TREE_CHAIN
argument_list|(
name|cur_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_arg
operator|==
operator|(
name|tree
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|cur_arg
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|cur_arg
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
condition|)
name|varargs_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Iterate over all of the register ranges */
for|for
control|(
name|range
operator|=
literal|0
init|;
name|range
operator|<
name|STACK_REGS_MAX
condition|;
name|range
operator|++
control|)
block|{
name|frv_stack_regs_t
modifier|*
name|reg_ptr
init|=
operator|&
operator|(
name|info_ptr
operator|->
name|regs
index|[
name|range
index|]
operator|)
decl_stmt|;
name|int
name|first
init|=
name|reg_ptr
operator|->
name|first
decl_stmt|;
name|int
name|last
init|=
name|reg_ptr
operator|->
name|last
decl_stmt|;
name|int
name|size_1word
init|=
literal|0
decl_stmt|;
name|int
name|size_2words
init|=
literal|0
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* Calculate which registers need to be saved& save area size */
switch|switch
condition|(
name|range
condition|)
block|{
default|default:
for|for
control|(
name|regno
operator|=
name|first
init|;
name|regno
operator|<=
name|last
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|current_function_calls_eh_return
operator|&&
operator|(
name|regno
operator|>=
name|FIRST_EH_REGNUM
operator|&&
name|regno
operator|<=
name|LAST_EH_REGNUM
operator|)
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|cfun
operator|->
name|uses_pic_offset_table
operator|&&
name|regno
operator|==
name|PIC_REGNO
operator|)
condition|)
block|{
name|info_ptr
operator|->
name|save_p
index|[
name|regno
index|]
operator|=
name|REG_SAVE_1WORD
expr_stmt|;
name|size_1word
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
break|break;
comment|/* Calculate whether we need to create a frame after everything else              has been processed.  */
case|case
name|STACK_REGS_FP
case|:
break|break;
case|case
name|STACK_REGS_LR
case|:
if|if
condition|(
name|regs_ever_live
index|[
name|LR_REGNO
index|]
operator|||
name|profile_flag
operator|||
name|frame_pointer_needed
operator|||
operator|(
name|flag_pic
operator|&&
name|cfun
operator|->
name|uses_pic_offset_table
operator|)
condition|)
block|{
name|info_ptr
operator|->
name|save_p
index|[
name|LR_REGNO
index|]
operator|=
name|REG_SAVE_1WORD
expr_stmt|;
name|size_1word
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
break|break;
case|case
name|STACK_REGS_STDARG
case|:
if|if
condition|(
name|varargs_p
condition|)
block|{
comment|/* If this is a stdarg function with an non varardic argument split 		 between registers and the stack, adjust the saved registers 		 downward */
name|last
operator|-=
operator|(
name|ADDR_ALIGN
argument_list|(
name|cfun
operator|->
name|pretend_args_size
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|first
init|;
name|regno
operator|<=
name|last
condition|;
name|regno
operator|++
control|)
block|{
name|info_ptr
operator|->
name|save_p
index|[
name|regno
index|]
operator|=
name|REG_SAVE_1WORD
expr_stmt|;
name|size_1word
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
name|info_ptr
operator|->
name|stdarg_size
operator|=
name|size_1word
expr_stmt|;
block|}
break|break;
case|case
name|STACK_REGS_STRUCT
case|:
if|if
condition|(
name|cfun
operator|->
name|returns_struct
condition|)
block|{
name|info_ptr
operator|->
name|save_p
index|[
name|STRUCT_VALUE_REGNUM
index|]
operator|=
name|REG_SAVE_1WORD
expr_stmt|;
name|size_1word
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|size_1word
condition|)
block|{
comment|/* If this is a field, it only takes one word */
if|if
condition|(
name|reg_ptr
operator|->
name|field_p
condition|)
name|size_1word
operator|=
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Determine which register pairs can be saved together */
elseif|else
if|if
condition|(
name|reg_ptr
operator|->
name|dword_p
operator|&&
name|TARGET_DWORD
condition|)
block|{
for|for
control|(
name|regno
operator|=
name|first
init|;
name|regno
operator|<
name|last
condition|;
name|regno
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|save_p
index|[
name|regno
index|]
operator|&&
name|info_ptr
operator|->
name|save_p
index|[
name|regno
operator|+
literal|1
index|]
condition|)
block|{
name|size_2words
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|size_1word
operator|-=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|info_ptr
operator|->
name|save_p
index|[
name|regno
index|]
operator|=
name|REG_SAVE_2WORDS
expr_stmt|;
name|info_ptr
operator|->
name|save_p
index|[
name|regno
operator|+
literal|1
index|]
operator|=
name|REG_SAVE_NO_SAVE
expr_stmt|;
block|}
block|}
block|}
name|reg_ptr
operator|->
name|size_1word
operator|=
name|size_1word
expr_stmt|;
name|reg_ptr
operator|->
name|size_2words
operator|=
name|size_2words
expr_stmt|;
if|if
condition|(
operator|!
name|reg_ptr
operator|->
name|special_p
condition|)
block|{
name|info_ptr
operator|->
name|regs_size_1word
operator|+=
name|size_1word
expr_stmt|;
name|info_ptr
operator|->
name|regs_size_2words
operator|+=
name|size_2words
expr_stmt|;
block|}
block|}
block|}
comment|/* Set up the sizes of each each field in the frame body, making the sizes      of each be divisible by the size of a dword if dword operations might      be used, or the size of a word otherwise.  */
name|alignment
operator|=
operator|(
name|TARGET_DWORD
condition|?
literal|2
operator|*
name|UNITS_PER_WORD
else|:
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|info_ptr
operator|->
name|parameter_size
operator|=
name|ADDR_ALIGN
argument_list|(
name|cfun
operator|->
name|outgoing_args_size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|regs_size
operator|=
name|ADDR_ALIGN
argument_list|(
name|info_ptr
operator|->
name|regs_size_2words
operator|+
name|info_ptr
operator|->
name|regs_size_1word
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|vars_size
operator|=
name|ADDR_ALIGN
argument_list|(
name|get_frame_size
argument_list|()
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|pretend_size
operator|=
name|cfun
operator|->
name|pretend_args_size
expr_stmt|;
comment|/* Work out the size of the frame, excluding the header.  Both the frame      body and register parameter area will be dword-aligned.  */
name|info_ptr
operator|->
name|total_size
operator|=
operator|(
name|ADDR_ALIGN
argument_list|(
name|info_ptr
operator|->
name|parameter_size
operator|+
name|info_ptr
operator|->
name|regs_size
operator|+
name|info_ptr
operator|->
name|vars_size
argument_list|,
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|)
operator|+
name|ADDR_ALIGN
argument_list|(
name|info_ptr
operator|->
name|pretend_size
operator|+
name|info_ptr
operator|->
name|stdarg_size
argument_list|,
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
comment|/* See if we need to create a frame at all, if so add header area.  */
if|if
condition|(
name|info_ptr
operator|->
name|total_size
operator|>
literal|0
operator|||
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LR
index|]
operator|.
name|size_1word
operator|>
literal|0
operator|||
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STRUCT
index|]
operator|.
name|size_1word
operator|>
literal|0
condition|)
block|{
name|offset
operator|=
name|info_ptr
operator|->
name|parameter_size
expr_stmt|;
name|info_ptr
operator|->
name|header_size
operator|=
literal|4
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|info_ptr
operator|->
name|total_size
operator|+=
literal|4
operator|*
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Calculate the offsets to save normal register pairs */
for|for
control|(
name|range
operator|=
literal|0
init|;
name|range
operator|<
name|STACK_REGS_MAX
condition|;
name|range
operator|++
control|)
block|{
name|frv_stack_regs_t
modifier|*
name|reg_ptr
init|=
operator|&
operator|(
name|info_ptr
operator|->
name|regs
index|[
name|range
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|reg_ptr
operator|->
name|special_p
condition|)
block|{
name|int
name|first
init|=
name|reg_ptr
operator|->
name|first
decl_stmt|;
name|int
name|last
init|=
name|reg_ptr
operator|->
name|last
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|first
init|;
name|regno
operator|<=
name|last
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|info_ptr
operator|->
name|save_p
index|[
name|regno
index|]
operator|==
name|REG_SAVE_2WORDS
operator|&&
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
name|regno
operator|<
name|FIRST_ARG_REGNUM
operator|||
name|regno
operator|>
name|LAST_ARG_REGNUM
operator|)
condition|)
block|{
name|info_ptr
operator|->
name|reg_offset
index|[
name|regno
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
comment|/* Calculate the offsets to save normal single registers */
for|for
control|(
name|range
operator|=
literal|0
init|;
name|range
operator|<
name|STACK_REGS_MAX
condition|;
name|range
operator|++
control|)
block|{
name|frv_stack_regs_t
modifier|*
name|reg_ptr
init|=
operator|&
operator|(
name|info_ptr
operator|->
name|regs
index|[
name|range
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|reg_ptr
operator|->
name|special_p
condition|)
block|{
name|int
name|first
init|=
name|reg_ptr
operator|->
name|first
decl_stmt|;
name|int
name|last
init|=
name|reg_ptr
operator|->
name|last
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|first
init|;
name|regno
operator|<=
name|last
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|info_ptr
operator|->
name|save_p
index|[
name|regno
index|]
operator|==
name|REG_SAVE_1WORD
operator|&&
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
name|regno
operator|<
name|FIRST_ARG_REGNUM
operator|||
name|regno
operator|>
name|LAST_ARG_REGNUM
operator|)
condition|)
block|{
name|info_ptr
operator|->
name|reg_offset
index|[
name|regno
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
comment|/* Calculate the offset to save the local variables at.  */
name|offset
operator|=
name|ADDR_ALIGN
argument_list|(
name|offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|vars_size
condition|)
block|{
name|info_ptr
operator|->
name|vars_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|info_ptr
operator|->
name|vars_size
expr_stmt|;
block|}
comment|/* Align header to a dword-boundary.  */
name|offset
operator|=
name|ADDR_ALIGN
argument_list|(
name|offset
argument_list|,
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* Calculate the offsets in the fixed frame.  */
name|info_ptr
operator|->
name|save_p
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
name|REG_SAVE_1WORD
expr_stmt|;
name|info_ptr
operator|->
name|reg_offset
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
name|offset
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_FP
index|]
operator|.
name|size_1word
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|info_ptr
operator|->
name|save_p
index|[
name|LR_REGNO
index|]
operator|=
name|REG_SAVE_1WORD
expr_stmt|;
name|info_ptr
operator|->
name|reg_offset
index|[
name|LR_REGNO
index|]
operator|=
name|offset
operator|+
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_LR
index|]
operator|.
name|size_1word
operator|=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|returns_struct
condition|)
block|{
name|info_ptr
operator|->
name|save_p
index|[
name|STRUCT_VALUE_REGNUM
index|]
operator|=
name|REG_SAVE_1WORD
expr_stmt|;
name|info_ptr
operator|->
name|reg_offset
index|[
name|STRUCT_VALUE_REGNUM
index|]
operator|=
name|offset
operator|+
name|UNITS_PER_WORD
expr_stmt|;
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STRUCT
index|]
operator|.
name|size_1word
operator|=
name|UNITS_PER_WORD
expr_stmt|;
block|}
comment|/* Calculate the offsets to store the arguments passed in registers          for stdarg functions.  The register pairs are first and the single          register if any is last.  The register save area starts on a          dword-boundary.  */
if|if
condition|(
name|info_ptr
operator|->
name|stdarg_size
condition|)
block|{
name|int
name|first
init|=
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STDARG
index|]
operator|.
name|first
decl_stmt|;
name|int
name|last
init|=
name|info_ptr
operator|->
name|regs
index|[
name|STACK_REGS_STDARG
index|]
operator|.
name|last
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* Skip the header.  */
name|offset
operator|+=
literal|4
operator|*
name|UNITS_PER_WORD
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|first
init|;
name|regno
operator|<=
name|last
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|info_ptr
operator|->
name|save_p
index|[
name|regno
index|]
operator|==
name|REG_SAVE_2WORDS
condition|)
block|{
name|info_ptr
operator|->
name|reg_offset
index|[
name|regno
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info_ptr
operator|->
name|save_p
index|[
name|regno
index|]
operator|==
name|REG_SAVE_1WORD
condition|)
block|{
name|info_ptr
operator|->
name|reg_offset
index|[
name|regno
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|reload_completed
condition|)
name|frv_stack_cache
operator|=
name|info_ptr
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the information about the frv stack offsets, etc. when debugging. */
end_comment

begin_function
name|void
name|frv_debug_stack
parameter_list|(
name|info
parameter_list|)
name|frv_stack_t
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|range
decl_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
name|info
operator|=
name|frv_stack_info
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nStack information for function %s:\n"
argument_list|,
operator|(
operator|(
name|current_function_decl
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
else|:
literal|"<unknown>"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttotal_size\t= %6d\n"
argument_list|,
name|info
operator|->
name|total_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvars_size\t= %6d\n"
argument_list|,
name|info
operator|->
name|vars_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tparam_size\t= %6d\n"
argument_list|,
name|info
operator|->
name|parameter_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tregs_size\t= %6d, 1w = %3d, 2w = %3d\n"
argument_list|,
name|info
operator|->
name|regs_size
argument_list|,
name|info
operator|->
name|regs_size_1word
argument_list|,
name|info
operator|->
name|regs_size_2words
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\theader_size\t= %6d\n"
argument_list|,
name|info
operator|->
name|header_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tpretend_size\t= %6d\n"
argument_list|,
name|info
operator|->
name|pretend_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvars_offset\t= %6d\n"
argument_list|,
name|info
operator|->
name|vars_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tregs_offset\t= %6d\n"
argument_list|,
name|info
operator|->
name|regs_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|range
operator|=
literal|0
init|;
name|range
operator|<
name|STACK_REGS_MAX
condition|;
name|range
operator|++
control|)
block|{
name|frv_stack_regs_t
modifier|*
name|regs
init|=
operator|&
operator|(
name|info
operator|->
name|regs
index|[
name|range
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|regs
operator|->
name|size_1word
operator|+
name|regs
operator|->
name|size_2words
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|first
init|=
name|regs
operator|->
name|first
decl_stmt|;
name|int
name|last
init|=
name|regs
operator|->
name|last
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\tsize\t= %6d, 1w = %3d, 2w = %3d, save ="
argument_list|,
name|regs
operator|->
name|name
argument_list|,
name|regs
operator|->
name|size_1word
operator|+
name|regs
operator|->
name|size_2words
argument_list|,
name|regs
operator|->
name|size_1word
argument_list|,
name|regs
operator|->
name|size_2words
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|first
init|;
name|regno
operator|<=
name|last
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|->
name|save_p
index|[
name|regno
index|]
operator|==
name|REG_SAVE_1WORD
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s (%d)"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|info
operator|->
name|reg_offset
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|save_p
index|[
name|regno
index|]
operator|==
name|REG_SAVE_2WORDS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s-%s (%d)"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_names
index|[
name|regno
operator|+
literal|1
index|]
argument_list|,
name|info
operator|->
name|reg_offset
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following variable value is TRUE if the next output insn should    finish cpu cycle.  In order words the insn will have packing bit    (which means absence of asm code suffix `.p' on assembler. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frv_insn_packing_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if the current function contains a far jump.  */
end_comment

begin_function
specifier|static
name|int
name|frv_function_contains_far_jump
parameter_list|()
block|{
name|rtx
name|insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* Ignore tablejump patterns.  */
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|&&
name|get_attr_far_jump
argument_list|(
name|insn
argument_list|)
operator|==
name|FAR_JUMP_YES
operator|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
operator|(
name|insn
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* For the FRV, this function makes sure that a function with far jumps    will return correctly.  It also does the VLIW packing.  */
end_comment

begin_function
specifier|static
name|void
name|frv_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If no frame was created, check whether the function uses a call      instruction to implement a far jump.  If so, save the link in gr3 and      replace all returns to LR with returns to GR3.  GR3 is used because it      is call-clobbered, because is not available to the register allocator,      and because all functions that take a hidden argument pointer will have      a stack frame.  */
if|if
condition|(
name|frv_stack_info
argument_list|()
operator|->
name|total_size
operator|==
literal|0
operator|&&
name|frv_function_contains_far_jump
argument_list|()
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Just to check that the above comment is true.  */
if|if
condition|(
name|regs_ever_live
index|[
name|GPR_FIRST
operator|+
literal|3
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Generate the instruction that saves the link register.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovsg lr,gr3\n"
argument_list|)
expr_stmt|;
comment|/* Replace the LR with GR3 in *return_internal patterns.  The insn 	 will now return using jmpl @(gr3,0) rather than bralr.  We cannot 	 simply emit a different assembly directive because bralr and jmpl 	 execute in different units.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
name|NULL
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|>=
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|address
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|address
argument_list|)
operator|==
name|LR_REGNO
condition|)
name|REGNO
argument_list|(
name|address
argument_list|)
operator|=
name|GPR_FIRST
operator|+
literal|3
expr_stmt|;
block|}
block|}
block|}
name|frv_pack_insns
argument_list|()
expr_stmt|;
name|frv_insn_packing_flag
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the next available temporary register in a given class.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_alloc_temp_reg
parameter_list|(
name|info
parameter_list|,
name|class
parameter_list|,
name|mode
parameter_list|,
name|mark_as_used
parameter_list|,
name|no_abort
parameter_list|)
name|frv_tmp_reg_t
modifier|*
name|info
decl_stmt|;
comment|/* which registers are available */
name|enum
name|reg_class
name|class
decl_stmt|;
comment|/* register class desired */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* mode to allocate register with */
name|int
name|mark_as_used
decl_stmt|;
comment|/* register not available after allocation */
name|int
name|no_abort
decl_stmt|;
comment|/* return NULL instead of aborting */
block|{
name|int
name|regno
init|=
name|info
operator|->
name|next_reg
index|[
operator|(
name|int
operator|)
name|class
index|]
decl_stmt|;
name|int
name|orig_regno
init|=
name|regno
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|reg_in_class
init|=
operator|&
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nr
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|reg_in_class
argument_list|,
name|regno
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|info
operator|->
name|regs
argument_list|,
name|regno
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|++
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|orig_regno
condition|)
block|{
if|if
condition|(
name|no_abort
condition|)
return|return
name|NULL_RTX
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|info
operator|->
name|next_reg
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|=
name|regno
operator|+
name|nr
expr_stmt|;
if|if
condition|(
name|mark_as_used
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|info
operator|->
name|regs
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx with the value OFFSET, which will either be a register or a    signed 12-bit integer.  It can be used as the second operand in an "add"    instruction, or as the index in a load or store.     The function returns a constant rtx if OFFSET is small enough, otherwise    it loads the constant into register OFFSET_REGNO and returns that.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_frame_offset_rtx
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|rtx
name|offset_rtx
init|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|IN_RANGE_P
argument_list|(
name|offset
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
condition|)
return|return
name|offset_rtx
return|;
else|else
block|{
name|rtx
name|reg_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|OFFSET_REGNO
argument_list|)
decl_stmt|;
if|if
condition|(
name|IN_RANGE_P
argument_list|(
name|offset
argument_list|,
operator|-
literal|32768
argument_list|,
literal|32767
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg_rtx
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_insn
argument_list|(
name|gen_movsi_high
argument_list|(
name|reg_rtx
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi_lo_sum
argument_list|(
name|reg_rtx
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reg_rtx
return|;
block|}
block|}
end_function

begin_comment
comment|/* Generate (mem:MODE (plus:Pmode BASE (frv_frame_offset OFFSET)))).  The    prologue and epilogue uses such expressions to access the stack.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_frame_mem
parameter_list|(
name|mode
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
return|return
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|frv_frame_offset_rtx
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a frame-related expression:  	(set REG (mem (plus (sp) (const_int OFFSET)))).     Such expressions are used in FRAME_RELATED_EXPR notes for more complex    instructions.  Marking the expressions as frame-related is superfluous if    the note contains just a single set.  But if the note contains a PARALLEL    or SEQUENCE that has several sets, each set must be individually marked    as frame-related.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_dwarf_store
parameter_list|(
name|reg
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|rtx
name|set
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|set
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Emit a frame-related instruction whose pattern is PATTERN.  The    instruction is the last in a sequence that cumulatively performs the    operation described by DWARF_PATTERN.  The instruction is marked as    frame-related and has a REG_FRAME_RELATED_EXPR note containing    DWARF_PATTERN.  */
end_comment

begin_function
specifier|static
name|void
name|frv_frame_insn
parameter_list|(
name|pattern
parameter_list|,
name|dwarf_pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|rtx
name|dwarf_pattern
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|emit_insn
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf_pattern
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit instructions that transfer REG to or from the memory location (sp +    STACK_OFFSET).  The register is stored in memory if ACCESSOR->OP is    FRV_STORE and loaded if it is FRV_LOAD.  Only the prologue uses this    function to store registers and only the epilogue uses it to load them.     The caller sets up ACCESSOR so that BASE is equal to (sp + BASE_OFFSET).    The generated instruction will use BASE as its base register.  BASE may    simply be the stack pointer, but if several accesses are being made to a    region far away from the stack pointer, it may be more efficient to set    up a temporary instead.        Store instructions will be frame-related and will be annotated with the    overall effect of the store.  Load instructions will be followed by a    (use) to prevent later optimizations from zapping them.     The function takes care of the moves to and from SPRs, using TEMP_REGNO    as a temporary in such cases.  */
end_comment

begin_function
specifier|static
name|void
name|frv_frame_access
parameter_list|(
name|accessor
parameter_list|,
name|reg
parameter_list|,
name|stack_offset
parameter_list|)
name|frv_frame_accessor_t
modifier|*
name|accessor
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|stack_offset
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|frv_frame_mem
argument_list|(
name|mode
argument_list|,
name|accessor
operator|->
name|base
argument_list|,
name|stack_offset
operator|-
name|accessor
operator|->
name|base_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|accessor
operator|->
name|op
operator|==
name|FRV_LOAD
condition|)
block|{
if|if
condition|(
name|SPR_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|TEMP_REGNO
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SPR_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|TEMP_REGNO
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|frv_frame_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|,
name|temp
argument_list|)
argument_list|,
name|frv_dwarf_store
argument_list|(
name|reg
argument_list|,
name|stack_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|DImode
condition|)
block|{
comment|/* For DImode saves, the dwarf2 version needs to be a SEQUENCE 	     with a separate save for each register.  */
name|rtx
name|reg1
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg2
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|set1
init|=
name|frv_dwarf_store
argument_list|(
name|reg1
argument_list|,
name|stack_offset
argument_list|)
decl_stmt|;
name|rtx
name|set2
init|=
name|frv_dwarf_store
argument_list|(
name|reg2
argument_list|,
name|stack_offset
operator|+
literal|4
argument_list|)
decl_stmt|;
name|frv_frame_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
argument_list|,
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|set1
argument_list|,
name|set2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|frv_frame_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
argument_list|,
name|frv_dwarf_store
argument_list|(
name|reg
argument_list|,
name|stack_offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A function that uses frv_frame_access to transfer a group of registers to    or from the stack.  ACCESSOR is passed directly to frv_frame_access, INFO    is the stack information generated by frv_stack_info, and REG_SET is the    number of the register set to transfer.  */
end_comment

begin_function
specifier|static
name|void
name|frv_frame_access_multi
parameter_list|(
name|accessor
parameter_list|,
name|info
parameter_list|,
name|reg_set
parameter_list|)
name|frv_frame_accessor_t
modifier|*
name|accessor
decl_stmt|;
name|frv_stack_t
modifier|*
name|info
decl_stmt|;
name|int
name|reg_set
decl_stmt|;
block|{
name|frv_stack_regs_t
modifier|*
name|regs_info
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|regs_info
operator|=
operator|&
name|info
operator|->
name|regs
index|[
name|reg_set
index|]
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|regs_info
operator|->
name|first
init|;
name|regno
operator|<=
name|regs_info
operator|->
name|last
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|info
operator|->
name|save_p
index|[
name|regno
index|]
condition|)
name|frv_frame_access
argument_list|(
name|accessor
argument_list|,
name|info
operator|->
name|save_p
index|[
name|regno
index|]
operator|==
name|REG_SAVE_2WORDS
condition|?
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
else|:
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|info
operator|->
name|reg_offset
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save or restore callee-saved registers that are kept outside the frame    header.  The function saves the registers if OP is FRV_STORE and restores    them if OP is FRV_LOAD.  INFO is the stack information generated by    frv_stack_info.  */
end_comment

begin_function
specifier|static
name|void
name|frv_frame_access_standard_regs
parameter_list|(
name|op
parameter_list|,
name|info
parameter_list|)
name|enum
name|frv_stack_op
name|op
decl_stmt|;
name|frv_stack_t
modifier|*
name|info
decl_stmt|;
block|{
name|frv_frame_accessor_t
name|accessor
decl_stmt|;
name|accessor
operator|.
name|op
operator|=
name|op
expr_stmt|;
name|accessor
operator|.
name|base
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|accessor
operator|.
name|base_offset
operator|=
literal|0
expr_stmt|;
name|frv_frame_access_multi
argument_list|(
operator|&
name|accessor
argument_list|,
name|info
argument_list|,
name|STACK_REGS_GPR
argument_list|)
expr_stmt|;
name|frv_frame_access_multi
argument_list|(
operator|&
name|accessor
argument_list|,
name|info
argument_list|,
name|STACK_REGS_FPR
argument_list|)
expr_stmt|;
name|frv_frame_access_multi
argument_list|(
operator|&
name|accessor
argument_list|,
name|info
argument_list|,
name|STACK_REGS_LCR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after register allocation to add any instructions needed for the    prologue.  Using a prologue insn is favored compared to putting all of the    instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler    to intermix instructions with the saves of the caller saved registers.  In    some cases, it might be necessary to emit a barrier instruction as the last    insn to prevent such scheduling.     Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1    so that the debug info generation code can handle them properly.  */
end_comment

begin_function
name|void
name|frv_expand_prologue
parameter_list|()
block|{
name|frv_stack_t
modifier|*
name|info
init|=
name|frv_stack_info
argument_list|()
decl_stmt|;
name|rtx
name|sp
init|=
name|stack_pointer_rtx
decl_stmt|;
name|rtx
name|fp
init|=
name|frame_pointer_rtx
decl_stmt|;
name|frv_frame_accessor_t
name|accessor
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|frv_debug_stack
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|total_size
operator|==
literal|0
condition|)
return|return;
comment|/* We're interested in three areas of the frame here:           A: the register save area 	 B: the old FP 	 C: the header after B       If the frame pointer isn't used, we'll have to set up A, B and C      using the stack pointer.  If the frame pointer is used, we'll access      them as follows:           A: set up using sp 	 B: set up using sp or a temporary (see below) 	 C: set up using fp       We set up B using the stack pointer if the frame is small enough.      Otherwise, it's more efficient to copy the old stack pointer into a      temporary and use that.       Note that it's important to make sure the prologue and epilogue use the      same registers to access A and C, since doing otherwise will confuse      the aliasing code.  */
comment|/* Set up ACCESSOR for accessing region B above.  If the frame pointer      isn't used, the same method will serve for C.  */
name|accessor
operator|.
name|op
operator|=
name|FRV_STORE
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
operator|&&
name|info
operator|->
name|total_size
operator|>
literal|2048
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|accessor
operator|.
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|OLD_SP_REGNO
argument_list|)
expr_stmt|;
name|accessor
operator|.
name|base_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|accessor
operator|.
name|base
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|accessor
operator|.
name|base
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|accessor
operator|.
name|base_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate the stack space.  */
block|{
name|rtx
name|asm_offset
init|=
name|frv_frame_offset_rtx
argument_list|(
operator|-
name|info
operator|->
name|total_size
argument_list|)
decl_stmt|;
name|rtx
name|dwarf_offset
init|=
name|GEN_INT
argument_list|(
operator|-
name|info
operator|->
name|total_size
argument_list|)
decl_stmt|;
name|frv_frame_insn
argument_list|(
name|gen_stack_adjust
argument_list|(
name|sp
argument_list|,
name|sp
argument_list|,
name|asm_offset
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|sp
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sp
argument_list|,
name|dwarf_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the frame pointer is needed, store the old one at (sp + FP_OFFSET)      and point the new one to that location.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|int
name|fp_offset
init|=
name|info
operator|->
name|reg_offset
index|[
name|FRAME_POINTER_REGNUM
index|]
decl_stmt|;
comment|/* ASM_SRC and DWARF_SRC both point to the frame header.  ASM_SRC is 	 based on ACCESSOR.BASE but DWARF_SRC is always based on the stack 	 pointer.  */
name|rtx
name|asm_src
init|=
name|plus_constant
argument_list|(
name|accessor
operator|.
name|base
argument_list|,
name|fp_offset
operator|-
name|accessor
operator|.
name|base_offset
argument_list|)
decl_stmt|;
name|rtx
name|dwarf_src
init|=
name|plus_constant
argument_list|(
name|sp
argument_list|,
name|fp_offset
argument_list|)
decl_stmt|;
comment|/* Store the old frame pointer at (sp + FP_OFFSET).  */
name|frv_frame_access
argument_list|(
operator|&
name|accessor
argument_list|,
name|fp
argument_list|,
name|fp_offset
argument_list|)
expr_stmt|;
comment|/* Set up the new frame pointer.  */
name|frv_frame_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|fp
argument_list|,
name|asm_src
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|fp
argument_list|,
name|dwarf_src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Access region C from the frame pointer.  */
name|accessor
operator|.
name|base
operator|=
name|fp
expr_stmt|;
name|accessor
operator|.
name|base_offset
operator|=
name|fp_offset
expr_stmt|;
block|}
comment|/* Set up region C.  */
name|frv_frame_access_multi
argument_list|(
operator|&
name|accessor
argument_list|,
name|info
argument_list|,
name|STACK_REGS_STRUCT
argument_list|)
expr_stmt|;
name|frv_frame_access_multi
argument_list|(
operator|&
name|accessor
argument_list|,
name|info
argument_list|,
name|STACK_REGS_LR
argument_list|)
expr_stmt|;
name|frv_frame_access_multi
argument_list|(
operator|&
name|accessor
argument_list|,
name|info
argument_list|,
name|STACK_REGS_STDARG
argument_list|)
expr_stmt|;
comment|/* Set up region A.  */
name|frv_frame_access_standard_regs
argument_list|(
name|FRV_STORE
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* If this is a varargs/stdarg function, issue a blockage to prevent the      scheduler from moving loads before the stores saving the registers.  */
if|if
condition|(
name|info
operator|->
name|stdarg_size
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set up pic register/small data register for this function. */
if|if
condition|(
name|flag_pic
operator|&&
name|cfun
operator|->
name|uses_pic_offset_table
condition|)
name|emit_insn
argument_list|(
name|gen_pic_prologue
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_REGNO
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNO
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|OFFSET_REGNO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Under frv, all of the work is done via frv_expand_epilogue, but    this function provides a convient place to do cleanup.  */
end_comment

begin_function
specifier|static
name|void
name|frv_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|frv_stack_cache
operator|=
operator|(
name|frv_stack_t
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* zap last used registers for conditional execution.  */
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|frv_ifcvt
operator|.
name|tmp_reg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|frv_ifcvt
operator|.
name|tmp_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* release the bitmap of created insns.  */
name|BITMAP_XFREE
argument_list|(
name|frv_ifcvt
operator|.
name|scratch_insns_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called after register allocation to add any instructions needed for the    epilogue.  Using an epilogue insn is favored compared to putting all of the    instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler    to intermix instructions with the saves of the caller saved registers.  In    some cases, it might be necessary to emit a barrier instruction as the last    insn to prevent such scheduling.     If SIBCALL_P is true, the final branch back to the calling function is    omitted, and is used for sibling call (aka tail call) sites.  For sibcalls,    we must not clobber any arguments used for parameter passing or any stack    slots for arguments passed to the current function.  */
end_comment

begin_function
name|void
name|frv_expand_epilogue
parameter_list|(
name|sibcall_p
parameter_list|)
name|int
name|sibcall_p
decl_stmt|;
block|{
name|frv_stack_t
modifier|*
name|info
init|=
name|frv_stack_info
argument_list|()
decl_stmt|;
name|rtx
name|fp
init|=
name|frame_pointer_rtx
decl_stmt|;
name|rtx
name|sp
init|=
name|stack_pointer_rtx
decl_stmt|;
name|rtx
name|return_addr
decl_stmt|;
name|int
name|fp_offset
decl_stmt|;
name|fp_offset
operator|=
name|info
operator|->
name|reg_offset
index|[
name|FRAME_POINTER_REGNUM
index|]
expr_stmt|;
comment|/* Restore the stack pointer to its original value if alloca or the like      is used.  */
if|if
condition|(
operator|!
name|current_function_sp_is_unchanging
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|sp
argument_list|,
name|fp
argument_list|,
name|frv_frame_offset_rtx
argument_list|(
operator|-
name|fp_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the callee-saved registers that were used in this function.  */
name|frv_frame_access_standard_regs
argument_list|(
name|FRV_LOAD
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Set RETURN_ADDR to the address we should return to.  Set it to NULL if      no return instruction should be emitted.  */
if|if
condition|(
name|sibcall_p
condition|)
name|return_addr
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|save_p
index|[
name|LR_REGNO
index|]
condition|)
block|{
name|int
name|lr_offset
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* Use the same method to access the link register's slot as we did in 	 the prologue.  In other words, use the frame pointer if available, 	 otherwise use the stack pointer.  	 LR_OFFSET is the offset of the link register's slot from the start 	 of the frame and MEM is a memory rtx for it.  */
name|lr_offset
operator|=
name|info
operator|->
name|reg_offset
index|[
name|LR_REGNO
index|]
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|mem
operator|=
name|frv_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|fp
argument_list|,
name|lr_offset
operator|-
name|fp_offset
argument_list|)
expr_stmt|;
else|else
name|mem
operator|=
name|frv_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|sp
argument_list|,
name|lr_offset
argument_list|)
expr_stmt|;
comment|/* Load the old link register into a GPR.  */
name|return_addr
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|TEMP_REGNO
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|return_addr
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|return_addr
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNO
argument_list|)
expr_stmt|;
comment|/* Restore the old frame pointer.  Emit a USE afterwards to make sure      the load is preserved.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|fp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|fp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Deallocate the stack frame.  */
if|if
condition|(
name|info
operator|->
name|total_size
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset
init|=
name|frv_frame_offset_rtx
argument_list|(
name|info
operator|->
name|total_size
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_stack_adjust
argument_list|(
name|sp
argument_list|,
name|sp
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this function uses eh_return, add the final stack adjustment now.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|emit_insn
argument_list|(
name|gen_stack_adjust
argument_list|(
name|sp
argument_list|,
name|sp
argument_list|,
name|EH_RETURN_STACKADJ_RTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_addr
condition|)
name|emit_jump_insn
argument_list|(
name|gen_epilogue_return
argument_list|(
name|return_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement that outputs the assembler code for a thunk function,    used to implement C++ virtual function calls with multiple inheritance.  The    thunk acts as a wrapper around a virtual function, adjusting the implicit    object parameter before handing control off to the real function.     First, emit code to add the integer DELTA to the location that contains the    incoming first argument.  Assume that this argument contains a pointer, and    is the one used to pass the `this' pointer in C++.  This is the incoming    argument *before* the function prologue, e.g. `%o0' on a sparc.  The    addition must preserve the values of all other incoming arguments.     After the addition, emit code to jump to FUNCTION, which is a    `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does not touch    the return address.  Hence returning from FUNCTION will return to whoever    called the current `thunk'.     The effect must be as if FUNCTION had been called directly with the adjusted    first argument.  This macro is responsible for emitting all of the code for    a thunk function; `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' are not    invoked.     The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been    extracted from it.)  It might possibly be useful on some targets, but    probably not.     If you do not define this macro, the target-independent code in the C++    frontend will generate a less efficient heavyweight thunk that calls    FUNCTION instead of jumping to it.  The generic approach does not support    varargs.  */
end_comment

begin_function
specifier|static
name|void
name|frv_asm_output_mi_thunk
parameter_list|(
name|file
parameter_list|,
name|thunk_fndecl
parameter_list|,
name|delta
parameter_list|,
name|vcall_offset
parameter_list|,
name|function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|thunk_fndecl
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|delta
decl_stmt|;
name|HOST_WIDE_INT
name|vcall_offset
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|function
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name_func
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_arg0
init|=
name|reg_names
index|[
name|FIRST_ARG_REGNUM
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_jmp
init|=
name|reg_names
index|[
name|JUMP_REGNO
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|parallel
init|=
operator|(
operator|(
name|PACKING_FLAG_USED_P
argument_list|()
operator|)
condition|?
literal|".p"
else|:
literal|""
operator|)
decl_stmt|;
comment|/* Do the add using an addi if possible */
if|if
condition|(
name|IN_RANGE_P
argument_list|(
name|delta
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddi %s,#%d,%s\n"
argument_list|,
name|name_arg0
argument_list|,
operator|(
name|int
operator|)
name|delta
argument_list|,
name|name_arg0
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name_add
init|=
name|reg_names
index|[
name|TEMP_REGNO
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi%s #hi("
argument_list|,
name|parallel
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"),%s\n"
argument_list|,
name|name_add
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsetlo #lo("
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"),%s\n"
argument_list|,
name|name_add
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%s\n"
argument_list|,
name|name_add
argument_list|,
name|name_arg0
argument_list|,
name|name_arg0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi%s #hi("
argument_list|,
name|parallel
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name_func
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"),%s\n"
argument_list|,
name|name_jmp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsetlo #lo("
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name_func
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"),%s\n"
argument_list|,
name|name_jmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use JUMP_REGNO as a temporary PIC register.  */
specifier|const
name|char
modifier|*
name|name_lr
init|=
name|reg_names
index|[
name|LR_REGNO
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_gppic
init|=
name|name_jmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_tmp
init|=
name|reg_names
index|[
name|TEMP_REGNO
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovsg %s,%s\n"
argument_list|,
name|name_lr
argument_list|,
name|name_tmp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall 1f\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"1:\tmovsg %s,%s\n"
argument_list|,
name|name_lr
argument_list|,
name|name_gppic
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovgs %s,%s\n"
argument_list|,
name|name_tmp
argument_list|,
name|name_lr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi%s #gprelhi(1b),%s\n"
argument_list|,
name|parallel
argument_list|,
name|name_tmp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsetlo #gprello(1b),%s\n"
argument_list|,
name|name_tmp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%s,%s\n"
argument_list|,
name|name_gppic
argument_list|,
name|name_tmp
argument_list|,
name|name_gppic
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi%s #gprelhi("
argument_list|,
name|parallel
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name_func
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"),%s\n"
argument_list|,
name|name_tmp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsetlo #gprello("
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name_func
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"),%s\n"
argument_list|,
name|name_tmp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%s\n"
argument_list|,
name|name_gppic
argument_list|,
name|name_tmp
argument_list|,
name|name_jmp
argument_list|)
expr_stmt|;
block|}
comment|/* Jump to the function address */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmpl @(%s,%s)\n"
argument_list|,
name|name_jmp
argument_list|,
name|reg_names
index|[
name|GPR_FIRST
operator|+
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression which is nonzero if a function must have and use a frame    pointer.  This expression is evaluated in the reload pass.  If its value is    nonzero the function will have a frame pointer.     The expression can in principle examine the current function and decide    according to the facts, but on most machines the constant 0 or the constant    1 suffices.  Use 0 when the machine allows code to be generated with no    frame pointer, and doing so saves some time or space.  Use 1 when there is    no possible advantage to avoiding a frame pointer.     In certain cases, the compiler does not know how to produce valid code    without a frame pointer.  The compiler recognizes those cases and    automatically gives the function a frame pointer regardless of what    `FRAME_POINTER_REQUIRED' says.  You don't need to worry about them.     In a function that does not require a frame pointer, the frame pointer    register can be allocated for ordinary usage, unless you mark it as a fixed    register.  See `FIXED_REGISTERS' for more information.  */
end_comment

begin_comment
comment|/* On frv, create a frame whenever we need to create stack */
end_comment

begin_function
name|int
name|frv_frame_pointer_required
parameter_list|()
block|{
if|if
condition|(
operator|!
name|current_function_is_leaf
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|get_frame_size
argument_list|()
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|cfun
operator|->
name|stdarg
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|current_function_sp_is_unchanging
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|cfun
operator|->
name|uses_pic_offset_table
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|profile_flag
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|frame_needed
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It specifies the    initial difference between the specified pair of registers.  This macro must    be defined if `ELIMINABLE_REGS' is defined.  */
end_comment

begin_comment
comment|/* See frv_stack_info for more details on the frv stack frame.  */
end_comment

begin_function
name|int
name|frv_initial_elimination_offset
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|{
name|frv_stack_t
modifier|*
name|info
init|=
name|frv_stack_info
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|from
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|ret
operator|=
name|info
operator|->
name|total_size
operator|-
name|info
operator|->
name|pretend_size
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|from
operator|==
name|FRAME_POINTER_REGNUM
condition|)
name|ret
operator|=
operator|-
name|info
operator|->
name|reg_offset
index|[
name|FRAME_POINTER_REGNUM
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|from
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|ret
operator|=
operator|(
name|info
operator|->
name|total_size
operator|-
name|info
operator|->
name|reg_offset
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|-
name|info
operator|->
name|pretend_size
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Eliminate %s to %s by adding %d\n"
argument_list|,
name|reg_names
index|[
name|from
index|]
argument_list|,
name|reg_names
index|[
name|to
index|]
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This macro offers an alternative to using `__builtin_saveregs' and defining    the macro `EXPAND_BUILTIN_SAVEREGS'.  Use it to store the anonymous register    arguments into the stack so that all the arguments appear to have been    passed consecutively on the stack.  Once this is done, you can use the    standard implementation of varargs that works for machines that pass all    their arguments on the stack.     The argument ARGS_SO_FAR is the `CUMULATIVE_ARGS' data structure, containing    the values that obtain after processing of the named arguments.  The    arguments MODE and TYPE describe the last named argument--its machine mode    and its data type as a tree node.     The macro implementation should do two things: first, push onto the stack    all the argument registers *not* used for the named arguments, and second,    store the size of the data thus pushed into the `int'-valued variable whose    name is supplied as the argument PRETEND_ARGS_SIZE.  The value that you    store here will serve as additional offset for setting up the stack frame.     Because you must generate code to push the anonymous arguments at compile    time without knowing their data types, `SETUP_INCOMING_VARARGS' is only    useful on machines that have just a single category of argument register and    use it uniformly for all data types.     If the argument SECOND_TIME is nonzero, it means that the arguments of the    function are being analyzed for the second time.  This happens for an inline    function, which is not actually compiled until the end of the source file.    The macro `SETUP_INCOMING_VARARGS' should not generate any instructions in    this case.  */
end_comment

begin_function
name|void
name|frv_setup_incoming_varargs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|pretend_size
parameter_list|,
name|second_time
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|pretend_size
decl_stmt|;
name|int
name|second_time
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setup_vararg: words = %2d, mode = %4s, pretend_size = %d, second_time = %d\n"
argument_list|,
operator|*
name|cum
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
operator|*
name|pretend_size
argument_list|,
name|second_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If defined, is a C expression that produces the machine-specific code for a    call to `__builtin_saveregs'.  This code will be moved to the very beginning    of the function, before any parameter access are made.  The return value of    this function should be an RTX that contains the value to use as the return    of `__builtin_saveregs'.     If this macro is not defined, the compiler will output an ordinary call to    the library function `__builtin_saveregs'.  */
end_comment

begin_function
name|rtx
name|frv_expand_builtin_saveregs
parameter_list|()
block|{
name|int
name|offset
init|=
name|UNITS_PER_WORD
operator|*
name|FRV_NUM_ARG_REGS
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expand_builtin_saveregs: offset from ap = %d\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|virtual_incoming_args_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand __builtin_va_start to do the va_start macro.  */
end_comment

begin_function
name|void
name|frv_expand_builtin_va_start
parameter_list|(
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|num
init|=
name|cfun
operator|->
name|args_info
operator|-
name|FIRST_ARG_REGNUM
operator|-
name|FRV_NUM_ARG_REGS
decl_stmt|;
name|nextarg
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|virtual_incoming_args_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|UNITS_PER_WORD
operator|*
name|num
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: args_info = %d, num = %d\n"
argument_list|,
name|cfun
operator|->
name|args_info
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|nextarg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand __builtin_va_arg to do the va_arg macro.  */
end_comment

begin_function
name|rtx
name|frv_expand_builtin_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg:\n"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
name|addr
operator|=
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a block move operation, and return 1 if successful.  Return 0    if we should let the compiler generate normal code.     operands[0] is the destination    operands[1] is the source    operands[2] is the length    operands[3] is the alignment */
end_comment

begin_comment
comment|/* Maximum number of loads to do before doing the stores */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_MOVE_REG
end_ifndef

begin_define
define|#
directive|define
name|MAX_MOVE_REG
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Maximum number of total loads to do.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TOTAL_MOVE_REG
end_ifndef

begin_define
define|#
directive|define
name|TOTAL_MOVE_REG
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|frv_expand_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|orig_dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|orig_src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|constp
init|=
operator|(
name|GET_CODE
argument_list|(
name|bytes_rtx
argument_list|)
operator|==
name|CONST_INT
operator|)
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|num_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|rtx
name|src_mem
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|;
name|rtx
name|tmp_reg
decl_stmt|;
name|rtx
name|stores
index|[
name|MAX_MOVE_REG
index|]
decl_stmt|;
name|int
name|move_bytes
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If this is not a fixed size move, just call memcpy */
if|if
condition|(
operator|!
name|constp
condition|)
return|return
name|FALSE
return|;
comment|/* If this is not a fixed size alignment, abort */
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
expr_stmt|;
comment|/* Anything to move? */
name|bytes
operator|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Don't support real large moves.  */
if|if
condition|(
name|bytes
operator|>
name|TOTAL_MOVE_REG
operator|*
name|align
condition|)
return|return
name|FALSE
return|;
comment|/* Move the address into scratch registers.  */
name|dest_reg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src_reg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|num_reg
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bytes
operator|>
literal|0
condition|;
operator|(
name|bytes
operator|-=
name|move_bytes
operator|)
operator|,
operator|(
name|offset
operator|+=
name|move_bytes
operator|)
control|)
block|{
comment|/* Calculate the correct offset for src/dest */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|src_addr
operator|=
name|src_reg
expr_stmt|;
name|dest_addr
operator|=
name|dest_reg
expr_stmt|;
block|}
else|else
block|{
name|src_addr
operator|=
name|plus_constant
argument_list|(
name|src_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|plus_constant
argument_list|(
name|dest_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the appropriate load and store, saving the stores 	 for later.  */
if|if
condition|(
name|bytes
operator|>=
literal|4
operator|&&
name|align
operator|>=
literal|4
condition|)
name|mode
operator|=
name|SImode
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|2
operator|&&
name|align
operator|>=
literal|2
condition|)
name|mode
operator|=
name|HImode
expr_stmt|;
else|else
name|mode
operator|=
name|QImode
expr_stmt|;
name|move_bytes
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|src_mem
operator|=
name|change_address
argument_list|(
name|orig_src
argument_list|,
name|mode
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|change_address
argument_list|(
name|orig_dest
argument_list|,
name|mode
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp_reg
argument_list|,
name|src_mem
argument_list|)
argument_list|)
expr_stmt|;
name|stores
index|[
name|num_reg
operator|++
index|]
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest_mem
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_reg
operator|>=
name|MAX_MOVE_REG
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_reg
condition|;
name|i
operator|++
control|)
name|emit_insn
argument_list|(
name|stores
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|num_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_reg
condition|;
name|i
operator|++
control|)
name|emit_insn
argument_list|(
name|stores
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a block clear operation, and return 1 if successful.  Return 0    if we should let the compiler generate normal code.     operands[0] is the destination    operands[1] is the length    operands[2] is the alignment */
end_comment

begin_function
name|int
name|frv_expand_block_clear
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|orig_dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|int
name|constp
init|=
operator|(
name|GET_CODE
argument_list|(
name|bytes_rtx
argument_list|)
operator|==
name|CONST_INT
operator|)
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|num_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|;
name|int
name|clear_bytes
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If this is not a fixed size move, just call memcpy */
if|if
condition|(
operator|!
name|constp
condition|)
return|return
name|FALSE
return|;
comment|/* If this is not a fixed size alignment, abort */
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
expr_stmt|;
comment|/* Anything to move? */
name|bytes
operator|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Don't support real large clears.  */
if|if
condition|(
name|bytes
operator|>
name|TOTAL_MOVE_REG
operator|*
name|align
condition|)
return|return
name|FALSE
return|;
comment|/* Move the address into a scratch register.  */
name|dest_reg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|num_reg
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bytes
operator|>
literal|0
condition|;
operator|(
name|bytes
operator|-=
name|clear_bytes
operator|)
operator|,
operator|(
name|offset
operator|+=
name|clear_bytes
operator|)
control|)
block|{
comment|/* Calculate the correct offset for src/dest */
name|dest_addr
operator|=
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
condition|?
name|dest_reg
else|:
name|plus_constant
argument_list|(
name|dest_reg
argument_list|,
name|offset
argument_list|)
operator|)
expr_stmt|;
comment|/* Generate the appropriate store of gr0 */
if|if
condition|(
name|bytes
operator|>=
literal|4
operator|&&
name|align
operator|>=
literal|4
condition|)
name|mode
operator|=
name|SImode
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|2
operator|&&
name|align
operator|>=
literal|2
condition|)
name|mode
operator|=
name|HImode
expr_stmt|;
else|else
name|mode
operator|=
name|QImode
expr_stmt|;
name|clear_bytes
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|change_address
argument_list|(
name|orig_dest
argument_list|,
name|mode
argument_list|,
name|dest_addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest_mem
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following variable is used to output modifiers of assembler    code of the current output insn.. */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|frv_insn_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function is used to add assembler insn code suffix .p    if it is necessary. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|frv_asm_output_opcode
parameter_list|(
name|f
parameter_list|,
name|ptr
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|PACKING_FLAG_USED_P
argument_list|()
condition|)
return|return
name|ptr
return|;
for|for
control|(
init|;
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|' '
operator|&&
operator|*
name|ptr
operator|!=
literal|'\t'
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|(
operator|(
operator|*
name|ptr
operator|>=
literal|'a'
operator|&&
operator|*
name|ptr
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|>=
literal|'A'
operator|&&
operator|*
name|ptr
operator|<=
literal|'Z'
operator|)
operator|)
condition|)
block|{
name|int
name|letter
init|=
operator|*
name|ptr
operator|++
decl_stmt|;
name|c
operator|=
name|atoi
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|frv_print_operand
argument_list|(
name|f
argument_list|,
name|frv_insn_operands
index|[
name|c
index|]
argument_list|,
name|letter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|ptr
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|ptr
operator|++
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|frv_insn_packing_flag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|".p"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* The following function sets up the packing bit for the current    output insn.  Remember that the function is not called for asm    insns. */
end_comment

begin_function
name|void
name|frv_final_prescan_insn
parameter_list|(
name|insn
parameter_list|,
name|opvec
parameter_list|,
name|noperands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|opvec
decl_stmt|;
name|int
name|noperands
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|PACKING_FLAG_USED_P
argument_list|()
condition|)
return|return;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
return|return;
name|frv_insn_operands
operator|=
name|opvec
expr_stmt|;
comment|/* Look for the next printable instruction.  frv_pack_insns () has set      things up so that any printable instruction will have TImode if it      starts a new packet and VOIDmode if it should be packed with the      previous instruction.       Printable instructions will be asm_operands or match one of the .md      patterns.  Since asm instructions cannot be packed -- and will      therefore have TImode -- this loop terminates on any recognisable      instruction, and on any unrecognisable instruction with TImode.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
operator|||
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
comment|/* Set frv_insn_packing_flag to FALSE if the next instruction should      be packed with this one.  Set it to TRUE otherwise.  If the next      instruction is an asm insntruction, this statement will set the      flag to TRUE, and that value will still hold when the asm operands      themselves are printed.  */
name|frv_insn_packing_flag
operator|=
operator|!
operator|(
name|insn
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|TImode
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression whose value is RTL representing the address in a stack frame    where the pointer to the caller's frame is stored.  Assume that FRAMEADDR is    an RTL expression for the address of the stack frame itself.     If you don't define this macro, the default is to return the value of    FRAMEADDR--that is, the stack frame address is also the address of the stack    word that points to the previous frame.  */
end_comment

begin_comment
comment|/* The default is correct, but we need to make sure the frame gets created.  */
end_comment

begin_function
name|rtx
name|frv_dynamic_chain_address
parameter_list|(
name|frame
parameter_list|)
name|rtx
name|frame
decl_stmt|;
block|{
name|cfun
operator|->
name|machine
operator|->
name|frame_needed
operator|=
literal|1
expr_stmt|;
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* A C expression whose value is RTL representing the value of the return    address for the frame COUNT steps up from the current frame, after the    prologue.  FRAMEADDR is the frame pointer of the COUNT frame, or the frame    pointer of the COUNT - 1 frame if `RETURN_ADDR_IN_PREVIOUS_FRAME' is    defined.     The value of the expression must always be the correct address when COUNT is    zero, but may be `NULL_RTX' if there is not way to determine the return    address of other frames.  */
end_comment

begin_function
name|rtx
name|frv_return_addr_rtx
parameter_list|(
name|count
parameter_list|,
name|frame
parameter_list|)
name|int
name|count
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|frame
decl_stmt|;
block|{
name|cfun
operator|->
name|machine
operator|->
name|frame_needed
operator|=
literal|1
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|frame
argument_list|,
literal|8
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a memory reference MEMREF, interpret the referenced memory as    an array of MODE values, and return a reference to the element    specified by INDEX.  Assume that any pre-modification implicit in    MEMREF has already happened.     MEMREF must be a legitimate operand for modes larger than SImode.    GO_IF_LEGITIMATE_ADDRESS forbids register+register addresses, which    this function cannot handle.  */
end_comment

begin_function
name|rtx
name|frv_index_memory
parameter_list|(
name|memref
parameter_list|,
name|mode
parameter_list|,
name|index
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PRE_MODIFY
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|change_address
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|index
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a memory address as an operand to reference that memory location.  */
end_comment

begin_function
name|void
name|frv_print_operand_address
parameter_list|(
name|stream
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SYMBOL_REF
case|:
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|output_addr_const
argument_list|(
name|stream
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand_address:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|frv_print_operand_memory_reference_reg
parameter_list|(
name|stream
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|regno
argument_list|)
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Bad register to frv_print_operand_memory_reference_reg:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a memory reference suitable for the ld/st instructions.  */
end_comment

begin_function
specifier|static
name|void
name|frv_print_operand_memory_reference
parameter_list|(
name|stream
parameter_list|,
name|x
parameter_list|,
name|addr_offset
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|addr_offset
decl_stmt|;
block|{
name|rtx
name|x0
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|x1
init|=
name|NULL_RTX
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
case|case
name|REG
case|:
name|x0
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|PRE_MODIFY
case|:
comment|/* (pre_modify (reg) (plus (reg) (reg))) */
name|x0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|x1
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|x0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|x0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand_memory_reference:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addr_offset
condition|)
block|{
if|if
condition|(
operator|!
name|x1
condition|)
name|x1
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand_memory_reference:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"@("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x0
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|GPR_R0
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|SUBREG
condition|)
name|frv_print_operand_memory_reference_reg
argument_list|(
name|stream
argument_list|,
name|x0
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand_memory_reference:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x1
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|GPR_R0
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
case|case
name|REG
case|:
name|frv_print_operand_memory_reference_reg
argument_list|(
name|stream
argument_list|,
name|x1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|INTVAL
argument_list|(
name|x1
argument_list|)
operator|+
name|addr_offset
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|x0
operator|&&
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x0
argument_list|)
operator|==
name|SDA_BASE_REG
operator|&&
name|symbol_ref_small_data_p
argument_list|(
name|x1
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"#gprel12("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|XSTR
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand_memory_reference:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
if|if
condition|(
name|x0
operator|&&
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x0
argument_list|)
operator|==
name|SDA_BASE_REG
operator|&&
name|const_small_data_p
argument_list|(
name|x1
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"#gprel12("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"+%d)"
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand_memory_reference:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand_memory_reference:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 2 for likely branches and 0 for non-likely branches  */
end_comment

begin_define
define|#
directive|define
name|FRV_JUMP_LIKELY
value|2
end_define

begin_define
define|#
directive|define
name|FRV_JUMP_NOT_LIKELY
value|0
end_define

begin_function
specifier|static
name|int
name|frv_print_operand_jump_hint
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
name|rtx
name|labelref
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|HOST_WIDE_INT
name|prob
init|=
operator|-
literal|1
decl_stmt|;
enum|enum
block|{
name|UNKNOWN
block|,
name|BACKWARD
block|,
name|FORWARD
block|}
name|jump_type
init|=
name|UNKNOWN
enum|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Assume any non-conditional jump is likely.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|ret
operator|=
name|FRV_JUMP_LIKELY
expr_stmt|;
else|else
block|{
name|labelref
operator|=
name|condjump_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|labelref
condition|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|labelref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|jump_type
operator|=
operator|(
name|insn_current_address
operator|>
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
argument_list|)
condition|?
name|BACKWARD
else|:
name|FORWARD
operator|)
expr_stmt|;
block|}
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
name|ret
operator|=
operator|(
operator|(
name|jump_type
operator|==
name|BACKWARD
operator|)
condition|?
name|FRV_JUMP_LIKELY
else|:
name|FRV_JUMP_NOT_LIKELY
operator|)
expr_stmt|;
else|else
block|{
name|prob
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
operator|(
name|prob
operator|>=
operator|(
name|REG_BR_PROB_BASE
operator|/
literal|2
operator|)
operator|)
condition|?
name|FRV_JUMP_LIKELY
else|:
name|FRV_JUMP_NOT_LIKELY
operator|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (TARGET_DEBUG)     {       char *direction;        switch (jump_type) 	{ 	default: 	case UNKNOWN:	direction = "unknown jump direction";	break; 	case BACKWARD:	direction = "jump backward";		break; 	case FORWARD:	direction = "jump forward";		break; 	}        fprintf (stderr, 	       "%s: uid %ld, %s, probability = %ld, max prob. = %ld, hint = %d\n", 	       IDENTIFIER_POINTER (DECL_NAME (current_function_decl)), 	       (long)INSN_UID (insn), direction, (long)prob, 	       (long)REG_BR_PROB_BASE, ret);     }
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an operand to an assembler instruction.     `%' followed by a letter and a digit says to output an operand in an    alternate fashion.  Four letters have standard, built-in meanings described    below.  The machine description macro `PRINT_OPERAND' can define additional    letters with nonstandard meanings.     `%cDIGIT' can be used to substitute an operand that is a constant value    without the syntax that normally indicates an immediate operand.     `%nDIGIT' is like `%cDIGIT' except that the value of the constant is negated    before printing.     `%aDIGIT' can be used to substitute an operand as if it were a memory    reference, with the actual operand treated as the address.  This may be    useful when outputting a "load address" instruction, because often the    assembler syntax for such an instruction requires you to write the operand    as if it were a memory reference.     `%lDIGIT' is used to substitute a `label_ref' into a jump instruction.     `%=' outputs a number which is unique to each instruction in the entire    compilation.  This is useful for making local labels to be referred to more    than once in a single template that generates multiple assembler    instructions.     `%' followed by a punctuation character specifies a substitution that does    not use an operand.  Only one case is standard: `%%' outputs a `%' into the    assembler code.  Other nonstandard cases can be defined in the    `PRINT_OPERAND' macro.  You must also define which punctuation characters    are valid with the `PRINT_OPERAND_PUNCT_VALID_P' macro.  */
end_comment

begin_function
name|void
name|frv_print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
operator|&&
operator|!
name|isalpha
argument_list|(
name|code
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|value
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|value
operator|=
name|l
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
name|value
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Bad insn in frv_print_operand, bad const_double"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Output r0 */
name|fputs
argument_list|(
name|reg_names
index|[
name|GPR_R0
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|frv_print_operand_jump_hint
argument_list|(
name|current_output_insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDATA_FLAG_CHAR
case|:
comment|/* Output small data area base register (gr16). */
name|fputs
argument_list|(
name|reg_names
index|[
name|SDA_BASE_REG
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* Output pic register (gr17). */
name|fputs
argument_list|(
name|reg_names
index|[
name|PIC_REGNO
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* Output the temporary integer CCR register */
name|fputs
argument_list|(
name|reg_names
index|[
name|ICR_TEMP
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* Output the temporary integer CC register */
name|fputs
argument_list|(
name|reg_names
index|[
name|ICC_TEMP
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
comment|/* case 'a': print an address */
case|case
literal|'C'
case|:
comment|/* Print appropriate test for integer branch false operation */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, 'C' modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"nc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"hi"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"ls"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"c"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* case 'c': print a constant without the constant prefix.  If        CONSTANT_ADDRESS_P(x) is not true, PRINT_OPERAND is called.  */
case|case
literal|'c'
case|:
comment|/* Print appropriate test for integer branch true operation */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, 'c' modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"c"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"ls"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"hi"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"nc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* Print 1 for a NE and 0 for an EQ to give the final argument 	 for a conditional instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NE
condition|)
name|fputs
argument_list|(
literal|"1"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
condition|)
name|fputs
argument_list|(
literal|"0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, 'e' modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Print appropriate test for floating point branch false operation */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, 'F' modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"uge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"ug"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"ule"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ul"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* Print appropriate test for floating point branch true operation */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, 'f' modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* Print 'i' if the operand is a constant, or is a memory reference that          adds a constant */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
condition|?
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
else|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
name|fputs
argument_list|(
literal|"i"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'i'
case|:
comment|/* For jump instructions, print 'i' if the operand is a constant or          is an expression that adds a constant */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fputs
argument_list|(
literal|"i"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
name|fputs
argument_list|(
literal|"i"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* Print the lower register of a double word register pair */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, 'L' modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
comment|/* case 'l': print a LABEL_REF */
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
comment|/* Print a memory reference for ld/st/jmp, %N prints a memory reference          for the second word of double memory operations.  */
name|offset
operator|=
operator|(
name|code
operator|==
literal|'M'
operator|)
condition|?
literal|0
else|:
name|UNITS_PER_WORD
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, 'M/N' modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|MEM
case|:
name|frv_print_operand_memory_reference
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
case|case
name|CONST_INT
case|:
case|case
name|PLUS
case|:
case|case
name|SYMBOL_REF
case|:
name|frv_print_operand_memory_reference
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'O'
case|:
comment|/* Print the opcode of a command.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, 'O' modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
case|case
name|PLUS
case|:
name|fputs
argument_list|(
literal|"add"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|fputs
argument_list|(
literal|"sub"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"and"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"or"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|fputs
argument_list|(
literal|"sll"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|fputs
argument_list|(
literal|"sra"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|fputs
argument_list|(
literal|"srl"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* case 'n': negate and print a constant int */
case|case
literal|'P'
case|:
comment|/* Print PIC label using operand as the number.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|fatal_insn
argument_list|(
literal|"Bad insn to frv_print_operand, P modifier:"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".LCF%ld"
argument_list|,
operator|(
name|long
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Print 'u' if the operand is a update load/store */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_MODIFY
condition|)
name|fputs
argument_list|(
literal|"u"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* If value is 0, print gr0, otherwise it must be a register  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|GPR_R0
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Bad insn in frv_print_operand, z case"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Print constant in hex */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s0x%.4lx"
argument_list|,
name|IMMEDIATE_PREFIX
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through */
case|case
literal|'\0'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%ld"
argument_list|,
name|IMMEDIATE_PREFIX
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|frv_print_operand_address
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|frv_print_operand_address
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"Bad insn in frv_print_operand, 0 case"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"frv_print_operand: unknown code"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C statement (sans semicolon) for initializing the variable CUM for the    state at the beginning of the argument list.  The variable has type    `CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node for the data type    of the function which will receive the args, or 0 if the args are to a    compiler support library function.  The value of INDIRECT is nonzero when    processing an indirect call, for example a call through a function pointer.    The value of INDIRECT is zero for a call to an explicitly named function, a    library function call, or when `INIT_CUMULATIVE_ARGS' is used to find    arguments for the function being compiled.     When processing a call to a compiler support library function, LIBNAME    identifies which one.  It is a `symbol_ref' rtx which contains the name of    the function, as a string.  LIBNAME is 0 when an ordinary C function call is    being processed.  Thus, each time this macro is called, either LIBNAME or    FNTYPE is nonzero, but never both of them at once.  */
end_comment

begin_function
name|void
name|frv_init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|,
name|indirect
parameter_list|,
name|incoming
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|rtx
name|libname
decl_stmt|;
name|int
name|indirect
decl_stmt|;
name|int
name|incoming
decl_stmt|;
block|{
operator|*
name|cum
operator|=
name|FIRST_ARG_REGNUM
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
name|fputs
argument_list|(
literal|" indirect"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|incoming
condition|)
name|fputs
argument_list|(
literal|" incoming"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" return=%s,"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|libname
operator|&&
name|GET_CODE
argument_list|(
name|libname
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" libname=%s"
argument_list|,
name|XSTR
argument_list|(
name|libname
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|returns_struct
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" return-struct"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If defined, a C expression that gives the alignment boundary, in bits, of an    argument with the specified mode and type.  If it is not defined,    `PARM_BOUNDARY' is used for all arguments.  */
end_comment

begin_function
name|int
name|frv_function_arg_boundary
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|BITS_PER_WORD
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression that controls whether a function argument is passed in a    register, and which register.     The arguments are CUM, of type CUMULATIVE_ARGS, which summarizes (in a way    defined by INIT_CUMULATIVE_ARGS and FUNCTION_ARG_ADVANCE) all of the previous    arguments so far passed in registers; MODE, the machine mode of the argument;    TYPE, the data type of the argument as a tree node or 0 if that is not known    (which happens for C support library functions); and NAMED, which is 1 for an    ordinary argument and 0 for nameless arguments that correspond to `...' in the    called function's prototype.     The value of the expression should either be a `reg' RTX for the hard    register in which to pass the argument, or zero to pass the argument on the    stack.     For machines like the VAX and 68000, where normally all arguments are    pushed, zero suffices as a definition.     The usual way to make the ANSI library `stdarg.h' work on a machine where    some arguments are usually passed in registers, is to cause nameless    arguments to be passed on the stack instead.  This is done by making    `FUNCTION_ARG' return 0 whenever NAMED is 0.     You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of    this macro to determine if this argument is of a type that must be passed in    the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'    returns nonzero for such an argument, the compiler will abort.  If    `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the    stack and then loaded into a register.  */
end_comment

begin_function
name|rtx
name|frv_function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|,
name|incoming
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|named
decl_stmt|;
name|int
name|incoming
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|machine_mode
name|xmode
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|SImode
else|:
name|mode
decl_stmt|;
name|int
name|arg_num
init|=
operator|*
name|cum
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|debstr
decl_stmt|;
comment|/* Return a marker for use in the call instruction.  */
if|if
condition|(
name|xmode
operator|==
name|VOIDmode
condition|)
block|{
name|ret
operator|=
name|const0_rtx
expr_stmt|;
name|debstr
operator|=
literal|"<0>"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg_num
operator|<=
name|LAST_ARG_REGNUM
condition|)
block|{
name|ret
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|xmode
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|debstr
operator|=
name|reg_names
index|[
name|arg_num
index|]
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|NULL_RTX
expr_stmt|;
name|debstr
operator|=
literal|"memory"
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg: words = %2d, mode = %4s, named = %d, size = %3d, arg = %s\n"
argument_list|,
name|arg_num
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|debstr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C statement (sans semicolon) to update the summarizer variable CUM to    advance past an argument in the argument list.  The values MODE, TYPE and    NAMED describe that argument.  Once this is done, the variable CUM is    suitable for analyzing the *following* argument with `FUNCTION_ARG', etc.     This macro need not do anything if the argument in question was passed on    the stack.  The compiler knows how to track the amount of stack space used    for arguments without any special help.  */
end_comment

begin_function
name|void
name|frv_function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|enum
name|machine_mode
name|xmode
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|SImode
else|:
name|mode
decl_stmt|;
name|int
name|bytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|arg_num
init|=
operator|*
name|cum
decl_stmt|;
operator|*
name|cum
operator|=
name|arg_num
operator|+
name|words
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, mode = %4s, named = %d, size = %3d\n"
argument_list|,
name|arg_num
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|,
name|words
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression for the number of words, at the beginning of an argument,    must be put in registers.  The value must be zero for arguments that are    passed entirely in registers or that are entirely pushed on the stack.     On some machines, certain arguments must be passed partially in registers    and partially in memory.  On these machines, typically the first N words of    arguments are passed in registers, and the rest on the stack.  If a    multi-word argument (a `double' or a structure) crosses that boundary, its    first few words must be passed in registers and the rest must be pushed.    This macro tells the compiler when this occurs, and how many of the words    should go in registers.     `FUNCTION_ARG' for these arguments should return the first register to be    used by the caller for this argument; likewise `FUNCTION_INCOMING_ARG', for    the called function.  */
end_comment

begin_function
name|int
name|frv_function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|machine_mode
name|xmode
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|SImode
else|:
name|mode
decl_stmt|;
name|int
name|bytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|xmode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
name|int
name|arg_num
init|=
operator|*
name|cum
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
name|arg_num
operator|<=
name|LAST_ARG_REGNUM
operator|&&
name|arg_num
operator|+
name|words
operator|>
name|LAST_ARG_REGNUM
operator|+
literal|1
operator|)
condition|?
name|LAST_ARG_REGNUM
operator|-
name|arg_num
operator|+
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
operator|&&
name|ret
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_partial_nregs: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression that indicates when an argument must be passed by reference.    If nonzero for an argument, a copy of that argument is made in memory and a    pointer to the argument is passed instead of the argument itself.  The    pointer is passed in whatever way is appropriate for passing a pointer to    that type.     On machines where `REG_PARM_STACK_SPACE' is not defined, a suitable    definition of this macro might be         #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)  \           MUST_PASS_IN_STACK (MODE, TYPE)  */
end_comment

begin_function
name|int
name|frv_function_arg_pass_by_reference
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If defined, a C expression that indicates when it is the called function's    responsibility to make a copy of arguments passed by invisible reference.    Normally, the caller makes a copy and passes the address of the copy to the    routine being called.  When FUNCTION_ARG_CALLEE_COPIES is defined and is    nonzero, the caller does not make a copy.  Instead, it passes a pointer to    the "live" value.  The called function must not modify this value.  If it    can be determined that the value won't be modified, it need not make a copy;    otherwise a copy must be made.  */
end_comment

begin_function
name|int
name|frv_function_arg_callee_copies
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If defined, a C expression that indicates when it is more desirable to keep    an argument passed by invisible reference as a reference, rather than    copying it to a pseudo register.  */
end_comment

begin_function
name|int
name|frv_function_arg_keep_as_reference
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if a register is ok to use as a base or index register.  */
end_comment

begin_function
specifier|static
name|FRV_INLINE
name|int
name|frv_regno_ok_for_base_p
parameter_list|(
name|regno
parameter_list|,
name|strict_p
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|strict_p
decl_stmt|;
block|{
if|if
condition|(
name|GPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strict_p
condition|)
return|return
operator|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|GPR_P
argument_list|(
name|reg_renumber
index|[
name|regno
index|]
argument_list|)
operator|)
return|;
if|if
condition|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|TRUE
return|;
return|return
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement with a conditional `goto LABEL;' executed if X (an    RTX) is a legitimate memory address on the target machine for a memory    operand of mode MODE.     It usually pays to define several simpler macros to serve as subroutines for    this one.  Otherwise it may be too complicated to understand.     This macro must exist in two variants: a strict variant and a non-strict    one.  The strict variant is used in the reload pass.  It must be defined so    that any pseudo-register that has not been allocated a hard register is    considered a memory reference.  In contexts where some kind of register is    required, a pseudo-register with no hard register must be rejected.     The non-strict variant is used in other passes.  It must be defined to    accept all pseudo-registers in every context where some kind of register is    required.     Compiler source files that want to use the strict variant of this macro    define the macro `REG_OK_STRICT'.  You should use an `#ifdef REG_OK_STRICT'    conditional to define the strict variant in that case and the non-strict    variant otherwise.     Subroutines to check for acceptable registers for various purposes (one for    base registers, one for index registers, and so on) are typically among the    subroutines used to define `GO_IF_LEGITIMATE_ADDRESS'.  Then only these    subroutine macros need have two variants; the higher levels of macros may be    the same whether strict or not.     Normally, constant addresses which are the sum of a `symbol_ref' and an    integer are stored inside a `const' RTX to mark them as constant.    Therefore, there is no need to recognize such sums specifically as    legitimate addresses.  Normally you would simply recognize any `const' as    legitimate.     Usually `PRINT_OPERAND_ADDRESS' is not prepared to handle constant sums that    are not marked with `const'.  It assumes that a naked `plus' indicates    indexing.  If so, then you *must* reject such naked constant sums as    illegitimate addresses, so that none of them will be given to    `PRINT_OPERAND_ADDRESS'.     On some machines, whether a symbolic address is legitimate depends on the    section that the address refers to.  On these machines, define the macro    `ENCODE_SECTION_INFO' to store the information into the `symbol_ref', and    then check for it here.  When you see a `const', you will have to look    inside it to find the `symbol_ref' in order to determine the section.     The best way to modify the name string is by adding text to the beginning,    with suitable punctuation to prevent any ambiguity.  Allocate the new name    in `saveable_obstack'.  You will have to modify `ASM_OUTPUT_LABELREF' to    remove and decode the added text and output the name accordingly, and define    `(* targetm.strip_name_encoding)' to access the original name string.     You can check the information stored here into the `symbol_ref' in the    definitions of the macros `GO_IF_LEGITIMATE_ADDRESS' and    `PRINT_OPERAND_ADDRESS'.  */
end_comment

begin_function
name|int
name|frv_legitimate_address_p
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|strict_p
parameter_list|,
name|condexec_p
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|strict_p
decl_stmt|;
name|int
name|condexec_p
decl_stmt|;
block|{
name|rtx
name|x0
decl_stmt|,
name|x1
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|unsigned
name|regno0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|SUBREG
case|:
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
break|break;
comment|/* fall through */
case|case
name|REG
case|:
name|ret
operator|=
name|frv_regno_ok_for_base_p
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|strict_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_MODIFY
case|:
name|x0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|frv_regno_ok_for_base_p
argument_list|(
name|REGNO
argument_list|(
name|x0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|x0
argument_list|,
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|frv_regno_ok_for_base_p
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|strict_p
argument_list|)
condition|)
break|break;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
comment|/* 12 bit immediate */
if|if
condition|(
name|condexec_p
condition|)
name|ret
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
expr_stmt|;
comment|/* If we can't use load/store double operations, make sure we can 	     address the second word.  */
if|if
condition|(
name|ret
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|ret
operator|=
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
name|x0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|SUBREG
condition|)
name|x0
operator|=
name|SUBREG_REG
argument_list|(
name|x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|!=
name|REG
condition|)
break|break;
name|regno0
operator|=
name|REGNO
argument_list|(
name|x0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frv_regno_ok_for_base_p
argument_list|(
name|regno0
argument_list|,
name|strict_p
argument_list|)
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|SUBREG
case|:
name|x1
operator|=
name|SUBREG_REG
argument_list|(
name|x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|REG
condition|)
break|break;
comment|/* fall through */
case|case
name|REG
case|:
comment|/* Do not allow reg+reg addressing for modes> 1 word if we can't depend 	     on having move double instructions */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|ret
operator|=
name|FALSE
expr_stmt|;
else|else
name|ret
operator|=
name|frv_regno_ok_for_base_p
argument_list|(
name|REGNO
argument_list|(
name|x1
argument_list|)
argument_list|,
name|strict_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
comment|/* 12 bit immediate */
if|if
condition|(
name|condexec_p
condition|)
name|ret
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|value
operator|=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|IN_RANGE_P
argument_list|(
name|value
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
expr_stmt|;
comment|/* If we can't use load/store double operations, make sure we can 		 address the second word.  */
if|if
condition|(
name|ret
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|ret
operator|=
name|IN_RANGE_P
argument_list|(
name|value
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|condexec_p
operator|&&
name|regno0
operator|==
name|SDA_BASE_REG
operator|&&
name|symbol_ref_small_data_p
argument_list|(
name|x1
argument_list|)
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CONST
case|:
if|if
condition|(
operator|!
name|condexec_p
operator|&&
name|regno0
operator|==
name|SDA_BASE_REG
operator|&&
name|const_small_data_p
argument_list|(
name|x1
argument_list|)
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== GO_IF_LEGITIMATE_ADDRESS, mode = %s, result = %d, addresses are %sstrict%s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|ret
argument_list|,
operator|(
name|strict_p
operator|)
condition|?
literal|""
else|:
literal|"not "
argument_list|,
operator|(
name|condexec_p
operator|)
condition|?
literal|", inside conditional code"
else|:
literal|""
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement that attempts to replace X with a valid memory    address for an operand of mode MODE.  WIN will be a C statement label    elsewhere in the code; the macro definition may use          GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);     to avoid further processing if the address has become legitimate.     X will always be the result of a call to `break_out_memory_refs', and OLDX    will be the operand that was given to that function to produce X.     The code generated by this macro should not alter the substructure of X.  If    it transforms X into a more legitimate form, it should assign X (which will    always be a C variable) a new value.     It is not necessary for this macro to come up with a legitimate address.    The compiler has standard ways of doing so in all cases.  In fact, it is    safe for this macro to do nothing.  But often a machine-dependent strategy    can generate better code.  */
end_comment

begin_function
name|rtx
name|frv_legitimize_address
parameter_list|(
name|x
parameter_list|,
name|oldx
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Don't try to legitimize addresses if we are not optimizing, since the      address we generate is not a general operand, and will horribly mess      things up when force_reg is called to try and put it in a register because      we aren't optimizing.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|symbol_ref_small_data_p
argument_list|(
name|x
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|const_small_data_p
argument_list|(
name|x
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|SDA_BASE_REG
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|cfun
operator|->
name|uses_pic_offset_table
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_DEBUG_ADDR
operator|&&
name|ret
operator|!=
name|NULL_RTX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== LEGITIMIZE_ADDRESS, mode = %s, modified address\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a valid FRV address.  CONDEXEC_P is true if    the operand is used by a predicated instruction.  */
end_comment

begin_function
specifier|static
name|int
name|frv_legitimate_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|condexec_p
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|condexec_p
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|frv_legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reload_completed
argument_list|,
name|condexec_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 is OP is a memory operand, or will be turned into one by    reload.  */
end_comment

begin_function
name|int
name|frv_load_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|rtx
name|tmp
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SUBREG
condition|)
name|tmp
operator|=
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|op
operator|=
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
block|}
return|return
name|op
operator|&&
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a GPR register or a FPR register.  */
end_comment

begin_function
name|int
name|gpr_or_fpr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|regno
argument_list|)
operator|||
name|FPR_P
argument_list|(
name|regno
argument_list|)
operator|||
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a GPR register or 12 bit signed immediate.  */
end_comment

begin_function
name|int
name|gpr_or_int12_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
return|return
name|GPR_OR_PSEUDO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a GPR register, or a FPR register, or a 12 bit    signed immediate.  */
end_comment

begin_function
name|int
name|gpr_fpr_or_int12_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|regno
argument_list|)
operator|||
name|FPR_P
argument_list|(
name|regno
argument_list|)
operator|||
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a register or 6 bit signed immediate.  */
end_comment

begin_function
name|int
name|fpr_or_int6_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
operator|-
literal|32
argument_list|,
literal|31
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
return|return
name|FPR_OR_PSEUDO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a register or 10 bit signed immediate.  */
end_comment

begin_function
name|int
name|gpr_or_int10_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
operator|-
literal|512
argument_list|,
literal|511
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
return|return
name|GPR_OR_PSEUDO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a register or an integer immediate.  */
end_comment

begin_function
name|int
name|gpr_or_int_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
return|return
name|GPR_OR_PSEUDO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a 12 bit signed immediate.  */
end_comment

begin_function
name|int
name|int12_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|FALSE
return|;
return|return
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a 6 bit signed immediate.  */
end_comment

begin_function
name|int
name|int6_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|FALSE
return|;
return|return
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
operator|-
literal|32
argument_list|,
literal|31
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a 5 bit signed immediate.  */
end_comment

begin_function
name|int
name|int5_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
operator|-
literal|16
argument_list|,
literal|15
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a 5 bit unsigned immediate.  */
end_comment

begin_function
name|int
name|uint5_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a 4 bit unsigned immediate.  */
end_comment

begin_function
name|int
name|uint4_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a 1 bit unsigned immediate (0 or 1).  */
end_comment

begin_function
name|int
name|uint1_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is an integer constant that takes 2 instructions    to load up and can be split into sethi/setlo instructions..  */
end_comment

begin_function
name|int
name|int_2word_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|l
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|LABEL_REF
case|:
return|return
operator|(
name|flag_pic
operator|==
literal|0
operator|)
return|;
case|case
name|CONST
case|:
comment|/* small data references are already 1 word */
return|return
operator|(
name|flag_pic
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|const_small_data_p
argument_list|(
name|op
argument_list|)
operator|)
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* small data references are already 1 word */
return|return
operator|(
name|flag_pic
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|symbol_ref_small_data_p
argument_list|(
name|op
argument_list|)
operator|)
return|;
case|case
name|CONST_INT
case|:
return|return
operator|!
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
operator|-
literal|32768
argument_list|,
literal|32767
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|value
operator|=
name|l
expr_stmt|;
return|return
operator|!
name|IN_RANGE_P
argument_list|(
name|value
argument_list|,
operator|-
literal|32768
argument_list|,
literal|32767
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|value
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|!
name|IN_RANGE_P
argument_list|(
name|value
argument_list|,
operator|-
literal|32768
argument_list|,
literal|32767
argument_list|)
return|;
block|}
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is the pic address register.  */
end_comment

begin_function
name|int
name|pic_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_pic
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|PIC_REGNO
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a symbolic reference when a PIC option is specified    that takes 3 seperate instructions to form.  */
end_comment

begin_function
name|int
name|pic_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_pic
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|LABEL_REF
case|:
return|return
name|TRUE
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* small data references are already 1 word */
return|return
operator|!
name|symbol_ref_small_data_p
argument_list|(
name|op
argument_list|)
return|;
case|case
name|CONST
case|:
comment|/* small data references are already 1 word */
return|return
operator|!
name|const_small_data_p
argument_list|(
name|op
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is the small data register.  */
end_comment

begin_function
name|int
name|small_data_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|SDA_BASE_REG
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a symbolic reference to a small data area static or    global object.  */
end_comment

begin_function
name|int
name|small_data_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CONST
case|:
return|return
name|const_small_data_p
argument_list|(
name|op
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|symbol_ref_small_data_p
argument_list|(
name|op
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a 16 bit unsigned immediate */
end_comment

begin_function
name|int
name|uint16_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|FALSE
return|;
return|return
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is an integer constant with the bottom 16 bits clear */
end_comment

begin_function
name|int
name|upper_int16_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a GPR register. */
end_comment

begin_function
name|int
name|integer_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
return|return
name|GPR_OR_PSEUDO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a GPR register.  Do not allow SUBREG's    here, in order to prevent a combine bug.  */
end_comment

begin_function
name|int
name|gpr_no_subreg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
return|return
name|GPR_OR_PSEUDO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a FPR register. */
end_comment

begin_function
name|int
name|fpr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
return|return
name|FPR_OR_PSEUDO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an even GPR or FPR register. */
end_comment

begin_function
name|int
name|even_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|GPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
if|if
condition|(
name|FPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an odd GPR register. */
end_comment

begin_function
name|int
name|odd_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* assume that reload will give us an even register */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|GPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
return|;
if|if
condition|(
name|FPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an even GPR register. */
end_comment

begin_function
name|int
name|even_gpr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|GPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|GPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an odd GPR register. */
end_comment

begin_function
name|int
name|odd_gpr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* assume that reload will give us an even register */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|GPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|GPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a quad aligned FPR register. */
end_comment

begin_function
name|int
name|quad_fpr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|FPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an even FPR register. */
end_comment

begin_function
name|int
name|even_fpr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|FPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an odd FPR register. */
end_comment

begin_function
name|int
name|odd_fpr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* assume that reload will give us an even register */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|FPR_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a 2 word memory address that can be loaded in one    instruction to load or store.  We assume the stack and frame pointers are    suitably aligned, and variables in the small data area.  FIXME -- at some we    should recognize other globals and statics. We can't assume that any old    pointer is aligned, given that arguments could be passed on an odd word on    the stack and the address taken and passed through to another function.  */
end_comment

begin_function
name|int
name|dbl_memory_one_insn_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
name|rtx
name|addr_reg
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_DWORD
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|!=
literal|2
operator|*
name|UNITS_PER_WORD
condition|)
return|return
name|FALSE
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|addr_reg
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|addr0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|addr1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr0
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|plus_small_data_p
argument_list|(
name|addr0
argument_list|,
name|addr1
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|addr1
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|addr_reg
operator|=
name|addr0
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|addr_reg
operator|==
name|frame_pointer_rtx
operator|||
name|addr_reg
operator|==
name|stack_pointer_rtx
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a 2 word memory address that needs to    use two instructions to load or store.  */
end_comment

begin_function
name|int
name|dbl_memory_two_insn_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|!=
literal|2
operator|*
name|UNITS_PER_WORD
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|TARGET_DWORD
condition|)
return|return
name|TRUE
return|;
return|return
operator|!
name|dbl_memory_one_insn_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is something that can be an output for a move    operation.  */
end_comment

begin_function
name|int
name|move_destination_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|subreg
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
name|subreg
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|subreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|frv_legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|subreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reload_completed
argument_list|,
name|FALSE
argument_list|)
return|;
return|return
operator|(
name|code
operator|==
name|REG
operator|)
return|;
case|case
name|REG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|TRUE
return|;
return|return
name|frv_legitimate_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is something that can be an input for a move    operation.  */
end_comment

begin_function
name|int
name|move_source_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|subreg
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
return|return
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
name|subreg
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|subreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|frv_legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|subreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reload_completed
argument_list|,
name|FALSE
argument_list|)
return|;
return|return
operator|(
name|code
operator|==
name|REG
operator|)
return|;
case|case
name|REG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|TRUE
return|;
return|return
name|frv_legitimate_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is something that can be an output for a conditional    move operation.  */
end_comment

begin_function
name|int
name|condexec_dest_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|subreg
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
name|subreg
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|subreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|frv_legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|subreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reload_completed
argument_list|,
name|TRUE
argument_list|)
return|;
return|return
operator|(
name|code
operator|==
name|REG
operator|)
return|;
case|case
name|REG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|TRUE
return|;
return|return
name|frv_legitimate_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is something that can be an input for a conditional    move operation.  */
end_comment

begin_function
name|int
name|condexec_source_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|subreg
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
return|return
name|ZERO_P
argument_list|(
name|op
argument_list|)
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
name|subreg
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|subreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|frv_legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|subreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reload_completed
argument_list|,
name|TRUE
argument_list|)
return|;
return|return
operator|(
name|code
operator|==
name|REG
operator|)
return|;
case|case
name|REG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|TRUE
return|;
return|return
name|frv_legitimate_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a register of any flavor or a 0 of the    appropriate type.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
return|return
name|ZERO_P
argument_list|(
name|op
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is the link register */
end_comment

begin_function
name|int
name|lr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|LR_REGNO
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a gpr register or a valid memory operation.  */
end_comment

begin_function
name|int
name|gpr_or_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|integer_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|frv_legitimate_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a fpr register or a valid memory operation.  */
end_comment

begin_function
name|int
name|fpr_or_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|fpr_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|frv_legitimate_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an icc register */
end_comment

begin_function
name|int
name|icc_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|ICC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an fcc register */
end_comment

begin_function
name|int
name|fcc_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|FCC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is either an fcc or icc register */
end_comment

begin_function
name|int
name|cc_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|CC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an integer CCR register */
end_comment

begin_function
name|int
name|icr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|ICR_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is an fcc register */
end_comment

begin_function
name|int
name|fcr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|FCR_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is either an fcc or icc register */
end_comment

begin_function
name|int
name|cr_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|CR_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a memory reference suitable for a call.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|TRUE
return|;
comment|/* Note this doesn't allow reg+reg or reg+imm12 addressing (which should      never occur anyway), but prevents reload from not handling the case      properly of a call through a pointer on a function that calls      vfork/setjmp, etc. due to the need to flush all of the registers to stack.  */
return|return
name|gpr_or_int12_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is an kind of relational operator */
end_comment

begin_function
name|int
name|relational_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
break|break;
block|}
name|op1
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|FALSE
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CCmode
case|:
case|case
name|CC_UNSmode
case|:
return|return
name|ICC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
return|;
case|case
name|CC_FPmode
case|:
return|return
name|FCC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
return|;
case|case
name|CC_CCRmode
case|:
return|return
name|CR_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is a signed integer relational operator */
end_comment

begin_function
name|int
name|signed_relational_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
break|break;
block|}
name|op1
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|FALSE
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CCmode
operator|&&
name|ICC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CC_CCRmode
operator|&&
name|CR_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is a signed integer relational operator */
end_comment

begin_function
name|int
name|unsigned_relational_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
break|break;
block|}
name|op1
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|FALSE
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CC_UNSmode
operator|&&
name|ICC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CC_CCRmode
operator|&&
name|CR_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is a floating point relational operator */
end_comment

begin_function
name|int
name|float_relational_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
if|#
directive|if
literal|0
block|case UEQ: case UNE:     case ULE: case ULT:     case UGE: case UGT:     case ORDERED:     case UNORDERED:
endif|#
directive|endif
break|break;
block|}
name|op1
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|FALSE
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CC_FPmode
operator|&&
name|FCC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CC_CCRmode
operator|&&
name|CR_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is EQ/NE of a conditional execution register.  */
end_comment

begin_function
name|int
name|ccr_eqne_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
break|break;
block|}
name|op1
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|FALSE
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|CC_CCRmode
operator|&&
name|CR_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is a minimum or maximum operator (both signed and    unsigned).  */
end_comment

begin_function
name|int
name|minmax_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
break|break;
block|}
if|if
condition|(
operator|!
name|integer_register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|gpr_or_int10_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is an integer binary operator that can executed    conditionally and takes 1 cycle.  */
end_comment

begin_function
name|int
name|condexec_si_binary_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if operator is an integer binary operator that can be    executed conditionally by a media instruction.  */
end_comment

begin_function
name|int
name|condexec_si_media_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if operator is an integer division operator that can executed    conditionally.  */
end_comment

begin_function
name|int
name|condexec_si_divide_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if operator is an integer unary operator that can executed    conditionally.  */
end_comment

begin_function
name|int
name|condexec_si_unary_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if operator is a conversion-type expression that can be    evaluated conditionally by floating-point instructions.  */
end_comment

begin_function
name|int
name|condexec_sf_conv_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|NEG
case|:
case|case
name|ABS
case|:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if operator is an addition or subtraction expression.    Such expressions can be evaluated conditionally by floating-point    instructions.  */
end_comment

begin_function
name|int
name|condexec_sf_add_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the memory operand is one that can be conditionally    executed.  */
end_comment

begin_function
name|int
name|condexec_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|op_mode
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|FALSE
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|TRUE
return|;
return|return
name|frv_legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|reload_completed
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is an integer binary operator that can be combined    with a setcc operation.  Do not allow the arithmetic operations that could    potentially overflow since the FR-V sets the condition code based on the    "true" value of the result, not the result after truncating to a 32-bit    register.  */
end_comment

begin_function
name|int
name|intop_compare_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
break|break;
block|}
if|if
condition|(
operator|!
name|integer_register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|gpr_or_int10_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true if operator is an integer binary operator that can be combined    with a setcc operation inside of a conditional execution.  */
end_comment

begin_function
name|int
name|condexec_intop_cmp_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|op_mode
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
break|break;
block|}
if|if
condition|(
operator|!
name|integer_register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|integer_register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a valid ACC register number */
end_comment

begin_function
name|int
name|acc_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|ACC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a valid even ACC register number */
end_comment

begin_function
name|int
name|even_acc_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|(
operator|(
name|regno
operator|-
name|ACC_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is zero or four */
end_comment

begin_function
name|int
name|quad_acc_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACC_OR_PSEUDO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|(
operator|(
name|regno
operator|-
name|ACC_FIRST
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operand is a valid ACCG register number */
end_comment

begin_function
name|int
name|accg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|FALSE
return|;
return|return
name|ACCG_OR_PSEUDO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the bare return instruction can be used outside of the    epilog code.  For frv, we only do it if there was no stack allocation.  */
end_comment

begin_function
name|int
name|direct_return_p
parameter_list|()
block|{
name|frv_stack_t
modifier|*
name|info
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
name|FALSE
return|;
name|info
operator|=
name|frv_stack_info
argument_list|()
expr_stmt|;
return|return
operator|(
name|info
operator|->
name|total_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to handle a MOVSI, adding in the small data register or pic    register if needed to load up addresses.  Return TRUE if the appropriate    instructions are emitted.  */
end_comment

begin_function
name|int
name|frv_emit_movsi
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|int
name|base_regno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
operator|&&
operator|!
name|register_operand
argument_list|(
name|dest
argument_list|,
name|SImode
argument_list|)
operator|&&
operator|(
operator|!
name|reg_or_0_operand
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|)
comment|/* Virtual registers will almost always be replaced by an 		add instruction, so expose this to CSE by copying to 		an intermediate register */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|IN_RANGE_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|,
name|FIRST_VIRTUAL_REGISTER
argument_list|,
name|LAST_VIRTUAL_REGISTER
argument_list|)
operator|)
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Explicitly add in the PIC or small data register if needed.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|flag_pic
condition|)
name|base_regno
operator|=
name|PIC_REGNO
expr_stmt|;
break|break;
case|case
name|CONST
case|:
if|if
condition|(
name|const_small_data_p
argument_list|(
name|src
argument_list|)
condition|)
name|base_regno
operator|=
name|SDA_BASE_REG
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|base_regno
operator|=
name|PIC_REGNO
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|symbol_ref_small_data_p
argument_list|(
name|src
argument_list|)
condition|)
name|base_regno
operator|=
name|SDA_BASE_REG
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|base_regno
operator|=
name|PIC_REGNO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|base_regno
operator|>=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|base_regno
argument_list|)
argument_list|,
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_regno
operator|==
name|PIC_REGNO
condition|)
name|cfun
operator|->
name|uses_pic_offset_table
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a string to output a single word move.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_move_single
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|dest_regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|dest_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* gpr<- some sort of register */
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"mov %1, %0"
return|;
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"movfg %1, %0"
return|;
elseif|else
if|if
condition|(
name|SPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"movsg %1, %0"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* gpr<- memory */
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|QImode
case|:
return|return
literal|"ldsb%I1%U1 %M1,%0"
return|;
case|case
name|HImode
case|:
return|return
literal|"ldsh%I1%U1 %M1,%0"
return|;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
return|return
literal|"ld%I1%U1 %M1, %0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* gpr<- integer/floating constant */
name|HOST_WIDE_INT
name|value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
condition|)
name|value
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|value
operator|=
name|l
expr_stmt|;
block|}
else|else
name|value
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_RANGE_P
argument_list|(
name|value
argument_list|,
operator|-
literal|32768
argument_list|,
literal|32767
argument_list|)
condition|)
return|return
literal|"setlos %1, %0"
return|;
return|return
literal|"#"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST
condition|)
block|{
comment|/* Silently fix up instances where the small data pointer is not                  used in the address.  */
if|if
condition|(
name|small_data_symbolic_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
literal|"addi %@, #gprel12(%1), %0"
return|;
return|return
literal|"#"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|dest_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* fpr<- some sort of register */
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"movgf %1, %0"
return|;
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT
condition|)
return|return
literal|"fmovs %1, %0"
return|;
else|else
return|return
literal|"mor %1, %1, %0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* fpr<- memory */
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|QImode
case|:
return|return
literal|"ldbf%I1%U1 %M1,%0"
return|;
case|case
name|HImode
case|:
return|return
literal|"ldhf%I1%U1 %M1,%0"
return|;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
return|return
literal|"ldf%I1%U1 %M1, %0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ZERO_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|"movgf %., %0"
return|;
block|}
elseif|else
if|if
condition|(
name|SPR_P
argument_list|(
name|dest_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* spr<- some sort of register */
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"movgs %1, %0"
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|QImode
case|:
return|return
literal|"stb%I0%U0 %1, %M0"
return|;
case|case
name|HImode
case|:
return|return
literal|"sth%I0%U0 %1, %M0"
return|;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
return|return
literal|"st%I0%U0 %1, %M0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|QImode
case|:
return|return
literal|"stbf%I0%U0 %1, %M0"
return|;
case|case
name|HImode
case|:
return|return
literal|"sthf%I0%U0 %1, %M0"
return|;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
return|return
literal|"stf%I0%U0 %1, %M0"
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ZERO_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|QImode
case|:
return|return
literal|"stb%I0%U0 %., %M0"
return|;
case|case
name|HImode
case|:
return|return
literal|"sth%I0%U0 %., %M0"
return|;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
return|return
literal|"st%I0%U0 %., %M0"
return|;
block|}
block|}
block|}
name|fatal_insn
argument_list|(
literal|"Bad output_move_single operand"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a string to output a double word move.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|dest_regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|dest_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* gpr<- some sort of register */
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"#"
return|;
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|dest_regno
operator|-
name|GPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|src_regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"movfgd %1, %0"
return|;
return|return
literal|"#"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* gpr<- memory */
if|if
condition|(
name|dbl_memory_one_insn_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|"ldd%I1%U1 %M1, %0"
return|;
return|return
literal|"#"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
literal|"#"
return|;
block|}
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|dest_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* fpr<- some sort of register */
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|dest_regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|src_regno
operator|-
name|GPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"movgfd %1, %0"
return|;
return|return
literal|"#"
return|;
block|}
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DOUBLE
operator|&&
operator|(
operator|(
name|dest_regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|src_regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"fmovd %1, %0"
return|;
return|return
literal|"#"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* fpr<- memory */
if|if
condition|(
name|dbl_memory_one_insn_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|"lddf%I1%U1 %M1, %0"
return|;
return|return
literal|"#"
return|;
block|}
elseif|else
if|if
condition|(
name|ZERO_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|"#"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|src_regno
operator|-
name|GPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|dbl_memory_one_insn_operand
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|"std%I0%U0 %1, %M0"
return|;
return|return
literal|"#"
return|;
block|}
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|src_regno
operator|-
name|FPR_FIRST
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|dbl_memory_one_insn_operand
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|"stdf%I0%U0 %1, %M0"
return|;
return|return
literal|"#"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ZERO_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|dbl_memory_one_insn_operand
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|"std%I0%U0 %., %M0"
return|;
return|return
literal|"#"
return|;
block|}
block|}
name|fatal_insn
argument_list|(
literal|"Bad output_move_double operand"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a string to output a single word conditional move.    Operand0 -- EQ/NE of ccr register and 0    Operand1 -- CCR register    Operand2 -- destination    Operand3 -- source  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_condmove_single
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|src
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|dest_regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|dest_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* gpr<- some sort of register */
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"cmov %z3, %2, %1, %e0"
return|;
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"cmovfg %3, %2, %1, %e0"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* gpr<- memory */
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|QImode
case|:
return|return
literal|"cldsb%I3%U3 %M3, %2, %1, %e0"
return|;
case|case
name|HImode
case|:
return|return
literal|"cldsh%I3%U3 %M3, %2, %1, %e0"
return|;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
return|return
literal|"cld%I3%U3 %M3, %2, %1, %e0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ZERO_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|"cmov %., %2, %1, %e0"
return|;
block|}
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|dest_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* fpr<- some sort of register */
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
return|return
literal|"cmovgf %3, %2, %1, %e0"
return|;
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT
condition|)
return|return
literal|"cfmovs %3,%2,%1,%e0"
return|;
else|else
return|return
literal|"cmor %3, %3, %2, %1, %e0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* fpr<- memory */
if|if
condition|(
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|SFmode
condition|)
return|return
literal|"cldf%I3%U3 %M3, %2, %1, %e0"
return|;
block|}
elseif|else
if|if
condition|(
name|ZERO_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|"cmovgf %., %2, %1, %e0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|src_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|GPR_P
argument_list|(
name|src_regno
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|QImode
case|:
return|return
literal|"cstb%I2%U2 %3, %M2, %1, %e0"
return|;
case|case
name|HImode
case|:
return|return
literal|"csth%I2%U2 %3, %M2, %1, %e0"
return|;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
return|return
literal|"cst%I2%U2 %3, %M2, %1, %e0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|src_regno
argument_list|)
operator|&&
operator|(
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|SFmode
operator|)
condition|)
return|return
literal|"cstf%I2%U2 %3, %M2, %1, %e0"
return|;
block|}
elseif|else
if|if
condition|(
name|ZERO_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|QImode
case|:
return|return
literal|"cstb%I2%U2 %., %M2, %1, %e0"
return|;
case|case
name|HImode
case|:
return|return
literal|"csth%I2%U2 %., %M2, %1, %e0"
return|;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
return|return
literal|"cst%I2%U2 %., %M2, %1, %e0"
return|;
block|}
block|}
block|}
name|fatal_insn
argument_list|(
literal|"Bad output_condmove_single operand"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit the appropriate code to do a comparison, returning the register the    comparison was done it.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_emit_comparison
parameter_list|(
name|test
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|test
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
block|{
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
name|rtx
name|cc_reg
decl_stmt|;
comment|/* Floating point doesn't have comparison against a constant */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CC_FPmode
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REG
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Possibly disable using anything but a fixed register in order to work      around cse moving comparisons past function calls.  */
name|cc_mode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|test
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|cc_reg
operator|=
operator|(
operator|(
name|TARGET_ALLOC_CC
operator|)
condition|?
name|gen_reg_rtx
argument_list|(
name|cc_mode
argument_list|)
else|:
name|gen_rtx_REG
argument_list|(
name|cc_mode
argument_list|,
operator|(
name|cc_mode
operator|==
name|CC_FPmode
operator|)
condition|?
name|FCC_FIRST
else|:
name|ICC_FIRST
argument_list|)
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|cc_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code for a conditional branch.  The comparison operands were previously    stored in frv_compare_op0 and frv_compare_op1.     XXX: I originally wanted to add a clobber of a CCR register to use in    conditional execution, but that confuses the rest of the compiler.  */
end_comment

begin_function
name|int
name|frv_emit_cond_branch
parameter_list|(
name|test
parameter_list|,
name|label
parameter_list|)
name|enum
name|rtx_code
name|test
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|rtx
name|test_rtx
decl_stmt|;
name|rtx
name|label_ref
decl_stmt|;
name|rtx
name|if_else
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|frv_emit_comparison
argument_list|(
name|test
argument_list|,
name|frv_compare_op0
argument_list|,
name|frv_compare_op1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
init|=
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
decl_stmt|;
comment|/* Branches generate: 	(set (pc) 	     (if_then_else (<test>,<cc_reg>, (const_int 0)) 			    (label_ref<branch_label>) 			    (pc))) */
name|label_ref
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|test_rtx
operator|=
name|gen_rtx
argument_list|(
name|test
argument_list|,
name|cc_mode
argument_list|,
name|cc_reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|if_else
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|cc_mode
argument_list|,
name|test_rtx
argument_list|,
name|label_ref
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|if_else
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to set a gpr to 1/0 based on a comparison.  The comparison    operands were previously stored in frv_compare_op0 and frv_compare_op1.  */
end_comment

begin_function
name|int
name|frv_emit_scc
parameter_list|(
name|test
parameter_list|,
name|target
parameter_list|)
name|enum
name|rtx_code
name|test
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
name|rtx
name|test_rtx
decl_stmt|;
name|rtx
name|clobber
decl_stmt|;
name|rtx
name|cr_reg
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|frv_emit_comparison
argument_list|(
name|test
argument_list|,
name|frv_compare_op0
argument_list|,
name|frv_compare_op1
argument_list|)
decl_stmt|;
comment|/* SCC instructions generate: 	(parallel [(set<target> (<test>,<cc_reg>, (const_int 0)) 		   (clobber (<ccr_reg>))])  */
name|test_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|test
argument_list|,
name|SImode
argument_list|,
name|cc_reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|test_rtx
argument_list|)
expr_stmt|;
name|cr_reg
operator|=
operator|(
operator|(
name|TARGET_ALLOC_CC
operator|)
condition|?
name|gen_reg_rtx
argument_list|(
name|CC_CCRmode
argument_list|)
else|:
name|gen_rtx_REG
argument_list|(
name|CC_CCRmode
argument_list|,
operator|(
operator|(
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
operator|==
name|CC_FPmode
operator|)
condition|?
name|FCR_FIRST
else|:
name|ICR_FIRST
operator|)
argument_list|)
operator|)
expr_stmt|;
name|clobber
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|cr_reg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|set
argument_list|,
name|clobber
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a SCC instruction into component parts, returning a SEQUENCE to hold    the seperate insns.  */
end_comment

begin_function
name|rtx
name|frv_split_scc
parameter_list|(
name|dest
parameter_list|,
name|test
parameter_list|,
name|cc_reg
parameter_list|,
name|cr_reg
parameter_list|,
name|value
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|test
decl_stmt|;
name|rtx
name|cc_reg
decl_stmt|;
name|rtx
name|cr_reg
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
name|rtx
name|ret
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Set the appropriate CCR bit.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cr_reg
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|cr_reg
argument_list|)
argument_list|,
name|cc_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the value into the destination.  */
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move 0 into the destination if the test failed */
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_EQ
argument_list|(
name|GET_MODE
argument_list|(
name|cr_reg
argument_list|)
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finish up, return sequence.  */
name|ret
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit the code for a conditional move, return TRUE if we could do the    move.  */
end_comment

begin_function
name|int
name|frv_emit_cond_move
parameter_list|(
name|dest
parameter_list|,
name|test_rtx
parameter_list|,
name|src1
parameter_list|,
name|src2
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|test_rtx
decl_stmt|;
name|rtx
name|src1
decl_stmt|;
name|rtx
name|src2
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
name|rtx
name|clobber_cc
decl_stmt|;
name|rtx
name|test2
decl_stmt|;
name|rtx
name|cr_reg
decl_stmt|;
name|rtx
name|if_rtx
decl_stmt|;
name|enum
name|rtx_code
name|test
init|=
name|GET_CODE
argument_list|(
name|test_rtx
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|frv_emit_comparison
argument_list|(
name|test
argument_list|,
name|frv_compare_op0
argument_list|,
name|frv_compare_op1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
init|=
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
decl_stmt|;
comment|/* Conditional move instructions generate: 	(parallel [(set<target> 			(if_then_else (<test><cc_reg> (const_int 0))<src1><src2>)) 		   (clobber (<ccr_reg>))])  */
comment|/* Handle various cases of conditional move involving two constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value1
init|=
name|INTVAL
argument_list|(
name|src1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|value2
init|=
name|INTVAL
argument_list|(
name|src2
argument_list|)
decl_stmt|;
comment|/* having 0 as one of the constants can be done by loading the other          constant, and optionally moving in gr0.  */
if|if
condition|(
name|value1
operator|==
literal|0
operator|||
name|value2
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* If the first value is within an addi range and also the difference          between the two fits in an addi's range, load up the difference, then          conditionally move in 0, and then unconditionally add the first 	 value.  */
elseif|else
if|if
condition|(
name|IN_RANGE_P
argument_list|(
name|value1
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
operator|&&
name|IN_RANGE_P
argument_list|(
name|value2
operator|-
name|value1
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
condition|)
empty_stmt|;
comment|/* If neither condition holds, just force the constant into a 	 register.  */
else|else
block|{
name|src1
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|src1
argument_list|)
expr_stmt|;
name|src2
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If one value is a register, insure the other value is either 0 or a      register.  */
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|src1
argument_list|)
operator|!=
literal|0
condition|)
name|src1
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|src1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|src2
argument_list|)
operator|!=
literal|0
condition|)
name|src2
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
name|test2
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|test
argument_list|,
name|cc_mode
argument_list|,
name|cc_reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|if_rtx
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|test2
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|if_rtx
argument_list|)
expr_stmt|;
name|cr_reg
operator|=
operator|(
operator|(
name|TARGET_ALLOC_CC
operator|)
condition|?
name|gen_reg_rtx
argument_list|(
name|CC_CCRmode
argument_list|)
else|:
name|gen_rtx_REG
argument_list|(
name|CC_CCRmode
argument_list|,
operator|(
name|cc_mode
operator|==
name|CC_FPmode
operator|)
condition|?
name|FCR_FIRST
else|:
name|ICR_FIRST
argument_list|)
operator|)
expr_stmt|;
name|clobber_cc
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|cr_reg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|set
argument_list|,
name|clobber_cc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a conditonal move into constituent parts, returning a SEQUENCE    containing all of the insns.  */
end_comment

begin_function
name|rtx
name|frv_split_cond_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|test
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|src1
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|src2
init|=
name|operands
index|[
literal|4
index|]
decl_stmt|;
name|rtx
name|cr_reg
init|=
name|operands
index|[
literal|5
index|]
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|enum
name|machine_mode
name|cr_mode
init|=
name|GET_MODE
argument_list|(
name|cr_reg
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Set the appropriate CCR bit.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cr_reg
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|cr_reg
argument_list|)
argument_list|,
name|cc_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle various cases of conditional move involving two constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value1
init|=
name|INTVAL
argument_list|(
name|src1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|value2
init|=
name|INTVAL
argument_list|(
name|src2
argument_list|)
decl_stmt|;
comment|/* having 0 as one of the constants can be done by loading the other          constant, and optionally moving in gr0.  */
if|if
condition|(
name|value1
operator|==
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|cr_mode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value2
operator|==
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_EQ
argument_list|(
name|cr_mode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the first value is within an addi range and also the difference          between the two fits in an addi's range, load up the difference, then          conditionally move in 0, and then unconditionally add the first 	 value.  */
elseif|else
if|if
condition|(
name|IN_RANGE_P
argument_list|(
name|value1
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
operator|&&
name|IN_RANGE_P
argument_list|(
name|value2
operator|-
name|value1
argument_list|,
operator|-
literal|2048
argument_list|,
literal|2047
argument_list|)
condition|)
block|{
name|rtx
name|dest_si
init|=
operator|(
operator|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SImode
operator|)
condition|?
name|dest
else|:
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|dest_si
argument_list|,
name|GEN_INT
argument_list|(
name|value2
operator|-
name|value1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|cr_mode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest_si
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dest_si
argument_list|,
name|dest_si
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Emit the conditional move for the test being true if needed.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|src1
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|cr_mode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the conditional move for the test being false if needed.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|src2
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_EQ
argument_list|(
name|cr_mode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finish up, return sequence.  */
name|ret
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split (set DEST SOURCE), where DEST is a double register and SOURCE is a    memory location that is not known to be dword-aligned.  */
end_comment

begin_function
name|void
name|frv_split_double_load
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|source
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|dest1
init|=
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|dest2
init|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|source
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If the address is pre-modified, load the lower-numbered register      first, then load the other register using an integer offset from      the modified base register.  This order should always be safe,      since the pre-modification cannot affect the same registers as the      load does.       The situation for other loads is more complicated.  Loading one      of the registers could affect the value of ADDRESS, so we must      be careful which order we do them in.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|address
argument_list|)
operator|==
name|PRE_MODIFY
operator|||
operator|!
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* It is safe to load the lower-numbered register first.  */
name|emit_move_insn
argument_list|(
name|dest1
argument_list|,
name|change_address
argument_list|(
name|source
argument_list|,
name|SImode
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest2
argument_list|,
name|frv_index_memory
argument_list|(
name|source
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ADDRESS is not pre-modified and the address depends on the          lower-numbered register.  Load the higher-numbered register          first.  */
name|emit_move_insn
argument_list|(
name|dest2
argument_list|,
name|frv_index_memory
argument_list|(
name|source
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest1
argument_list|,
name|change_address
argument_list|(
name|source
argument_list|,
name|SImode
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Split (set DEST SOURCE), where DEST refers to a dword memory location    and SOURCE is either a double register or the constant zero.  */
end_comment

begin_function
name|void
name|frv_split_double_store
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|source
decl_stmt|;
block|{
name|rtx
name|dest1
init|=
name|change_address
argument_list|(
name|dest
argument_list|,
name|SImode
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|rtx
name|dest2
init|=
name|frv_index_memory
argument_list|(
name|dest
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZERO_P
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|dest1
argument_list|,
name|CONST0_RTX
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest2
argument_list|,
name|CONST0_RTX
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|dest1
argument_list|,
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest2
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a min/max operation returning a SEQUENCE containing all of the    insns.  */
end_comment

begin_function
name|rtx
name|frv_split_minmax
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|minmax
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|src1
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|src2
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|operands
index|[
literal|4
index|]
decl_stmt|;
name|rtx
name|cr_reg
init|=
name|operands
index|[
literal|5
index|]
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|enum
name|rtx_code
name|test_code
decl_stmt|;
name|enum
name|machine_mode
name|cr_mode
init|=
name|GET_MODE
argument_list|(
name|cr_reg
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Figure out which test to use */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|minmax
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|SMIN
case|:
name|test_code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|test_code
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
name|test_code
operator|=
name|LTU
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|test_code
operator|=
name|GTU
expr_stmt|;
break|break;
block|}
comment|/* Issue the compare instruction.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the appropriate CCR bit.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cr_reg
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|test_code
argument_list|,
name|GET_MODE
argument_list|(
name|cr_reg
argument_list|)
argument_list|,
name|cc_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If are taking the min/max of a nonzero constant, load that first, and      then do a conditional move of the other value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|src2
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|src1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|cr_mode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, do each half of the move.  */
else|else
block|{
comment|/* Emit the conditional move for the test being true if needed.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|src1
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|cr_mode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the conditional move for the test being false if needed.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|src2
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_EQ
argument_list|(
name|cr_mode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finish up, return sequence.  */
name|ret
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split an integer abs operation returning a SEQUENCE containing all of the    insns.  */
end_comment

begin_function
name|rtx
name|frv_split_abs
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|cr_reg
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Issue the compare< 0 instruction.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|CCmode
argument_list|,
name|src
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the appropriate CCR bit.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cr_reg
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|LT
argument_list|,
name|CC_CCRmode
argument_list|,
name|cc_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the conditional negate if the value is negative */
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|CC_CCRmode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_negsi2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the conditional move for the test being false if needed.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_EQ
argument_list|(
name|CC_CCRmode
argument_list|,
name|cr_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finish up, return sequence.  */
name|ret
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* An internal function called by for_each_rtx to clear in a hard_reg set each    register used in an insn.  */
end_comment

begin_function
specifier|static
name|int
name|frv_clear_registers_used
parameter_list|(
name|ptr
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|ptr
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|ptr
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
operator|*
name|ptr
argument_list|)
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|p_regs
init|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|reg_max
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|reg_max
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
operator|*
name|p_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the extra fields provided by IFCVT_EXTRA_FIELDS.  */
end_comment

begin_comment
comment|/* On the FR-V, we don't have any extra fields per se, but it is useful hook to    initialize the static storage.  */
end_comment

begin_function
name|void
name|frv_ifcvt_init_extra_fields
parameter_list|(
name|ce_info
parameter_list|)
name|ce_if_block_t
modifier|*
name|ce_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|frv_ifcvt
operator|.
name|added_insns_list
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|cur_scratch_regs
operator|=
literal|0
expr_stmt|;
name|frv_ifcvt
operator|.
name|num_nested_cond_exec
operator|=
literal|0
expr_stmt|;
name|frv_ifcvt
operator|.
name|cr_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|nested_cc_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|extra_int_cr
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|extra_fp_cr
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|last_nested_if_cr
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal function to add a potenial insn to the list of insns to be inserted    if the conditional execution conversion is successful.  */
end_comment

begin_function
specifier|static
name|void
name|frv_ifcvt_add_insn
parameter_list|(
name|pattern
parameter_list|,
name|insn
parameter_list|,
name|before_p
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|before_p
decl_stmt|;
block|{
name|rtx
name|link
init|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|pattern
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|link
operator|->
name|jump
operator|=
name|before_p
expr_stmt|;
comment|/* mark to add this before or after insn */
name|frv_ifcvt
operator|.
name|added_insns_list
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|link
argument_list|,
name|frv_ifcvt
operator|.
name|added_insns_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_COND_EXEC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n:::::::::: frv_ifcvt_add_insn: add the following %s insn %d:\n"
argument_list|,
operator|(
name|before_p
operator|)
condition|?
literal|"before"
else|:
literal|"after"
argument_list|,
operator|(
name|int
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression to modify the code described by the conditional if    information CE_INFO, possibly updating the tests in TRUE_EXPR, and    FALSE_EXPR for converting if-then and if-then-else code to conditional    instructions.  Set either TRUE_EXPR or FALSE_EXPR to a null pointer if the    tests cannot be converted.  */
end_comment

begin_function
name|void
name|frv_ifcvt_modify_tests
parameter_list|(
name|ce_info
parameter_list|,
name|p_true
parameter_list|,
name|p_false
parameter_list|)
name|ce_if_block_t
modifier|*
name|ce_info
decl_stmt|;
name|rtx
modifier|*
name|p_true
decl_stmt|;
name|rtx
modifier|*
name|p_false
decl_stmt|;
block|{
name|basic_block
name|test_bb
init|=
name|ce_info
operator|->
name|test_bb
decl_stmt|;
comment|/* test basic block */
name|basic_block
name|then_bb
init|=
name|ce_info
operator|->
name|then_bb
decl_stmt|;
comment|/* THEN */
name|basic_block
name|else_bb
init|=
name|ce_info
operator|->
name|else_bb
decl_stmt|;
comment|/* ELSE or NULL */
name|basic_block
name|join_bb
init|=
name|ce_info
operator|->
name|join_bb
decl_stmt|;
comment|/* join block or NULL */
name|rtx
name|true_expr
init|=
operator|*
name|p_true
decl_stmt|;
name|rtx
name|cr
decl_stmt|;
name|rtx
name|cc
decl_stmt|;
name|rtx
name|nested_cc
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|true_expr
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
name|basic_block
modifier|*
name|bb
decl_stmt|;
name|int
name|num_bb
decl_stmt|;
name|frv_tmp_reg_t
modifier|*
name|tmp_reg
init|=
operator|&
name|frv_ifcvt
operator|.
name|tmp_reg
decl_stmt|;
name|rtx
name|check_insn
decl_stmt|;
name|rtx
name|sub_cond_exec_reg
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|rtx_code
name|code_true
decl_stmt|;
name|enum
name|rtx_code
name|code_false
decl_stmt|;
name|enum
name|reg_class
name|cc_class
decl_stmt|;
name|enum
name|reg_class
name|cr_class
decl_stmt|;
name|int
name|cc_first
decl_stmt|;
name|int
name|cc_last
decl_stmt|;
comment|/* Make sure we are only dealing with hard registers.  Also honor the      -mno-cond-exec switch, and -mno-nested-cond-exec switches if      applicable.  */
if|if
condition|(
operator|!
name|reload_completed
operator|||
name|TARGET_NO_COND_EXEC
operator|||
operator|(
name|TARGET_NO_NESTED_CE
operator|&&
name|ce_info
operator|->
name|pass
operator|>
literal|1
operator|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Figure out which registers we can allocate for our own purposes.  Only      consider registers that are not preserved across function calls and are      not fixed.  However, allow the ICC/ICR temporary registers to be allocated      if we did not need to use them in reloading other registers. */
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|tmp_reg
operator|->
name|regs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|)
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|ICC_TEMP
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|ICR_TEMP
argument_list|)
expr_stmt|;
comment|/* If this is a nested IF, we need to discover whether the CC registers that      are set/used inside of the block are used anywhere else.  If not, we can      change them to be the CC register that is paired with the CR register that      controls the outermost IF block.  */
if|if
condition|(
name|ce_info
operator|->
name|pass
operator|>
literal|1
condition|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|frv_ifcvt
operator|.
name|nested_cc_ok_rewrite
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|CC_FIRST
init|;
name|j
operator|<=
name|CC_LAST
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|then_bb
operator|->
name|global_live_at_start
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|else_bb
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|else_bb
operator|->
name|global_live_at_start
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|join_bb
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|join_bb
operator|->
name|global_live_at_start
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
name|SET_HARD_REG_BIT
argument_list|(
name|frv_ifcvt
operator|.
name|nested_cc_ok_rewrite
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|frv_ifcvt
operator|.
name|cur_scratch_regs
condition|;
name|j
operator|++
control|)
name|frv_ifcvt
operator|.
name|scratch_regs
index|[
name|j
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|added_insns_list
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|cur_scratch_regs
operator|=
literal|0
expr_stmt|;
name|bb
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|alloca
argument_list|(
operator|(
literal|2
operator|+
name|ce_info
operator|->
name|num_multiple_test_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_bb
condition|)
block|{
name|int
name|regno
decl_stmt|;
comment|/* Remove anything live at the beginning of the join block from being          available for allocation.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|join_bb->global_live_at_start
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|{ 				   if (regno< FIRST_PSEUDO_REGISTER) 				     CLEAR_HARD_REG_BIT (tmp_reg->regs, regno); 				 }
argument_list|)
empty_stmt|;
block|}
comment|/* Add in all of the blocks in multiple&&/|| blocks to be scanned.  */
name|num_bb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ce_info
operator|->
name|num_multiple_test_blocks
condition|)
block|{
name|basic_block
name|multiple_test_bb
init|=
name|ce_info
operator|->
name|last_test_bb
decl_stmt|;
while|while
condition|(
name|multiple_test_bb
operator|!=
name|test_bb
condition|)
block|{
name|bb
index|[
name|num_bb
operator|++
index|]
operator|=
name|multiple_test_bb
expr_stmt|;
name|multiple_test_bb
operator|=
name|multiple_test_bb
operator|->
name|pred
operator|->
name|src
expr_stmt|;
block|}
block|}
comment|/* Add in the THEN and ELSE blocks to be scanned.  */
name|bb
index|[
name|num_bb
operator|++
index|]
operator|=
name|then_bb
expr_stmt|;
if|if
condition|(
name|else_bb
condition|)
name|bb
index|[
name|num_bb
operator|++
index|]
operator|=
name|else_bb
expr_stmt|;
name|sub_cond_exec_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|num_nested_cond_exec
operator|=
literal|0
expr_stmt|;
comment|/* Scan all of the blocks for registers that must not be allocated.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_bb
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|last_insn
init|=
name|bb
index|[
name|j
index|]
operator|->
name|end
decl_stmt|;
name|rtx
name|insn
init|=
name|bb
index|[
name|j
index|]
operator|->
name|head
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Scanning %s block %d, start %d, end %d\n"
argument_list|,
operator|(
name|bb
index|[
name|j
index|]
operator|==
name|else_bb
operator|)
condition|?
literal|"else"
else|:
operator|(
operator|(
name|bb
index|[
name|j
index|]
operator|==
name|then_bb
operator|)
condition|?
literal|"then"
else|:
literal|"test"
operator|)
argument_list|,
operator|(
name|int
operator|)
name|bb
index|[
name|j
index|]
operator|->
name|index
argument_list|,
operator|(
name|int
operator|)
name|INSN_UID
argument_list|(
name|bb
index|[
name|j
index|]
operator|->
name|head
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|INSN_UID
argument_list|(
name|bb
index|[
name|j
index|]
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Anything live at the beginning of the block is obviously unavailable          for allocation.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|bb[j]->global_live_at_start
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|{ 				   if (regno< FIRST_PSEUDO_REGISTER) 				     CLEAR_HARD_REG_BIT (tmp_reg->regs, regno); 				 }
argument_list|)
empty_stmt|;
comment|/* loop through the insns in the block.  */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Mark any new registers that are created as being unavailable for              allocation.  Also see if the CC register used in nested IFs can be              reallocated.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pattern
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|skip_nested_if
init|=
name|FALSE
decl_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|frv_clear_registers_used
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp_reg
operator|->
name|regs
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|COND_EXEC
condition|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
name|sub_cond_exec_reg
condition|)
block|{
name|sub_cond_exec_reg
operator|=
name|reg
expr_stmt|;
name|frv_ifcvt
operator|.
name|num_nested_cond_exec
operator|++
expr_stmt|;
block|}
block|}
name|set
operator|=
name|single_set_pattern
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|src_code
init|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|CC_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|src_code
operator|==
name|COMPARE
condition|)
name|skip_nested_if
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|CR_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|(
name|src_code
operator|==
name|IF_THEN_ELSE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|src_code
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
name|skip_nested_if
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skip_nested_if
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|frv_clear_registers_used
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|frv_ifcvt
operator|.
name|nested_cc_ok_rewrite
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|last_insn
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a nested if, rewrite the CC registers that are available to      include the ones that can be rewritten, to increase the chance of being      able to allocate a paired CC/CR register combination.  */
if|if
condition|(
name|ce_info
operator|->
name|pass
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
name|CC_FIRST
init|;
name|j
operator|<=
name|CC_LAST
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|frv_ifcvt
operator|.
name|nested_cc_ok_rewrite
argument_list|,
name|j
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|j
argument_list|)
expr_stmt|;
else|else
name|CLEAR_HARD_REG_BIT
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|int
name|num_gprs
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Available GPRs: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|GPR_FIRST
init|;
name|j
operator|<=
name|GPR_LAST
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" %d [%s]"
argument_list|,
name|j
argument_list|,
name|reg_names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|num_gprs
operator|>
name|GPR_TEMP_NUM
operator|+
literal|2
condition|)
break|break;
block|}
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%s\nAvailable CRs:  "
argument_list|,
operator|(
name|num_gprs
operator|>
name|GPR_TEMP_NUM
operator|+
literal|2
operator|)
condition|?
literal|" ..."
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|CR_FIRST
init|;
name|j
operator|<=
name|CR_LAST
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" %d [%s]"
argument_list|,
name|j
argument_list|,
name|reg_names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce_info
operator|->
name|pass
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Modifiable CCs: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|CC_FIRST
init|;
name|j
operator|<=
name|CC_LAST
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|tmp_reg
operator|->
name|regs
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" %d [%s]"
argument_list|,
name|j
argument_list|,
name|reg_names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n%d nested COND_EXEC statements\n"
argument_list|,
name|frv_ifcvt
operator|.
name|num_nested_cond_exec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate the appropriate temporary condition code register.  Try to      allocate the ICR/FCR register that corresponds to the ICC/FCC register so      that conditional cmp's can be done.  */
if|if
condition|(
name|mode
operator|==
name|CCmode
operator|||
name|mode
operator|==
name|CC_UNSmode
condition|)
block|{
name|cr_class
operator|=
name|ICR_REGS
expr_stmt|;
name|cc_class
operator|=
name|ICC_REGS
expr_stmt|;
name|cc_first
operator|=
name|ICC_FIRST
expr_stmt|;
name|cc_last
operator|=
name|ICC_LAST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CC_FPmode
condition|)
block|{
name|cr_class
operator|=
name|FCR_REGS
expr_stmt|;
name|cc_class
operator|=
name|FCC_REGS
expr_stmt|;
name|cc_first
operator|=
name|FCC_FIRST
expr_stmt|;
name|cc_last
operator|=
name|FCC_LAST
expr_stmt|;
block|}
else|else
block|{
name|cc_first
operator|=
name|cc_last
operator|=
literal|0
expr_stmt|;
name|cr_class
operator|=
name|cc_class
operator|=
name|NO_REGS
expr_stmt|;
block|}
name|cc
operator|=
name|XEXP
argument_list|(
name|true_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nested_cc
operator|=
name|cr
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|cc_class
operator|!=
name|NO_REGS
condition|)
block|{
comment|/* For nested IFs and&&/||, see if we can find a CC and CR register pair          so we can execute a csubcc/caddcc/cfcmps instruction.  */
name|int
name|cc_regno
decl_stmt|;
for|for
control|(
name|cc_regno
operator|=
name|cc_first
init|;
name|cc_regno
operator|<=
name|cc_last
condition|;
name|cc_regno
operator|++
control|)
block|{
name|int
name|cr_regno
init|=
name|cc_regno
operator|-
name|CC_FIRST
operator|+
name|CR_FIRST
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|frv_ifcvt
operator|.
name|tmp_reg
operator|.
name|regs
argument_list|,
name|cc_regno
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|frv_ifcvt
operator|.
name|tmp_reg
operator|.
name|regs
argument_list|,
name|cr_regno
argument_list|)
condition|)
block|{
name|frv_ifcvt
operator|.
name|tmp_reg
operator|.
name|next_reg
index|[
operator|(
name|int
operator|)
name|cr_class
index|]
operator|=
name|cr_regno
expr_stmt|;
name|cr
operator|=
name|frv_alloc_temp_reg
argument_list|(
name|tmp_reg
argument_list|,
name|cr_class
argument_list|,
name|CC_CCRmode
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|frv_ifcvt
operator|.
name|tmp_reg
operator|.
name|next_reg
index|[
operator|(
name|int
operator|)
name|cc_class
index|]
operator|=
name|cc_regno
expr_stmt|;
name|nested_cc
operator|=
name|frv_alloc_temp_reg
argument_list|(
name|tmp_reg
argument_list|,
name|cc_class
argument_list|,
name|CCmode
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|cr
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Could not allocate a CR temporary register\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Will use %s for conditional execution, %s for nested comparisons\n"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|cr
argument_list|)
index|]
argument_list|,
operator|(
name|nested_cc
operator|)
condition|?
name|reg_names
index|[
name|REGNO
argument_list|(
name|nested_cc
argument_list|)
index|]
else|:
literal|"<none>"
argument_list|)
expr_stmt|;
comment|/* Set the CCR bit.  Note for integer tests, we reverse the condition so that      in an IF-THEN-ELSE sequence, we are testing the TRUE case against the CCR      bit being true.  We don't do this for floating point, because of NaNs.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|true_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|cc
argument_list|)
operator|!=
name|CC_FPmode
condition|)
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code_true
operator|=
name|EQ
expr_stmt|;
name|code_false
operator|=
name|NE
expr_stmt|;
block|}
else|else
block|{
name|code_true
operator|=
name|NE
expr_stmt|;
name|code_false
operator|=
name|EQ
expr_stmt|;
block|}
name|check_insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cr
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|CC_CCRmode
argument_list|,
name|cc
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the check insn to be inserted later.  */
name|frv_ifcvt_add_insn
argument_list|(
name|check_insn
argument_list|,
name|test_bb
operator|->
name|end
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Update the tests.  */
name|frv_ifcvt
operator|.
name|cr_reg
operator|=
name|cr
expr_stmt|;
name|frv_ifcvt
operator|.
name|nested_cc_reg
operator|=
name|nested_cc
expr_stmt|;
operator|*
name|p_true
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code_true
argument_list|,
name|CC_CCRmode
argument_list|,
name|cr
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
operator|*
name|p_false
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code_false
argument_list|,
name|CC_CCRmode
argument_list|,
name|cr
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return;
comment|/* Fail, don't do this conditional execution.  */
name|fail
label|:
operator|*
name|p_true
operator|=
name|NULL_RTX
expr_stmt|;
operator|*
name|p_false
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Disabling this conditional execution.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression to modify the code described by the conditional if    information CE_INFO, for the basic block BB, possibly updating the tests in    TRUE_EXPR, and FALSE_EXPR for converting the&& and || parts of if-then or    if-then-else code to conditional instructions.  Set either TRUE_EXPR or    FALSE_EXPR to a null pointer if the tests cannot be converted.  */
end_comment

begin_comment
comment|/* p_true and p_false are given expressions of the form:  	(and (eq:CC_CCR (reg:CC_CCR) 			(const_int 0)) 	     (eq:CC (reg:CC) 		    (const_int 0))) */
end_comment

begin_function
name|void
name|frv_ifcvt_modify_multiple_tests
parameter_list|(
name|ce_info
parameter_list|,
name|bb
parameter_list|,
name|p_true
parameter_list|,
name|p_false
parameter_list|)
name|ce_if_block_t
modifier|*
name|ce_info
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
modifier|*
name|p_true
decl_stmt|;
name|rtx
modifier|*
name|p_false
decl_stmt|;
block|{
name|rtx
name|old_true
init|=
name|XEXP
argument_list|(
operator|*
name|p_true
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|old_false
init|=
name|XEXP
argument_list|(
operator|*
name|p_false
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|true_expr
init|=
name|XEXP
argument_list|(
operator|*
name|p_true
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|false_expr
init|=
name|XEXP
argument_list|(
operator|*
name|p_false
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|test_expr
decl_stmt|;
name|rtx
name|old_test
decl_stmt|;
name|rtx
name|cr
init|=
name|XEXP
argument_list|(
name|old_true
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|check_insn
decl_stmt|;
name|rtx
name|new_cr
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
modifier|*
name|p_new_cr
init|=
operator|(
name|rtx
operator|*
operator|)
literal|0
decl_stmt|;
name|rtx
name|if_else
decl_stmt|;
name|rtx
name|compare
decl_stmt|;
name|rtx
name|cc
decl_stmt|;
name|enum
name|reg_class
name|cr_class
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|true_expr
argument_list|)
decl_stmt|;
name|rtx
function_decl|(
modifier|*
name|logical_func
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
if|if
condition|(
name|TARGET_DEBUG_COND_EXEC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n:::::::::: frv_ifcvt_modify_multiple_tests, before modification for %s\ntrue insn:\n"
argument_list|,
name|ce_info
operator|->
name|and_and_p
condition|?
literal|"&&"
else|:
literal|"||"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
operator|*
name|p_true
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\nfalse insn:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
operator|*
name|p_false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_NO_MULTI_CE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cr
argument_list|)
operator|!=
name|REG
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|mode
operator|==
name|CCmode
operator|||
name|mode
operator|==
name|CC_UNSmode
condition|)
block|{
name|cr_class
operator|=
name|ICR_REGS
expr_stmt|;
name|p_new_cr
operator|=
operator|&
name|frv_ifcvt
operator|.
name|extra_int_cr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CC_FPmode
condition|)
block|{
name|cr_class
operator|=
name|FCR_REGS
expr_stmt|;
name|p_new_cr
operator|=
operator|&
name|frv_ifcvt
operator|.
name|extra_fp_cr
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
comment|/* Allocate a temp CR, reusing a previously allocated temp CR if we have 3 or      more&&/|| tests.  */
name|new_cr
operator|=
operator|*
name|p_new_cr
expr_stmt|;
if|if
condition|(
operator|!
name|new_cr
condition|)
block|{
name|new_cr
operator|=
operator|*
name|p_new_cr
operator|=
name|frv_alloc_temp_reg
argument_list|(
operator|&
name|frv_ifcvt
operator|.
name|tmp_reg
argument_list|,
name|cr_class
argument_list|,
name|CC_CCRmode
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_cr
condition|)
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ce_info
operator|->
name|and_and_p
condition|)
block|{
name|old_test
operator|=
name|old_false
expr_stmt|;
name|test_expr
operator|=
name|true_expr
expr_stmt|;
name|logical_func
operator|=
operator|(
name|GET_CODE
argument_list|(
name|old_true
argument_list|)
operator|==
name|EQ
operator|)
condition|?
name|gen_andcr
else|:
name|gen_andncr
expr_stmt|;
operator|*
name|p_true
operator|=
name|gen_rtx_NE
argument_list|(
name|CC_CCRmode
argument_list|,
name|cr
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
operator|*
name|p_false
operator|=
name|gen_rtx_EQ
argument_list|(
name|CC_CCRmode
argument_list|,
name|cr
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old_test
operator|=
name|old_false
expr_stmt|;
name|test_expr
operator|=
name|false_expr
expr_stmt|;
name|logical_func
operator|=
operator|(
name|GET_CODE
argument_list|(
name|old_false
argument_list|)
operator|==
name|EQ
operator|)
condition|?
name|gen_orcr
else|:
name|gen_orncr
expr_stmt|;
operator|*
name|p_true
operator|=
name|gen_rtx_EQ
argument_list|(
name|CC_CCRmode
argument_list|,
name|cr
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
operator|*
name|p_false
operator|=
name|gen_rtx_NE
argument_list|(
name|CC_CCRmode
argument_list|,
name|cr
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* First add the andcr/andncr/orcr/orncr, which will be added after the      conditional check instruction, due to frv_ifcvt_add_insn being a LIFO      stack.  */
name|frv_ifcvt_add_insn
argument_list|(
call|(
modifier|*
name|logical_func
call|)
argument_list|(
name|cr
argument_list|,
name|cr
argument_list|,
name|new_cr
argument_list|)
argument_list|,
name|bb
operator|->
name|end
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Now add the conditional check insn.  */
name|cc
operator|=
name|XEXP
argument_list|(
name|test_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compare
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|test_expr
argument_list|)
argument_list|,
name|CC_CCRmode
argument_list|,
name|cc
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|if_else
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|CC_CCRmode
argument_list|,
name|old_test
argument_list|,
name|compare
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|check_insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_cr
argument_list|,
name|if_else
argument_list|)
expr_stmt|;
comment|/* add the new check insn to the list of check insns that need to be      inserted.  */
name|frv_ifcvt_add_insn
argument_list|(
name|check_insn
argument_list|,
name|bb
operator|->
name|end
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_COND_EXEC
condition|)
block|{
name|fputs
argument_list|(
literal|"\n:::::::::: frv_ifcvt_modify_multiple_tests, after modification\ntrue insn:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
operator|*
name|p_true
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\nfalse insn:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
operator|*
name|p_false
argument_list|)
expr_stmt|;
block|}
return|return;
name|fail
label|:
operator|*
name|p_true
operator|=
operator|*
name|p_false
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If we allocated a CR register, release it. */
if|if
condition|(
name|new_cr
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|frv_ifcvt
operator|.
name|tmp_reg
operator|.
name|regs
argument_list|,
name|REGNO
argument_list|(
name|new_cr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_new_cr
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_DEBUG_COND_EXEC
condition|)
name|fputs
argument_list|(
literal|"\n:::::::::: frv_ifcvt_modify_multiple_tests, failed.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a register which will be loaded with a value if an IF block is    converted to conditional execution.  This is used to rewrite instructions    that use constants to ones that just use registers.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_ifcvt_load_value
parameter_list|(
name|value
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|value
decl_stmt|;
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|num_alloc
init|=
name|frv_ifcvt
operator|.
name|cur_scratch_regs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
comment|/* We know gr0 == 0, so replace any errant uses.  */
if|if
condition|(
name|value
operator|==
name|const0_rtx
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GPR_FIRST
argument_list|)
return|;
comment|/* First search all registers currently loaded to see if we have an      applicable constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|value
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|value
argument_list|)
operator|==
name|LR_REGNO
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_alloc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|frv_ifcvt
operator|.
name|scratch_regs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|SET_DEST
argument_list|(
name|frv_ifcvt
operator|.
name|scratch_regs
index|[
name|i
index|]
argument_list|)
return|;
block|}
block|}
comment|/* Have we exhausted the number of registers available? */
if|if
condition|(
name|num_alloc
operator|>=
name|GPR_TEMP_NUM
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Too many temporary registers allocated\n"
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Allocate the new register.  */
name|reg
operator|=
name|frv_alloc_temp_reg
argument_list|(
operator|&
name|frv_ifcvt
operator|.
name|tmp_reg
argument_list|,
name|GPR_REGS
argument_list|,
name|SImode
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fputs
argument_list|(
literal|"Could not find a scratch register\n"
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
name|frv_ifcvt
operator|.
name|cur_scratch_regs
operator|++
expr_stmt|;
name|frv_ifcvt
operator|.
name|scratch_regs
index|[
name|num_alloc
index|]
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Register %s will hold %ld\n"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
argument_list|,
operator|(
name|long
operator|)
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|value
argument_list|)
operator|==
name|LR_REGNO
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Register %s will hold LR\n"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Register %s will hold a saved value\n"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update a MEM used in conditional code that might contain an offset to put    the offset into a scratch register, so that the conditional load/store    operations can be used.  This function returns the original pointer if the    MEM is valid to use in conditional code, NULL if we can't load up the offset    into a temporary register, or the new MEM if we were successful.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_ifcvt_rewrite_mem
parameter_list|(
name|mem
parameter_list|,
name|mode
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|frv_legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|reload_completed
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|addr_op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|addr_op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|plus_small_data_p
argument_list|(
name|addr_op0
argument_list|,
name|addr_op1
argument_list|)
condition|)
name|addr
operator|=
name|frv_ifcvt_load_value
argument_list|(
name|addr
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr_op0
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|addr_op1
argument_list|)
condition|)
block|{
name|rtx
name|reg
init|=
name|frv_ifcvt_load_value
argument_list|(
name|addr_op1
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
return|return
name|NULL_RTX
return|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr_op0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|frv_ifcvt_load_value
argument_list|(
name|addr
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|addr
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
operator|!=
name|addr
condition|)
return|return
name|change_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
return|;
block|}
return|return
name|mem
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a PATTERN, return a SET expression if this PATTERN has only a single    SET, possibly conditionally executed.  It may also have CLOBBERs, USEs.  */
end_comment

begin_function
specifier|static
name|rtx
name|single_set_pattern
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|pattern
operator|=
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
return|return
name|pattern
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|set
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
break|break;
case|case
name|SET
case|:
if|if
condition|(
name|set
condition|)
return|return
literal|0
return|;
else|else
name|set
operator|=
name|sub
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
name|set
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression to modify the code described by the conditional if    information CE_INFO with the new PATTERN in INSN.  If PATTERN is a null    pointer after the IFCVT_MODIFY_INSN macro executes, it is assumed that that    insn cannot be converted to be executed conditionally.  */
end_comment

begin_function
name|rtx
name|frv_ifcvt_modify_insn
parameter_list|(
name|ce_info
parameter_list|,
name|pattern
parameter_list|,
name|insn
parameter_list|)
name|ce_if_block_t
modifier|*
name|ce_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|orig_ce_pattern
init|=
name|pattern
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|rtx
name|test
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|!=
name|COND_EXEC
condition|)
name|abort
argument_list|()
expr_stmt|;
name|test
operator|=
name|COND_EXEC_TEST
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
operator|==
name|AND
condition|)
block|{
name|rtx
name|cr
init|=
name|frv_ifcvt
operator|.
name|cr_reg
decl_stmt|;
name|rtx
name|test_reg
decl_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|cr
argument_list|,
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|op1
operator|=
name|XEXP
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|test_reg
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|test_reg
argument_list|)
operator|!=
name|REG
condition|)
goto|goto
name|fail
goto|;
comment|/* Is this the first nested if block in this sequence?  If so, generate          an andcr or andncr.  */
if|if
condition|(
operator|!
name|frv_ifcvt
operator|.
name|last_nested_if_cr
condition|)
block|{
name|rtx
name|and_op
decl_stmt|;
name|frv_ifcvt
operator|.
name|last_nested_if_cr
operator|=
name|test_reg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NE
condition|)
name|and_op
operator|=
name|gen_andcr
argument_list|(
name|test_reg
argument_list|,
name|cr
argument_list|,
name|test_reg
argument_list|)
expr_stmt|;
else|else
name|and_op
operator|=
name|gen_andncr
argument_list|(
name|test_reg
argument_list|,
name|cr
argument_list|,
name|test_reg
argument_list|)
expr_stmt|;
name|frv_ifcvt_add_insn
argument_list|(
name|and_op
argument_list|,
name|insn
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* If this isn't the first statement in the nested if sequence, see if we          are dealing with the same register.  */
elseif|else
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|test_reg
argument_list|,
name|frv_ifcvt
operator|.
name|last_nested_if_cr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|COND_EXEC_TEST
argument_list|(
name|pattern
argument_list|)
operator|=
name|test
operator|=
name|op1
expr_stmt|;
block|}
comment|/* If this isn't a nested if, reset state variables.  */
else|else
block|{
name|frv_ifcvt
operator|.
name|last_nested_if_cr
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|set
operator|=
name|single_set_pattern
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* Check for normal binary operators */
if|if
condition|(
name|mode
operator|==
name|SImode
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Special case load of small data address which looks like: 	     r16+symbol_ref */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|plus_small_data_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|src
operator|=
name|frv_ifcvt_load_value
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
condition|)
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
goto|goto
name|fail
goto|;
block|}
elseif|else
if|if
condition|(
name|integer_register_operand
argument_list|(
name|op0
argument_list|,
name|SImode
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|op1
operator|=
name|frv_ifcvt_load_value
argument_list|(
name|op1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* For multiply by a constant, we need to handle the sign extending          correctly.  Add a USE of the value after the multiply to prevent flow          from cratering because only one register out of the two were used.  */
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|op0
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|frv_ifcvt_load_value
argument_list|(
name|op1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
block|{
name|op1
operator|=
name|gen_rtx_SIGN_EXTEND
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
block|}
name|frv_ifcvt_add_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|)
argument_list|,
name|insn
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* If we are just loading a constant created for a nested conditional          execution statement, just load the constant without any conditional          execution, since we know that the constant will not interfere with any          other registers.  */
elseif|else
if|if
condition|(
name|frv_ifcvt
operator|.
name|scratch_insns_bitmap
operator|&&
name|bitmap_bit_p
argument_list|(
name|frv_ifcvt
operator|.
name|scratch_insns_bitmap
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|pattern
operator|=
name|set
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|SFmode
condition|)
block|{
name|int
name|changed_p
init|=
name|FALSE
decl_stmt|;
comment|/* Check for just loading up a constant */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|&&
name|integer_register_operand
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|src
operator|=
name|frv_ifcvt_load_value
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|src
condition|)
goto|goto
name|fail
goto|;
name|changed_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* See if we need to fix up stores */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|new_mem
init|=
name|frv_ifcvt_rewrite_mem
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new_mem
condition|)
goto|goto
name|fail
goto|;
elseif|else
if|if
condition|(
name|new_mem
operator|!=
name|dest
condition|)
block|{
name|changed_p
operator|=
name|TRUE
expr_stmt|;
name|dest
operator|=
name|new_mem
expr_stmt|;
block|}
block|}
comment|/* See if we need to fix up loads */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|new_mem
init|=
name|frv_ifcvt_rewrite_mem
argument_list|(
name|src
argument_list|,
name|mode
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new_mem
condition|)
goto|goto
name|fail
goto|;
elseif|else
if|if
condition|(
name|new_mem
operator|!=
name|src
condition|)
block|{
name|changed_p
operator|=
name|TRUE
expr_stmt|;
name|src
operator|=
name|new_mem
expr_stmt|;
block|}
block|}
comment|/* If either src or destination changed, redo SET.  */
if|if
condition|(
name|changed_p
condition|)
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Rewrite a nested set cccr in terms of IF_THEN_ELSE.  Also deal with          rewriting the CC register to be the same as the paired CC/CR register          for nested ifs.  */
elseif|else
if|if
condition|(
name|mode
operator|==
name|CC_CCRmode
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|if_else
decl_stmt|;
if|if
condition|(
name|ce_info
operator|->
name|pass
operator|>
literal|1
operator|&&
name|regno
operator|!=
operator|(
name|int
operator|)
name|REGNO
argument_list|(
name|frv_ifcvt
operator|.
name|nested_cc_reg
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|frv_ifcvt
operator|.
name|nested_cc_ok_rewrite
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|src
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|CC_CCRmode
argument_list|,
name|frv_ifcvt
operator|.
name|nested_cc_reg
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|if_else
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|CC_CCRmode
argument_list|,
name|test
argument_list|,
name|src
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|if_else
argument_list|)
expr_stmt|;
block|}
comment|/* Remap a nested compare instruction to use the paired CC/CR reg.  */
elseif|else
if|if
condition|(
name|ce_info
operator|->
name|pass
operator|>
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|CC_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|frv_ifcvt
operator|.
name|nested_cc_reg
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|frv_ifcvt
operator|.
name|nested_cc_ok_rewrite
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|PUT_MODE
argument_list|(
name|frv_ifcvt
operator|.
name|nested_cc_reg
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|frv_ifcvt
operator|.
name|nested_cc_reg
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_COND_EXEC
condition|)
block|{
name|rtx
name|orig_pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n:::::::::: frv_ifcvt_modify_insn: pass = %d, insn after modification:\n"
argument_list|,
name|ce_info
operator|->
name|pass
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|orig_pattern
expr_stmt|;
block|}
return|return
name|pattern
return|;
name|fail
label|:
if|if
condition|(
name|TARGET_DEBUG_COND_EXEC
condition|)
block|{
name|rtx
name|orig_pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|orig_ce_pattern
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n:::::::::: frv_ifcvt_modify_insn: pass = %d, insn could not be modified:\n"
argument_list|,
name|ce_info
operator|->
name|pass
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|orig_pattern
expr_stmt|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression to perform any final machine dependent modifications in    converting code to conditional execution in the code described by the    conditional if information CE_INFO.  */
end_comment

begin_function
name|void
name|frv_ifcvt_modify_final
parameter_list|(
name|ce_info
parameter_list|)
name|ce_if_block_t
modifier|*
name|ce_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|existing_insn
decl_stmt|;
name|rtx
name|check_insn
decl_stmt|;
name|rtx
name|p
init|=
name|frv_ifcvt
operator|.
name|added_insns_list
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Loop inserting the check insns.  The last check insn is the first test,      and is the appropriate place to insert constants.  */
if|if
condition|(
operator|!
name|p
condition|)
name|abort
argument_list|()
expr_stmt|;
do|do
block|{
name|rtx
name|check_and_insert_insns
init|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|old_p
init|=
name|p
decl_stmt|;
name|check_insn
operator|=
name|XEXP
argument_list|(
name|check_and_insert_insns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|existing_insn
operator|=
name|XEXP
argument_list|(
name|check_and_insert_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The jump bit is used to say that the new insn is to be inserted BEFORE          the existing insn, otherwise it is to be inserted AFTER.  */
if|if
condition|(
name|check_and_insert_insns
operator|->
name|jump
condition|)
block|{
name|emit_insn_before
argument_list|(
name|check_insn
argument_list|,
name|existing_insn
argument_list|)
expr_stmt|;
name|check_and_insert_insns
operator|->
name|jump
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|emit_insn_after
argument_list|(
name|check_insn
argument_list|,
name|existing_insn
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|check_and_insert_insns
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|old_p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|NULL_RTX
condition|)
do|;
comment|/* Load up any constants needed into temp gprs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|frv_ifcvt
operator|.
name|cur_scratch_regs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|emit_insn_before
argument_list|(
name|frv_ifcvt
operator|.
name|scratch_regs
index|[
name|i
index|]
argument_list|,
name|existing_insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|frv_ifcvt
operator|.
name|scratch_insns_bitmap
condition|)
name|frv_ifcvt
operator|.
name|scratch_insns_bitmap
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|frv_ifcvt
operator|.
name|scratch_insns_bitmap
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|frv_ifcvt
operator|.
name|scratch_regs
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|frv_ifcvt
operator|.
name|added_insns_list
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|cur_scratch_regs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression to cancel any machine dependent modifications in converting    code to conditional execution in the code described by the conditional if    information CE_INFO.  */
end_comment

begin_function
name|void
name|frv_ifcvt_modify_cancel
parameter_list|(
name|ce_info
parameter_list|)
name|ce_if_block_t
modifier|*
name|ce_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|p
init|=
name|frv_ifcvt
operator|.
name|added_insns_list
decl_stmt|;
comment|/* Loop freeing up the EXPR_LIST's allocated.  */
while|while
condition|(
name|p
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|check_and_jump
init|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|old_p
init|=
name|p
decl_stmt|;
name|p
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|check_and_jump
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|old_p
argument_list|)
expr_stmt|;
block|}
comment|/* Release any temporary gprs allocated.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|frv_ifcvt
operator|.
name|cur_scratch_regs
condition|;
name|i
operator|++
control|)
name|frv_ifcvt
operator|.
name|scratch_regs
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|added_insns_list
operator|=
name|NULL_RTX
expr_stmt|;
name|frv_ifcvt
operator|.
name|cur_scratch_regs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression for the size in bytes of the trampoline, as an integer.    The template is:  	setlo #0,<jmp_reg> 	setlo #0,<static_chain> 	sethi #0,<jmp_reg> 	sethi #0,<static_chain> 	jmpl @(gr0,<jmp_reg>) */
end_comment

begin_function
name|int
name|frv_trampoline_size
parameter_list|()
block|{
return|return
literal|5
comment|/* instructions */
operator|*
literal|4
comment|/* instruction size */
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C statement to initialize the variable parts of a trampoline.  ADDR is an    RTX for the address of the trampoline; FNADDR is an RTX for the address of    the nested function; STATIC_CHAIN is an RTX for the static chain value that    should be passed to the function when it is called.     The template is:  	setlo #0,<jmp_reg> 	setlo #0,<static_chain> 	sethi #0,<jmp_reg> 	sethi #0,<static_chain> 	jmpl @(gr0,<jmp_reg>) */
end_comment

begin_function
name|void
name|frv_initialize_trampoline
parameter_list|(
name|addr
parameter_list|,
name|fnaddr
parameter_list|,
name|static_chain
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|rtx
name|fnaddr
decl_stmt|;
name|rtx
name|static_chain
decl_stmt|;
block|{
name|rtx
name|sc_reg
init|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|static_chain
argument_list|)
decl_stmt|;
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|SImode
argument_list|,
literal|"__trampoline_setup"
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|,
name|addr
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|frv_trampoline_size
argument_list|()
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|fnaddr
argument_list|,
name|Pmode
argument_list|,
name|sc_reg
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Many machines have some registers that cannot be copied directly to or from    memory or even from other types of registers.  An example is the `MQ'    register, which on most machines, can only be copied to or from general    registers, but not memory.  Some machines allow copying all registers to and    from memory, but require a scratch register for stores to some memory    locations (e.g., those with symbolic address on the RT, and those with    certain symbolic address on the SPARC when compiling PIC).  In some cases,    both an intermediate and a scratch register are required.     You should define these macros to indicate to the reload phase that it may    need to allocate at least one register for a reload in addition to the    register to contain the data.  Specifically, if copying X to a register    CLASS in MODE requires an intermediate register, you should define    `SECONDARY_INPUT_RELOAD_CLASS' to return the largest register class all of    whose registers can be used as intermediate registers or scratch registers.     If copying a register CLASS in MODE to X requires an intermediate or scratch    register, `SECONDARY_OUTPUT_RELOAD_CLASS' should be defined to return the    largest register class required.  If the requirements for input and output    reloads are the same, the macro `SECONDARY_RELOAD_CLASS' should be used    instead of defining both macros identically.     The values returned by these macros are often `GENERAL_REGS'.  Return    `NO_REGS' if no spare register is needed; i.e., if X can be directly copied    to or from a register of CLASS in MODE without requiring a scratch register.    Do not define this macro if it would always return `NO_REGS'.     If a scratch register is required (either with or without an intermediate    register), you should define patterns for `reload_inM' or `reload_outM', as    required..  These patterns, which will normally be implemented with a    `define_expand', should be similar to the `movM' patterns, except that    operand 2 is the scratch register.     Define constraints for the reload register and scratch register that contain    a single register class.  If the original reload register (whose class is    CLASS) can meet the constraint given in the pattern, the value returned by    these macros is used for the class of the scratch register.  Otherwise, two    additional reload registers are required.  Their classes are obtained from    the constraints in the insn pattern.     X might be a pseudo-register or a `subreg' of a pseudo-register, which could    either be in a hard register or in memory.  Use `true_regnum' to find out;    it will return -1 if the pseudo is in memory and the hard register number if    it is in a register.     These macros should not be used in the case where a particular class of    registers can only be copied to memory and not to another class of    registers.  In that case, secondary reload registers are not needed and    would not be helpful.  Instead, a stack location must be used to perform the    copy and the `movM' pattern should use memory as an intermediate storage.    This case often occurs between floating-point and general registers.  */
end_comment

begin_function
name|enum
name|reg_class
name|frv_secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|x
parameter_list|,
name|in_p
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|in_p
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|reg_class
name|ret
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
default|default:
name|ret
operator|=
name|NO_REGS
expr_stmt|;
break|break;
comment|/* Accumulators/Accumulator guard registers need to go through floating          point registers.  */
case|case
name|QUAD_REGS
case|:
case|case
name|EVEN_REGS
case|:
case|case
name|GPR_REGS
case|:
name|ret
operator|=
name|NO_REGS
expr_stmt|;
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|ACC_P
argument_list|(
name|regno
argument_list|)
operator|||
name|ACCG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|ret
operator|=
name|FPR_REGS
expr_stmt|;
block|}
break|break;
comment|/* Nonzero constants should be loaded into an FPR through a GPR.  */
case|case
name|QUAD_FPR_REGS
case|:
case|case
name|FEVEN_REGS
case|:
case|case
name|FPR_REGS
case|:
if|if
condition|(
name|x
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|ZERO_P
argument_list|(
name|x
argument_list|)
condition|)
name|ret
operator|=
name|GPR_REGS
expr_stmt|;
else|else
name|ret
operator|=
name|NO_REGS
expr_stmt|;
break|break;
comment|/* All of these types need gpr registers.  */
case|case
name|ICC_REGS
case|:
case|case
name|FCC_REGS
case|:
case|case
name|CC_REGS
case|:
case|case
name|ICR_REGS
case|:
case|case
name|FCR_REGS
case|:
case|case
name|CR_REGS
case|:
case|case
name|LCR_REG
case|:
case|case
name|LR_REG
case|:
name|ret
operator|=
name|GPR_REGS
expr_stmt|;
break|break;
comment|/* The accumulators need fpr registers */
case|case
name|ACC_REGS
case|:
case|case
name|EVEN_ACC_REGS
case|:
case|case
name|QUAD_ACC_REGS
case|:
case|case
name|ACCG_REGS
case|:
name|ret
operator|=
name|FPR_REGS
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression whose value is nonzero if pseudos that have been assigned to    registers of class CLASS would likely be spilled because registers of CLASS    are needed for spill registers.     The default value of this macro returns 1 if CLASS has exactly one register    and zero otherwise.  On most machines, this default should be used.  Only    define this macro to some other expression if pseudo allocated by    `local-alloc.c' end up in memory because their hard registers were needed    for spill registers.  If this macro returns nonzero for those classes, those    pseudos will only be allocated by `global.c', which knows how to reallocate    the pseudo to another register.  If there would not be another register    available for reallocation, you should not change the definition of this    macro since the only effect of such a definition would be to slow down    register allocation.  */
end_comment

begin_function
name|int
name|frv_class_likely_spilled_p
parameter_list|(
name|class
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
switch|switch
condition|(
name|class
condition|)
block|{
default|default:
break|break;
case|case
name|ICC_REGS
case|:
case|case
name|FCC_REGS
case|:
case|case
name|CC_REGS
case|:
case|case
name|ICR_REGS
case|:
case|case
name|FCR_REGS
case|:
case|case
name|CR_REGS
case|:
case|case
name|LCR_REG
case|:
case|case
name|LR_REG
case|:
case|case
name|SPR_REGS
case|:
case|case
name|QUAD_ACC_REGS
case|:
case|case
name|EVEN_ACC_REGS
case|:
case|case
name|ACC_REGS
case|:
case|case
name|ACCG_REGS
case|:
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* An expression for the alignment of a structure field FIELD if the    alignment computed in the usual way is COMPUTED.  GNU CC uses this    value instead of the value in `BIGGEST_ALIGNMENT' or    `BIGGEST_FIELD_ALIGNMENT', if defined, for structure fields only.  */
end_comment

begin_comment
comment|/* The definition type of the bit field data is either char, short, long or    long long. The maximum bit size is the number of bits of its own type.     The bit field data is assigned to a storage unit that has an adequate size    for bit field data retention and is located at the smallest address.     Consecutive bit field data are packed at consecutive bits having the same    storage unit, with regard to the type, beginning with the MSB and continuing    toward the LSB.     If a field to be assigned lies over a bit field type boundary, its    assignment is completed by aligning it with a boundary suitable for the    type.     When a bit field having a bit length of 0 is declared, it is forcibly    assigned to the next storage unit.     e.g) 	struct { 		int	a:2; 		int	b:6; 		char	c:4; 		int	d:10; 		int	 :0; 		int	f:2; 	} x;  		+0	  +1	    +2	      +3&x	00000000  00000000  00000000  00000000 		MLM----L 		a    b&x+4	00000000  00000000  00000000  00000000 		M--L 		c&x+8	00000000  00000000  00000000  00000000 		M----------L 		d&x+12	00000000  00000000  00000000  00000000 		ML 		f */
end_comment

begin_function
name|int
name|frv_adjust_field_align
parameter_list|(
name|field
parameter_list|,
name|computed
parameter_list|)
name|tree
name|field
decl_stmt|;
name|int
name|computed
decl_stmt|;
block|{
comment|/* C++ provides a null DECL_CONTEXT if the bit field is wider than its      type.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|tree
name|parent
init|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|prev
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|cur
decl_stmt|;
comment|/* Loop finding the previous field to the current one */
for|for
control|(
name|cur
operator|=
name|TYPE_FIELDS
argument_list|(
name|parent
argument_list|)
init|;
name|cur
operator|&&
name|cur
operator|!=
name|field
condition|;
name|cur
operator|=
name|TREE_CHAIN
argument_list|(
name|cur
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|prev
operator|=
name|cur
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cur
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this isn't a :0 field and if the previous element is a bitfield 	 also, see if the type is different, if so, we will need to align the 	 bit-field to the next boundary */
if|if
condition|(
name|prev
operator|&&
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|!=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|int
name|prev_align
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|prev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|cur_align
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|computed
operator|=
operator|(
name|prev_align
operator|>
name|cur_align
operator|)
condition|?
name|prev_align
else|:
name|cur_align
expr_stmt|;
block|}
block|}
return|return
name|computed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression that is nonzero if it is permissible to store a value of mode    MODE in hard register number REGNO (or in several registers starting with    that one).  For a machine where all registers are equivalent, a suitable    definition is          #define HARD_REGNO_MODE_OK(REGNO, MODE) 1     It is not necessary for this macro to check for the numbers of fixed    registers, because the allocation mechanism considers them to be always    occupied.     On some machines, double-precision values must be kept in even/odd register    pairs.  The way to implement that is to define this macro to reject odd    register numbers for such modes.     The minimum requirement for a mode to be OK in a register is that the    `movMODE' instruction pattern support moves between the register and any    other hard register for which the mode is OK; and that moving a value into    the register and back out not alter it.     Since the same instruction used to move `SImode' will work for all narrower    integer modes, it is not necessary on any machine for `HARD_REGNO_MODE_OK'    to distinguish between these modes, provided you define patterns `movhi',    etc., to take advantage of this.  This is useful because of the interaction    between `HARD_REGNO_MODE_OK' and `MODES_TIEABLE_P'; it is very desirable for    all integer modes to be tieable.     Many machines have special registers for floating point arithmetic.  Often    people assume that floating point machine modes are allowed only in floating    point registers.  This is not true.  Any registers that can hold integers    can safely *hold* a floating point machine mode, whether or not floating    arithmetic can be done on it in those registers.  Integer move instructions    can be used to move the values.     On some machines, though, the converse is true: fixed-point machine modes    may not go in floating registers.  This is true if the floating registers    normalize any value stored in them, because storing a non-floating value    there would garble it.  In this case, `HARD_REGNO_MODE_OK' should reject    fixed-point machine modes in floating registers.  But if the floating    registers do not automatically normalize, if you can store any bit pattern    in one and retrieve it unchanged without a trap, then any machine mode may    go in a floating register, so you can define this macro to say so.     The primary significance of special floating registers is rather that they    are the registers acceptable in floating point arithmetic instructions.    However, this is of no concern to `HARD_REGNO_MODE_OK'.  You handle it by    writing the proper constraints for those instructions.     On some machines, the floating registers are especially slow to access, so    that it is better to store a value in a stack frame than in such a register    if floating point arithmetic is not being done.  As long as the floating    registers are not in class `GENERAL_REGS', they will not be used unless some    pattern's constraint asks for one.  */
end_comment

begin_function
name|int
name|frv_hard_regno_mode_ok
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|base
decl_stmt|;
name|int
name|mask
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CCmode
case|:
case|case
name|CC_UNSmode
case|:
return|return
name|ICC_P
argument_list|(
name|regno
argument_list|)
operator|||
name|GPR_P
argument_list|(
name|regno
argument_list|)
return|;
case|case
name|CC_CCRmode
case|:
return|return
name|CR_P
argument_list|(
name|regno
argument_list|)
operator|||
name|GPR_P
argument_list|(
name|regno
argument_list|)
return|;
case|case
name|CC_FPmode
case|:
return|return
name|FCC_P
argument_list|(
name|regno
argument_list|)
operator|||
name|GPR_P
argument_list|(
name|regno
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* Set BASE to the first register in REGNO's class.  Set MASK to the      bits that must be clear in (REGNO - BASE) for the register to be      well-aligned.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|ACCG_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* ACCGs store one byte.  Two-byte quantities must start in 	     even-numbered registers, four-byte ones in registers whose 	     numbers are divisible by four, and so on.  */
name|base
operator|=
name|ACCG_FIRST
expr_stmt|;
name|mask
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* The other registers store one word.  */
if|if
condition|(
name|GPR_P
argument_list|(
name|regno
argument_list|)
condition|)
name|base
operator|=
name|GPR_FIRST
expr_stmt|;
elseif|else
if|if
condition|(
name|FPR_P
argument_list|(
name|regno
argument_list|)
condition|)
name|base
operator|=
name|FPR_FIRST
expr_stmt|;
elseif|else
if|if
condition|(
name|ACC_P
argument_list|(
name|regno
argument_list|)
condition|)
name|base
operator|=
name|ACC_FIRST
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Anything smaller than an SI is OK in any word-sized register.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
literal|4
condition|)
return|return
literal|1
return|;
name|mask
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|4
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|(
name|regno
operator|-
name|base
operator|)
operator|&
name|mask
operator|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression for the number of consecutive hard registers, starting at    register number REGNO, required to hold a value of mode MODE.     On a machine where all registers are exactly one word, a suitable definition    of this macro is          #define HARD_REGNO_NREGS(REGNO, MODE)            \            ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \             / UNITS_PER_WORD))  */
end_comment

begin_comment
comment|/* On the FRV, make the CC_FP mode take 3 words in the integer registers, so    that we can build the appropriate instructions to properly reload the    values.  Also, make the byte-sized accumulator guards use one guard    for each byte.  */
end_comment

begin_function
name|int
name|frv_hard_regno_nregs
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|ACCG_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
else|else
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression for the maximum number of consecutive registers of    class CLASS needed to hold a value of mode MODE.     This is closely related to the macro `HARD_REGNO_NREGS'.  In fact, the value    of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be the maximum value of    `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO values in the class CLASS.     This macro helps control the handling of multiple-word values in    the reload pass.     This declaration is required.  */
end_comment

begin_function
name|int
name|frv_class_max_nregs
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|class
operator|==
name|ACCG_REGS
condition|)
comment|/* An N-byte value requires N accumulator guards.  */
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
else|else
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression that is nonzero if X is a legitimate constant for an    immediate operand on the target machine.  You can assume that X satisfies    `CONSTANT_P', so you need not check this.  In fact, `1' is a suitable    definition for this macro on machines where anything `CONSTANT_P' is valid.  */
end_comment

begin_function
name|int
name|frv_legitimate_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* All of the integer constants are ok */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
return|return
name|TRUE
return|;
comment|/* double integer constants are ok */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|DImode
condition|)
return|return
name|TRUE
return|;
comment|/* 0 is always ok */
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* If floating point is just emulated, allow any constant, since it will be      constructed in the GPRs */
if|if
condition|(
operator|!
name|TARGET_HAS_FPRS
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|&&
operator|!
name|TARGET_DOUBLE
condition|)
return|return
name|TRUE
return|;
comment|/* Otherwise store the constant away and do a load.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression for the cost of moving data from a register in class FROM to    one in class TO.  The classes are expressed using the enumeration values    such as `GENERAL_REGS'.  A value of 4 is the default; other values are    interpreted relative to that.     It is not required that the cost always equal 2 when FROM is the same as TO;    on some machines it is expensive to move between registers if they are not    general registers.     If reload sees an insn consisting of a single `set' between two hard    registers, and if `REGISTER_MOVE_COST' applied to their classes returns a    value of 2, reload does not check to ensure that the constraints of the insn    are met.  Setting a cost of other than 2 will allow reload to verify that    the constraints are met.  You should do this if the `movM' pattern's    constraints do not allow such copying.  */
end_comment

begin_define
define|#
directive|define
name|HIGH_COST
value|40
end_define

begin_define
define|#
directive|define
name|MEDIUM_COST
value|3
end_define

begin_define
define|#
directive|define
name|LOW_COST
value|1
end_define

begin_function
name|int
name|frv_register_move_cost
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|enum
name|reg_class
name|from
decl_stmt|;
name|enum
name|reg_class
name|to
decl_stmt|;
block|{
switch|switch
condition|(
name|from
condition|)
block|{
default|default:
break|break;
case|case
name|QUAD_REGS
case|:
case|case
name|EVEN_REGS
case|:
case|case
name|GPR_REGS
case|:
switch|switch
condition|(
name|to
condition|)
block|{
default|default:
break|break;
case|case
name|QUAD_REGS
case|:
case|case
name|EVEN_REGS
case|:
case|case
name|GPR_REGS
case|:
return|return
name|LOW_COST
return|;
case|case
name|FEVEN_REGS
case|:
case|case
name|FPR_REGS
case|:
return|return
name|LOW_COST
return|;
case|case
name|LCR_REG
case|:
case|case
name|LR_REG
case|:
case|case
name|SPR_REGS
case|:
return|return
name|LOW_COST
return|;
block|}
case|case
name|FEVEN_REGS
case|:
case|case
name|FPR_REGS
case|:
switch|switch
condition|(
name|to
condition|)
block|{
default|default:
break|break;
case|case
name|QUAD_REGS
case|:
case|case
name|EVEN_REGS
case|:
case|case
name|GPR_REGS
case|:
case|case
name|ACC_REGS
case|:
case|case
name|EVEN_ACC_REGS
case|:
case|case
name|QUAD_ACC_REGS
case|:
case|case
name|ACCG_REGS
case|:
return|return
name|MEDIUM_COST
return|;
case|case
name|FEVEN_REGS
case|:
case|case
name|FPR_REGS
case|:
return|return
name|LOW_COST
return|;
block|}
case|case
name|LCR_REG
case|:
case|case
name|LR_REG
case|:
case|case
name|SPR_REGS
case|:
switch|switch
condition|(
name|to
condition|)
block|{
default|default:
break|break;
case|case
name|QUAD_REGS
case|:
case|case
name|EVEN_REGS
case|:
case|case
name|GPR_REGS
case|:
return|return
name|MEDIUM_COST
return|;
block|}
case|case
name|ACC_REGS
case|:
case|case
name|EVEN_ACC_REGS
case|:
case|case
name|QUAD_ACC_REGS
case|:
case|case
name|ACCG_REGS
case|:
switch|switch
condition|(
name|to
condition|)
block|{
default|default:
break|break;
case|case
name|FEVEN_REGS
case|:
case|case
name|FPR_REGS
case|:
return|return
name|MEDIUM_COST
return|;
block|}
block|}
return|return
name|HIGH_COST
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implementation of TARGET_ASM_INTEGER.  In the FRV case we need to    use ".picptr" to generate safe relocations for PIC code.  We also    need a fixup entry for aligned (non-debugging) code.  */
end_comment

begin_function
specifier|static
name|bool
name|frv_assemble_integer
parameter_list|(
name|value
parameter_list|,
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|rtx
name|value
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|aligned_p
decl_stmt|;
block|{
if|if
condition|(
name|flag_pic
operator|&&
name|size
operator|==
name|UNITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|aligned_p
condition|)
block|{
specifier|static
name|int
name|label_num
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCP"
argument_list|,
name|label_num
operator|++
argument_list|)
expr_stmt|;
name|p
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s:\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|FIXUP_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.picptr\t%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.previous\n"
argument_list|)
expr_stmt|;
block|}
name|assemble_integer_with_op
argument_list|(
literal|"\t.picptr\t"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|aligned_p
condition|)
block|{
comment|/* We've set the unaligned SI op to NULL, so we always have to 	     handle the unaligned case here.  */
name|assemble_integer_with_op
argument_list|(
literal|"\t.4byte\t"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|default_assemble_integer
argument_list|(
name|value
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function to set up the backend function structure.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|frv_init_machine_status
parameter_list|()
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the register state information, to know about which registers are set    or clobbered.  */
end_comment

begin_function
specifier|static
name|void
name|frv_registers_update
parameter_list|(
name|x
parameter_list|,
name|reg_state
parameter_list|,
name|modified
parameter_list|,
name|p_num_mod
parameter_list|,
name|flag
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|char
name|reg_state
index|[]
decl_stmt|;
name|int
name|modified
index|[]
decl_stmt|;
name|int
modifier|*
name|p_num_mod
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|reg_max
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
break|break;
comment|/* Clobber just modifies a register, it doesn't make it live.  */
case|case
name|CLOBBER
case|:
name|frv_registers_update
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modified
argument_list|,
name|p_num_mod
argument_list|,
name|flag
operator||
name|REGSTATE_MODIFIED
argument_list|)
expr_stmt|;
return|return;
comment|/* Pre modify updates the first argument, just references the second.  */
case|case
name|PRE_MODIFY
case|:
case|case
name|SET
case|:
name|frv_registers_update
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modified
argument_list|,
name|p_num_mod
argument_list|,
name|flag
operator||
name|REGSTATE_MODIFIED
operator||
name|REGSTATE_LIVE
argument_list|)
expr_stmt|;
name|frv_registers_update
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modified
argument_list|,
name|p_num_mod
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return;
comment|/* For COND_EXEC, pass the appropriate flag to evaluate the conditional          statement, but just to be sure, make sure it is the type of cond_exec          we expect.  */
case|case
name|COND_EXEC
case|:
name|cond
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CR_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|flag
operator|&
operator|(
name|REGSTATE_MODIFIED
operator||
name|REGSTATE_IF_EITHER
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|frv_registers_update
argument_list|(
name|cond
argument_list|,
name|reg_state
argument_list|,
name|modified
argument_list|,
name|p_num_mod
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|flag
operator||=
operator|(
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
name|CR_FIRST
operator|)
operator||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
operator|)
condition|?
name|REGSTATE_IF_TRUE
else|:
name|REGSTATE_IF_FALSE
operator|)
operator|)
expr_stmt|;
name|frv_registers_update
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modified
argument_list|,
name|p_num_mod
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|fatal_insn
argument_list|(
literal|"frv_registers_update"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* MEM resets the modification bits.  */
case|case
name|MEM
case|:
name|flag
operator|&=
operator|~
name|REGSTATE_MODIFIED
expr_stmt|;
break|break;
comment|/* See if we need to set the modified flag.  */
case|case
name|SUBREG
case|:
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_max
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|reg_common
goto|;
block|}
break|break;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_max
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fall through */
name|reg_common
label|:
if|if
condition|(
name|flag
operator|&
name|REGSTATE_MODIFIED
condition|)
block|{
name|flag
operator|&=
name|REGSTATE_MASK
expr_stmt|;
while|while
condition|(
name|regno
operator|<
name|reg_max
condition|)
block|{
name|int
name|rs
init|=
name|reg_state
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|flag
operator|!=
name|rs
condition|)
block|{
if|if
condition|(
operator|(
name|rs
operator|&
name|REGSTATE_MODIFIED
operator|)
operator|==
literal|0
condition|)
block|{
name|modified
index|[
operator|*
name|p_num_mod
index|]
operator|=
name|regno
expr_stmt|;
operator|(
operator|*
name|p_num_mod
operator|)
operator|++
expr_stmt|;
block|}
comment|/* If the previous register state had the register as                      modified, possibly in some conditional execution context,                      and the current insn modifies in some other context, or                      outside of conditional execution, just mark the variable                      as modified.  */
else|else
name|flag
operator|&=
operator|~
operator|(
name|REGSTATE_IF_EITHER
operator||
name|REGSTATE_CC_MASK
operator|)
expr_stmt|;
name|reg_state
index|[
name|regno
index|]
operator|=
operator|(
name|rs
operator||
name|flag
operator|)
expr_stmt|;
block|}
name|regno
operator|++
expr_stmt|;
block|}
block|}
return|return;
block|}
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
operator|++
name|j
control|)
block|{
switch|switch
condition|(
name|format
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|frv_registers_update
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modified
argument_list|,
name|p_num_mod
argument_list|,
name|flag
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
condition|;
operator|++
name|k
control|)
name|frv_registers_update
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modified
argument_list|,
name|p_num_mod
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Nothing to do.  */
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return if any registers in a hard register set were used an insn.  */
end_comment

begin_function
specifier|static
name|int
name|frv_registers_used_p
parameter_list|(
name|x
parameter_list|,
name|reg_state
parameter_list|,
name|flag
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|char
name|reg_state
index|[]
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|reg_max
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
break|break;
comment|/* Skip clobber, that doesn't use the previous value */
case|case
name|CLOBBER
case|:
return|return
name|FALSE
return|;
comment|/* For SET, if a conditional jump has occurred in the same insn, only 	 allow a set of a CR register if that register is not currently live. 	 This is because on the FR-V, B0/B1 instructions are always last. 	 Otherwise, don't look at the result, except within a MEM, but do look 	 at the source.  */
case|case
name|SET
case|:
name|dest
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|REGSTATE_CONDJUMP
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|CR_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
operator|(
name|reg_state
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|&
name|REGSTATE_LIVE
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|result
operator|=
name|frv_registers_used_p
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
return|return
name|frv_registers_used_p
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|flag
argument_list|)
return|;
comment|/* For COND_EXEC, pass the appropriate flag to evaluate the conditional          statement, but just to be sure, make sure it is the type of cond_exec          we expect.  */
case|case
name|COND_EXEC
case|:
name|cond
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CR_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|flag
operator|&
operator|(
name|REGSTATE_MODIFIED
operator||
name|REGSTATE_IF_EITHER
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|frv_registers_used_p
argument_list|(
name|cond
argument_list|,
name|reg_state
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|flag
operator||=
operator|(
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
name|CR_FIRST
operator|)
operator||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
operator|)
condition|?
name|REGSTATE_IF_TRUE
else|:
name|REGSTATE_IF_FALSE
operator|)
operator|)
expr_stmt|;
return|return
name|frv_registers_used_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|flag
argument_list|)
return|;
block|}
else|else
name|fatal_insn
argument_list|(
literal|"frv_registers_used_p"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* See if a register or subreg was modified in the same VLIW insn.  */
case|case
name|SUBREG
case|:
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_max
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|reg_common
goto|;
block|}
break|break;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_max
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fall through */
name|reg_common
label|:
while|while
condition|(
name|regno
operator|<
name|reg_max
condition|)
block|{
name|int
name|rs
init|=
name|reg_state
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|rs
operator|&
name|REGSTATE_MODIFIED
condition|)
block|{
name|int
name|rs_if
init|=
name|rs
operator|&
name|REGSTATE_IF_EITHER
decl_stmt|;
name|int
name|flag_if
init|=
name|flag
operator|&
name|REGSTATE_IF_EITHER
decl_stmt|;
comment|/* Simple modification, no conditional execution */
if|if
condition|(
operator|(
name|rs
operator|&
name|REGSTATE_IF_EITHER
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* See if the variable is only modified in a conditional 		 execution expression opposite to the conditional execution 		 expression that governs this expression (ie, true vs. false 		 for the same CC register).  If this isn't two halves of the 		 same conditional expression, consider the register 		 modified. */
if|if
condition|(
operator|(
operator|(
name|rs_if
operator|==
name|REGSTATE_IF_TRUE
operator|&&
name|flag_if
operator|==
name|REGSTATE_IF_FALSE
operator|)
operator|||
operator|(
name|rs_if
operator|==
name|REGSTATE_IF_FALSE
operator|&&
name|flag_if
operator|==
name|REGSTATE_IF_TRUE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|rs
operator|&
name|REGSTATE_CC_MASK
operator|)
operator|==
operator|(
name|flag
operator|&
name|REGSTATE_CC_MASK
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
name|TRUE
return|;
block|}
name|regno
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
operator|++
name|j
control|)
block|{
switch|switch
condition|(
name|format
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|result
operator|=
name|frv_registers_used_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
condition|;
operator|++
name|k
control|)
block|{
name|result
operator|=
name|frv_registers_used_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
block|}
break|break;
default|default:
comment|/* Nothing to do.  */
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return if any registers in a hard register set were set in an insn.  */
end_comment

begin_function
specifier|static
name|int
name|frv_registers_set_p
parameter_list|(
name|x
parameter_list|,
name|reg_state
parameter_list|,
name|modify_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|char
name|reg_state
index|[]
decl_stmt|;
name|int
name|modify_p
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|reg_max
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|CLOBBER
case|:
return|return
name|frv_registers_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|TRUE
argument_list|)
return|;
case|case
name|PRE_MODIFY
case|:
case|case
name|SET
case|:
return|return
operator|(
name|frv_registers_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|TRUE
argument_list|)
operator|||
name|frv_registers_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
case|case
name|COND_EXEC
case|:
name|cond
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just to be sure, make sure it is the type of cond_exec we          expect.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CR_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|modify_p
condition|)
return|return
name|frv_registers_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modify_p
argument_list|)
return|;
else|else
name|fatal_insn
argument_list|(
literal|"frv_registers_set_p"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* MEM resets the modification bits.  */
case|case
name|MEM
case|:
name|modify_p
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* See if we need to set the modified modify_p.  */
case|case
name|SUBREG
case|:
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_max
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|reg_common
goto|;
block|}
break|break;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reg_max
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fall through */
name|reg_common
label|:
if|if
condition|(
name|modify_p
condition|)
while|while
condition|(
name|regno
operator|<
name|reg_max
condition|)
block|{
name|int
name|rs
init|=
name|reg_state
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|rs
operator|&
name|REGSTATE_MODIFIED
condition|)
return|return
name|TRUE
return|;
name|regno
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
name|length
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|length
condition|;
operator|++
name|j
control|)
block|{
switch|switch
condition|(
name|format
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|frv_registers_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modify_p
argument_list|)
condition|)
return|return
name|TRUE
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|frv_registers_set_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modify_p
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
break|break;
default|default:
comment|/* Nothing to do.  */
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In rare cases, correct code generation requires extra machine dependent    processing between the second jump optimization pass and delayed branch    scheduling.  On those machines, define this macro as a C statement to act on    the code starting at INSN.  */
end_comment

begin_comment
comment|/* On the FR-V, this pass is used to rescan the insn chain, and pack    conditional branches/calls/jumps, etc. with previous insns where it can.  It    does not reorder the instructions.  We assume the scheduler left the flow    information in a reasonable state.  */
end_comment

begin_function
specifier|static
name|void
name|frv_pack_insns
parameter_list|()
block|{
name|state_t
name|frv_state
decl_stmt|;
comment|/* frv state machine */
name|int
name|cur_start_vliw_p
decl_stmt|;
comment|/* current insn starts a VLIW insn */
name|int
name|next_start_vliw_p
decl_stmt|;
comment|/* next insn starts a VLIW insn */
name|int
name|cur_condjump_p
decl_stmt|;
comment|/* flag if current insn is a cond jump*/
name|int
name|next_condjump_p
decl_stmt|;
comment|/* flag if next insn is a cond jump */
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|num_mod
init|=
literal|0
decl_stmt|;
comment|/* # of modified registers */
name|int
name|modified
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
comment|/* registers modified in current VLIW */
comment|/* register state information */
name|unsigned
name|char
name|reg_state
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
comment|/* If we weren't going to pack the insns, don't bother with this pass.  */
if|if
condition|(
operator|!
name|optimize
operator|||
operator|!
name|flag_schedule_insns_after_reload
operator|||
name|TARGET_NO_VLIW_BRANCH
condition|)
return|return;
switch|switch
condition|(
name|frv_cpu_type
condition|)
block|{
default|default:
case|case
name|FRV_CPU_FR300
case|:
comment|/* FR300/simple are single issue */
case|case
name|FRV_CPU_SIMPLE
case|:
return|return;
case|case
name|FRV_CPU_GENERIC
case|:
comment|/* FR-V and FR500 are multi-issue */
case|case
name|FRV_CPU_FR400
case|:
case|case
name|FRV_CPU_FR500
case|:
case|case
name|FRV_CPU_TOMCAT
case|:
break|break;
block|}
comment|/* Set up the instruction and register states.  */
name|dfa_start
argument_list|()
expr_stmt|;
name|frv_state
operator|=
operator|(
name|state_t
operator|)
name|xmalloc
argument_list|(
name|state_size
argument_list|()
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|reg_state
argument_list|,
name|REGSTATE_DEAD
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go through the insns, and repack the insns.  */
name|state_reset
argument_list|(
name|frv_state
argument_list|)
expr_stmt|;
name|cur_start_vliw_p
operator|=
name|FALSE
expr_stmt|;
name|next_start_vliw_p
operator|=
name|TRUE
expr_stmt|;
name|cur_condjump_p
operator|=
literal|0
expr_stmt|;
name|next_condjump_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|pattern_code
decl_stmt|;
comment|/* For basic block begin notes redo the live information, and skip other          notes.  */
if|if
condition|(
name|code
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
operator|(
name|int
operator|)
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
name|regset
name|live
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
name|reg_state
index|[
name|j
index|]
operator|&=
operator|~
name|REGSTATE_LIVE
expr_stmt|;
name|live
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|insn
argument_list|)
operator|->
name|global_live_at_start
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|live
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 					  reg_state[j] |= REGSTATE_LIVE; 					}
argument_list|)
empty_stmt|;
block|}
continue|continue;
block|}
comment|/* things like labels reset everything.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'i'
condition|)
block|{
name|next_start_vliw_p
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* Clear the VLIW start flag on random USE and CLOBBER insns, which is          set on the USE insn that preceeds the return, and potentially on          CLOBBERs for setting multiword variables.  Also skip the ADDR_VEC          holding the case table labels.  */
name|pattern_code
operator|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_code
operator|==
name|USE
operator|||
name|pattern_code
operator|==
name|CLOBBER
operator|||
name|pattern_code
operator|==
name|ADDR_VEC
operator|||
name|pattern_code
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|CLEAR_VLIW_START
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cur_start_vliw_p
operator|=
name|next_start_vliw_p
expr_stmt|;
name|next_start_vliw_p
operator|=
name|FALSE
expr_stmt|;
name|cur_condjump_p
operator||=
name|next_condjump_p
expr_stmt|;
name|next_condjump_p
operator|=
literal|0
expr_stmt|;
comment|/* Unconditional branches and calls end the current VLIW insn.  */
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
block|{
name|next_start_vliw_p
operator|=
name|TRUE
expr_stmt|;
comment|/* On a TOMCAT, calls must be alone in the VLIW insns.  */
if|if
condition|(
name|frv_cpu_type
operator|==
name|FRV_CPU_TOMCAT
condition|)
name|cur_start_vliw_p
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|next_condjump_p
operator|=
name|REGSTATE_CONDJUMP
expr_stmt|;
else|else
name|next_start_vliw_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Only allow setting a CCR register after a conditional branch.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|cur_condjump_p
operator|&
name|REGSTATE_CONDJUMP
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|!=
name|TYPE_CCR
condition|)
name|cur_start_vliw_p
operator|=
name|TRUE
expr_stmt|;
comment|/* Determine if we need to start a new VLIW instruction.  */
if|if
condition|(
name|cur_start_vliw_p
comment|/* Do not check for register conflicts in a setlo instruction 	     because any output or true dependencies will be with the 	     partnering sethi instruction, with which it can be packed.  	     Although output dependencies are rare they are still 	     possible.  So check output dependencies in VLIW insn. */
operator|||
operator|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|!=
name|TYPE_SETLO
operator|&&
operator|(
name|frv_registers_used_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|cur_condjump_p
argument_list|)
operator|||
name|frv_registers_set_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|)
operator|||
name|state_transition
argument_list|(
name|frv_state
argument_list|,
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SET_VLIW_START
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|state_reset
argument_list|(
name|frv_state
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|frv_state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|cur_condjump_p
operator|=
literal|0
expr_stmt|;
comment|/* Update the modified registers.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_mod
condition|;
name|j
operator|++
control|)
name|reg_state
index|[
name|modified
index|[
name|j
index|]
index|]
operator|&=
operator|~
operator|(
name|REGSTATE_CC_MASK
operator||
name|REGSTATE_IF_EITHER
operator||
name|REGSTATE_MODIFIED
operator|)
expr_stmt|;
name|num_mod
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|CLEAR_VLIW_START
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Record which registers are modified.  */
name|frv_registers_update
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_state
argument_list|,
name|modified
argument_list|,
operator|&
name|num_mod
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Process the death notices */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
name|NULL_RTX
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|regno
operator|<
name|n
condition|;
name|regno
operator|++
control|)
name|reg_state
index|[
name|regno
index|]
operator|&=
operator|~
name|REGSTATE_LIVE
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|frv_state
argument_list|)
expr_stmt|;
name|dfa_finish
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|def_builtin
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|)
define|\
value|builtin_function ((name), (type), (code), BUILT_IN_MD, NULL, NULL)
end_define

begin_struct
struct|struct
name|builtin_description
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|frv_builtins
name|code
decl_stmt|;
name|enum
name|rtx_code
name|comparison
decl_stmt|;
name|unsigned
name|int
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Media intrinsics that take a single, constant argument.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_set
index|[]
init|=
block|{
block|{
name|CODE_FOR_mhdsets
block|,
literal|"__MHDSETS"
block|,
name|FRV_BUILTIN_MHDSETS
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Media intrinsics that take just one argument. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
block|{
name|CODE_FOR_mnot
block|,
literal|"__MNOT"
block|,
name|FRV_BUILTIN_MNOT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_munpackh
block|,
literal|"__MUNPACKH"
block|,
name|FRV_BUILTIN_MUNPACKH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mbtoh
block|,
literal|"__MBTOH"
block|,
name|FRV_BUILTIN_MBTOH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mhtob
block|,
literal|"__MHTOB"
block|,
name|FRV_BUILTIN_MHTOB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mabshs
block|,
literal|"__MABSHS"
block|,
name|FRV_BUILTIN_MABSHS
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Media intrinsics that take two arguments. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
block|{
name|CODE_FOR_mand
block|,
literal|"__MAND"
block|,
name|FRV_BUILTIN_MAND
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mor
block|,
literal|"__MOR"
block|,
name|FRV_BUILTIN_MOR
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mxor
block|,
literal|"__MXOR"
block|,
name|FRV_BUILTIN_MXOR
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_maveh
block|,
literal|"__MAVEH"
block|,
name|FRV_BUILTIN_MAVEH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_msaths
block|,
literal|"__MSATHS"
block|,
name|FRV_BUILTIN_MSATHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_msathu
block|,
literal|"__MSATHU"
block|,
name|FRV_BUILTIN_MSATHU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_maddhss
block|,
literal|"__MADDHSS"
block|,
name|FRV_BUILTIN_MADDHSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_maddhus
block|,
literal|"__MADDHUS"
block|,
name|FRV_BUILTIN_MADDHUS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_msubhss
block|,
literal|"__MSUBHSS"
block|,
name|FRV_BUILTIN_MSUBHSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_msubhus
block|,
literal|"__MSUBHUS"
block|,
name|FRV_BUILTIN_MSUBHUS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqaddhss
block|,
literal|"__MQADDHSS"
block|,
name|FRV_BUILTIN_MQADDHSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqaddhus
block|,
literal|"__MQADDHUS"
block|,
name|FRV_BUILTIN_MQADDHUS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqsubhss
block|,
literal|"__MQSUBHSS"
block|,
name|FRV_BUILTIN_MQSUBHSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqsubhus
block|,
literal|"__MQSUBHUS"
block|,
name|FRV_BUILTIN_MQSUBHUS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mpackh
block|,
literal|"__MPACKH"
block|,
name|FRV_BUILTIN_MPACKH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mdpackh
block|,
literal|"__MDPACKH"
block|,
name|FRV_BUILTIN_MDPACKH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mcop1
block|,
literal|"__Mcop1"
block|,
name|FRV_BUILTIN_MCOP1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mcop2
block|,
literal|"__Mcop2"
block|,
name|FRV_BUILTIN_MCOP2
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mwcut
block|,
literal|"__MWCUT"
block|,
name|FRV_BUILTIN_MWCUT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqsaths
block|,
literal|"__MQSATHS"
block|,
name|FRV_BUILTIN_MQSATHS
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Media intrinsics that take two arguments, the first being an ACC number.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_cut
index|[]
init|=
block|{
block|{
name|CODE_FOR_mcut
block|,
literal|"__MCUT"
block|,
name|FRV_BUILTIN_MCUT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mcutss
block|,
literal|"__MCUTSS"
block|,
name|FRV_BUILTIN_MCUTSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mdcutssi
block|,
literal|"__MDCUTSSI"
block|,
name|FRV_BUILTIN_MDCUTSSI
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two-argument media intrinsics with an immediate second argument. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_2argimm
index|[]
init|=
block|{
block|{
name|CODE_FOR_mrotli
block|,
literal|"__MROTLI"
block|,
name|FRV_BUILTIN_MROTLI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mrotri
block|,
literal|"__MROTRI"
block|,
name|FRV_BUILTIN_MROTRI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_msllhi
block|,
literal|"__MSLLHI"
block|,
name|FRV_BUILTIN_MSLLHI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_msrlhi
block|,
literal|"__MSRLHI"
block|,
name|FRV_BUILTIN_MSRLHI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_msrahi
block|,
literal|"__MSRAHI"
block|,
name|FRV_BUILTIN_MSRAHI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mexpdhw
block|,
literal|"__MEXPDHW"
block|,
name|FRV_BUILTIN_MEXPDHW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mexpdhd
block|,
literal|"__MEXPDHD"
block|,
name|FRV_BUILTIN_MEXPDHD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mdrotli
block|,
literal|"__MDROTLI"
block|,
name|FRV_BUILTIN_MDROTLI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mcplhi
block|,
literal|"__MCPLHI"
block|,
name|FRV_BUILTIN_MCPLHI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mcpli
block|,
literal|"__MCPLI"
block|,
name|FRV_BUILTIN_MCPLI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mhsetlos
block|,
literal|"__MHSETLOS"
block|,
name|FRV_BUILTIN_MHSETLOS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mhsetloh
block|,
literal|"__MHSETLOH"
block|,
name|FRV_BUILTIN_MHSETLOH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mhsethis
block|,
literal|"__MHSETHIS"
block|,
name|FRV_BUILTIN_MHSETHIS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mhsethih
block|,
literal|"__MHSETHIH"
block|,
name|FRV_BUILTIN_MHSETHIH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mhdseth
block|,
literal|"__MHDSETH"
block|,
name|FRV_BUILTIN_MHDSETH
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Media intrinsics that take two arguments and return void, the first argument    being a pointer to 4 words in memory. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_void2arg
index|[]
init|=
block|{
block|{
name|CODE_FOR_mdunpackh
block|,
literal|"__MDUNPACKH"
block|,
name|FRV_BUILTIN_MDUNPACKH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mbtohe
block|,
literal|"__MBTOHE"
block|,
name|FRV_BUILTIN_MBTOHE
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Media intrinsics that take three arguments, the first being a const_int that    denotes an accumulator, and that return void. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_void3arg
index|[]
init|=
block|{
block|{
name|CODE_FOR_mcpxrs
block|,
literal|"__MCPXRS"
block|,
name|FRV_BUILTIN_MCPXRS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mcpxru
block|,
literal|"__MCPXRU"
block|,
name|FRV_BUILTIN_MCPXRU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mcpxis
block|,
literal|"__MCPXIS"
block|,
name|FRV_BUILTIN_MCPXIS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mcpxiu
block|,
literal|"__MCPXIU"
block|,
name|FRV_BUILTIN_MCPXIU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mmulhs
block|,
literal|"__MMULHS"
block|,
name|FRV_BUILTIN_MMULHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mmulhu
block|,
literal|"__MMULHU"
block|,
name|FRV_BUILTIN_MMULHU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mmulxhs
block|,
literal|"__MMULXHS"
block|,
name|FRV_BUILTIN_MMULXHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mmulxhu
block|,
literal|"__MMULXHU"
block|,
name|FRV_BUILTIN_MMULXHU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mmachs
block|,
literal|"__MMACHS"
block|,
name|FRV_BUILTIN_MMACHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mmachu
block|,
literal|"__MMACHU"
block|,
name|FRV_BUILTIN_MMACHU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mmrdhs
block|,
literal|"__MMRDHS"
block|,
name|FRV_BUILTIN_MMRDHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mmrdhu
block|,
literal|"__MMRDHU"
block|,
name|FRV_BUILTIN_MMRDHU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqcpxrs
block|,
literal|"__MQCPXRS"
block|,
name|FRV_BUILTIN_MQCPXRS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqcpxru
block|,
literal|"__MQCPXRU"
block|,
name|FRV_BUILTIN_MQCPXRU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqcpxis
block|,
literal|"__MQCPXIS"
block|,
name|FRV_BUILTIN_MQCPXIS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqcpxiu
block|,
literal|"__MQCPXIU"
block|,
name|FRV_BUILTIN_MQCPXIU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqmulhs
block|,
literal|"__MQMULHS"
block|,
name|FRV_BUILTIN_MQMULHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqmulhu
block|,
literal|"__MQMULHU"
block|,
name|FRV_BUILTIN_MQMULHU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqmulxhs
block|,
literal|"__MQMULXHS"
block|,
name|FRV_BUILTIN_MQMULXHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqmulxhu
block|,
literal|"__MQMULXHU"
block|,
name|FRV_BUILTIN_MQMULXHU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqmachs
block|,
literal|"__MQMACHS"
block|,
name|FRV_BUILTIN_MQMACHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqmachu
block|,
literal|"__MQMACHU"
block|,
name|FRV_BUILTIN_MQMACHU
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqxmachs
block|,
literal|"__MQXMACHS"
block|,
name|FRV_BUILTIN_MQXMACHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqxmacxhs
block|,
literal|"__MQXMACXHS"
block|,
name|FRV_BUILTIN_MQXMACXHS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mqmacxhs
block|,
literal|"__MQMACXHS"
block|,
name|FRV_BUILTIN_MQMACXHS
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Media intrinsics that take two accumulator numbers as argument and    return void.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_voidacc
index|[]
init|=
block|{
block|{
name|CODE_FOR_maddaccs
block|,
literal|"__MADDACCS"
block|,
name|FRV_BUILTIN_MADDACCS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_msubaccs
block|,
literal|"__MSUBACCS"
block|,
name|FRV_BUILTIN_MSUBACCS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_masaccs
block|,
literal|"__MASACCS"
block|,
name|FRV_BUILTIN_MASACCS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mdaddaccs
block|,
literal|"__MDADDACCS"
block|,
name|FRV_BUILTIN_MDADDACCS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mdsubaccs
block|,
literal|"__MDSUBACCS"
block|,
name|FRV_BUILTIN_MDSUBACCS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|CODE_FOR_mdasaccs
block|,
literal|"__MDASACCS"
block|,
name|FRV_BUILTIN_MDASACCS
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize media builtins. */
end_comment

begin_function
specifier|static
name|void
name|frv_init_builtins
parameter_list|()
block|{
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
name|tree
name|accumulator
init|=
name|integer_type_node
decl_stmt|;
name|tree
name|integer
init|=
name|integer_type_node
decl_stmt|;
name|tree
name|voidt
init|=
name|void_type_node
decl_stmt|;
name|tree
name|uhalf
init|=
name|short_unsigned_type_node
decl_stmt|;
name|tree
name|sword1
init|=
name|long_integer_type_node
decl_stmt|;
name|tree
name|uword1
init|=
name|long_unsigned_type_node
decl_stmt|;
name|tree
name|sword2
init|=
name|long_long_integer_type_node
decl_stmt|;
name|tree
name|uword2
init|=
name|long_long_unsigned_type_node
decl_stmt|;
name|tree
name|uword4
init|=
name|build_pointer_type
argument_list|(
name|uword1
argument_list|)
decl_stmt|;
define|#
directive|define
name|UNARY
parameter_list|(
name|RET
parameter_list|,
name|T1
parameter_list|)
define|\
value|build_function_type (RET, tree_cons (NULL_TREE, T1, endlink))
define|#
directive|define
name|BINARY
parameter_list|(
name|RET
parameter_list|,
name|T1
parameter_list|,
name|T2
parameter_list|)
define|\
value|build_function_type (RET, tree_cons (NULL_TREE, T1, \ 			    tree_cons (NULL_TREE, T2, endlink)))
define|#
directive|define
name|TRINARY
parameter_list|(
name|RET
parameter_list|,
name|T1
parameter_list|,
name|T2
parameter_list|,
name|T3
parameter_list|)
define|\
value|build_function_type (RET, tree_cons (NULL_TREE, T1, \ 			    tree_cons (NULL_TREE, T2, \ 			    tree_cons (NULL_TREE, T3, endlink))))
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|voidt
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_acc
init|=
name|UNARY
argument_list|(
name|voidt
argument_list|,
name|accumulator
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_uw4_uw1
init|=
name|BINARY
argument_list|(
name|voidt
argument_list|,
name|uword4
argument_list|,
name|uword1
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_uw4_uw2
init|=
name|BINARY
argument_list|(
name|voidt
argument_list|,
name|uword4
argument_list|,
name|uword2
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_acc_uw1
init|=
name|BINARY
argument_list|(
name|voidt
argument_list|,
name|accumulator
argument_list|,
name|uword1
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_acc_acc
init|=
name|BINARY
argument_list|(
name|voidt
argument_list|,
name|accumulator
argument_list|,
name|accumulator
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_acc_uw1_uw1
init|=
name|TRINARY
argument_list|(
name|voidt
argument_list|,
name|accumulator
argument_list|,
name|uword1
argument_list|,
name|uword1
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_acc_sw1_sw1
init|=
name|TRINARY
argument_list|(
name|voidt
argument_list|,
name|accumulator
argument_list|,
name|sword1
argument_list|,
name|sword1
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_acc_uw2_uw2
init|=
name|TRINARY
argument_list|(
name|voidt
argument_list|,
name|accumulator
argument_list|,
name|uword2
argument_list|,
name|uword2
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_acc_sw2_sw2
init|=
name|TRINARY
argument_list|(
name|voidt
argument_list|,
name|accumulator
argument_list|,
name|sword2
argument_list|,
name|sword2
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_uw1
init|=
name|UNARY
argument_list|(
name|uword1
argument_list|,
name|uword1
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_sw1
init|=
name|UNARY
argument_list|(
name|uword1
argument_list|,
name|sword1
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_uw2
init|=
name|UNARY
argument_list|(
name|uword1
argument_list|,
name|uword2
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_acc
init|=
name|UNARY
argument_list|(
name|uword1
argument_list|,
name|accumulator
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_uh_uh
init|=
name|BINARY
argument_list|(
name|uword1
argument_list|,
name|uhalf
argument_list|,
name|uhalf
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_uw1_uw1
init|=
name|BINARY
argument_list|(
name|uword1
argument_list|,
name|uword1
argument_list|,
name|uword1
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_uw1_int
init|=
name|BINARY
argument_list|(
name|uword1
argument_list|,
name|uword1
argument_list|,
name|integer
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_acc_uw1
init|=
name|BINARY
argument_list|(
name|uword1
argument_list|,
name|accumulator
argument_list|,
name|uword1
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_acc_sw1
init|=
name|BINARY
argument_list|(
name|uword1
argument_list|,
name|accumulator
argument_list|,
name|sword1
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_uw2_uw1
init|=
name|BINARY
argument_list|(
name|uword1
argument_list|,
name|uword2
argument_list|,
name|uword1
argument_list|)
decl_stmt|;
name|tree
name|uw1_ftype_uw2_int
init|=
name|BINARY
argument_list|(
name|uword1
argument_list|,
name|uword2
argument_list|,
name|integer
argument_list|)
decl_stmt|;
name|tree
name|sw1_ftype_int
init|=
name|UNARY
argument_list|(
name|sword1
argument_list|,
name|integer
argument_list|)
decl_stmt|;
name|tree
name|sw1_ftype_sw1_sw1
init|=
name|BINARY
argument_list|(
name|sword1
argument_list|,
name|sword1
argument_list|,
name|sword1
argument_list|)
decl_stmt|;
name|tree
name|sw1_ftype_sw1_int
init|=
name|BINARY
argument_list|(
name|sword1
argument_list|,
name|sword1
argument_list|,
name|integer
argument_list|)
decl_stmt|;
name|tree
name|uw2_ftype_uw1
init|=
name|UNARY
argument_list|(
name|uword2
argument_list|,
name|uword1
argument_list|)
decl_stmt|;
name|tree
name|uw2_ftype_uw1_int
init|=
name|BINARY
argument_list|(
name|uword2
argument_list|,
name|uword1
argument_list|,
name|integer
argument_list|)
decl_stmt|;
name|tree
name|uw2_ftype_uw2_uw2
init|=
name|BINARY
argument_list|(
name|uword2
argument_list|,
name|uword2
argument_list|,
name|uword2
argument_list|)
decl_stmt|;
name|tree
name|uw2_ftype_uw2_int
init|=
name|BINARY
argument_list|(
name|uword2
argument_list|,
name|uword2
argument_list|,
name|integer
argument_list|)
decl_stmt|;
name|tree
name|uw2_ftype_acc_int
init|=
name|BINARY
argument_list|(
name|uword2
argument_list|,
name|accumulator
argument_list|,
name|integer
argument_list|)
decl_stmt|;
name|tree
name|sw2_ftype_sw2_sw2
init|=
name|BINARY
argument_list|(
name|sword2
argument_list|,
name|sword2
argument_list|,
name|sword2
argument_list|)
decl_stmt|;
name|def_builtin
argument_list|(
literal|"__MAND"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MAND
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MOR"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MOR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MXOR"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MXOR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MNOT"
argument_list|,
name|uw1_ftype_uw1
argument_list|,
name|FRV_BUILTIN_MNOT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MROTLI"
argument_list|,
name|uw1_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MROTLI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MROTRI"
argument_list|,
name|uw1_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MROTRI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MWCUT"
argument_list|,
name|uw1_ftype_uw2_uw1
argument_list|,
name|FRV_BUILTIN_MWCUT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MAVEH"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MAVEH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MSLLHI"
argument_list|,
name|uw1_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MSLLHI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MSRLHI"
argument_list|,
name|uw1_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MSRLHI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MSRAHI"
argument_list|,
name|sw1_ftype_sw1_int
argument_list|,
name|FRV_BUILTIN_MSRAHI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MSATHS"
argument_list|,
name|sw1_ftype_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MSATHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MSATHU"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MSATHU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MADDHSS"
argument_list|,
name|sw1_ftype_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MADDHSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MADDHUS"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MADDHUS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MSUBHSS"
argument_list|,
name|sw1_ftype_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MSUBHSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MSUBHUS"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MSUBHUS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MMULHS"
argument_list|,
name|void_ftype_acc_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MMULHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MMULHU"
argument_list|,
name|void_ftype_acc_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MMULHU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MMULXHS"
argument_list|,
name|void_ftype_acc_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MMULXHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MMULXHU"
argument_list|,
name|void_ftype_acc_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MMULXHU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MMACHS"
argument_list|,
name|void_ftype_acc_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MMACHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MMACHU"
argument_list|,
name|void_ftype_acc_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MMACHU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MMRDHS"
argument_list|,
name|void_ftype_acc_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MMRDHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MMRDHU"
argument_list|,
name|void_ftype_acc_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MMRDHU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQADDHSS"
argument_list|,
name|sw2_ftype_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQADDHSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQADDHUS"
argument_list|,
name|uw2_ftype_uw2_uw2
argument_list|,
name|FRV_BUILTIN_MQADDHUS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQSUBHSS"
argument_list|,
name|sw2_ftype_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQSUBHSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQSUBHUS"
argument_list|,
name|uw2_ftype_uw2_uw2
argument_list|,
name|FRV_BUILTIN_MQSUBHUS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQMULHS"
argument_list|,
name|void_ftype_acc_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQMULHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQMULHU"
argument_list|,
name|void_ftype_acc_uw2_uw2
argument_list|,
name|FRV_BUILTIN_MQMULHU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQMULXHS"
argument_list|,
name|void_ftype_acc_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQMULXHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQMULXHU"
argument_list|,
name|void_ftype_acc_uw2_uw2
argument_list|,
name|FRV_BUILTIN_MQMULXHU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQMACHS"
argument_list|,
name|void_ftype_acc_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQMACHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQMACHU"
argument_list|,
name|void_ftype_acc_uw2_uw2
argument_list|,
name|FRV_BUILTIN_MQMACHU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCPXRS"
argument_list|,
name|void_ftype_acc_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MCPXRS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCPXRU"
argument_list|,
name|void_ftype_acc_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MCPXRU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCPXIS"
argument_list|,
name|void_ftype_acc_sw1_sw1
argument_list|,
name|FRV_BUILTIN_MCPXIS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCPXIU"
argument_list|,
name|void_ftype_acc_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MCPXIU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQCPXRS"
argument_list|,
name|void_ftype_acc_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQCPXRS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQCPXRU"
argument_list|,
name|void_ftype_acc_uw2_uw2
argument_list|,
name|FRV_BUILTIN_MQCPXRU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQCPXIS"
argument_list|,
name|void_ftype_acc_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQCPXIS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQCPXIU"
argument_list|,
name|void_ftype_acc_uw2_uw2
argument_list|,
name|FRV_BUILTIN_MQCPXIU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCUT"
argument_list|,
name|uw1_ftype_acc_uw1
argument_list|,
name|FRV_BUILTIN_MCUT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCUTSS"
argument_list|,
name|uw1_ftype_acc_sw1
argument_list|,
name|FRV_BUILTIN_MCUTSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MEXPDHW"
argument_list|,
name|uw1_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MEXPDHW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MEXPDHD"
argument_list|,
name|uw2_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MEXPDHD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MPACKH"
argument_list|,
name|uw1_ftype_uh_uh
argument_list|,
name|FRV_BUILTIN_MPACKH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MUNPACKH"
argument_list|,
name|uw2_ftype_uw1
argument_list|,
name|FRV_BUILTIN_MUNPACKH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MDPACKH"
argument_list|,
name|uw2_ftype_uw2_uw2
argument_list|,
name|FRV_BUILTIN_MDPACKH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MDUNPACKH"
argument_list|,
name|void_ftype_uw4_uw2
argument_list|,
name|FRV_BUILTIN_MDUNPACKH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MBTOH"
argument_list|,
name|uw2_ftype_uw1
argument_list|,
name|FRV_BUILTIN_MBTOH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MHTOB"
argument_list|,
name|uw1_ftype_uw2
argument_list|,
name|FRV_BUILTIN_MHTOB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MBTOHE"
argument_list|,
name|void_ftype_uw4_uw1
argument_list|,
name|FRV_BUILTIN_MBTOHE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCLRACC"
argument_list|,
name|void_ftype_acc
argument_list|,
name|FRV_BUILTIN_MCLRACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCLRACCA"
argument_list|,
name|void_ftype_void
argument_list|,
name|FRV_BUILTIN_MCLRACCA
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MRDACC"
argument_list|,
name|uw1_ftype_acc
argument_list|,
name|FRV_BUILTIN_MRDACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MRDACCG"
argument_list|,
name|uw1_ftype_acc
argument_list|,
name|FRV_BUILTIN_MRDACCG
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MWTACC"
argument_list|,
name|void_ftype_acc_uw1
argument_list|,
name|FRV_BUILTIN_MWTACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MWTACCG"
argument_list|,
name|void_ftype_acc_uw1
argument_list|,
name|FRV_BUILTIN_MWTACCG
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__Mcop1"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MCOP1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__Mcop2"
argument_list|,
name|uw1_ftype_uw1_uw1
argument_list|,
name|FRV_BUILTIN_MCOP2
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MTRAP"
argument_list|,
name|void_ftype_void
argument_list|,
name|FRV_BUILTIN_MTRAP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQXMACHS"
argument_list|,
name|void_ftype_acc_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQXMACHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQXMACXHS"
argument_list|,
name|void_ftype_acc_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQXMACXHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQMACXHS"
argument_list|,
name|void_ftype_acc_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQMACXHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MADDACCS"
argument_list|,
name|void_ftype_acc_acc
argument_list|,
name|FRV_BUILTIN_MADDACCS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MSUBACCS"
argument_list|,
name|void_ftype_acc_acc
argument_list|,
name|FRV_BUILTIN_MSUBACCS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MASACCS"
argument_list|,
name|void_ftype_acc_acc
argument_list|,
name|FRV_BUILTIN_MASACCS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MDADDACCS"
argument_list|,
name|void_ftype_acc_acc
argument_list|,
name|FRV_BUILTIN_MDADDACCS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MDSUBACCS"
argument_list|,
name|void_ftype_acc_acc
argument_list|,
name|FRV_BUILTIN_MDSUBACCS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MDASACCS"
argument_list|,
name|void_ftype_acc_acc
argument_list|,
name|FRV_BUILTIN_MDASACCS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MABSHS"
argument_list|,
name|uw1_ftype_sw1
argument_list|,
name|FRV_BUILTIN_MABSHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MDROTLI"
argument_list|,
name|uw2_ftype_uw2_int
argument_list|,
name|FRV_BUILTIN_MDROTLI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCPLHI"
argument_list|,
name|uw1_ftype_uw2_int
argument_list|,
name|FRV_BUILTIN_MCPLHI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MCPLI"
argument_list|,
name|uw1_ftype_uw2_int
argument_list|,
name|FRV_BUILTIN_MCPLI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MDCUTSSI"
argument_list|,
name|uw2_ftype_acc_int
argument_list|,
name|FRV_BUILTIN_MDCUTSSI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MQSATHS"
argument_list|,
name|sw2_ftype_sw2_sw2
argument_list|,
name|FRV_BUILTIN_MQSATHS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MHSETLOS"
argument_list|,
name|sw1_ftype_sw1_int
argument_list|,
name|FRV_BUILTIN_MHSETLOS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MHSETHIS"
argument_list|,
name|sw1_ftype_sw1_int
argument_list|,
name|FRV_BUILTIN_MHSETHIS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MHDSETS"
argument_list|,
name|sw1_ftype_int
argument_list|,
name|FRV_BUILTIN_MHDSETS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MHSETLOH"
argument_list|,
name|uw1_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MHSETLOH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MHSETHIH"
argument_list|,
name|uw1_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MHSETHIH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__MHDSETH"
argument_list|,
name|uw1_ftype_uw1_int
argument_list|,
name|FRV_BUILTIN_MHDSETH
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|UNARY
undef|#
directive|undef
name|BINARY
undef|#
directive|undef
name|TRINARY
block|}
end_function

begin_comment
comment|/* Convert an integer constant to an accumulator register.  ICODE is the    code of the target instruction, OPNUM is the number of the    accumulator operand and OPVAL is the constant integer.  Try both    ACC and ACCG registers; only report an error if neither fit the    instruction.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_int_to_acc
parameter_list|(
name|icode
parameter_list|,
name|opnum
parameter_list|,
name|opval
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|rtx
name|opval
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|opval
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|error
argument_list|(
literal|"accumulator is not a constant integer"
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
if|if
condition|(
operator|!
name|IN_RANGE_P
argument_list|(
name|INTVAL
argument_list|(
name|opval
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NUM_ACCS
operator|-
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"accumulator number is out of bounds"
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|mode
argument_list|,
name|ACC_FIRST
operator|+
name|INTVAL
argument_list|(
name|opval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|predicate
operator|)
operator|(
name|reg
operator|,
name|VOIDmode
operator|)
condition|)
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|=
name|ACCG_FIRST
operator|+
name|INTVAL
argument_list|(
name|opval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|predicate
operator|)
operator|(
name|reg
operator|,
name|VOIDmode
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"inappropriate accumulator for `%s'"
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* If an ACC rtx has mode MODE, return the mode that the matching ACCG    should have.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|frv_matching_accg_mode
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V4SImode
case|:
return|return
name|V4QImode
return|;
case|case
name|DImode
case|:
return|return
name|HImode
return|;
case|case
name|SImode
case|:
return|return
name|QImode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the accumulator guard that should be paired with accumulator    register ACC.  The mode of the returned register is in the same    class as ACC, but is four times smaller.  */
end_comment

begin_function
name|rtx
name|frv_matching_accg_for_acc
parameter_list|(
name|acc
parameter_list|)
name|rtx
name|acc
decl_stmt|;
block|{
return|return
name|gen_rtx_REG
argument_list|(
name|frv_matching_accg_mode
argument_list|(
name|GET_MODE
argument_list|(
name|acc
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|acc
argument_list|)
operator|-
name|ACC_FIRST
operator|+
name|ACCG_FIRST
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a value from the head of the tree list pointed to by ARGLISTPTR.    Return the value as an rtx and replace *ARGLISTPTR with the tail of the    list.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_read_argument
parameter_list|(
name|arglistptr
parameter_list|)
name|tree
modifier|*
name|arglistptr
decl_stmt|;
block|{
name|tree
name|next
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|arglistptr
argument_list|)
decl_stmt|;
operator|*
name|arglistptr
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|arglistptr
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|next
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OPVAL can be used for operand OPNUM of instruction ICODE.    The instruction should require a constant operand of some sort.  The    function prints an error if OPVAL is not valid.  */
end_comment

begin_function
specifier|static
name|int
name|frv_check_constant_argument
parameter_list|(
name|icode
parameter_list|,
name|opnum
parameter_list|,
name|opval
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|rtx
name|opval
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|opval
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|error
argument_list|(
literal|"`%s' expects a constant argument"
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|predicate
operator|)
operator|(
name|opval
operator|,
name|VOIDmode
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"constant argument out of range for `%s'"
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return a legitimate rtx for instruction ICODE's return value.  Use TARGET    if it's not null, has the right mode, and satisfies operand 0's    predicate.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_legitimize_target
parameter_list|(
name|icode
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|mode
operator|)
condition|)
return|return
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
return|;
else|else
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Given that ARG is being passed as operand OPNUM to instruction ICODE,    check whether ARG satisfies the operand's contraints.  If it doesn't,    copy ARG to a temporary register and return that.  Otherwise return ARG    itself.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_legitimize_argument
parameter_list|(
name|icode
parameter_list|,
name|opnum
parameter_list|,
name|arg
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|rtx
name|arg
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|predicate
operator|)
operator|(
name|arg
operator|,
name|mode
operator|)
condition|)
return|return
name|arg
return|;
else|else
return|return
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins that take a single, constant argument.  At the moment,    only MHDSETS falls into this category.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_set_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|frv_check_constant_argument
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|target
operator|=
name|frv_legitimize_target
argument_list|(
name|icode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins that take one operand. */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_unop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|target
operator|=
name|frv_legitimize_target
argument_list|(
name|icode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|op0
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins that take two operands. */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_binop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|target
operator|=
name|frv_legitimize_target
argument_list|(
name|icode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|op0
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|2
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand cut-style builtins, which take two operands and an implicit ACCG    one. */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_cut_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|target
operator|=
name|frv_legitimize_target
argument_list|(
name|icode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|op0
operator|=
name|frv_int_to_acc
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_mdcutssi
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|!
name|frv_check_constant_argument
argument_list|(
name|icode
argument_list|,
literal|2
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
block|}
else|else
name|op1
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|2
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|frv_matching_accg_for_acc
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins that take two operands and the second is immediate. */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_binopimm_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|frv_check_constant_argument
argument_list|(
name|icode
argument_list|,
literal|2
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|target
operator|=
name|frv_legitimize_target
argument_list|(
name|icode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|op0
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins that take two operands, the first operand being a pointer to    ints and return void. */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_voidbinop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|rtx
name|reg
init|=
name|op0
decl_stmt|;
if|if
condition|(
operator|!
name|offsettable_address_p
argument_list|(
literal|0
argument_list|,
name|mode0
argument_list|,
name|op0
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offsettable_address_p
argument_list|(
literal|0
argument_list|,
name|mode0
argument_list|,
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|V4SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|op1
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins that take three operands and return void.  The first    argument must be a constant that describes a pair or quad accumulators.  A    fourth argument is created that is the accumulator guard register that    corresponds to the accumulator.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_voidtriop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op3
decl_stmt|;
name|op0
operator|=
name|frv_int_to_acc
argument_list|(
name|icode
argument_list|,
literal|0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
name|NULL_RTX
return|;
name|op1
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|op3
operator|=
name|frv_matching_accg_for_acc
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins that perform accumulator-to-accumulator operations.    These builtins take two accumulator numbers as argument and return    void.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_voidaccop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|rtx
name|op3
decl_stmt|;
name|op0
operator|=
name|frv_int_to_acc
argument_list|(
name|icode
argument_list|,
literal|0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
name|NULL_RTX
return|;
name|op1
operator|=
name|frv_int_to_acc
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op1
condition|)
return|return
name|NULL_RTX
return|;
name|op2
operator|=
name|frv_matching_accg_for_acc
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op3
operator|=
name|frv_matching_accg_for_acc
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand the MCLRACC builtin.  This builtin takes a single accumulator    number as argument.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_mclracc_builtin
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|enum
name|insn_code
name|icode
init|=
name|CODE_FOR_mclracc
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|op0
operator|=
name|frv_int_to_acc
argument_list|(
name|icode
argument_list|,
literal|0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
name|NULL_RTX
return|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins that take no arguments.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_noargs_builtin
parameter_list|(
name|icode
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand MRDACC and MRDACCG.  These builtins take a single accumulator    number or accumulator guard number as argument and return an SI integer.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_mrdacc_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|target
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|op0
operator|=
name|frv_int_to_acc
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
name|NULL_RTX
return|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand MWTACC and MWTACCG.  These builtins take an accumulator or    accumulator guard as their first argument and an SImode value as their    second.  */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_mwtacc_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|op0
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|frv_read_argument
argument_list|(
operator|&
name|arglist
argument_list|)
decl_stmt|;
name|op0
operator|=
name|frv_int_to_acc
argument_list|(
name|icode
argument_list|,
literal|0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
name|NULL_RTX
return|;
name|op1
operator|=
name|frv_legitimize_argument
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand builtins. */
end_comment

begin_function
specifier|static
name|rtx
name|frv_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|fcode
init|=
operator|(
name|unsigned
operator|)
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_MEDIA
condition|)
block|{
name|error
argument_list|(
literal|"media functions are not available unless -mmedia is used"
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|FRV_BUILTIN_MCOP1
case|:
case|case
name|FRV_BUILTIN_MCOP2
case|:
case|case
name|FRV_BUILTIN_MDUNPACKH
case|:
case|case
name|FRV_BUILTIN_MBTOHE
case|:
if|if
condition|(
operator|!
name|TARGET_MEDIA_REV1
condition|)
block|{
name|error
argument_list|(
literal|"this media function is only available on the fr500"
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
break|break;
case|case
name|FRV_BUILTIN_MQXMACHS
case|:
case|case
name|FRV_BUILTIN_MQXMACXHS
case|:
case|case
name|FRV_BUILTIN_MQMACXHS
case|:
case|case
name|FRV_BUILTIN_MADDACCS
case|:
case|case
name|FRV_BUILTIN_MSUBACCS
case|:
case|case
name|FRV_BUILTIN_MASACCS
case|:
case|case
name|FRV_BUILTIN_MDADDACCS
case|:
case|case
name|FRV_BUILTIN_MDSUBACCS
case|:
case|case
name|FRV_BUILTIN_MDASACCS
case|:
case|case
name|FRV_BUILTIN_MABSHS
case|:
case|case
name|FRV_BUILTIN_MDROTLI
case|:
case|case
name|FRV_BUILTIN_MCPLHI
case|:
case|case
name|FRV_BUILTIN_MCPLI
case|:
case|case
name|FRV_BUILTIN_MDCUTSSI
case|:
case|case
name|FRV_BUILTIN_MQSATHS
case|:
case|case
name|FRV_BUILTIN_MHSETLOS
case|:
case|case
name|FRV_BUILTIN_MHSETLOH
case|:
case|case
name|FRV_BUILTIN_MHSETHIS
case|:
case|case
name|FRV_BUILTIN_MHSETHIH
case|:
case|case
name|FRV_BUILTIN_MHDSETS
case|:
case|case
name|FRV_BUILTIN_MHDSETH
case|:
if|if
condition|(
operator|!
name|TARGET_MEDIA_REV2
condition|)
block|{
name|error
argument_list|(
literal|"this media function is only available on the fr400"
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Expand unique builtins. */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|FRV_BUILTIN_MTRAP
case|:
return|return
name|frv_expand_noargs_builtin
argument_list|(
name|CODE_FOR_mtrap
argument_list|)
return|;
case|case
name|FRV_BUILTIN_MCLRACC
case|:
return|return
name|frv_expand_mclracc_builtin
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|FRV_BUILTIN_MCLRACCA
case|:
if|if
condition|(
name|TARGET_ACC_8
condition|)
return|return
name|frv_expand_noargs_builtin
argument_list|(
name|CODE_FOR_mclracca8
argument_list|)
return|;
else|else
return|return
name|frv_expand_noargs_builtin
argument_list|(
name|CODE_FOR_mclracca4
argument_list|)
return|;
case|case
name|FRV_BUILTIN_MRDACC
case|:
return|return
name|frv_expand_mrdacc_builtin
argument_list|(
name|CODE_FOR_mrdacc
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|FRV_BUILTIN_MRDACCG
case|:
return|return
name|frv_expand_mrdacc_builtin
argument_list|(
name|CODE_FOR_mrdaccg
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|FRV_BUILTIN_MWTACC
case|:
return|return
name|frv_expand_mwtacc_builtin
argument_list|(
name|CODE_FOR_mwtacc
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|FRV_BUILTIN_MWTACCG
case|:
return|return
name|frv_expand_mwtacc_builtin
argument_list|(
name|CODE_FOR_mwtaccg
argument_list|,
name|arglist
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* Expand groups of builtins. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_set
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_set
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|frv_expand_set_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_1arg
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_1arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|frv_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_2arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|frv_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_cut
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_cut
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|frv_expand_cut_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2argimm
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_2argimm
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|frv_expand_binopimm_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_void2arg
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_void2arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|frv_expand_voidbinop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_void3arg
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_void3arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|frv_expand_voidtriop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_voidacc
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_voidacc
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|frv_expand_voidaccop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|frv_strip_name_encoding
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
operator|==
literal|'*'
operator|||
operator|*
name|str
operator|==
name|SDATA_FLAG_CHAR
condition|)
name|str
operator|++
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|frv_in_small_data_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|symbol_ref_small_data_p
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|g_switch_value
return|;
block|}
end_function

end_unit

