begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IBM RS/6000.    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,     2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_NO_PROTOTYPE
end_ifndef

begin_define
define|#
directive|define
name|TARGET_NO_PROTOTYPE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_comment
comment|/* Target cpu type */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|rs6000_cpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rs6000_cpu_select
name|rs6000_select
index|[
literal|3
index|]
init|=
block|{
comment|/* switch		name,			tune	arch */
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"--with-cpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mcpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mtune="
block|,
literal|1
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of long double */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_long_double_size_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_long_double_type_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether -mabi=altivec has appeared */
end_comment

begin_decl_stmt
name|int
name|rs6000_altivec_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to non-zero once AIX common-mode calls have been defined.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|common_mode_defined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|rs6000_compare_op0
decl_stmt|,
name|rs6000_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_compare_fp_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label number of label created for -mrelocatable, to call to so we can    get the address of the GOT section */
end_comment

begin_decl_stmt
name|int
name|rs6000_pic_labelno
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USING_ELFOS_H
end_ifdef

begin_comment
comment|/* Which abi to adhere to */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_abi_name
init|=
name|RS6000_ABI_NAME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Semantics of the small data area */
end_comment

begin_decl_stmt
name|enum
name|rs6000_sdata_type
name|rs6000_sdata
init|=
name|SDATA_DATA
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which small data model to use */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_sdata_name
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter for labels which are to be placed in .fixup.  */
end_comment

begin_decl_stmt
name|int
name|fixuplabelno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ABI enumeration available for subtarget to use.  */
end_comment

begin_decl_stmt
name|enum
name|rs6000_abi
name|rs6000_current_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ABI string from -mabi= option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_abi_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug flags */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_debug_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_debug_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug stack applications */
end_comment

begin_decl_stmt
name|int
name|rs6000_debug_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug argument handling */
end_comment

begin_comment
comment|/* Flag to say the TOC is initialized */
end_comment

begin_decl_stmt
name|int
name|toc_initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|toc_label_name
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alias set for saves and restores from the rs6000 stack.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rs6000_sr_alias_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_add_gc_roots
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_insns_constant_wide
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|expand_block_move_mem
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_condition_mode
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|rs6000_generate_compare
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_maybe_dead
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_emit_stack_tie
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_frame_related
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_emit_allocate_stack
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|rs6000_hash_constant
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|toc_hash_function
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|toc_hash_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|toc_hash_mark_entry
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toc_hash_mark_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constant_pool_expr_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_free_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_init_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|rs6000_assemble_integer
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rs6000_ra_ever_killed
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|rs6000_handle_longcall_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|rs6000_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_output_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_output_function_epilogue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|rs6000_emit_set_long_const
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|rs6000_elf_section_type_flags
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_elf_asm_out_constructor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_elf_asm_out_destructor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|xcoff_asm_named_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|rs6000_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rs6000_adjust_priority
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rs6000_issue_rate
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_init_builtins
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|altivec_init_builtins
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|rs6000_expand_builtin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|altivec_expand_builtin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|altivec_expand_unop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|altivec_expand_binop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|altivec_expand_abs_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|altivec_expand_predicate_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|altivec_expand_ternop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|altivec_expand_stv_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rs6000_parse_abi_options
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|first_altivec_reg_to_save
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|compute_vrsave_mask
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|is_altivec_return_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vrsave_operation
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|generate_set_vrsave
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rs6000_stack_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|altivec_frame_fixup
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|easy_vector_constant
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Default register names.  */
end_comment

begin_decl_stmt
name|char
name|rs6000_reg_names
index|[]
index|[
literal|8
index|]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"mq"
block|,
literal|"lr"
block|,
literal|"ctr"
block|,
literal|"ap"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"xer"
block|,
comment|/* AltiVec registers.  */
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"vrsave"
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_REGNAMES
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|alt_reg_names
index|[]
index|[
literal|8
index|]
init|=
block|{
literal|"%r0"
block|,
literal|"%r1"
block|,
literal|"%r2"
block|,
literal|"%r3"
block|,
literal|"%r4"
block|,
literal|"%r5"
block|,
literal|"%r6"
block|,
literal|"%r7"
block|,
literal|"%r8"
block|,
literal|"%r9"
block|,
literal|"%r10"
block|,
literal|"%r11"
block|,
literal|"%r12"
block|,
literal|"%r13"
block|,
literal|"%r14"
block|,
literal|"%r15"
block|,
literal|"%r16"
block|,
literal|"%r17"
block|,
literal|"%r18"
block|,
literal|"%r19"
block|,
literal|"%r20"
block|,
literal|"%r21"
block|,
literal|"%r22"
block|,
literal|"%r23"
block|,
literal|"%r24"
block|,
literal|"%r25"
block|,
literal|"%r26"
block|,
literal|"%r27"
block|,
literal|"%r28"
block|,
literal|"%r29"
block|,
literal|"%r30"
block|,
literal|"%r31"
block|,
literal|"%f0"
block|,
literal|"%f1"
block|,
literal|"%f2"
block|,
literal|"%f3"
block|,
literal|"%f4"
block|,
literal|"%f5"
block|,
literal|"%f6"
block|,
literal|"%f7"
block|,
literal|"%f8"
block|,
literal|"%f9"
block|,
literal|"%f10"
block|,
literal|"%f11"
block|,
literal|"%f12"
block|,
literal|"%f13"
block|,
literal|"%f14"
block|,
literal|"%f15"
block|,
literal|"%f16"
block|,
literal|"%f17"
block|,
literal|"%f18"
block|,
literal|"%f19"
block|,
literal|"%f20"
block|,
literal|"%f21"
block|,
literal|"%f22"
block|,
literal|"%f23"
block|,
literal|"%f24"
block|,
literal|"%f25"
block|,
literal|"%f26"
block|,
literal|"%f27"
block|,
literal|"%f28"
block|,
literal|"%f29"
block|,
literal|"%f30"
block|,
literal|"%f31"
block|,
literal|"mq"
block|,
literal|"lr"
block|,
literal|"ctr"
block|,
literal|"ap"
block|,
literal|"%cr0"
block|,
literal|"%cr1"
block|,
literal|"%cr2"
block|,
literal|"%cr3"
block|,
literal|"%cr4"
block|,
literal|"%cr5"
block|,
literal|"%cr6"
block|,
literal|"%cr7"
block|,
literal|"xer"
block|,
comment|/* AltiVec registers.  */
literal|"%v0"
block|,
literal|"%v1"
block|,
literal|"%v2"
block|,
literal|"%v3"
block|,
literal|"%v4"
block|,
literal|"%v5"
block|,
literal|"%v6"
block|,
literal|"%v7"
block|,
literal|"%v8"
block|,
literal|"%v9"
block|,
literal|"%v10"
block|,
literal|"%v11"
block|,
literal|"%v12"
block|,
literal|"%v13"
block|,
literal|"%v14"
block|,
literal|"%v15"
block|,
literal|"%v16"
block|,
literal|"%v17"
block|,
literal|"%v18"
block|,
literal|"%v19"
block|,
literal|"%v20"
block|,
literal|"%v21"
block|,
literal|"%v22"
block|,
literal|"%v23"
block|,
literal|"%v24"
block|,
literal|"%v25"
block|,
literal|"%v26"
block|,
literal|"%v27"
block|,
literal|"%v28"
block|,
literal|"%v29"
block|,
literal|"%v30"
block|,
literal|"%v31"
block|,
literal|"vrsave"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MASK_STRICT_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|MASK_STRICT_ALIGN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|rs6000_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|DOUBLE_INT_ASM_OP
end_define

begin_comment
comment|/* Default unaligned ops are only provided for ELF.  Find the ops needed    for non-ELF systems.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_comment
comment|/* For XCOFF.  rs6000_assemble_integer will handle unaligned DIs on    64-bit targets.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.vbyte\t2,"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.vbyte\t4,"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\t.vbyte\t8,"
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* For Darwin.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.short\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.long\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This hook deals with fixups for relocatable code and DI-mode objects    in 64-bit code.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|rs6000_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|rs6000_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|rs6000_output_function_epilogue
end_define

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_undef
undef|#
directive|undef
name|TARGET_SECTION_TYPE_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SECTION_TYPE_FLAGS
value|rs6000_elf_section_type_flags
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|rs6000_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|rs6000_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_PRIORITY
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_PRIORITY
value|rs6000_adjust_priority
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|rs6000_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|rs6000_expand_builtin
end_define

begin_comment
comment|/* The VRSAVE bitmask puts bit %v0 as the most significant bit.  */
end_comment

begin_define
define|#
directive|define
name|ALTIVEC_REG_BIT
parameter_list|(
name|REGNO
parameter_list|)
value|(0x80000000>> ((REGNO) - FIRST_ALTIVEC_REGNO))
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Override command line options.  Mostly we process the processor    type and sometimes adjust other TARGET_ options.  */
end_comment

begin_function
name|void
name|rs6000_override_options
parameter_list|(
name|default_cpu
parameter_list|)
specifier|const
name|char
modifier|*
name|default_cpu
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|rs6000_cpu_select
modifier|*
name|ptr
decl_stmt|;
comment|/* Simplify the entries below by making a mask for any POWER      variant and any PowerPC variant.  */
define|#
directive|define
name|POWER_MASKS
value|(MASK_POWER | MASK_POWER2 | MASK_MULTIPLE | MASK_STRING)
define|#
directive|define
name|POWERPC_MASKS
value|(MASK_POWERPC | MASK_PPC_GPOPT \ 		       | MASK_PPC_GFXOPT | MASK_POWERPC64)
define|#
directive|define
name|POWERPC_OPT_MASKS
value|(MASK_PPC_GPOPT | MASK_PPC_GFXOPT)
specifier|static
struct|struct
name|ptt
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Canonical processor name.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
comment|/* Processor type enum value.  */
specifier|const
name|int
name|target_enable
decl_stmt|;
comment|/* Target flags to enable.  */
specifier|const
name|int
name|target_disable
decl_stmt|;
comment|/* Target flags to disable.  */
block|}
decl|const
name|processor_target_table
index|[]
init|=
block|{
block|{
literal|"common"
block|,
name|PROCESSOR_COMMON
block|,
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_MASKS
block|}
block|,
block|{
literal|"power"
block|,
name|PROCESSOR_POWER
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|MASK_POWER2
operator||
name|POWERPC_MASKS
operator||
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"power2"
block|,
name|PROCESSOR_POWER
block|,
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|POWERPC_MASKS
operator||
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"power3"
block|,
name|PROCESSOR_PPC630
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
block|}
block|,
block|{
literal|"powerpc"
block|,
name|PROCESSOR_POWERPC
block|,
name|MASK_POWERPC
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"powerpc64"
block|,
name|PROCESSOR_POWERPC64
block|,
name|MASK_POWERPC
operator||
name|MASK_POWERPC64
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
block|}
block|,
block|{
literal|"rios"
block|,
name|PROCESSOR_RIOS1
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|MASK_POWER2
operator||
name|POWERPC_MASKS
operator||
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"rios1"
block|,
name|PROCESSOR_RIOS1
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|MASK_POWER2
operator||
name|POWERPC_MASKS
operator||
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"rsc"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|MASK_POWER2
operator||
name|POWERPC_MASKS
operator||
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"rsc1"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|MASK_POWER2
operator||
name|POWERPC_MASKS
operator||
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"rios2"
block|,
name|PROCESSOR_RIOS2
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator||
name|MASK_POWER2
block|,
name|POWERPC_MASKS
operator||
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"rs64a"
block|,
name|PROCESSOR_RS64A
block|,
name|MASK_POWERPC
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
block|}
block|,
block|{
literal|"401"
block|,
name|PROCESSOR_PPC403
block|,
name|MASK_POWERPC
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"403"
block|,
name|PROCESSOR_PPC403
block|,
name|MASK_POWERPC
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_NEW_MNEMONICS
operator||
name|MASK_STRICT_ALIGN
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"405"
block|,
name|PROCESSOR_PPC405
block|,
name|MASK_POWERPC
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"505"
block|,
name|PROCESSOR_MPCCORE
block|,
name|MASK_POWERPC
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"601"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|MASK_POWERPC
operator||
name|MASK_NEW_MNEMONICS
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|MASK_POWER2
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"602"
block|,
name|PROCESSOR_PPC603
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"603"
block|,
name|PROCESSOR_PPC603
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"603e"
block|,
name|PROCESSOR_PPC603
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"ec603e"
block|,
name|PROCESSOR_PPC603
block|,
name|MASK_POWERPC
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"604"
block|,
name|PROCESSOR_PPC604
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"604e"
block|,
name|PROCESSOR_PPC604e
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"620"
block|,
name|PROCESSOR_PPC620
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
block|}
block|,
block|{
literal|"630"
block|,
name|PROCESSOR_PPC630
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
block|}
block|,
block|{
literal|"740"
block|,
name|PROCESSOR_PPC750
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"750"
block|,
name|PROCESSOR_PPC750
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"7400"
block|,
name|PROCESSOR_PPC7400
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"7450"
block|,
name|PROCESSOR_PPC7450
block|,
name|MASK_POWERPC
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"801"
block|,
name|PROCESSOR_MPCCORE
block|,
name|MASK_POWERPC
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"821"
block|,
name|PROCESSOR_MPCCORE
block|,
name|MASK_POWERPC
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"823"
block|,
name|PROCESSOR_MPCCORE
block|,
name|MASK_POWERPC
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"860"
block|,
name|PROCESSOR_MPCCORE
block|,
name|MASK_POWERPC
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWER_MASKS
operator||
name|POWERPC_OPT_MASKS
operator||
name|MASK_POWERPC64
block|}
block|}
struct|;
name|size_t
name|ptt_size
init|=
sizeof|sizeof
argument_list|(
name|processor_target_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ptt
argument_list|)
decl_stmt|;
comment|/* Save current -mmultiple/-mno-multiple status.  */
name|int
name|multiple
init|=
name|TARGET_MULTIPLE
decl_stmt|;
comment|/* Save current -mstring/-mno-string status.  */
name|int
name|string
init|=
name|TARGET_STRING
decl_stmt|;
comment|/* Identify the processor type.  */
name|rs6000_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|default_cpu
expr_stmt|;
name|rs6000_cpu
operator|=
name|TARGET_POWERPC64
condition|?
name|PROCESSOR_DEFAULT64
else|:
name|PROCESSOR_DEFAULT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rs6000_select
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
operator|&
name|rs6000_select
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptt_size
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|string
argument_list|,
name|processor_target_table
index|[
name|j
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|set_tune_p
condition|)
name|rs6000_cpu
operator|=
name|processor_target_table
index|[
name|j
index|]
operator|.
name|processor
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|set_arch_p
condition|)
block|{
name|target_flags
operator||=
name|processor_target_table
index|[
name|j
index|]
operator|.
name|target_enable
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|processor_target_table
index|[
name|j
index|]
operator|.
name|target_disable
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|ptt_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are optimizing big endian systems for space, use the store      multiple instructions.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|optimize_size
condition|)
name|target_flags
operator||=
name|MASK_MULTIPLE
expr_stmt|;
comment|/* If -mmultiple or -mno-multiple was explicitly used, don't      override with the processor default */
if|if
condition|(
name|TARGET_MULTIPLE_SET
condition|)
name|target_flags
operator|=
operator|(
name|target_flags
operator|&
operator|~
name|MASK_MULTIPLE
operator|)
operator||
name|multiple
expr_stmt|;
comment|/* If -mstring or -mno-string was explicitly used, don't override      with the processor default.  */
if|if
condition|(
name|TARGET_STRING_SET
condition|)
name|target_flags
operator|=
operator|(
name|target_flags
operator|&
operator|~
name|MASK_STRING
operator|)
operator||
name|string
expr_stmt|;
comment|/* Don't allow -mmultiple or -mstring on little endian systems      unless the cpu is a 750, because the hardware doesn't support the      instructions used in little endian mode, and causes an alignment      trap.  The 750 does not cause an alignment trap (except when the      target is unaligned).  */
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|rs6000_cpu
operator|!=
name|PROCESSOR_PPC750
condition|)
block|{
if|if
condition|(
name|TARGET_MULTIPLE
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_MULTIPLE
expr_stmt|;
if|if
condition|(
name|TARGET_MULTIPLE_SET
condition|)
name|warning
argument_list|(
literal|"-mmultiple is not supported on little endian systems"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_STRING
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_STRING
expr_stmt|;
if|if
condition|(
name|TARGET_STRING_SET
condition|)
name|warning
argument_list|(
literal|"-mstring is not supported on little endian systems"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_pic
operator|!=
literal|0
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
name|flag_pic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"-f%s ignored (all code is position independent)"
argument_list|,
operator|(
name|flag_pic
operator|>
literal|1
operator|)
condition|?
literal|"PIC"
else|:
literal|"pic"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|flag_function_sections
operator|&&
operator|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|)
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
name|warning
argument_list|(
literal|"-ffunction-sections disabled on AIX when debugging"
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_data_sections
operator|&&
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"-fdata-sections not supported on AIX"
argument_list|)
expr_stmt|;
name|flag_data_sections
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set debug flags */
if|if
condition|(
name|rs6000_debug_name
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"all"
argument_list|)
condition|)
name|rs6000_debug_stack
operator|=
name|rs6000_debug_arg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"stack"
argument_list|)
condition|)
name|rs6000_debug_stack
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"arg"
argument_list|)
condition|)
name|rs6000_debug_arg
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown -mdebug-%s switch"
argument_list|,
name|rs6000_debug_name
argument_list|)
expr_stmt|;
block|}
comment|/* Set size of long double */
name|rs6000_long_double_type_size
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|rs6000_long_double_size_string
condition|)
block|{
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|size
init|=
name|strtol
argument_list|(
name|rs6000_long_double_size_string
argument_list|,
operator|&
name|tail
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
literal|'\0'
operator|||
operator|(
name|size
operator|!=
literal|64
operator|&&
name|size
operator|!=
literal|128
operator|)
condition|)
name|error
argument_list|(
literal|"Unknown switch -mlong-double-%s"
argument_list|,
name|rs6000_long_double_size_string
argument_list|)
expr_stmt|;
else|else
name|rs6000_long_double_type_size
operator|=
name|size
expr_stmt|;
block|}
comment|/* Handle -mabi= options.  */
name|rs6000_parse_abi_options
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_REGNAMES
comment|/* If the user desires alternate register names, copy in the      alternate names now.  */
if|if
condition|(
name|TARGET_REGNAMES
condition|)
name|memcpy
argument_list|(
name|rs6000_reg_names
argument_list|,
name|alt_reg_names
argument_list|,
sizeof|sizeof
argument_list|(
name|rs6000_reg_names
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUBTARGET_OVERRIDE_OPTIONS
name|SUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUBSUBTARGET_OVERRIDE_OPTIONS
name|SUBSUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
comment|/* Set TARGET_AIX_STRUCT_RET last, after the ABI is determined.      If -maix-struct-return or -msvr4-struct-return was explicitly      used, don't override with the ABI default.  */
if|if
condition|(
operator|!
operator|(
name|target_flags
operator|&
name|MASK_AIX_STRUCT_RET_SET
operator|)
condition|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|!
name|DRAFT_V4_STRUCT_RET
condition|)
name|target_flags
operator|=
operator|(
name|target_flags
operator|&
operator|~
name|MASK_AIX_STRUCT_RET
operator|)
expr_stmt|;
else|else
name|target_flags
operator||=
name|MASK_AIX_STRUCT_RET
expr_stmt|;
block|}
comment|/* Register global variables with the garbage collector.  */
name|rs6000_add_gc_roots
argument_list|()
expr_stmt|;
comment|/* Allocate an alias set for register saves& restores from stack.  */
name|rs6000_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_TOC
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|toc_label_name
argument_list|,
literal|"LCTOC"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We can only guarantee the availability of DI pseudo-ops when      assembling for 64-bit targets.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|aligned_op
operator|.
name|di
operator|=
name|NULL
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
operator|.
name|di
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Arrange to save and restore machine status around nested functions.  */
name|init_machine_status
operator|=
name|rs6000_init_machine_status
expr_stmt|;
name|free_machine_status
operator|=
name|rs6000_free_machine_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle -mabi= options.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_parse_abi_options
parameter_list|()
block|{
if|if
condition|(
name|rs6000_abi_string
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_abi_string
argument_list|,
literal|"altivec"
argument_list|)
condition|)
name|rs6000_altivec_abi
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_abi_string
argument_list|,
literal|"no-altivec"
argument_list|)
condition|)
name|rs6000_altivec_abi
operator|=
literal|0
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown ABI specified: '%s'"
argument_list|,
name|rs6000_abi_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|optimization_options
parameter_list|(
name|level
parameter_list|,
name|size
parameter_list|)
name|int
name|level
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Do anything needed at the start of the asm file.  */
end_comment

begin_function
name|void
name|rs6000_file_start
parameter_list|(
name|file
parameter_list|,
name|default_cpu
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|default_cpu
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|buffer
decl_stmt|;
name|struct
name|rs6000_cpu_select
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\n%s rs6000/powerpc options:"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|rs6000_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|default_cpu
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rs6000_select
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
operator|&
name|rs6000_select
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s %s%s"
argument_list|,
name|start
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
name|ptr
operator|->
name|string
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USING_ELFOS_H
switch|switch
condition|(
name|rs6000_sdata
condition|)
block|{
case|case
name|SDATA_NONE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=none"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_DATA
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=data"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_SYSV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=sysv"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_EABI
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=eabi"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rs6000_sdata
operator|&&
name|g_switch_value
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -G %d"
argument_list|,
name|start
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|start
operator|==
literal|'\0'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a CONST_DOUBLE from a string.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|rs6000_float_const
parameter_list|(
name|string
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|string
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|immed_real_const_1
argument_list|(
name|value
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if this function is known to have a null epilogue.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|()
block|{
if|if
condition|(
name|reload_completed
condition|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|first_gp_reg_save
operator|==
literal|32
operator|&&
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|&&
name|info
operator|->
name|first_altivec_reg_save
operator|==
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
operator|&&
operator|!
name|info
operator|->
name|lr_save_p
operator|&&
operator|!
name|info
operator|->
name|cr_save_p
operator|&&
name|info
operator|->
name|vrsave_mask
operator|==
literal|0
operator|&&
operator|!
name|info
operator|->
name|push_p
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 always.  */
end_comment

begin_function
name|int
name|any_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if op is the count register.  */
end_comment

begin_function
name|int
name|count_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|COUNT_REGISTER_REGNUM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if op is an altivec register.  */
end_comment

begin_function
name|int
name|altivec_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>
name|FIRST_PSEUDO_REGISTER
operator|||
name|ALTIVEC_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xer_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XER_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a signed 8-bit constant.  Int multiplication    by such constants completes more quickly.  */
end_comment

begin_function
name|int
name|s8bit_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
operator|-
literal|128
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<=
literal|127
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that can fit in a D field.  */
end_comment

begin_function
name|int
name|short_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar for an unsigned D field.  */
end_comment

begin_function
name|int
name|u_short_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|'K'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a CONST_INT that cannot fit in a signed D field.  */
end_comment

begin_function
name|int
name|non_short_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a CONST_INT that is a positive value    and an exact power of 2.  */
end_comment

begin_function
name|int
name|exact_log2_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a register that is not special (i.e., not MQ,    ctr, or lr).  */
end_comment

begin_function
name|int
name|gpc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
name|XER_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|MQ_REGNO
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a pseudo-register or a register denoting a    CR field.  */
end_comment

begin_function
name|int
name|cc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a pseudo-register or a register denoting a    CR field that isn't CR0.  */
end_comment

begin_function
name|int
name|cc_reg_not_cr0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|CR_REGNO_NOT_CR0_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a constant integer valid for a D-field or    a non-special register.  If a register, it must be in the proper    mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_short_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|short_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, except check if the negation of the constant would be    valid for a D-field.  */
end_comment

begin_function
name|int
name|reg_or_neg_short_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'P'
argument_list|)
return|;
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a constant integer valid for a DS-field or    a non-special register.  If a register, it must be in the proper    mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_aligned_short_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|short_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|3
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or an integer whose    high-order 16 bits are zero.  */
end_comment

begin_function
name|int
name|reg_or_u_short_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|u_short_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or ANY    constant integer.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or ANY    32-bit signed constant integer.  */
end_comment

begin_function
name|int
name|reg_or_arith_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|32
operator|&&
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x80000000
argument_list|)
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0x100000000ll
operator|)
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or a 32-bit    signed constant integer valid for 64-bit addition.  */
end_comment

begin_function
name|int
name|reg_or_add_cint64_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x7fff8000
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|32
operator|&&
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x80008000
argument_list|)
operator|<
literal|0x100000000ll
operator|)
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or a 32-bit    signed constant integer valid for 64-bit subtraction.  */
end_comment

begin_function
name|int
name|reg_or_sub_cint64_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
operator|<
literal|0x7fff8000
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|32
operator|&&
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
operator|+
literal|0x80008000
argument_list|)
operator|<
literal|0x100000000ll
operator|)
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or ANY    32-bit unsigned constant integer.  */
end_comment

begin_function
name|int
name|reg_or_logical_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|||
name|mode
operator|!=
name|DImode
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
return|;
block|}
else|else
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is an operand that can be loaded via the GOT.  */
end_comment

begin_function
name|int
name|got_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a simple references that can be loaded via    the GOT (labels involving addition aren't allowed).  */
end_comment

begin_function
name|int
name|got_no_const_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of instructions it takes to form a constant in an    integer register.  */
end_comment

begin_function
specifier|static
name|int
name|num_insns_constant_wide
parameter_list|(
name|value
parameter_list|)
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
comment|/* signed constant loadable with {cal|addi} */
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|value
argument_list|,
literal|'I'
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* constant loadable with {cau|addis} */
elseif|else
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|value
argument_list|,
literal|'L'
argument_list|)
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
elseif|else
if|if
condition|(
name|TARGET_POWERPC64
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
name|value
operator|&
literal|0xffffffff
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
name|value
operator|>>
literal|32
decl_stmt|;
name|low
operator|=
operator|(
name|low
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
comment|/* sign extend */
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
operator|(
name|low
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|high
operator|==
operator|-
literal|1
operator|&&
operator|(
name|low
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
operator|!
name|low
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
else|else
return|return
literal|2
return|;
block|}
end_function

begin_function
name|int
name|num_insns_constant
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>>
literal|31
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>>
literal|31
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|2
return|;
else|else
endif|#
directive|endif
return|return
name|num_insns_constant_wide
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|mode
operator|==
name|SFmode
condition|)
block|{
name|long
name|l
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|int
name|endian
init|=
operator|(
name|WORDS_BIG_ENDIAN
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|DImode
condition|)
block|{
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|high
operator|=
name|l
index|[
name|endian
index|]
expr_stmt|;
name|low
operator|=
name|l
index|[
literal|1
operator|-
name|endian
index|]
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_32BIT
condition|)
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|)
return|;
else|else
block|{
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|>=
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
return|;
elseif|else
if|if
condition|(
name|high
operator|==
operator|-
literal|1
operator|&&
name|low
operator|<
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
return|;
elseif|else
if|if
condition|(
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|low
operator|==
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a CONST_DOUBLE and it can be put into a    register with one instruction per word.  We only do this if we can    safely read CONST_DOUBLE_{LOW,HIGH}.  */
end_comment

begin_function
name|int
name|easy_fp_constant
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|mode
operator|!=
name|DImode
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Consider all constants with -msoft-float to be easy.  */
if|if
condition|(
name|TARGET_SOFT_FLOAT
operator|&&
name|mode
operator|!=
name|DImode
condition|)
return|return
literal|1
return|;
comment|/* If we are using V.4 style PIC, consider all constants to be hard.  */
if|if
condition|(
name|flag_pic
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|TARGET_RELOCATABLE
comment|/* Similarly if we are using -mrelocatable, consider all constants      to be hard.  */
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
block|{
name|long
name|k
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
literal|0
index|]
argument_list|)
operator|==
literal|1
operator|&&
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
literal|1
index|]
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
name|long
name|l
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|num_insns_constant_wide
argument_list|(
name|l
argument_list|)
operator|==
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
operator|(
name|TARGET_POWERPC64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_insns_constant
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|)
operator|<=
literal|2
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
return|return
literal|1
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a CONST_INT and can be put into a    register with one instruction.  */
end_comment

begin_function
specifier|static
name|int
name|easy_vector_constant
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
name|rtx
name|elt
decl_stmt|;
name|int
name|units
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_VECTOR
condition|)
return|return
literal|0
return|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* We can generate 0 easily.  Look for that.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
block|{
name|elt
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* We could probably simplify this by just checking for equality 	 with CONST0_RTX for the current mode, but let's be safe 	 instead.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|elt
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|elt
argument_list|)
operator|!=
literal|0
operator|||
name|CONST_DOUBLE_HIGH
argument_list|(
name|elt
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
comment|/* We could probably generate a few other constants trivially, but      gcc doesn't generate them yet.  FIXME later.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is the constant 0.  This works for scalars    as well as vectors.  */
end_comment

begin_function
name|int
name|zero_constant
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is 0.0.  */
end_comment

begin_function
name|int
name|zero_fp_constant
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is in volatile memory.  Note that during    the RTL generation phase, memory_operand does not return TRUE for    volatile memory references.  So this function allows us to    recognize volatile references where its safe.  */
end_comment

begin_function
name|int
name|volatile_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reload_completed
condition|)
return|return
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|reload_in_progress
condition|)
return|return
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is an offsettable memory operand.  */
end_comment

begin_function
name|int
name|offsettable_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
name|reload_completed
operator|||
name|reload_in_progress
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either an easy FP constant (see above) or    memory.  */
end_comment

begin_function
name|int
name|mem_or_easy_const_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|easy_fp_constant
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a non-special register or an item    that can be used as the operand of a `mode' add insn.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
operator|)
return|;
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant but not a valid add_operand.  */
end_comment

begin_function
name|int
name|non_add_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a non-special register or a constant that    can be used as the operand of an OR or XOR insn on the RS/6000.  */
end_comment

begin_function
name|int
name|logical_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|opl
decl_stmt|,
name|oph
decl_stmt|;
if|if
condition|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|opl
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|<=
literal|32
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|opl
operator|<
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|opl
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|oph
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|oph
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|opl
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffff
operator|)
operator|==
literal|0
operator|||
operator|(
name|opl
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffff0000
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if C is a constant that is not a logical operand (as    above), but could be split into one.  */
end_comment

begin_function
name|int
name|non_logical_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
operator|!
name|logical_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|reg_or_logical_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if C is a constant that can be encoded in a 32-bit mask on the    RS/6000.  It is if there are no more than two 1->0 or 0->1 transitions.    Reject all ones and all zeros, since these should have been optimized    away and confuse the making of MB and ME.  */
end_comment

begin_function
name|int
name|mask_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Fail in 64-bit mode if the mask wraps around because the upper      32-bits of the mask will all be 1s, contrary to GCC's internal view.  */
if|if
condition|(
name|TARGET_POWERPC64
operator|&&
operator|(
name|c
operator|&
literal|0x80000001
operator|)
operator|==
literal|0x80000001
condition|)
return|return
literal|0
return|;
comment|/* We don't change the number of transitions by inverting,      so make sure we start with the LS bit zero.  */
if|if
condition|(
name|c
operator|&
literal|1
condition|)
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Reject all zeros or all ones.  */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Find the first transition.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* Invert to look for a second transition.  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Erase first transition.  */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/* Find the second transition (if any).  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* Match if all the bits above are 1's (or c is zero).  */
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a constant that is a PowerPC64 mask.    It is if there are no more than one 1->0 or 0->1 transitions.    Reject all ones and all zeros, since these should have been optimized    away and confuse the making of MB and ME.  */
end_comment

begin_function
name|int
name|mask64_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|;
comment|/* We don't change the number of transitions by inverting, 	 so make sure we start with the LS bit zero.  */
name|c
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|1
condition|)
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Reject all zeros or all ones.  */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Find the transition, and check that all bits above are 1's.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|DImode
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|,
name|lsb
decl_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
name|high
operator|=
operator|~
name|high
expr_stmt|;
name|low
operator|=
operator|~
name|low
expr_stmt|;
block|}
if|if
condition|(
name|low
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
return|return
name|low
operator|==
operator|-
name|lsb
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
operator|~
literal|0
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a non-special register or a constant    that can be used as the operand of a PowerPC64 logical AND insn.  */
end_comment

begin_function
name|int
name|and64_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|fixed_regs
index|[
name|CR0_REGNO
index|]
condition|)
comment|/* CR0 not available, don't do andi./andis.  */
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
return|return
operator|(
name|logical_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a non-special register or a    constant that can be used as the operand of an RS/6000 logical AND insn.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|fixed_regs
index|[
name|CR0_REGNO
index|]
condition|)
comment|/* CR0 not available, don't do andi./andis.  */
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
return|return
operator|(
name|logical_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a general register or memory operand.  */
end_comment

begin_function
name|int
name|reg_or_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|volatile_mem_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a general register or memory operand without    pre_inc or pre_dec which produces invalid form of PowerPC lwa    instruction.  */
end_comment

begin_function
name|int
name|lwa_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|inner
init|=
name|op
decl_stmt|;
if|if
condition|(
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
return|return
name|gpc_reg_operand
argument_list|(
name|inner
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|memory_operand
argument_list|(
name|inner
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PRE_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PRE_DEC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|%
literal|4
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand, used inside a MEM, is a valid first argument    to CALL.  This is a SYMBOL_REF or a pseudo-register, which will be    forced to lr.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a SYMBOL_REF for a function known to be in    this file and the function is not weakly defined.  */
end_comment

begin_function
name|int
name|current_file_function_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|op
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|current_function_decl
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this operand is a valid input for a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Memory is always valid.  */
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
literal|1
return|;
comment|/* For floating-point, easy constants are valid.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
name|easy_fp_constant
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Allow any integer constant.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
return|return
literal|1
return|;
comment|/* For floating-point or multi-word mode, the only remaining valid type      is a register.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
comment|/* The only cases left are integral modes one word or smaller (we      do not get called for MODE_CC values).  These can be in any      register.  */
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* A SYMBOL_REF referring to the TOC is valid.  */
if|if
condition|(
name|LEGITIMATE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* A constant pool expression (relative to the TOC) is valid */
if|if
condition|(
name|TOC_RELATIVE_EXPR_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* V.4 allows SYMBOL_REFs and CONSTs that are in the small data region      to be valid.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|)
operator|&&
name|small_data_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an operand in small memory on V.4/eabi.  */
end_comment

begin_function
name|int
name|small_data_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
name|TARGET_ELF
name|rtx
name|sym_ref
decl_stmt|;
if|if
condition|(
name|rs6000_sdata
operator|==
name|SDATA_NONE
operator|||
name|rs6000_sdata
operator|==
name|SDATA_DATA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|sym_ref
operator|=
name|op
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
else|else
block|{
name|rtx
name|sum
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|summand
decl_stmt|;
comment|/* We have to be careful here, because it is the referenced address         that must be 32k from _SDA_BASE_, not just the symbol.  */
name|summand
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|summand
operator|<
literal|0
operator|||
name|summand
operator|>
name|g_switch_value
condition|)
return|return
literal|0
return|;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|!=
literal|'@'
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|constant_pool_expr_1
parameter_list|(
name|op
parameter_list|,
name|have_sym
parameter_list|,
name|have_toc
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
modifier|*
name|have_sym
decl_stmt|;
name|int
modifier|*
name|have_toc
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|op
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
operator|*
name|have_sym
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|toc_label_name
argument_list|)
condition|)
block|{
operator|*
name|have_toc
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
operator|(
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
operator|&&
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
operator|)
return|;
case|case
name|CONST
case|:
return|return
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|constant_pool_expr_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
name|int
name|have_sym
init|=
literal|0
decl_stmt|;
name|int
name|have_toc
init|=
literal|0
decl_stmt|;
return|return
name|constant_pool_expr_1
argument_list|(
name|op
argument_list|,
operator|&
name|have_sym
argument_list|,
operator|&
name|have_toc
argument_list|)
operator|&&
name|have_sym
return|;
block|}
end_function

begin_function
name|int
name|toc_relative_expr_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
name|int
name|have_sym
init|=
literal|0
decl_stmt|;
name|int
name|have_toc
init|=
literal|0
decl_stmt|;
return|return
name|constant_pool_expr_1
argument_list|(
name|op
argument_list|,
operator|&
name|have_sym
argument_list|,
operator|&
name|have_toc
argument_list|)
operator|&&
name|have_toc
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This is used from only one place: `memory_address' in explow.c.     OLDX is the address as it was before break_out_memory_refs was    called.  In some cases it is useful to look at this to decide what    needs to be done.     MODE is passed so that this function can use GO_IF_LEGITIMATE_ADDRESS.     It is always safe for this function to do nothing.  It exists to    recognize opportunities to optimize the output.     On RS/6000, first check for the sum of a register with a constant    integer that is out of range.  If so, generate code to add the    constant with the low-order 16 bits masked to the register and force    this result into another register (this can be done with `cau').    Then generate an address of REG+(CONST&0xffff), allowing for the    possibility of bit 16 being a one.     Then check for the sum of a register and something not constant, try to    load the other things into a register and return the sum.  */
end_comment

begin_function
name|rtx
name|rs6000_legitimize_address
parameter_list|(
name|x
parameter_list|,
name|oldx
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
condition|)
block|{
name|HOST_WIDE_INT
name|high_int
decl_stmt|,
name|low_int
decl_stmt|;
name|rtx
name|sum
decl_stmt|;
name|high_int
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffff
operator|)
expr_stmt|;
name|low_int
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|low_int
operator|&
literal|0x8000
condition|)
name|high_int
operator|+=
literal|0x10000
operator|,
name|low_int
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|16
expr_stmt|;
name|sum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high_int
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum
argument_list|,
name|GEN_INT
argument_list|(
name|low_int
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|TARGET_HARD_FLOAT
operator|||
name|TARGET_POWERPC64
operator|||
name|mode
operator|!=
name|DFmode
operator|)
operator|&&
operator|(
name|TARGET_POWERPC64
operator|||
name|mode
operator|!=
name|DImode
operator|)
operator|&&
name|mode
operator|!=
name|TImode
condition|)
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|reg
decl_stmt|;
comment|/* Make sure both operands are registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
name|reg
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ELF
operator|&&
name|TARGET_32BIT
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
operator|||
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|mode
operator|==
name|DFmode
operator|)
operator|)
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|reg
argument_list|,
operator|(
name|x
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
operator|(
name|x
operator|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MACHO
operator|&&
name|TARGET_32BIT
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|TARGET_HARD_FLOAT
operator|||
name|mode
operator|!=
name|DFmode
operator|)
operator|&&
name|mode
operator|!=
name|DImode
operator|&&
name|mode
operator|!=
name|TImode
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|reg
argument_list|,
operator|(
name|x
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
operator|(
name|x
operator|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_TOC
operator|&&
name|CONSTANT_POOL_EXPR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
return|return
name|create_TOC_reference
argument_list|(
name|x
argument_list|)
return|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* The convention appears to be to define this wherever it is used.    With legitimize_reload_address now defined here, REG_MODE_OK_FOR_BASE_P    is now used here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REG_MODE_OK_FOR_BASE_P
end_ifndef

begin_define
define|#
directive|define
name|REG_MODE_OK_FOR_BASE_P
parameter_list|(
name|REGNO
parameter_list|,
name|MODE
parameter_list|)
value|REG_OK_FOR_BASE_P (REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to    replace the input X, or the original X if no replacement is called for.    The output parameter *WIN is 1 if the calling macro should goto WIN,    0 if it should not.     For RS/6000, we wish to handle large displacements off a base    register by splitting the addend across an addiu/addis and the mem insn.    This cuts number of extra insns needed from 3 to 1.     On Darwin, we use this to generate code for floating point constants.    A movsf_low is generated so we wind up with 2 instructions rather than 3.    The Darwin code is inside #if TARGET_MACHO because only then is    machopic_function_base_name() defined.  */
end_comment

begin_function
name|rtx
name|rs6000_legitimize_reload_address
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|ind_levels
parameter_list|,
name|win
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|ind_levels
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|win
decl_stmt|;
block|{
comment|/* We must recognize output that we have already generated ourselves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* Result of previous invocation of this function on Darwin 	 floating point constant.  */
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
operator|(
name|val
operator|-
name|low
operator|)
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
decl_stmt|;
comment|/* Check for 32-bit overflow.  */
if|if
condition|(
name|high
operator|+
name|low
operator|!=
name|val
condition|)
block|{
operator|*
name|win
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* Reload the high part into a base reg; leave the low part          in the mem directly.  */
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_pic
condition|)
block|{
comment|/* Darwin load of floating point constant.  */
name|rtx
name|offset
init|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|x
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TARGET_TOC
operator|&&
name|CONSTANT_POOL_EXPR_P
argument_list|(
name|x
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|)
block|{
operator|(
name|x
operator|)
operator|=
name|create_TOC_reference
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
operator|*
name|win
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression    that is a valid memory address for an instruction.    The MODE argument is the machine mode for the MEM expression    that wants to use this address.     On the RS/6000, there are four valid address: a SYMBOL_REF that    refers to a constant pool entry of an address (or the sum of it    plus a constant), a short (16-bit signed) constant plus a register,    the sum of two registers, or a register indirect, possibly with an    auto-increment.  For DFmode and DImode with an constant plus register,    we must ensure that both words are addressable or PowerPC64 with offset    word aligned.     For modes spanning multiple registers (DFmode in 32-bit GPRs,    32-bit DImode, TImode), indexed addressing cannot be used because    adjacent memory cells are accessed by adding word-sized offsets    during assembly output.  */
end_comment

begin_function
name|int
name|rs6000_legitimate_address
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|reg_ok_strict
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|reg_ok_strict
decl_stmt|;
block|{
if|if
condition|(
name|LEGITIMATE_INDIRECT_ADDRESS_P
argument_list|(
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_DEC
operator|)
operator|&&
name|TARGET_UPDATE
operator|&&
name|LEGITIMATE_INDIRECT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|LEGITIMATE_SMALL_DATA_P
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|LEGITIMATE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If not REG_OK_STRICT (before reload) let pass any stack offset.  */
if|if
condition|(
operator|!
name|reg_ok_strict
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|LEGITIMATE_OFFSET_ADDRESS_P
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mode
operator|!=
name|TImode
operator|&&
operator|(
name|TARGET_HARD_FLOAT
operator|||
name|TARGET_POWERPC64
operator|||
name|mode
operator|!=
name|DFmode
operator|)
operator|&&
operator|(
name|TARGET_POWERPC64
operator|||
name|mode
operator|!=
name|DImode
operator|)
operator|&&
name|LEGITIMATE_INDEXED_ADDRESS_P
argument_list|(
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|LEGITIMATE_LO_SUM_ADDRESS_P
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to output insns to set TARGET equal to the constant C if it can    be done in less than N insns.  Do all computations in MODE.    Returns the place where the output has been placed if it can be    done and the insns have been emitted.  If it would take more than N    insns, zero is returned and no insns and emitted.  */
end_comment

begin_function
name|rtx
name|rs6000_emit_set_const
parameter_list|(
name|dest
parameter_list|,
name|mode
parameter_list|,
name|source
parameter_list|,
name|n
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|source
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|n
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|c0
decl_stmt|,
name|c1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|SImode
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c0
operator|=
name|INTVAL
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|-
operator|(
name|c0
operator|<
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|c0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|-
operator|(
name|c0
operator|<
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|c0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|source
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|rs6000_emit_set_long_const
argument_list|(
name|dest
argument_list|,
name|c0
argument_list|,
name|c1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Having failed to find a 3 insn sequence in rs6000_emit_set_const,    fall back to a straight forward decomposition.  We do this to avoid    exponential run times encountered when looking for longer sequences    with rs6000_emit_set_const.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_emit_set_long_const
parameter_list|(
name|dest
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|HOST_WIDE_INT
name|c1
decl_stmt|,
name|c2
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_POWERPC64
condition|)
block|{
name|rtx
name|operand1
decl_stmt|,
name|operand2
decl_stmt|;
name|operand1
operator|=
name|operand_subword_force
argument_list|(
name|dest
argument_list|,
name|WORDS_BIG_ENDIAN
operator|==
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|operand2
operator|=
name|operand_subword_force
argument_list|(
name|dest
argument_list|,
name|WORDS_BIG_ENDIAN
operator|!=
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operand1
argument_list|,
name|GEN_INT
argument_list|(
name|c1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operand2
argument_list|,
name|GEN_INT
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|ud1
decl_stmt|,
name|ud2
decl_stmt|,
name|ud3
decl_stmt|,
name|ud4
decl_stmt|;
name|ud1
operator|=
name|c1
operator|&
literal|0xffff
expr_stmt|;
name|ud2
operator|=
operator|(
name|c1
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|c2
operator|=
name|c1
operator|>>
literal|32
expr_stmt|;
endif|#
directive|endif
name|ud3
operator|=
name|c2
operator|&
literal|0xffff
expr_stmt|;
name|ud4
operator|=
operator|(
name|c2
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
name|ud3
operator|==
literal|0xffff
operator|&&
name|ud2
operator|==
literal|0xffff
operator|&&
operator|(
name|ud1
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
name|ud3
operator|==
literal|0
operator|&&
name|ud2
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud1
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud1
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud1
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
name|ud3
operator|==
literal|0xffff
operator|&&
operator|(
name|ud2
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
name|ud3
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud2
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud2
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud2
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
operator|(
name|ud3
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud3
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud3
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud3
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud3
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud2
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ud4
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud4
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud4
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud3
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud2
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
operator|<<
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Emit a move from SOURCE to DEST in mode MODE.  */
end_comment

begin_function
name|void
name|rs6000_emit_move
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|source
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|source
expr_stmt|;
comment|/* Sanity checks.  Check that we get CONST_DOUBLE only when we should.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* FIXME.  This should never happen.  */
comment|/* Since it seems that it does, do the safe thing and convert 	 to a CONST_INT.  */
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check if GCC is setting up a block move that will end up using FP      registers as temporaries.  We must make sure this is acceptable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|DImode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|DImode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|SImode
argument_list|,
operator|(
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>
literal|32
condition|?
literal|32
else|:
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|SImode
argument_list|,
operator|(
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>
literal|32
condition|?
literal|32
else|:
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|)
argument_list|)
operator|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
operator|&&
operator|!
name|TARGET_POWERPC
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regnum
operator|=
name|true_regnum
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
name|regnum
operator|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|regnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If operands[1] is a register, on POWER it may have 	 double-precision data in it, so truncate it to single 	 precision.  */
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|regnum
argument_list|)
operator|||
name|regnum
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|newreg
decl_stmt|;
name|newreg
operator|=
operator|(
name|no_new_pseudos
condition|?
name|operands
index|[
literal|1
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_aux_truncdfsf2
argument_list|(
name|newreg
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|newreg
expr_stmt|;
block|}
block|}
comment|/* Handle the case where reload calls us with an invalid address;      and the case of CONSTANT_P_RTX.  */
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|general_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|||
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME:  In the long term, this switch statement should go away      and be replaced by a sequence of tests based on things like      mode == Pmode.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HImode
case|:
case|case
name|QImode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
case|case
name|DFmode
case|:
case|case
name|SFmode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|easy_fp_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|easy_vector_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|DImode
case|:
comment|/* Use default pattern for address of ELF small data */
if|if
condition|(
name|TARGET_ELF
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST
operator|)
operator|&&
name|small_data_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|flag_pic
operator|==
literal|1
operator|&&
name|got_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi_got
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|TARGET_ELF
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|HIGH
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|rtx
name|target
init|=
operator|(
name|no_new_pseudos
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
comment|/* If this is a function address on -mcall-aixdesc, 	     convert it to the address of the descriptor.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|XSTR
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new_ref
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
name|name
operator|++
expr_stmt|;
name|new_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|new_ref
argument_list|)
operator|=
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAG
argument_list|(
name|new_ref
argument_list|)
operator|=
name|SYMBOL_REF_FLAG
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SYMBOL_REF_USED
argument_list|(
name|new_ref
argument_list|)
operator|=
name|SYMBOL_REF_USED
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|new_ref
expr_stmt|;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_low
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is a SYMBOL_REF that refers to a constant pool entry, 	 and we have put it in the TOC, we just need to make a TOC-relative 	 reference to it.  */
if|if
condition|(
name|TARGET_TOC
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_EXPR_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|create_TOC_reference
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|!
name|easy_fp_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|num_insns_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|>
literal|2
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|HIGH
operator|&&
operator|!
name|LEGITIMATE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|TOC_RELATIVE_EXPR_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Emit a USE operation so that the constant isn't deleted if 	     expensive optimizations are turned on because nobody 	     references it.  This should only be done for operands that 	     contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set. 	     This should not be done for operands that contain LABEL_REFs. 	     For now, we just handle the obvious case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|LABEL_REF
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* Darwin uses a special PIC legitimizer.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
index|[
literal|0
index|]
operator|!=
name|operands
index|[
literal|1
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If we are to limit the number of things we put in the TOC and 	     this is a symbol plus a constant we can add in one insn, 	     just put the symbol in the TOC and add the constant.  Don't do 	     this if reload is in progress.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST
operator|&&
name|TARGET_NO_SUM_IN_TOC
operator|&&
operator|!
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|add_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|rtx
name|sym
init|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|other
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|sym
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|sym
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|sym
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_TOC
operator|&&
name|CONSTANT_POOL_EXPR_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|create_TOC_reference
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|get_TOC_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TImode
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Above, we may have called force_const_mem which may have returned      an invalid address.  If we can, fix this up; otherwise, reload will      have to deal with it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.     For incoming args we set the number of arguments in the prototype large    so we never return a PARALLEL.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|,
name|incoming
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|incoming
decl_stmt|;
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cumulative
decl_stmt|;
operator|*
name|cum
operator|=
name|zero_cumulative
expr_stmt|;
name|cum
operator|->
name|words
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|fregno
operator|=
name|FP_ARG_MIN_REG
expr_stmt|;
name|cum
operator|->
name|vregno
operator|=
name|ALTIVEC_ARG_MIN_REG
expr_stmt|;
name|cum
operator|->
name|prototype
operator|=
operator|(
name|fntype
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
expr_stmt|;
name|cum
operator|->
name|call_cookie
operator|=
name|CALL_NORMAL
expr_stmt|;
name|cum
operator|->
name|sysv_gregno
operator|=
name|GP_ARG_MIN_REG
expr_stmt|;
if|if
condition|(
name|incoming
condition|)
name|cum
operator|->
name|nargs_prototype
operator|=
literal|1000
expr_stmt|;
comment|/* don't return a PARALLEL */
elseif|else
if|if
condition|(
name|cum
operator|->
name|prototype
condition|)
name|cum
operator|->
name|nargs_prototype
operator|=
operator|(
name|list_length
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|-
literal|1
operator|+
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|||
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
else|else
name|cum
operator|->
name|nargs_prototype
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|orig_nargs
operator|=
name|cum
operator|->
name|nargs_prototype
expr_stmt|;
comment|/* Check for longcall's */
if|if
condition|(
name|fntype
operator|&&
name|lookup_attribute
argument_list|(
literal|"longcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|cum
operator|->
name|call_cookie
operator|=
name|CALL_LONG
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" ret code = %s,"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cum
operator|->
name|call_cookie
operator|&
name|CALL_LONG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" longcall,"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" proto = %d, nargs = %d\n"
argument_list|,
name|cum
operator|->
name|prototype
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If defined, a C expression which determines whether, and in which    direction, to pad out an argument with extra space.  The value    should be of type `enum direction': either `upward' to pad above    the argument, `downward' to pad below, or `none' to inhibit    padding.     For the AIX ABI structs are always stored left shifted in their    argument slot.  */
end_comment

begin_function
name|enum
name|direction
name|function_arg_padding
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|upward
return|;
comment|/* This is the default definition.  */
return|return
operator|(
operator|!
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
operator|(
operator|(
name|mode
operator|==
name|BLKmode
condition|?
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|PARM_BOUNDARY
operator|)
condition|?
name|downward
else|:
name|upward
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If defined, a C expression that gives the alignment boundary, in bits,    of an argument with the specified mode and type.  If it is not defined,     PARM_BOUNDARY is used for all arguments.        V.4 wants long longs to be double word aligned.  */
end_comment

begin_function
name|int
name|function_arg_boundary
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|128
return|;
else|else
return|return
name|PARM_BOUNDARY
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    (TYPE is null for libcalls where that information may not be available.)  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|cum
operator|->
name|nargs_prototype
operator|--
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|vregno
operator|<=
name|ALTIVEC_ARG_MAX_REG
operator|&&
name|cum
operator|->
name|nargs_prototype
operator|>=
literal|0
condition|)
name|cum
operator|->
name|vregno
operator|++
expr_stmt|;
else|else
name|cum
operator|->
name|words
operator|+=
name|RS6000_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
operator|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
name|cum
operator|->
name|fregno
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
name|cum
operator|->
name|words
operator|+=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|RS6000_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|n_words
decl_stmt|;
name|int
name|gregno
init|=
name|cum
operator|->
name|sysv_gregno
decl_stmt|;
comment|/* Aggregates and IEEE quad get passed by reference.  */
if|if
condition|(
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|mode
operator|==
name|TFmode
condition|)
name|n_words
operator|=
literal|1
expr_stmt|;
else|else
name|n_words
operator|=
name|RS6000_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Long long is put in odd registers.  */
if|if
condition|(
name|n_words
operator|==
literal|2
operator|&&
operator|(
name|gregno
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|gregno
operator|+=
literal|1
expr_stmt|;
comment|/* Long long is not split between registers and stack.  */
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|>
name|GP_ARG_MAX_REG
condition|)
block|{
comment|/* Long long is aligned on the stack.  */
if|if
condition|(
name|n_words
operator|==
literal|2
condition|)
name|cum
operator|->
name|words
operator|+=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|n_words
expr_stmt|;
block|}
comment|/* Note: continuing to accumulate gregno past when we've started 	     spilling to the stack indicates the fact that we've started 	     spilling to the stack to expand_builtin_saveregs.  */
name|cum
operator|->
name|sysv_gregno
operator|=
name|gregno
operator|+
name|n_words
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, fregno = %2d, "
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gregno = %2d, nargs = %4d, proto = %d, "
argument_list|,
name|cum
operator|->
name|sysv_gregno
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|,
name|cum
operator|->
name|prototype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mode = %4s, named = %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|align
init|=
operator|(
name|TARGET_32BIT
operator|&&
operator|(
name|cum
operator|->
name|words
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|function_arg_boundary
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|==
literal|64
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|cum
operator|->
name|words
operator|+=
name|align
operator|+
name|RS6000_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|TARGET_HARD_FLOAT
condition|)
name|cum
operator|->
name|fregno
operator|++
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, fregno = %2d, "
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nargs = %4d, proto = %d, mode = %4s, "
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|,
name|cum
operator|->
name|prototype
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"named = %d, align = %d\n"
argument_list|,
name|named
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).     On RS/6000 the first eight words of non-FP are normally in registers    and the rest are pushed.  Under AIX, the first 13 FP args are in registers.    Under V.4, the first 8 FP args are in registers.     If this is floating-point and no prototype is specified, we use    both an FP and integer register (or possibly FP reg and stack).  Library    functions (when TYPE is zero) always have the proper types for args,    so we can pass the FP value just in one register.  emit_library_function    doesn't support PARALLEL anyway.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|enum
name|rs6000_abi
name|abi
init|=
name|DEFAULT_ABI
decl_stmt|;
comment|/* Return a marker to indicate whether CR1 needs to set or clear the      bit that V.4 uses to say fp args were passed in registers.      Assume that we don't need the marker for software floating point,      or compiler generated library calls.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|abi
operator|==
name|ABI_V4
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|cum
operator|->
name|nargs_prototype
operator|<
literal|0
operator|&&
name|type
operator|&&
operator|(
name|cum
operator|->
name|prototype
operator|||
name|TARGET_NO_PROTOTYPE
operator|)
condition|)
block|{
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|call_cookie
operator||
operator|(
operator|(
name|cum
operator|->
name|fregno
operator|==
name|FP_ARG_MIN_REG
operator|)
condition|?
name|CALL_V4_SET_FP_ARGS
else|:
name|CALL_V4_CLEAR_FP_ARGS
operator|)
argument_list|)
return|;
block|}
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|call_cookie
argument_list|)
return|;
block|}
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|named
operator|&&
name|cum
operator|->
name|vregno
operator|<=
name|ALTIVEC_ARG_MAX_REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|vregno
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|abi
operator|==
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
operator|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
else|else
block|{
name|int
name|n_words
decl_stmt|;
name|int
name|gregno
init|=
name|cum
operator|->
name|sysv_gregno
decl_stmt|;
comment|/* Aggregates and IEEE quad get passed by reference.  */
if|if
condition|(
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|mode
operator|==
name|TFmode
condition|)
name|n_words
operator|=
literal|1
expr_stmt|;
else|else
name|n_words
operator|=
name|RS6000_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Long long is put in odd registers.  */
if|if
condition|(
name|n_words
operator|==
literal|2
operator|&&
operator|(
name|gregno
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|gregno
operator|+=
literal|1
expr_stmt|;
comment|/* Long long is not split between registers and stack.  */
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|<=
name|GP_ARG_MAX_REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|gregno
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|int
name|align
init|=
operator|(
name|TARGET_32BIT
operator|&&
operator|(
name|cum
operator|->
name|words
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|function_arg_boundary
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|==
literal|64
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|align_words
init|=
name|cum
operator|->
name|words
operator|+
name|align
decl_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|USE_FP_FOR_ARG_P
argument_list|(
operator|*
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|type
operator|||
operator|(
operator|(
name|cum
operator|->
name|nargs_prototype
operator|>
literal|0
operator|)
comment|/* IBM AIX extended its linkage convention definition always 		     to require FP args after register save area hole on the 		     stack.  */
operator|&&
operator|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|||
operator|!
name|TARGET_XL_CALL
operator|||
operator|(
name|align_words
operator|<
name|GP_ARG_NUM_REG
operator|)
operator|)
operator|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
return|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
operator|(
operator|(
name|align_words
operator|>=
name|GP_ARG_NUM_REG
operator|)
condition|?
name|NULL_RTX
else|:
operator|(
name|align_words
operator|+
name|RS6000_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|>
name|GP_ARG_NUM_REG
comment|/* If this is partially on the stack, then 				       we only include the portion actually 				       in registers here.  */
condition|?
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
else|:
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
operator|)
operator|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|align_words
operator|<
name|GP_ARG_NUM_REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For an arg passed partly in registers and partly in memory,    this is the number of registers used.    For args passed entirely in registers or entirely in memory, zero.  */
end_comment

begin_function
name|int
name|function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|USE_FP_FOR_ARG_P
argument_list|(
operator|*
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
operator|||
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
operator|*
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|nargs_prototype
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cum
operator|->
name|words
operator|<
name|GP_ARG_NUM_REG
operator|&&
name|GP_ARG_NUM_REG
operator|<
operator|(
name|cum
operator|->
name|words
operator|+
name|RS6000_ARG_SIZE
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|)
condition|)
block|{
name|int
name|ret
init|=
name|GP_ARG_NUM_REG
operator|-
name|cum
operator|->
name|words
decl_stmt|;
if|if
condition|(
name|ret
operator|&&
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_partial_nregs: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression that indicates when an argument must be passed by    reference.  If nonzero for an argument, a copy of that argument is    made in memory and a pointer to the argument is passed instead of    the argument itself.  The pointer is passed in whatever way is    appropriate for passing a pointer to that type.     Under V.4, structures and unions are passed by reference.  */
end_comment

begin_function
name|int
name|function_arg_pass_by_reference
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|mode
operator|==
name|TFmode
operator|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference: aggregate\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform any needed actions needed for a function that is receiving a    variable number of arguments.      CUM is as above.     MODE and TYPE are the mode and type of the current parameter.     PRETEND_SIZE is a variable that should be set to the amount of stack    that must be pushed by the prolog to pretend that our caller pushed    it.     Normally, this macro will push all remaining incoming registers on the    stack and set PRETEND_SIZE to the length of the registers pushed.  */
end_comment

begin_function
name|void
name|setup_incoming_varargs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|pretend_size
parameter_list|,
name|no_rtl
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|pretend_size
decl_stmt|;
name|int
name|no_rtl
decl_stmt|;
block|{
name|CUMULATIVE_ARGS
name|next_cum
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|rtx
name|save_area
init|=
name|NULL_RTX
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|first_reg_offset
decl_stmt|,
name|set
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|int
name|stdarg_p
decl_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|stdarg_p
operator|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
expr_stmt|;
comment|/* For varargs, we do not want to skip the dummy va_dcl argument.      For stdargs, we do want to skip the last named argument.  */
name|next_cum
operator|=
operator|*
name|cum
expr_stmt|;
if|if
condition|(
name|stdarg_p
condition|)
name|function_arg_advance
argument_list|(
operator|&
name|next_cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
comment|/* Indicate to allocate space on the stack for varargs save area.  */
comment|/* ??? Does this really have to be located at a magic spot on the 	 stack, or can we allocate this with assign_stack_local instead.  */
name|cfun
operator|->
name|machine
operator|->
name|sysv_varargs_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
condition|)
name|save_area
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
operator|-
name|RS6000_VARARGS_SIZE
argument_list|)
expr_stmt|;
name|first_reg_offset
operator|=
name|next_cum
operator|.
name|sysv_gregno
operator|-
name|GP_ARG_MIN_REG
expr_stmt|;
block|}
else|else
block|{
name|first_reg_offset
operator|=
name|next_cum
operator|.
name|words
expr_stmt|;
name|save_area
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|sysv_varargs_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
name|first_reg_offset
operator|+=
name|RS6000_ARG_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
operator|&&
name|first_reg_offset
operator|<
name|GP_ARG_NUM_REG
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|first_reg_offset
operator|*
name|reg_size
argument_list|)
argument_list|)
operator|,
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|move_block_from_reg
argument_list|(
name|GP_ARG_MIN_REG
operator|+
name|first_reg_offset
argument_list|,
name|mem
argument_list|,
name|GP_ARG_NUM_REG
operator|-
name|first_reg_offset
argument_list|,
operator|(
name|GP_ARG_NUM_REG
operator|-
name|first_reg_offset
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* ??? Does ABI_V4 need this at all?  */
operator|*
name|pretend_size
operator|=
operator|(
name|GP_ARG_NUM_REG
operator|-
name|first_reg_offset
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
comment|/* Save FP registers if needed.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
operator|!
name|no_rtl
operator|&&
name|next_cum
operator|.
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
block|{
name|int
name|fregno
init|=
name|next_cum
operator|.
name|fregno
decl_stmt|;
name|rtx
name|cr1
init|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR1_REGNO
argument_list|)
decl_stmt|;
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|off
init|=
operator|(
name|GP_ARG_NUM_REG
operator|*
name|reg_size
operator|)
operator|+
operator|(
operator|(
name|fregno
operator|-
name|FP_ARG_MIN_REG
operator|)
operator|*
literal|8
operator|)
decl_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cr1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|fregno
argument_list|)
argument_list|)
expr_stmt|;
name|fregno
operator|++
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
block|}
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the va_list data type.  */
end_comment

begin_function
name|tree
name|rs6000_build_va_list
parameter_list|()
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
comment|/* For AIX, prefer 'char *' because that's what the system      header files like.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
name|record
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"gpr"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"fpr"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement va_start.  */
end_comment

begin_function
name|void
name|rs6000_va_start
parameter_list|(
name|stdarg_p
parameter_list|,
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|int
name|stdarg_p
decl_stmt|;
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
comment|/* Only SVR4 needs something special.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
block|{
name|std_expand_builtin_va_start
argument_list|(
name|stdarg_p
argument_list|,
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|words
operator|=
name|current_function_args_info
operator|.
name|words
expr_stmt|;
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|sysv_gregno
operator|-
name|GP_ARG_MIN_REG
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|fregno
operator|-
name|FP_ARG_MIN_REG
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fputs
argument_list|(
literal|"va_start: words = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|words
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", n_gpr = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|n_gpr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", n_fpr = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|n_fpr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|n_gpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|n_fpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the overflow area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|!=
literal|0
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|words
operator|*
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the register save area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|RS6000_VARARGS_SIZE
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|rtx
name|rs6000_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|reg
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|;
name|int
name|indirect_p
decl_stmt|,
name|size
decl_stmt|,
name|rsize
decl_stmt|,
name|n_reg
decl_stmt|,
name|sav_ofs
decl_stmt|,
name|sav_scale
decl_stmt|;
name|rtx
name|lab_false
decl_stmt|,
name|lab_over
decl_stmt|,
name|addr_rtx
decl_stmt|,
name|r
decl_stmt|;
comment|/* For AIX, the rule is that structures are passed left-aligned in      their stack slot.  However, GCC does not presently do this:      structures which are the same size as integer types are passed      right-aligned, as if they were in fact integers.  This only      matters for structures of size 1 or 2, or 4 when TARGET_64BIT.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rsize
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
condition|)
block|{
comment|/* Aggregates and long doubles are passed by reference.  */
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|0
expr_stmt|;
name|sav_scale
operator|=
literal|4
expr_stmt|;
name|size
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|rsize
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TARGET_SOFT_FLOAT
condition|)
block|{
comment|/* FP args go in FP registers, if present.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|fpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|8
operator|*
literal|4
expr_stmt|;
name|sav_scale
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise into GP registers.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
name|rsize
expr_stmt|;
name|sav_ofs
operator|=
literal|0
expr_stmt|;
name|sav_scale
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Pull the value out of the saved registers ...  */
name|lab_false
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab_over
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/*  Vectors never go in registers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VECTOR_TYPE
condition|)
block|{
name|TREE_THIS_VOLATILE
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|reg
argument_list|,
name|NULL_RTX
argument_list|,
name|QImode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
operator|-
name|n_reg
operator|+
literal|1
argument_list|)
argument_list|,
name|GE
argument_list|,
name|const1_rtx
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
comment|/* Long long is aligned in the registers.  */
if|if
condition|(
name|n_reg
operator|>
literal|1
condition|)
block|{
name|u
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|n_reg
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|u
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sav_ofs
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|build_int_2
argument_list|(
name|sav_ofs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|sav
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|n_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|u
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|u
argument_list|,
name|build_int_2
argument_list|(
name|sav_scale
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab_over
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
name|emit_label
argument_list|(
name|lab_false
argument_list|)
expr_stmt|;
comment|/* ... otherwise out of the overflow area.  */
comment|/* Make sure we don't find reg 7 for the next int arg.       All AltiVec vectors go in the overflow area.  So in the AltiVec      case we need to get the vectors from the overflow area, but      remember where the GPRs and FPRs are.  */
if|if
condition|(
name|n_reg
operator|>
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VECTOR_TYPE
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* Care for on-stack alignment if needed.  */
if|if
condition|(
name|rsize
operator|<=
literal|1
condition|)
name|t
operator|=
name|ovf
expr_stmt|;
else|else
block|{
name|int
name|align
decl_stmt|;
comment|/* Vectors are 16 byte aligned.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
name|align
operator|=
literal|15
expr_stmt|;
else|else
name|align
operator|=
literal|7
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|build_int_2
argument_list|(
name|align
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|align
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|save_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab_over
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
block|{
name|r
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|r
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|addr_rtx
return|;
block|}
end_function

begin_comment
comment|/* Builtins.  */
end_comment

begin_define
define|#
directive|define
name|def_builtin
parameter_list|(
name|MASK
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {									\   if ((MASK)& target_flags)						\     builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL);	\ } while (0)
end_define

begin_struct
struct|struct
name|builtin_description
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|rs6000_builtins
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Simple ternary operations: VECd = foo (VECa, VECb, VECc).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_3arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmaddfp
block|,
literal|"__builtin_altivec_vmaddfp"
block|,
name|ALTIVEC_BUILTIN_VMADDFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmhaddshs
block|,
literal|"__builtin_altivec_vmhaddshs"
block|,
name|ALTIVEC_BUILTIN_VMHADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmhraddshs
block|,
literal|"__builtin_altivec_vmhraddshs"
block|,
name|ALTIVEC_BUILTIN_VMHRADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmladduhm
block|,
literal|"__builtin_altivec_vmladduhm"
block|,
name|ALTIVEC_BUILTIN_VMLADDUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumubm
block|,
literal|"__builtin_altivec_vmsumubm"
block|,
name|ALTIVEC_BUILTIN_VMSUMUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsummbm
block|,
literal|"__builtin_altivec_vmsummbm"
block|,
name|ALTIVEC_BUILTIN_VMSUMMBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumuhm
block|,
literal|"__builtin_altivec_vmsumuhm"
block|,
name|ALTIVEC_BUILTIN_VMSUMUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumshm
block|,
literal|"__builtin_altivec_vmsumshm"
block|,
name|ALTIVEC_BUILTIN_VMSUMSHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumuhs
block|,
literal|"__builtin_altivec_vmsumuhs"
block|,
name|ALTIVEC_BUILTIN_VMSUMUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumshs
block|,
literal|"__builtin_altivec_vmsumshs"
block|,
name|ALTIVEC_BUILTIN_VMSUMSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vnmsubfp
block|,
literal|"__builtin_altivec_vnmsubfp"
block|,
name|ALTIVEC_BUILTIN_VNMSUBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_4sf
block|,
literal|"__builtin_altivec_vperm_4sf"
block|,
name|ALTIVEC_BUILTIN_VPERM_4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_4si
block|,
literal|"__builtin_altivec_vperm_4si"
block|,
name|ALTIVEC_BUILTIN_VPERM_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_8hi
block|,
literal|"__builtin_altivec_vperm_8hi"
block|,
name|ALTIVEC_BUILTIN_VPERM_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_16qi
block|,
literal|"__builtin_altivec_vperm_16qi"
block|,
name|ALTIVEC_BUILTIN_VPERM_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_4sf
block|,
literal|"__builtin_altivec_vsel_4sf"
block|,
name|ALTIVEC_BUILTIN_VSEL_4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_4si
block|,
literal|"__builtin_altivec_vsel_4si"
block|,
name|ALTIVEC_BUILTIN_VSEL_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_8hi
block|,
literal|"__builtin_altivec_vsel_8hi"
block|,
name|ALTIVEC_BUILTIN_VSEL_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_16qi
block|,
literal|"__builtin_altivec_vsel_16qi"
block|,
name|ALTIVEC_BUILTIN_VSEL_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_16qi
block|,
literal|"__builtin_altivec_vsldoi_16qi"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_8hi
block|,
literal|"__builtin_altivec_vsldoi_8hi"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_4si
block|,
literal|"__builtin_altivec_vsldoi_4si"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_4sf
block|,
literal|"__builtin_altivec_vsldoi_4sf"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_4SF
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DST operations: void foo (void *, const int, const char).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_dst
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dst
block|,
literal|"__builtin_altivec_dst"
block|,
name|ALTIVEC_BUILTIN_DST
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dstt
block|,
literal|"__builtin_altivec_dstt"
block|,
name|ALTIVEC_BUILTIN_DSTT
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dstst
block|,
literal|"__builtin_altivec_dstst"
block|,
name|ALTIVEC_BUILTIN_DSTST
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dststt
block|,
literal|"__builtin_altivec_dststt"
block|,
name|ALTIVEC_BUILTIN_DSTSTT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple binary operations: VECc = foo (VECa, VECb).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv16qi3
block|,
literal|"__builtin_altivec_vaddubm"
block|,
name|ALTIVEC_BUILTIN_VADDUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv8hi3
block|,
literal|"__builtin_altivec_vadduhm"
block|,
name|ALTIVEC_BUILTIN_VADDUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv4si3
block|,
literal|"__builtin_altivec_vadduwm"
block|,
name|ALTIVEC_BUILTIN_VADDUWM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv4sf3
block|,
literal|"__builtin_altivec_vaddfp"
block|,
name|ALTIVEC_BUILTIN_VADDFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddcuw
block|,
literal|"__builtin_altivec_vaddcuw"
block|,
name|ALTIVEC_BUILTIN_VADDCUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddubs
block|,
literal|"__builtin_altivec_vaddubs"
block|,
name|ALTIVEC_BUILTIN_VADDUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddsbs
block|,
literal|"__builtin_altivec_vaddsbs"
block|,
name|ALTIVEC_BUILTIN_VADDSBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vadduhs
block|,
literal|"__builtin_altivec_vadduhs"
block|,
name|ALTIVEC_BUILTIN_VADDUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddshs
block|,
literal|"__builtin_altivec_vaddshs"
block|,
name|ALTIVEC_BUILTIN_VADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vadduws
block|,
literal|"__builtin_altivec_vadduws"
block|,
name|ALTIVEC_BUILTIN_VADDUWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddsws
block|,
literal|"__builtin_altivec_vaddsws"
block|,
name|ALTIVEC_BUILTIN_VADDSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_andv4si3
block|,
literal|"__builtin_altivec_vand"
block|,
name|ALTIVEC_BUILTIN_VAND
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vandc
block|,
literal|"__builtin_altivec_vandc"
block|,
name|ALTIVEC_BUILTIN_VANDC
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgub
block|,
literal|"__builtin_altivec_vavgub"
block|,
name|ALTIVEC_BUILTIN_VAVGUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsb
block|,
literal|"__builtin_altivec_vavgsb"
block|,
name|ALTIVEC_BUILTIN_VAVGSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavguh
block|,
literal|"__builtin_altivec_vavguh"
block|,
name|ALTIVEC_BUILTIN_VAVGUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsh
block|,
literal|"__builtin_altivec_vavgsh"
block|,
name|ALTIVEC_BUILTIN_VAVGSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavguw
block|,
literal|"__builtin_altivec_vavguw"
block|,
name|ALTIVEC_BUILTIN_VAVGUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsw
block|,
literal|"__builtin_altivec_vavgsw"
block|,
name|ALTIVEC_BUILTIN_VAVGSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcfux
block|,
literal|"__builtin_altivec_vcfux"
block|,
name|ALTIVEC_BUILTIN_VCFUX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcfsx
block|,
literal|"__builtin_altivec_vcfsx"
block|,
name|ALTIVEC_BUILTIN_VCFSX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpbfp
block|,
literal|"__builtin_altivec_vcmpbfp"
block|,
name|ALTIVEC_BUILTIN_VCMPBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequb
block|,
literal|"__builtin_altivec_vcmpequb"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequh
block|,
literal|"__builtin_altivec_vcmpequh"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequw
block|,
literal|"__builtin_altivec_vcmpequw"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpeqfp
block|,
literal|"__builtin_altivec_vcmpeqfp"
block|,
name|ALTIVEC_BUILTIN_VCMPEQFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgefp
block|,
literal|"__builtin_altivec_vcmpgefp"
block|,
name|ALTIVEC_BUILTIN_VCMPGEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtub
block|,
literal|"__builtin_altivec_vcmpgtub"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsb
block|,
literal|"__builtin_altivec_vcmpgtsb"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtuh
block|,
literal|"__builtin_altivec_vcmpgtuh"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsh
block|,
literal|"__builtin_altivec_vcmpgtsh"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtuw
block|,
literal|"__builtin_altivec_vcmpgtuw"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsw
block|,
literal|"__builtin_altivec_vcmpgtsw"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtfp
block|,
literal|"__builtin_altivec_vcmpgtfp"
block|,
name|ALTIVEC_BUILTIN_VCMPGTFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vctsxs
block|,
literal|"__builtin_altivec_vctsxs"
block|,
name|ALTIVEC_BUILTIN_VCTSXS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vctuxs
block|,
literal|"__builtin_altivec_vctuxs"
block|,
name|ALTIVEC_BUILTIN_VCTUXS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_umaxv16qi3
block|,
literal|"__builtin_altivec_vmaxub"
block|,
name|ALTIVEC_BUILTIN_VMAXUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv16qi3
block|,
literal|"__builtin_altivec_vmaxsb"
block|,
name|ALTIVEC_BUILTIN_VMAXSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv8hi3
block|,
literal|"__builtin_altivec_vmaxuh"
block|,
name|ALTIVEC_BUILTIN_VMAXUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv8hi3
block|,
literal|"__builtin_altivec_vmaxsh"
block|,
name|ALTIVEC_BUILTIN_VMAXSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv4si3
block|,
literal|"__builtin_altivec_vmaxuw"
block|,
name|ALTIVEC_BUILTIN_VMAXUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv4si3
block|,
literal|"__builtin_altivec_vmaxsw"
block|,
name|ALTIVEC_BUILTIN_VMAXSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv4sf3
block|,
literal|"__builtin_altivec_vmaxfp"
block|,
name|ALTIVEC_BUILTIN_VMAXFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghb
block|,
literal|"__builtin_altivec_vmrghb"
block|,
name|ALTIVEC_BUILTIN_VMRGHB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghh
block|,
literal|"__builtin_altivec_vmrghh"
block|,
name|ALTIVEC_BUILTIN_VMRGHH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghw
block|,
literal|"__builtin_altivec_vmrghw"
block|,
name|ALTIVEC_BUILTIN_VMRGHW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglb
block|,
literal|"__builtin_altivec_vmrglb"
block|,
name|ALTIVEC_BUILTIN_VMRGLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglh
block|,
literal|"__builtin_altivec_vmrglh"
block|,
name|ALTIVEC_BUILTIN_VMRGLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglw
block|,
literal|"__builtin_altivec_vmrglw"
block|,
name|ALTIVEC_BUILTIN_VMRGLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv16qi3
block|,
literal|"__builtin_altivec_vminub"
block|,
name|ALTIVEC_BUILTIN_VMINUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv16qi3
block|,
literal|"__builtin_altivec_vminsb"
block|,
name|ALTIVEC_BUILTIN_VMINSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv8hi3
block|,
literal|"__builtin_altivec_vminuh"
block|,
name|ALTIVEC_BUILTIN_VMINUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv8hi3
block|,
literal|"__builtin_altivec_vminsh"
block|,
name|ALTIVEC_BUILTIN_VMINSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv4si3
block|,
literal|"__builtin_altivec_vminuw"
block|,
name|ALTIVEC_BUILTIN_VMINUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv4si3
block|,
literal|"__builtin_altivec_vminsw"
block|,
name|ALTIVEC_BUILTIN_VMINSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv4sf3
block|,
literal|"__builtin_altivec_vminfp"
block|,
name|ALTIVEC_BUILTIN_VMINFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuleub
block|,
literal|"__builtin_altivec_vmuleub"
block|,
name|ALTIVEC_BUILTIN_VMULEUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulesb
block|,
literal|"__builtin_altivec_vmulesb"
block|,
name|ALTIVEC_BUILTIN_VMULESB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuleuh
block|,
literal|"__builtin_altivec_vmuleuh"
block|,
name|ALTIVEC_BUILTIN_VMULEUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulesh
block|,
literal|"__builtin_altivec_vmulesh"
block|,
name|ALTIVEC_BUILTIN_VMULESH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuloub
block|,
literal|"__builtin_altivec_vmuloub"
block|,
name|ALTIVEC_BUILTIN_VMULOUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulosb
block|,
literal|"__builtin_altivec_vmulosb"
block|,
name|ALTIVEC_BUILTIN_VMULOSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulouh
block|,
literal|"__builtin_altivec_vmulouh"
block|,
name|ALTIVEC_BUILTIN_VMULOUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulosh
block|,
literal|"__builtin_altivec_vmulosh"
block|,
name|ALTIVEC_BUILTIN_VMULOSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vnor
block|,
literal|"__builtin_altivec_vnor"
block|,
name|ALTIVEC_BUILTIN_VNOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_iorv4si3
block|,
literal|"__builtin_altivec_vor"
block|,
name|ALTIVEC_BUILTIN_VOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuhum
block|,
literal|"__builtin_altivec_vpkuhum"
block|,
name|ALTIVEC_BUILTIN_VPKUHUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuwum
block|,
literal|"__builtin_altivec_vpkuwum"
block|,
name|ALTIVEC_BUILTIN_VPKUWUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkpx
block|,
literal|"__builtin_altivec_vpkpx"
block|,
name|ALTIVEC_BUILTIN_VPKPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuhss
block|,
literal|"__builtin_altivec_vpkuhss"
block|,
name|ALTIVEC_BUILTIN_VPKUHSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkshss
block|,
literal|"__builtin_altivec_vpkshss"
block|,
name|ALTIVEC_BUILTIN_VPKSHSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuwss
block|,
literal|"__builtin_altivec_vpkuwss"
block|,
name|ALTIVEC_BUILTIN_VPKUWSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkswss
block|,
literal|"__builtin_altivec_vpkswss"
block|,
name|ALTIVEC_BUILTIN_VPKSWSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuhus
block|,
literal|"__builtin_altivec_vpkuhus"
block|,
name|ALTIVEC_BUILTIN_VPKUHUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkshus
block|,
literal|"__builtin_altivec_vpkshus"
block|,
name|ALTIVEC_BUILTIN_VPKSHUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuwus
block|,
literal|"__builtin_altivec_vpkuwus"
block|,
name|ALTIVEC_BUILTIN_VPKUWUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkswus
block|,
literal|"__builtin_altivec_vpkswus"
block|,
name|ALTIVEC_BUILTIN_VPKSWUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlb
block|,
literal|"__builtin_altivec_vrlb"
block|,
name|ALTIVEC_BUILTIN_VRLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlh
block|,
literal|"__builtin_altivec_vrlh"
block|,
name|ALTIVEC_BUILTIN_VRLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlw
block|,
literal|"__builtin_altivec_vrlw"
block|,
name|ALTIVEC_BUILTIN_VRLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslb
block|,
literal|"__builtin_altivec_vslb"
block|,
name|ALTIVEC_BUILTIN_VSLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslh
block|,
literal|"__builtin_altivec_vslh"
block|,
name|ALTIVEC_BUILTIN_VSLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslw
block|,
literal|"__builtin_altivec_vslw"
block|,
name|ALTIVEC_BUILTIN_VSLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsl
block|,
literal|"__builtin_altivec_vsl"
block|,
name|ALTIVEC_BUILTIN_VSL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslo
block|,
literal|"__builtin_altivec_vslo"
block|,
name|ALTIVEC_BUILTIN_VSLO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltb
block|,
literal|"__builtin_altivec_vspltb"
block|,
name|ALTIVEC_BUILTIN_VSPLTB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsplth
block|,
literal|"__builtin_altivec_vsplth"
block|,
name|ALTIVEC_BUILTIN_VSPLTH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltw
block|,
literal|"__builtin_altivec_vspltw"
block|,
name|ALTIVEC_BUILTIN_VSPLTW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrb
block|,
literal|"__builtin_altivec_vsrb"
block|,
name|ALTIVEC_BUILTIN_VSRB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrh
block|,
literal|"__builtin_altivec_vsrh"
block|,
name|ALTIVEC_BUILTIN_VSRH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrw
block|,
literal|"__builtin_altivec_vsrw"
block|,
name|ALTIVEC_BUILTIN_VSRW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrab
block|,
literal|"__builtin_altivec_vsrab"
block|,
name|ALTIVEC_BUILTIN_VSRAB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrah
block|,
literal|"__builtin_altivec_vsrah"
block|,
name|ALTIVEC_BUILTIN_VSRAH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsraw
block|,
literal|"__builtin_altivec_vsraw"
block|,
name|ALTIVEC_BUILTIN_VSRAW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsr
block|,
literal|"__builtin_altivec_vsr"
block|,
name|ALTIVEC_BUILTIN_VSR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsro
block|,
literal|"__builtin_altivec_vsro"
block|,
name|ALTIVEC_BUILTIN_VSRO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv16qi3
block|,
literal|"__builtin_altivec_vsububm"
block|,
name|ALTIVEC_BUILTIN_VSUBUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv8hi3
block|,
literal|"__builtin_altivec_vsubuhm"
block|,
name|ALTIVEC_BUILTIN_VSUBUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv4si3
block|,
literal|"__builtin_altivec_vsubuwm"
block|,
name|ALTIVEC_BUILTIN_VSUBUWM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv4sf3
block|,
literal|"__builtin_altivec_vsubfp"
block|,
name|ALTIVEC_BUILTIN_VSUBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubcuw
block|,
literal|"__builtin_altivec_vsubcuw"
block|,
name|ALTIVEC_BUILTIN_VSUBCUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsububs
block|,
literal|"__builtin_altivec_vsububs"
block|,
name|ALTIVEC_BUILTIN_VSUBUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubsbs
block|,
literal|"__builtin_altivec_vsubsbs"
block|,
name|ALTIVEC_BUILTIN_VSUBSBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubuhs
block|,
literal|"__builtin_altivec_vsubuhs"
block|,
name|ALTIVEC_BUILTIN_VSUBUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubshs
block|,
literal|"__builtin_altivec_vsubshs"
block|,
name|ALTIVEC_BUILTIN_VSUBSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubuws
block|,
literal|"__builtin_altivec_vsubuws"
block|,
name|ALTIVEC_BUILTIN_VSUBUWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubsws
block|,
literal|"__builtin_altivec_vsubsws"
block|,
name|ALTIVEC_BUILTIN_VSUBSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4ubs
block|,
literal|"__builtin_altivec_vsum4ubs"
block|,
name|ALTIVEC_BUILTIN_VSUM4UBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4sbs
block|,
literal|"__builtin_altivec_vsum4sbs"
block|,
name|ALTIVEC_BUILTIN_VSUM4SBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4shs
block|,
literal|"__builtin_altivec_vsum4shs"
block|,
name|ALTIVEC_BUILTIN_VSUM4SHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum2sws
block|,
literal|"__builtin_altivec_vsum2sws"
block|,
name|ALTIVEC_BUILTIN_VSUM2SWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsumsws
block|,
literal|"__builtin_altivec_vsumsws"
block|,
name|ALTIVEC_BUILTIN_VSUMSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_xorv4si3
block|,
literal|"__builtin_altivec_vxor"
block|,
name|ALTIVEC_BUILTIN_VXOR
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AltiVec predicates.  */
end_comment

begin_struct
struct|struct
name|builtin_description_predicates
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|rs6000_builtins
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description_predicates
name|bdesc_altivec_preds
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpbfp."
block|,
literal|"__builtin_altivec_vcmpbfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPBFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpeqfp."
block|,
literal|"__builtin_altivec_vcmpeqfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpgefp."
block|,
literal|"__builtin_altivec_vcmpgefp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGEFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpgtfp."
block|,
literal|"__builtin_altivec_vcmpgtfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpequw."
block|,
literal|"__builtin_altivec_vcmpequw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpgtsw."
block|,
literal|"__builtin_altivec_vcmpgtsw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpgtuw."
block|,
literal|"__builtin_altivec_vcmpgtuw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpgtuh."
block|,
literal|"__builtin_altivec_vcmpgtuh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpgtsh."
block|,
literal|"__builtin_altivec_vcmpgtsh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpequh."
block|,
literal|"__builtin_altivec_vcmpequh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpequb."
block|,
literal|"__builtin_altivec_vcmpequb_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUB_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpgtsb."
block|,
literal|"__builtin_altivec_vcmpgtsb_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSB_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpgtub."
block|,
literal|"__builtin_altivec_vcmpgtub_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUB_P
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ABS* opreations.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_abs
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv4si2
block|,
literal|"__builtin_altivec_abs_v4si"
block|,
name|ALTIVEC_BUILTIN_ABS_V4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv8hi2
block|,
literal|"__builtin_altivec_abs_v8hi"
block|,
name|ALTIVEC_BUILTIN_ABS_V8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv4sf2
block|,
literal|"__builtin_altivec_abs_v4sf"
block|,
name|ALTIVEC_BUILTIN_ABS_V4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv16qi2
block|,
literal|"__builtin_altivec_abs_v16qi"
block|,
name|ALTIVEC_BUILTIN_ABS_V16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v4si
block|,
literal|"__builtin_altivec_abss_v4si"
block|,
name|ALTIVEC_BUILTIN_ABSS_V4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v8hi
block|,
literal|"__builtin_altivec_abss_v8hi"
block|,
name|ALTIVEC_BUILTIN_ABSS_V8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v16qi
block|,
literal|"__builtin_altivec_abss_v16qi"
block|,
name|ALTIVEC_BUILTIN_ABSS_V16QI
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple unary operations: VECb = foo (unsigned literal) or VECb =    foo (VECa).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vexptefp
block|,
literal|"__builtin_altivec_vexptefp"
block|,
name|ALTIVEC_BUILTIN_VEXPTEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vlogefp
block|,
literal|"__builtin_altivec_vlogefp"
block|,
name|ALTIVEC_BUILTIN_VLOGEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrefp
block|,
literal|"__builtin_altivec_vrefp"
block|,
name|ALTIVEC_BUILTIN_VREFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfim
block|,
literal|"__builtin_altivec_vrfim"
block|,
name|ALTIVEC_BUILTIN_VRFIM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfin
block|,
literal|"__builtin_altivec_vrfin"
block|,
name|ALTIVEC_BUILTIN_VRFIN
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfip
block|,
literal|"__builtin_altivec_vrfip"
block|,
name|ALTIVEC_BUILTIN_VRFIP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_ftruncv4sf2
block|,
literal|"__builtin_altivec_vrfiz"
block|,
name|ALTIVEC_BUILTIN_VRFIZ
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrsqrtefp
block|,
literal|"__builtin_altivec_vrsqrtefp"
block|,
name|ALTIVEC_BUILTIN_VRSQRTEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltisb
block|,
literal|"__builtin_altivec_vspltisb"
block|,
name|ALTIVEC_BUILTIN_VSPLTISB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltish
block|,
literal|"__builtin_altivec_vspltish"
block|,
name|ALTIVEC_BUILTIN_VSPLTISH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltisw
block|,
literal|"__builtin_altivec_vspltisw"
block|,
name|ALTIVEC_BUILTIN_VSPLTISW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhsb
block|,
literal|"__builtin_altivec_vupkhsb"
block|,
name|ALTIVEC_BUILTIN_VUPKHSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhpx
block|,
literal|"__builtin_altivec_vupkhpx"
block|,
name|ALTIVEC_BUILTIN_VUPKHPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhsh
block|,
literal|"__builtin_altivec_vupkhsh"
block|,
name|ALTIVEC_BUILTIN_VUPKHSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklsb
block|,
literal|"__builtin_altivec_vupklsb"
block|,
name|ALTIVEC_BUILTIN_VUPKLSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklpx
block|,
literal|"__builtin_altivec_vupklpx"
block|,
name|ALTIVEC_BUILTIN_VUPKLPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklsh
block|,
literal|"__builtin_altivec_vupklsh"
block|,
name|ALTIVEC_BUILTIN_VUPKLSH
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
name|altivec_expand_unop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_abs_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch1
decl_stmt|,
name|scratch2
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
comment|/* If we have invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|scratch1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|scratch2
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|scratch1
argument_list|,
name|scratch2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_binop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_predicate_builtin
parameter_list|(
name|icode
parameter_list|,
name|opcode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
name|opcode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch
decl_stmt|;
name|tree
name|cr6_form
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|SImode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|int
name|cr6_form_int
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cr6_form
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"argument 1 of __builtin_altivec_predicate must be a constant"
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
else|else
name|cr6_form_int
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|cr6_form
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode0
operator|!=
name|mode1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we have invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|scratch
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* The vec_any* and vec_all* predicates use the same opcodes for two      different operations, but the bits in CR6 will be different      depending on what information we want.  So we have to play tricks      with CR6 to get the right bits out.       If you think this is disgusting, look at the specs for the      AltiVec predicates.  */
switch|switch
condition|(
name|cr6_form_int
condition|)
block|{
case|case
literal|0
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_zero
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_zero_reverse
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_lt
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_lt_reverse
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"argument 1 of __builtin_altivec_predicate is out of range"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_stv_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
comment|/* Invalid arguments.  Bail before doing anything stoopid!  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode2
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode0
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode1
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_ternop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
decl_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|struct
name|builtin_description_predicates
modifier|*
name|dp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_16qi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_16qi
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_8hi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_8hi
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_4si
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_4si
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_4sf
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_4sf
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_16qi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_16qi
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_8hi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_8hi
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_4si
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_4si
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_4sf
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_4sf
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_STVX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEBX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvebx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEHX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvehx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEWX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvewx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVXL
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvxl
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_MFVSCR
case|:
name|icode
operator|=
name|CODE_FOR_altivec_mfvscr
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ALTIVEC_BUILTIN_MTVSCR
case|:
name|icode
operator|=
name|CODE_FOR_altivec_mtvscr
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_DSSALL
case|:
name|emit_insn
argument_list|(
name|gen_altivec_dssall
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_DSS
case|:
name|icode
operator|=
name|CODE_FOR_altivec_dss
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_altivec_dss
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Handle DST variants.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_dst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_dst
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
block|{
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
comment|/* Invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|>
literal|3
condition|)
block|{
name|error
argument_list|(
literal|"argument 3 of `%s' must be a 2-bit literal"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* Expand abs* operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_abs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_abs
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_abs_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Handle simple unary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_1arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_1arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Handle simple binary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_2arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Expand the AltiVec predicates.  */
name|dp
operator|=
operator|(
expr|struct
name|builtin_description_predicates
operator|*
operator|)
name|bdesc_altivec_preds
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_altivec_preds
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|dp
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_predicate_builtin
argument_list|(
name|dp
operator|->
name|icode
argument_list|,
name|dp
operator|->
name|opcode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* LV* are funky.  We initialized them differently.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_LVSL
case|:
return|return
name|altivec_expand_binop_builtin
argument_list|(
name|CODE_FOR_altivec_lvsl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVSR
case|:
return|return
name|altivec_expand_binop_builtin
argument_list|(
name|CODE_FOR_altivec_lvsr
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEBX
case|:
return|return
name|altivec_expand_binop_builtin
argument_list|(
name|CODE_FOR_altivec_lvebx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEHX
case|:
return|return
name|altivec_expand_binop_builtin
argument_list|(
name|CODE_FOR_altivec_lvehx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEWX
case|:
return|return
name|altivec_expand_binop_builtin
argument_list|(
name|CODE_FOR_altivec_lvewx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVXL
case|:
return|return
name|altivec_expand_binop_builtin
argument_list|(
name|CODE_FOR_altivec_lvxl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVX
case|:
return|return
name|altivec_expand_binop_builtin
argument_list|(
name|CODE_FOR_altivec_lvx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
default|default:
break|break;
comment|/* Fall through.  */
block|}
comment|/* Handle simple ternary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_3arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_3arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_ternop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
return|return
name|altivec_expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_init_builtins
parameter_list|()
block|{
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
name|altivec_init_builtins
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|altivec_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|struct
name|builtin_description_predicates
modifier|*
name|dp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
name|tree
name|pint_type_node
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pvoid_type_node
init|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
decl_stmt|;
name|tree
name|pshort_type_node
init|=
name|build_pointer_type
argument_list|(
name|short_integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|tree
name|pfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|float_type_node
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v16qi
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_v16qi
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_v16qi
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi_v16qi
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V4SI foo (char).  */
name|tree
name|v4si_ftype_char
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V8HI foo (char).  */
name|tree
name|v8hi_ftype_char
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V16QI foo (char).  */
name|tree
name|v16qi_ftype_char
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V4SF foo (V4SF).  */
name|tree
name|v4sf_ftype_v4sf
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V4SI foo (int *).  */
name|tree
name|v4si_ftype_pint
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pint_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V8HI foo (short *).  */
name|tree
name|v8hi_ftype_pshort
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pshort_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V16QI foo (char *).  */
name|tree
name|v16qi_ftype_pchar
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pchar_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V4SF foo (float *).  */
name|tree
name|v4sf_ftype_pfloat
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pfloat_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* V8HI foo (V16QI).  */
name|tree
name|v8hi_ftype_v16qi
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (void *, int, char/literal).  */
name|tree
name|void_ftype_pvoid_int_char
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pvoid_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (int *, V4SI).  */
name|tree
name|void_ftype_pint_v4si
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pint_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (short *, V8HI).  */
name|tree
name|void_ftype_pshort_v8hi
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pshort_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (char *, V16QI).  */
name|tree
name|void_ftype_pchar_v16qi
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pchar_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (float *, V4SF).  */
name|tree
name|void_ftype_pfloat_v4sf
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pfloat_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (V4SI).  */
name|tree
name|void_ftype_v4si
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (vint, int, void *).  */
name|tree
name|void_ftype_v4si_int_pvoid
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pvoid_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (vchar, int, void *).  */
name|tree
name|void_ftype_v16qi_int_pvoid
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pvoid_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (vshort, int, void *).  */
name|tree
name|void_ftype_v8hi_int_pvoid
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pvoid_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (char).  */
name|tree
name|void_ftype_qi
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* void foo (void).  */
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
comment|/* vshort foo (void).  */
name|tree
name|v8hi_ftype_void
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* These are for the unsigned 5 bit literals.  */
name|tree
name|v4sf_ftype_v4si_char
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_char
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_char
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_char
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_char
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* These are for the unsigned 4 bit literals.  */
name|tree
name|v16qi_ftype_v16qi_v16qi_char
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_char
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_char
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_char
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* End of 4 bit literals.  */
name|tree
name|v4sf_ftype_v4sf_v4sf
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v4si
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v4sf
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_v4si
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_v8hi
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v8hi_v4si
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v16qi_v4si
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_v4sf
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v16qi_v16qi
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v8hi
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v4si_v4si
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v8hi_v8hi
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v4si
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v16qi
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v4si
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4si_v4si
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4sf_v4sf
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v16qi_v16qi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v4si_v4si
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v4sf_v4sf
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v8hi_v8hi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v16qi_v16qi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V16QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_int_pvoid
init|=
name|build_function_type
argument_list|(
name|V16QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pvoid_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_int_pvoid
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pvoid_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_int_pvoid
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pvoid_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8hi_v8hi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_4sf"
argument_list|,
name|v4sf_ftype_pfloat
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_4sf
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_4sf"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_4sf
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_4si"
argument_list|,
name|v4si_ftype_pint
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_4si
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_4si"
argument_list|,
name|void_ftype_pint_v4si
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_4si
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_8hi"
argument_list|,
name|v8hi_ftype_pshort
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_8hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_8hi"
argument_list|,
name|void_ftype_pshort_v8hi
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_8hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_16qi"
argument_list|,
name|v16qi_ftype_pchar
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_16qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_16qi"
argument_list|,
name|void_ftype_pchar_v16qi
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_16qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_mtvscr"
argument_list|,
name|void_ftype_v4si
argument_list|,
name|ALTIVEC_BUILTIN_MTVSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_mfvscr"
argument_list|,
name|v8hi_ftype_void
argument_list|,
name|ALTIVEC_BUILTIN_MFVSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_dssall"
argument_list|,
name|void_ftype_void
argument_list|,
name|ALTIVEC_BUILTIN_DSSALL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_dss"
argument_list|,
name|void_ftype_qi
argument_list|,
name|ALTIVEC_BUILTIN_DSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvsl"
argument_list|,
name|v16qi_ftype_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVSL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvsr"
argument_list|,
name|v16qi_ftype_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvebx"
argument_list|,
name|v16qi_ftype_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEBX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvehx"
argument_list|,
name|v8hi_ftype_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvewx"
argument_list|,
name|v4si_ftype_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvxl"
argument_list|,
name|v4si_ftype_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVXL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvx"
argument_list|,
name|v4si_ftype_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvx"
argument_list|,
name|void_ftype_v4si_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvebx"
argument_list|,
name|void_ftype_v16qi_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEBX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvehx"
argument_list|,
name|void_ftype_v8hi_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvewx"
argument_list|,
name|void_ftype_v4si_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvxl"
argument_list|,
name|void_ftype_v4si_int_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVXL
argument_list|)
expr_stmt|;
comment|/* Add the simple ternary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_3arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_3arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|,
name|mode3
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode3
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
comment|/* When all four are of the same mode.  */
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
operator|&&
name|mode2
operator|==
name|mode3
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_v16qi
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
operator|&&
name|mode3
operator|==
name|V16QImode
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_v16qi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_v16qi
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v16qi_v4si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v8hi_v4si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|V4SFmode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v4si
expr_stmt|;
comment|/* vchar, vchar, vchar, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_char
expr_stmt|;
comment|/* vshort, vshort, vshort, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_char
expr_stmt|;
comment|/* vint, vint, vint, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4si_v4si_char
expr_stmt|;
comment|/* vfloat, vfloat, vfloat, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_char
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the DST variants.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_dst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_dst
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|void_ftype_pvoid_int_char
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
comment|/* Initialize the predicates.  */
name|dp
operator|=
operator|(
expr|struct
name|builtin_description_predicates
operator|*
operator|)
name|bdesc_altivec_preds
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_altivec_preds
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|dp
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|dp
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode1
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|int_ftype_int_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|int_ftype_int_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|int_ftype_int_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|int_ftype_int_v4sf_v4sf
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|dp
operator|->
name|mask
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|dp
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the simple binary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_2arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
comment|/* When all three operands are of the same mode.  */
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* A few other combos we really don't want to do manually.  */
comment|/* vint, vfloat, vfloat.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|V4SFmode
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_v4sf
expr_stmt|;
comment|/* vshort, vchar, vchar.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v16qi_v16qi
expr_stmt|;
comment|/* vint, vshort, vshort.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v8hi
expr_stmt|;
comment|/* vshort, vint, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v8hi_ftype_v4si_v4si
expr_stmt|;
comment|/* vchar, vshort, vshort.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v16qi_ftype_v8hi_v8hi
expr_stmt|;
comment|/* vint, vchar, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v4si
expr_stmt|;
comment|/* vint, vchar, vchar.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v16qi
expr_stmt|;
comment|/* vint, vshort, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v4si
expr_stmt|;
comment|/* vint, vint, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4si_char
expr_stmt|;
comment|/* vshort, vshort, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v8hi_char
expr_stmt|;
comment|/* vchar, vchar, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_v16qi_char
expr_stmt|;
comment|/* vfloat, vint, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4si_char
expr_stmt|;
comment|/* vint, vfloat, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_char
expr_stmt|;
comment|/* int, x, x.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|SImode
condition|)
block|{
switch|switch
condition|(
name|mode1
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|int_ftype_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|int_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|int_ftype_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|int_ftype_v8hi_v8hi
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the abs* operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_abs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_abs
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the simple unary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_1arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_1arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_char
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_char
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_char
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SFmode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v16qi
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a memory reference for expand_block_move, copying volatile,    and other bits from an original memory reference.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_block_move_mem
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|,
name|orig_mem
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|rtx
name|orig_mem
decl_stmt|;
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|mem
argument_list|,
name|orig_mem
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* Expand a block move operation, and return 1 if successful.  Return 0    if we should let the compiler generate normal code.     operands[0] is the destination    operands[1] is the source    operands[2] is the length    operands[3] is the alignment */
end_comment

begin_define
define|#
directive|define
name|MAX_MOVE_REG
value|4
end_define

begin_function
name|int
name|expand_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|orig_dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|orig_src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|constp
init|=
operator|(
name|GET_CODE
argument_list|(
name|bytes_rtx
argument_list|)
operator|==
name|CONST_INT
operator|)
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|num_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|rtx
name|tmp_reg
decl_stmt|;
name|rtx
name|stores
index|[
name|MAX_MOVE_REG
index|]
decl_stmt|;
name|int
name|move_bytes
decl_stmt|;
comment|/* If this is not a fixed size move, just call memcpy */
if|if
condition|(
operator|!
name|constp
condition|)
return|return
literal|0
return|;
comment|/* If this is not a fixed size alignment, abort */
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
expr_stmt|;
comment|/* Anything to move? */
name|bytes
operator|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* store_one_arg depends on expand_block_move to handle at least the size of      reg_parm_stack_space.  */
if|if
condition|(
name|bytes
operator|>
operator|(
name|TARGET_POWERPC64
condition|?
literal|64
else|:
literal|32
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Move the address into scratch registers.  */
name|dest_reg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src_reg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|orig_src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_STRING
condition|)
comment|/* string instructions are available */
block|{
for|for
control|(
init|;
name|bytes
operator|>
literal|0
condition|;
name|bytes
operator|-=
name|move_bytes
control|)
block|{
if|if
condition|(
name|bytes
operator|>
literal|24
comment|/* move up to 32 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|9
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|10
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|11
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|12
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|32
operator|)
condition|?
literal|32
else|:
name|bytes
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movstrsi_8reg
argument_list|(
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|move_bytes
operator|==
literal|32
operator|)
condition|?
literal|0
else|:
name|move_bytes
argument_list|)
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>
literal|16
comment|/* move up to 24 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|9
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|10
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|24
operator|)
condition|?
literal|24
else|:
name|bytes
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movstrsi_6reg
argument_list|(
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>
literal|8
comment|/* move up to 16 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|16
operator|)
condition|?
literal|16
else|:
name|bytes
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movstrsi_4reg
argument_list|(
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|8
operator|&&
name|TARGET_POWERPC64
comment|/* 64-bit loads and stores require word-aligned                       displacements.  */
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|)
condition|)
block|{
name|move_bytes
operator|=
literal|8
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp_reg
argument_list|,
name|expand_block_move_mem
argument_list|(
name|DImode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|expand_block_move_mem
argument_list|(
name|DImode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>
literal|4
operator|&&
operator|!
name|TARGET_POWERPC64
condition|)
block|{
comment|/* move up to 8 bytes at a time */
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|8
operator|)
condition|?
literal|8
else|:
name|bytes
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movstrsi_2reg
argument_list|(
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|4
operator|&&
operator|(
name|align
operator|>=
literal|4
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
comment|/* move 4 bytes */
name|move_bytes
operator|=
literal|4
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp_reg
argument_list|,
name|expand_block_move_mem
argument_list|(
name|SImode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|expand_block_move_mem
argument_list|(
name|SImode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|==
literal|2
operator|&&
operator|(
name|align
operator|>=
literal|2
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
comment|/* move 2 bytes */
name|move_bytes
operator|=
literal|2
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp_reg
argument_list|,
name|expand_block_move_mem
argument_list|(
name|HImode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|expand_block_move_mem
argument_list|(
name|HImode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|==
literal|1
condition|)
comment|/* move 1 byte */
block|{
name|move_bytes
operator|=
literal|1
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp_reg
argument_list|,
name|expand_block_move_mem
argument_list|(
name|QImode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|expand_block_move_mem
argument_list|(
name|QImode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* move up to 4 bytes at a time */
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|4
operator|)
condition|?
literal|4
else|:
name|bytes
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movstrsi_1reg
argument_list|(
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|dest_reg
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|expand_block_move_mem
argument_list|(
name|BLKmode
argument_list|,
name|src_reg
argument_list|,
name|orig_src
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>
name|move_bytes
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_POWERPC64
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|src_reg
argument_list|,
name|src_reg
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dest_reg
argument_list|,
name|dest_reg
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|src_reg
argument_list|,
name|src_reg
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|dest_reg
argument_list|,
name|dest_reg
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
comment|/* string instructions not available */
block|{
name|num_reg
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bytes
operator|>
literal|0
condition|;
operator|(
name|bytes
operator|-=
name|move_bytes
operator|)
operator|,
operator|(
name|offset
operator|+=
name|move_bytes
operator|)
control|)
block|{
comment|/* Calculate the correct offset for src/dest */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|src_addr
operator|=
name|src_reg
expr_stmt|;
name|dest_addr
operator|=
name|dest_reg
expr_stmt|;
block|}
else|else
block|{
name|src_addr
operator|=
name|plus_constant
argument_list|(
name|src_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|plus_constant
argument_list|(
name|dest_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the appropriate load and store, saving the stores 	     for later.  */
if|if
condition|(
name|bytes
operator|>=
literal|8
operator|&&
name|TARGET_POWERPC64
comment|/* 64-bit loads and stores require word-aligned                  displacements.  */
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|)
condition|)
block|{
name|move_bytes
operator|=
literal|8
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movdi
argument_list|(
name|tmp_reg
argument_list|,
name|expand_block_move_mem
argument_list|(
name|DImode
argument_list|,
name|src_addr
argument_list|,
name|orig_src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stores
index|[
name|num_reg
operator|++
index|]
operator|=
name|gen_movdi
argument_list|(
name|expand_block_move_mem
argument_list|(
name|DImode
argument_list|,
name|dest_addr
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|4
operator|&&
operator|(
name|align
operator|>=
literal|4
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
name|move_bytes
operator|=
literal|4
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|tmp_reg
argument_list|,
name|expand_block_move_mem
argument_list|(
name|SImode
argument_list|,
name|src_addr
argument_list|,
name|orig_src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stores
index|[
name|num_reg
operator|++
index|]
operator|=
name|gen_movsi
argument_list|(
name|expand_block_move_mem
argument_list|(
name|SImode
argument_list|,
name|dest_addr
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|2
operator|&&
operator|(
name|align
operator|>=
literal|2
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
name|move_bytes
operator|=
literal|2
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|tmp_reg
argument_list|,
name|expand_block_move_mem
argument_list|(
name|HImode
argument_list|,
name|src_addr
argument_list|,
name|orig_src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stores
index|[
name|num_reg
operator|++
index|]
operator|=
name|gen_movhi
argument_list|(
name|expand_block_move_mem
argument_list|(
name|HImode
argument_list|,
name|dest_addr
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|move_bytes
operator|=
literal|1
expr_stmt|;
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|tmp_reg
argument_list|,
name|expand_block_move_mem
argument_list|(
name|QImode
argument_list|,
name|src_addr
argument_list|,
name|orig_src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stores
index|[
name|num_reg
operator|++
index|]
operator|=
name|gen_movqi
argument_list|(
name|expand_block_move_mem
argument_list|(
name|QImode
argument_list|,
name|dest_addr
argument_list|,
name|orig_dest
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_reg
operator|>=
name|MAX_MOVE_REG
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_reg
condition|;
name|i
operator|++
control|)
name|emit_insn
argument_list|(
name|stores
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|num_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_reg
condition|;
name|i
operator|++
control|)
name|emit_insn
argument_list|(
name|stores
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a load multiple operation.  It is known to be a    PARALLEL and the first section will be tested.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similar, but tests for store multiple.  Here, the second vector element    is a CLOBBER.  It will be tested later.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for a parallel vrsave operation.  */
end_comment

begin_function
name|int
name|vrsave_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|,
name|src_regno
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNSPEC_VOLATILE
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|!=
name|VRSAVE_REGNO
operator|&&
name|src_regno
operator|!=
name|VRSAVE_REGNO
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an PARALLEL suitable for mtcrf.  */
end_comment

begin_function
name|int
name|mtcrf_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XVECLEN
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
return|return
literal|0
return|;
name|src_reg
operator|=
name|XVECEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_reg
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|src_reg
argument_list|)
operator|!=
name|SImode
operator|||
operator|!
name|INT_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|src_reg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|exp
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|unspec
decl_stmt|;
name|int
name|maskval
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|CCmode
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|unspec
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|maskval
operator|=
literal|1
operator|<<
operator|(
name|MAX_CR_REGNO
operator|-
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|unspec
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|unspec
argument_list|,
literal|1
argument_list|)
operator|!=
literal|20
operator|||
name|XVECLEN
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
operator|||
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|src_reg
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|maskval
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an PARALLEL suitable for lmw.  */
end_comment

begin_function
name|int
name|lmw_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|unsigned
name|int
name|base_regno
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|>
literal|31
operator|||
name|count
operator|!=
literal|32
operator|-
operator|(
name|int
operator|)
name|dest_regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|LEGITIMATE_INDIRECT_ADDRESS_P
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|src_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_regno
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|LEGITIMATE_OFFSET_ADDRESS_P
argument_list|(
name|SImode
argument_list|,
name|src_addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|newaddr
decl_stmt|;
name|rtx
name|addr_reg
decl_stmt|;
name|HOST_WIDE_INT
name|newoffset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
condition|)
return|return
literal|0
return|;
name|newaddr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|LEGITIMATE_INDIRECT_ADDRESS_P
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|newoffset
operator|=
literal|0
expr_stmt|;
name|addr_reg
operator|=
name|newaddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LEGITIMATE_OFFSET_ADDRESS_P
argument_list|(
name|SImode
argument_list|,
name|newaddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|addr_reg
operator|=
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newoffset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|addr_reg
argument_list|)
operator|!=
name|base_regno
operator|||
name|newoffset
operator|!=
name|offset
operator|+
literal|4
operator|*
name|i
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an PARALLEL suitable for stmw.  */
end_comment

begin_function
name|int
name|stmw_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|unsigned
name|int
name|base_regno
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_regno
operator|>
literal|31
operator|||
name|count
operator|!=
literal|32
operator|-
operator|(
name|int
operator|)
name|src_regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|LEGITIMATE_INDIRECT_ADDRESS_P
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|dest_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_regno
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|LEGITIMATE_OFFSET_ADDRESS_P
argument_list|(
name|SImode
argument_list|,
name|dest_addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|newaddr
decl_stmt|;
name|rtx
name|addr_reg
decl_stmt|;
name|HOST_WIDE_INT
name|newoffset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
condition|)
return|return
literal|0
return|;
name|newaddr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|LEGITIMATE_INDIRECT_ADDRESS_P
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|newoffset
operator|=
literal|0
expr_stmt|;
name|addr_reg
operator|=
name|newaddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LEGITIMATE_OFFSET_ADDRESS_P
argument_list|(
name|SImode
argument_list|,
name|newaddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|addr_reg
operator|=
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newoffset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|addr_reg
argument_list|)
operator|!=
name|base_regno
operator|||
name|newoffset
operator|!=
name|offset
operator|+
literal|4
operator|*
name|i
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A validation routine: say whether CODE, a condition code, and MODE    match.  The other alternatives either don't make sense or should    never be generated.  */
end_comment

begin_function
specifier|static
name|void
name|validate_condition_mode
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* These don't make sense.  */
if|if
condition|(
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LE
operator|)
operator|&&
name|mode
operator|==
name|CCUNSmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|)
operator|&&
name|mode
operator|!=
name|CCUNSmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|CCFPmode
operator|&&
operator|(
name|code
operator|==
name|ORDERED
operator|||
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNLT
operator|||
name|code
operator|==
name|UNGE
operator|||
name|code
operator|==
name|UNLE
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* These should never be generated except for       flag_unsafe_math_optimizations.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|&&
operator|!
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNLT
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* These are invalid; the information is not there.  */
if|if
condition|(
name|mode
operator|==
name|CCEQmode
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|NE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operation that is valid for a branch insn.    We only check the opcode against the mode of the CC value here.  */
end_comment

begin_function
name|int
name|branch_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|cc_mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
literal|0
return|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|cc_mode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operation that is valid for a branch    insn and which is true if the corresponding bit in the CC register    is set.  */
end_comment

begin_function
name|int
name|branch_positive_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|branch_comparison_operator
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|UNORDERED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operation that is valid for an scc insn.    We check the opcode against the mode of the CC value and disallow EQ or    NE comparisons for integers.  */
end_comment

begin_function
name|int
name|scc_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|cc_mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
literal|0
return|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|cc_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|cc_mode
operator|!=
name|CCFPmode
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|trap_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'<'
return|;
block|}
end_function

begin_function
name|int
name|boolean_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|)
return|;
block|}
end_function

begin_function
name|int
name|boolean_or_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|)
return|;
block|}
end_function

begin_function
name|int
name|min_max_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|SMIN
operator|||
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|UMIN
operator|||
name|code
operator|==
name|UMAX
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if ANDOP is a mask that has no bits on that are not in the    mask required to convert the result of a rotate insn into a shift    left insn of SHIFTOP bits.  Both are known to be SImode CONST_INT.  */
end_comment

begin_function
name|int
name|includes_lshift_p
parameter_list|(
name|shiftop
parameter_list|,
name|andop
parameter_list|)
name|rtx
name|shiftop
decl_stmt|;
name|rtx
name|andop
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
decl_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTVAL
argument_list|(
name|andop
argument_list|)
operator|&
literal|0xffffffff
operator|&
operator|~
name|shift_mask
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar, but for right shift.  */
end_comment

begin_function
name|int
name|includes_rshift_p
parameter_list|(
name|shiftop
parameter_list|,
name|andop
parameter_list|)
name|rtx
name|shiftop
decl_stmt|;
name|rtx
name|andop
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
decl_stmt|;
name|shift_mask
operator|>>=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTVAL
argument_list|(
name|andop
argument_list|)
operator|&
literal|0xffffffff
operator|&
operator|~
name|shift_mask
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ANDOP is a mask suitable for use with an rldic insn    to perform a left shift.  It must have exactly SHIFTOP least    signifigant 0's, then one or more 1's, then zero or more 0's.  */
end_comment

begin_function
name|int
name|includes_rldic_lshift_p
parameter_list|(
name|shiftop
parameter_list|,
name|andop
parameter_list|)
name|rtx
name|shiftop
decl_stmt|;
name|rtx
name|andop
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask
decl_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
operator|~
literal|0
condition|)
return|return
literal|0
return|;
name|shift_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
comment|/* Find the least signifigant one bit.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* It must coincide with the LSB of the shift mask.  */
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask
condition|)
return|return
literal|0
return|;
comment|/* Invert to look for the next transition (if any).  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Remove the low group of ones (originally low group of zeros).  */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/* Again find the lsb, and check we have all 1's above.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|DImode
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|,
name|lsb
decl_stmt|;
name|HOST_WIDE_INT
name|shift_mask_low
decl_stmt|,
name|shift_mask_high
decl_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|low
operator|==
operator|~
literal|0
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
operator|~
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|&&
name|low
operator|==
literal|0
condition|)
block|{
name|shift_mask_high
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|>
literal|32
condition|)
name|shift_mask_high
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|-
literal|32
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask_high
operator|||
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
name|high
operator|=
operator|~
name|high
expr_stmt|;
name|high
operator|&=
operator|-
name|lsb
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
name|shift_mask_low
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask_low
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask_low
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
name|high
operator|=
operator|~
name|high
expr_stmt|;
name|low
operator|=
operator|~
name|low
expr_stmt|;
name|low
operator|&=
operator|-
name|lsb
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|&&
name|low
operator|==
literal|0
condition|)
block|{
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
return|return
name|low
operator|==
operator|-
name|lsb
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
operator|~
literal|0
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ANDOP is a mask suitable for use with an rldicr insn    to perform a left shift.  It must have SHIFTOP or more least    signifigant 0's, with the remainder of the word 1's.  */
end_comment

begin_function
name|int
name|includes_rldicr_lshift_p
parameter_list|(
name|shiftop
parameter_list|,
name|andop
parameter_list|)
name|rtx
name|shiftop
decl_stmt|;
name|rtx
name|andop
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask
decl_stmt|;
name|shift_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|andop
argument_list|)
expr_stmt|;
comment|/* Find the least signifigant one bit.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* It must be covered by the shift mask. 	 This test also rejects c == 0.  */
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check we have all 1's above the transition, and reject all 1's.  */
return|return
name|c
operator|==
operator|-
name|lsb
operator|&&
name|lsb
operator|!=
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|DImode
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask_low
decl_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
block|{
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|shift_mask_high
decl_stmt|;
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
block|{
name|shift_mask_high
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|>
literal|32
condition|)
name|shift_mask_high
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|-
literal|32
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask_high
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
if|if
condition|(
name|high
operator|!=
operator|~
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|shift_mask_low
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask_low
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask_low
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|low
operator|==
operator|-
name|lsb
operator|&&
name|lsb
operator|!=
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if REGNO (reg1) == REGNO (reg2) - 1 making them candidates    for lfq and stfq insns.     Note reg1 and reg2 *must* be hard registers.  To be sure we will    abort if we are passed pseudo registers.  */
end_comment

begin_function
name|int
name|registers_ok_for_quad_peep
parameter_list|(
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg2
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if addr1 and addr2 are suitable for lfq or stfq insn.    addr1 and addr2 must be in consecutive memory locations    (addr2 == addr1 + 8).  */
end_comment

begin_function
name|int
name|addrs_ok_for_quad_peep
parameter_list|(
name|addr1
parameter_list|,
name|addr2
parameter_list|)
name|rtx
name|addr1
decl_stmt|;
name|rtx
name|addr2
decl_stmt|;
block|{
name|unsigned
name|int
name|reg1
decl_stmt|;
name|int
name|offset1
decl_stmt|;
comment|/* Extract an offset (if used) from the first addr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* If not a REG, return zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset must be constant!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
comment|/* This was a simple (mem (reg)) expression.  Offset is 0.  */
name|offset1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure the second address is a (mem (plus (reg) (const_int))).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg1
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The offset for the second addr must be 8 more than the first addr.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|offset1
operator|+
literal|8
condition|)
return|return
literal|0
return|;
comment|/* All the tests passed.  addr1 and addr2 are valid for lfq or stfq      instructions.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the register class of a scratch register needed to copy IN into    or out of a register in CLASS in MODE.  If it can be done directly,    NO_REGS is returned.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
condition|)
block|{
comment|/* We cannot copy a symbolic operand directly into anything          other than BASE_REGS for TARGET_ELF.  So indicate that a          register from BASE_REGS is needed as an intermediate          register.           	 On Darwin, pic addresses require a load from memory, which 	 needs a base register.  */
if|if
condition|(
name|class
operator|!=
name|BASE_REGS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|HIGH
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|CONST
operator|)
condition|)
return|return
name|BASE_REGS
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|regno
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We can place anything into GENERAL_REGS and can put GENERAL_REGS      into anything.  */
if|if
condition|(
name|class
operator|==
name|GENERAL_REGS
operator|||
name|class
operator|==
name|BASE_REGS
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|INT_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Constants, memory, and FP registers can go into FP registers.  */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|&&
operator|(
name|class
operator|==
name|FLOAT_REGS
operator|||
name|class
operator|==
name|NON_SPECIAL_REGS
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Memory, and AltiVec registers can go into AltiVec registers.  */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|ALTIVEC_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|&&
name|class
operator|==
name|ALTIVEC_REGS
condition|)
return|return
name|NO_REGS
return|;
comment|/* We can copy among the CR registers.  */
if|if
condition|(
operator|(
name|class
operator|==
name|CR_REGS
operator|||
name|class
operator|==
name|CR0_REGS
operator|)
operator|&&
name|regno
operator|>=
literal|0
operator|&&
name|CR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Otherwise, we need GENERAL_REGS.  */
return|return
name|GENERAL_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison operation, return the bit number in CCR to test.  We    know this is a valid comparison.       SCC_P is 1 if this is for an scc.  That means that %D will have been    used instead of %C, so the bits will be in different places.     Return -1 if OP isn't a valid comparison for some reason.  */
end_comment

begin_function
name|int
name|ccr_bit
parameter_list|(
name|op
parameter_list|,
name|scc_p
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|scc_p
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
name|int
name|cc_regnum
decl_stmt|;
name|int
name|base_bit
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
operator|-
literal|1
return|;
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cc_regnum
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|base_bit
operator|=
literal|4
operator|*
operator|(
name|cc_regnum
operator|-
name|CR0_REGNO
operator|)
expr_stmt|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|cc_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
operator|+
literal|2
return|;
case|case
name|EQ
case|:
return|return
name|base_bit
operator|+
literal|2
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNLE
case|:
return|return
name|base_bit
operator|+
literal|1
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNGE
case|:
return|return
name|base_bit
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
return|return
name|base_bit
operator|+
literal|3
return|;
case|case
name|GE
case|:
case|case
name|GEU
case|:
comment|/* If scc, we will have done a cror to put the bit in the 	 unordered position.  So test that bit.  For integer, this is ! LT 	 unless this is an scc insn.  */
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
return|;
case|case
name|LE
case|:
case|case
name|LEU
case|:
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
operator|+
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the GOT register.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|rs6000_got_register
parameter_list|(
name|value
parameter_list|)
name|rtx
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* The second flow pass currently (June 1999) can't update      regs_ever_live without disturbing other parts of the compiler, so      update it here to make the prolog/epilogue code happy.  */
if|if
condition|(
name|no_new_pseudos
operator|&&
operator|!
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|pic_offset_table_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to init, mark and free struct machine_function.    These will be called, via pointer variables,    from push_function_context and pop_function_context.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_init_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|machine
operator|=
operator|(
name|machine_function
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_free_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|machine
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|p
operator|->
name|machine
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_define
define|#
directive|define
name|SMALL_DATA_RELOC
value|((rs6000_sdata == SDATA_EABI) ? "sda21" : "sdarel")
end_define

begin_define
define|#
directive|define
name|SMALL_DATA_REG
value|((rs6000_sdata == SDATA_EABI) ? 0 : 13)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SMALL_DATA_RELOC
value|"sda21"
end_define

begin_define
define|#
directive|define
name|SMALL_DATA_REG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
comment|/* These macros test for integers and extract the low-order bits.  */
define|#
directive|define
name|INT_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)	\&& GET_MODE (X) == VOIDmode)
define|#
directive|define
name|INT_LOWPART
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Write out an instruction after the call which may be replaced 	 with glue code by the loader.  This depends on the AIX version.  */
name|asm_fprintf
argument_list|(
name|file
argument_list|,
name|RS6000_CALL_GLUE
argument_list|)
expr_stmt|;
return|return;
comment|/* %a is output_address.  */
case|case
literal|'A'
case|:
comment|/* If X is a constant integer whose low-order 5 bits are zero, 	 write 'l'.  Otherwise, write 'r'.  This is a kludge to fix a bug 	 in the AIX assembler where "sri" with a zero shift count 	 writes a trash instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|31
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'r'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'b'
case|:
comment|/* If constant, low-order 16 bits of constant, unsigned. 	 Otherwise, write normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
comment|/* If the low-order bit is zero, write 'r'; otherwise, write 'l' 	 for 64-bit mask direction.  */
name|putc
argument_list|(
operator|(
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
literal|'r'
else|:
literal|'l'
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise 	 output_operand.  */
case|case
literal|'D'
case|:
comment|/* There used to be a comment for 'C' reading "This is an 	   optional cror needed for certain floating-point 	   comparisons.  Otherwise write nothing."  */
comment|/* Similar, except that this is for an scc, so we must be able to 	 encode the test in a single bit that is one.  We do the above 	 for any LE, GE, GEU, or LEU and invert the bit for NE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LEU
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GEU
condition|)
block|{
name|int
name|base_bit
init|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
name|CR0_REGNO
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"cror %d,%d,%d\n\t"
argument_list|,
name|base_bit
operator|+
literal|3
argument_list|,
name|base_bit
operator|+
literal|2
argument_list|,
name|base_bit
operator|+
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GEU
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NE
condition|)
block|{
name|int
name|base_bit
init|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
name|CR0_REGNO
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"crnor %d,%d,%d\n\t"
argument_list|,
name|base_bit
operator|+
literal|3
argument_list|,
name|base_bit
operator|+
literal|2
argument_list|,
name|base_bit
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'E'
case|:
comment|/* X is a CR register.  Print the number of the EQ bit of the CR */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'f'
case|:
comment|/* X is a CR register.  Print the shift count needed to move it 	 to the high-order four bits.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%f value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* Similar, but print the count for the rotate in the opposite 	 direction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%F value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|32
operator|-
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'G'
case|:
comment|/* X is a constant integer.  If it is negative, print "m", 	 otherwise print "z".  This is to make a aze or ame insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%G value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
condition|)
name|putc
argument_list|(
literal|'z'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'m'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'h'
case|:
comment|/* If constant, output low-order five bits.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|31
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* If constant, output low-order six bits.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|63
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
comment|/* Print `i' if this is a constant, else nothing.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|putc
argument_list|(
literal|'i'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'j'
case|:
comment|/* Write the bit number in CCR for jump.  */
name|i
operator|=
name|ccr_bit
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%j code"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
comment|/* Similar, but add one for shift count in rlinm for scc and pass 	 scc flag to `ccr_bit'.  */
name|i
operator|=
name|ccr_bit
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%J code"
argument_list|)
expr_stmt|;
else|else
comment|/* If we want bit 31, write a shift count of zero, not 32.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|==
literal|31
condition|?
literal|0
else|:
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'k'
case|:
comment|/* X must be a constant.  Write the 1's complement of the 	 constant.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%k value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|~
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'K'
case|:
comment|/* X must be a symbolic constant on ELF.  Write an 	 expression suitable for an 'addi' that adds in the low 16 	 bits of the MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
block|{
name|print_operand_address
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%K value"
argument_list|)
expr_stmt|;
name|print_operand_address
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_operand
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* %l is output_asm_label.  */
case|case
literal|'L'
case|:
comment|/* Write second word of DImode or DFmode reference.  Works on register 	 or non-indexed memory only.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Handle possible auto-increment.  Since it is pre-increment and 	     we have already done it, we can just use an offset of word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'m'
case|:
comment|/* MB value for a mask operand.  */
if|if
condition|(
operator|!
name|mask_operand
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
name|val
operator|=
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If the high bit is set and the low bit is not, the value is zero. 	 If the high bit is zero, the value is the first 1 bit we find from 	 the left.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|&&
operator|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|putc
argument_list|(
literal|'0'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|&
literal|0x80000000
condition|)
break|break;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, look for the first 0 bit from the right.  The result is its 	 number plus 1. We know the low-order bit is one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* If we ended in ...01, i would be 0.  The correct value is 31, so 	 we want 31 - i.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|31
operator|-
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
comment|/* ME value for a mask operand.  */
if|if
condition|(
operator|!
name|mask_operand
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|val
operator|=
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If the low bit is set and the high bit is not, the value is 31. 	 If the low bit is zero, the value is the first 1 bit we find from 	 the right.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|&&
operator|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"31"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
condition|)
break|break;
comment|/* If we had ....10, i would be 0.  The result should be 	     30, so we need 30 - i.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|30
operator|-
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, look for the first 0 bit from the left.  The result is its 	 number minus 1. We know the high-order bit is one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
comment|/* %n outputs the negative of its operand.  */
case|case
literal|'N'
case|:
comment|/* Write the number of elements in the vector times 4.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
comment|/* Similar, but subtract 1 first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%O value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'p'
case|:
comment|/* X is a CONST_INT that is a power of two.  Output the logarithm.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
operator|||
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%p value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
comment|/* The operand must be an indirect memory reference.  The result 	 is the register number.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|32
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'q'
case|:
comment|/* This outputs the logical code corresponding to a boolean 	 expression.  The expression may have one or both operands 	 negated (if one, only the first one).  For condition register          logical operations, it will also treat the negated          CR codes as NOTs, but not handle NOTs of them.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|t
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tbl
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|"and"
block|,
literal|"andc"
block|,
literal|"nor"
block|}
block|,
block|{
literal|"or"
block|,
literal|"orc"
block|,
literal|"nand"
block|}
block|,
block|{
literal|"xor"
block|,
literal|"eqv"
block|,
literal|"xor"
block|}
block|}
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|AND
condition|)
name|t
operator|=
name|tbl
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|IOR
condition|)
name|t
operator|=
name|tbl
index|[
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|XOR
condition|)
name|t
operator|=
name|tbl
index|[
literal|2
index|]
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%q value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOT
condition|)
name|s
operator|=
name|t
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
name|s
operator|=
name|t
index|[
literal|2
index|]
expr_stmt|;
else|else
name|s
operator|=
name|t
index|[
literal|1
index|]
expr_stmt|;
block|}
name|fputs
argument_list|(
name|s
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'R'
case|:
comment|/* X is a CR register.  Print the mask for `mtcrf'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|128
operator|>>
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
comment|/* Low 5 bits of 32 - value */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
literal|32
operator|-
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|)
operator|&
literal|31
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* PowerPC64 mask position.  All 0's and all 1's are excluded. 	 CONST_INT 32-bit mask is considered sign-extended so any 	 transition must occur within the CONST_INT, not on the boundary.  */
if|if
condition|(
operator|!
name|mask64_operand
argument_list|(
name|x
argument_list|,
name|DImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%S value"
argument_list|)
expr_stmt|;
name|val
operator|=
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|1
condition|)
comment|/* Clear Left */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
condition|)
break|break;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|i
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
operator|--
name|i
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* i = index of last set bit from right 	   mask begins at 63 - i from left */
if|if
condition|(
name|i
operator|>
literal|63
condition|)
name|output_operand_lossage
argument_list|(
literal|"%%S computed all 1's mask"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|63
operator|-
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
comment|/* Clear Right */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
condition|)
break|break;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|i
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
condition|)
operator|--
name|i
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* i = index of last clear bit from right 	   mask ends at 62 - i from left */
if|if
condition|(
name|i
operator|>
literal|62
condition|)
name|output_operand_lossage
argument_list|(
literal|"%%S computed all 0's mask"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|62
operator|-
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'T'
case|:
comment|/* Print the symbolic name of a branch target register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|LINK_REGISTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|COUNT_REGISTER_REGNUM
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%T value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|LINK_REGISTER_REGNUM
condition|)
name|fputs
argument_list|(
name|TARGET_NEW_MNEMONICS
condition|?
literal|"lr"
else|:
literal|"r"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"ctr"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'u'
case|:
comment|/* High-order 16 bits of constant for use in unsigned operand.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%u value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'v'
case|:
comment|/* High-order 16 bits of constant for use in signed operand.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%v value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'U'
case|:
comment|/* Print `u' if this has an auto-increment or auto-decrement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|)
condition|)
name|putc
argument_list|(
literal|'u'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'V'
case|:
comment|/* Print the trap code for this operand.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 4 */
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 24 */
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 16 */
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 20 */
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 8 */
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 12 */
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"llt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 2 */
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"lle"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 6 */
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"lgt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 1 */
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"lge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 5 */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
comment|/* If constant, low-order 16 bits of constant, signed.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
comment|/* MB value for a PowerPC64 rldic operand.  */
name|val
operator|=
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|?
name|INTVAL
argument_list|(
name|x
argument_list|)
else|:
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|<
literal|0
condition|)
break|break;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
comment|/* zero-extend high-part was all 0's */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|i
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
literal|0
condition|)
operator|--
name|i
expr_stmt|;
else|else
for|for
control|(
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|<
literal|0
condition|)
break|break;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'X'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|LEGITIMATE_INDEXED_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|putc
argument_list|(
literal|'x'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Y'
case|:
comment|/* Like 'L', for third word of TImode  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'z'
case|:
comment|/* X is a SYMBOL_REF.  Write out the name preceded by a 	 period and without any trailing data in brackets.  Used for function 	 names.  If we are configured for System V (or the embedded ABI) on 	 the PowerPC, do not emit the period, since those systems do not use 	 TOCs and the like.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
case|case
name|ABI_AIX_NODESC
case|:
case|case
name|ABI_DARWIN
case|:
break|break;
block|}
block|}
if|#
directive|if
name|TARGET_AIX
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
literal|'Z'
case|:
comment|/* Like 'L', for last word of TImode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
literal|12
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* Print AltiVec memory operand.  */
case|case
literal|'y'
case|:
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* We need to handle PRE_INC and PRE_DEC here, since we need to 	     know the width from the mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%s)"
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%s)"
argument_list|,
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the address of an operand.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_TOC
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TARGET_ELF
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@l(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET_MACHO
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lo16("
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|LEGITIMATE_CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_AIX
operator|&&
operator|(
operator|!
name|TARGET_ELF
operator|||
operator|!
name|TARGET_MINIMAL_TOC
operator|)
condition|)
block|{
name|rtx
name|contains_minus
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|minus
decl_stmt|,
name|symref
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Find the (minus (sym) (toc)) buried in X, and temporarily 	     turn it into (sym) for output_addr_const.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MINUS
condition|)
name|contains_minus
operator|=
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|minus
operator|=
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symref
operator|=
name|XEXP
argument_list|(
name|minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
operator|=
name|symref
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
condition|)
block|{
name|char
modifier|*
name|newname
decl_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"@toc"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newname
argument_list|,
literal|"@toc"
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
operator|=
name|newname
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
condition|)
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
operator|=
name|minus
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Target hook for assembling integer objects.  The powerpc version has    to handle fixup entries for relocatable code if RELOCATABLE_NEEDS_FIXUP    is defined.  It also needs to handle DI-mode objects on 64-bit    targets.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|aligned_p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|RELOCATABLE_NEEDS_FIXUP
comment|/* Special handling for SI values.  */
if|if
condition|(
name|size
operator|==
literal|4
operator|&&
name|aligned_p
condition|)
block|{
specifier|extern
name|int
name|in_toc_section
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|static
name|int
name|recurse
init|=
literal|0
decl_stmt|;
comment|/* For -mrelocatable, we mark all addresses that need to be fixed up 	 in the .fixup section.  */
if|if
condition|(
name|TARGET_RELOCATABLE
operator|&&
operator|!
name|in_toc_section
argument_list|()
operator|&&
operator|!
name|in_text_section
argument_list|()
operator|&&
operator|!
name|recurse
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|recurse
operator|=
literal|1
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCP"
argument_list|,
name|fixuplabelno
argument_list|)
expr_stmt|;
name|fixuplabelno
operator|++
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t("
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|")@fixup\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t\".fixup\",\"aw\"\n"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n\t.previous\n"
argument_list|)
expr_stmt|;
name|recurse
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Remove initial .'s to turn a -mcall-aixdesc function 	 address into the address of the descriptor, not the function 	 itself.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
name|name
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
endif|#
directive|endif
comment|/* RELOCATABLE_NEEDS_FIXUP */
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|enum
name|rtx_code
name|rs6000_reverse_condition
parameter_list|(
name|mode
parameter_list|,
name|code
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
comment|/* Reversal of FP compares takes care -- an ordered compare      becomes an unordered compare and vice versa.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
condition|)
return|return
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
return|;
else|else
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a compare for CODE.  Return a brand-new rtx that    represents the result of the compare.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_generate_compare
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|machine_mode
name|comp_mode
decl_stmt|;
name|rtx
name|compare_result
decl_stmt|;
if|if
condition|(
name|rs6000_compare_fp_p
condition|)
name|comp_mode
operator|=
name|CCFPmode
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
condition|)
name|comp_mode
operator|=
name|CCUNSmode
expr_stmt|;
else|else
name|comp_mode
operator|=
name|CCmode
expr_stmt|;
comment|/* First, the compare.  */
name|compare_result
operator|=
name|gen_reg_rtx
argument_list|(
name|comp_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|compare_result
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|comp_mode
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some kinds of FP comparisons need an OR operation;      except for flag_unsafe_math_optimizations we don't bother.  */
if|if
condition|(
name|rs6000_compare_fp_p
operator|&&
operator|!
name|flag_unsafe_math_optimizations
operator|&&
operator|(
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNLT
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|or1
decl_stmt|,
name|or2
decl_stmt|;
name|rtx
name|or1_rtx
decl_stmt|,
name|or2_rtx
decl_stmt|,
name|compare2_rtx
decl_stmt|;
name|rtx
name|or_result
init|=
name|gen_reg_rtx
argument_list|(
name|CCEQmode
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
name|or1
operator|=
name|LT
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|or1
operator|=
name|GT
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|LTGT
case|:
name|or1
operator|=
name|LT
expr_stmt|;
name|or2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|LT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|validate_condition_mode
argument_list|(
name|or1
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|validate_condition_mode
argument_list|(
name|or2
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|or1_rtx
operator|=
name|gen_rtx
argument_list|(
name|or1
argument_list|,
name|SImode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|or2_rtx
operator|=
name|gen_rtx
argument_list|(
name|or2
argument_list|,
name|SImode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|compare2_rtx
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|CCEQmode
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|or1_rtx
argument_list|,
name|or2_rtx
argument_list|)
argument_list|,
name|const_true_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|or_result
argument_list|,
name|compare2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|compare_result
operator|=
name|or_result
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|compare_result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit the RTL for an sCOND pattern.  */
end_comment

begin_function
name|void
name|rs6000_emit_sCOND
parameter_list|(
name|code
parameter_list|,
name|result
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|result
decl_stmt|;
block|{
name|rtx
name|condition_rtx
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
name|condition_rtx
operator|=
name|rs6000_generate_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_POWERPC64
operator|&&
operator|(
name|op_mode
operator|==
name|DImode
operator|||
name|rs6000_compare_fp_p
operator|)
condition|)
block|{
name|PUT_MODE
argument_list|(
name|condition_rtx
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|result
argument_list|,
name|condition_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_MODE
argument_list|(
name|condition_rtx
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|result
argument_list|,
name|condition_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a branch of kind CODE to location LOC.  */
end_comment

begin_function
name|void
name|rs6000_emit_cbranch
parameter_list|(
name|code
parameter_list|,
name|loc
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|loc
decl_stmt|;
block|{
name|rtx
name|condition_rtx
decl_stmt|,
name|loc_ref
decl_stmt|;
name|condition_rtx
operator|=
name|rs6000_generate_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|loc_ref
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|condition_rtx
argument_list|,
name|loc_ref
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, which is    the operand number of the label, or -1 if the branch is really a    conditional return.       OP is the conditional expression.  XEXP (OP, 0) is assumed to be a    condition code register and its mode specifies what kind of    comparison we made.     REVERSED is non-zero if we should reverse the sense of the comparison.     INSN is the insn.  */
end_comment

begin_function
name|char
modifier|*
name|output_cbranch
parameter_list|(
name|op
parameter_list|,
name|label
parameter_list|,
name|reversed
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|op
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|int
name|reversed
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|64
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
decl_stmt|;
name|int
name|cc_regno
init|=
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
operator|-
name|CR0_REGNO
decl_stmt|;
name|int
name|need_longbranch
init|=
name|label
operator|!=
name|NULL
operator|&&
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|==
literal|8
decl_stmt|;
name|int
name|really_reversed
init|=
name|reversed
operator|^
name|need_longbranch
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|ccode
decl_stmt|;
specifier|const
name|char
modifier|*
name|pred
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Work out which way this really branches.  We could use      reverse_condition_maybe_unordered here always but this      makes the resulting assembler clearer.  */
if|if
condition|(
name|really_reversed
condition|)
name|code
operator|=
name|rs6000_reverse_condition
argument_list|(
name|mode
argument_list|,
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Not all of these are actually distinct opcodes, but 	 we distinguish them for clarity of the resulting assembler.  */
case|case
name|NE
case|:
case|case
name|LTGT
case|:
name|ccode
operator|=
literal|"ne"
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
name|ccode
operator|=
literal|"eq"
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|ccode
operator|=
literal|"ge"
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNGT
case|:
name|ccode
operator|=
literal|"gt"
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|ccode
operator|=
literal|"le"
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNLT
case|:
name|ccode
operator|=
literal|"lt"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|ccode
operator|=
literal|"un"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|ccode
operator|=
literal|"nu"
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|ccode
operator|=
literal|"nl"
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|ccode
operator|=
literal|"ng"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Maybe we have a guess as to how likely the branch is.        The old mnemonics don't have a way to specify this information.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|!=
name|NULL_RTX
condition|)
block|{
comment|/* PROB is the difference from 50%.  */
name|int
name|prob
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
comment|/* For branches that are very close to 50%, assume not-taken.  */
if|if
condition|(
name|abs
argument_list|(
name|prob
argument_list|)
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|20
operator|&&
operator|(
operator|(
name|prob
operator|>
literal|0
operator|)
operator|^
name|need_longbranch
operator|)
condition|)
name|pred
operator|=
literal|"+"
expr_stmt|;
else|else
name|pred
operator|=
literal|"-"
expr_stmt|;
block|}
else|else
name|pred
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"{b%sr|b%slr%s} "
argument_list|,
name|ccode
argument_list|,
name|ccode
argument_list|,
name|pred
argument_list|)
expr_stmt|;
else|else
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"{b%s|b%s%s} "
argument_list|,
name|ccode
argument_list|,
name|ccode
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* We need to escape any '%' characters in the reg_names string.      Assume they'd only be the first character...  */
if|if
condition|(
name|reg_names
index|[
name|cc_regno
operator|+
name|CR0_REGNO
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'%'
expr_stmt|;
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|cc_regno
operator|+
name|CR0_REGNO
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
comment|/* If the branch distance was too far, we may have to use an 	 unconditional branch to go the distance.  */
if|if
condition|(
name|need_longbranch
condition|)
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|",$+8\n\tb %s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|",%s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Emit a conditional move: move TRUE_COND to DEST if OP of the    operands of the last comparison is nonzero/true, FALSE_COND if it    is zero/false.  Return 0 if the hardware has no such operation.  */
end_comment

begin_function
name|int
name|rs6000_emit_cmove
parameter_list|(
name|dest
parameter_list|,
name|op
parameter_list|,
name|true_cond
parameter_list|,
name|false_cond
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|op
decl_stmt|;
name|rtx
name|true_cond
decl_stmt|;
name|rtx
name|false_cond
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|rs6000_compare_op0
decl_stmt|;
name|rtx
name|op1
init|=
name|rs6000_compare_op1
decl_stmt|;
name|REAL_VALUE_TYPE
name|c1
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|result_mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* These modes should always match. */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|compare_mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|true_cond
argument_list|)
operator|!=
name|result_mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|false_cond
argument_list|)
operator|!=
name|result_mode
condition|)
return|return
literal|0
return|;
comment|/* First, work out if the hardware can do this at all, or      if it's too slow...  */
comment|/* If the comparison is an integer one, since we only have fsel      it'll be cheaper to use a branch.  */
if|if
condition|(
operator|!
name|rs6000_compare_fp_p
condition|)
return|return
literal|0
return|;
comment|/* Eliminate half of the comparisons by switching operands, this      makes the remaining code simpler.  */
if|if
condition|(
name|code
operator|==
name|UNLT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|LT
condition|)
block|{
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|temp
operator|=
name|true_cond
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
block|}
comment|/* UNEQ and LTGT take four instructions for a comparison with zero,      it'll probably be faster to use a branch here too.  */
if|if
condition|(
name|code
operator|==
name|UNEQ
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|c1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* We're going to try to implement comparions by performing      a subtract, then comparing against zero.  Unfortunately,      Inf - Inf is NaN which is not zero, and so if we don't      know that the the operand is finite and the comparison      would treat EQ different to UNORDERED, we can't do it.  */
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
operator|&&
name|code
operator|!=
name|GT
operator|&&
name|code
operator|!=
name|UNGE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|target_isinf
argument_list|(
name|c1
argument_list|)
operator|)
comment|/* Constructs of the form (a OP b ? a : b) are safe.  */
operator|&&
operator|(
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|false_cond
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|false_cond
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|true_cond
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|true_cond
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* At this point we know we can use fsel.  */
comment|/* Reduce the comparison to a comparison against zero.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
comment|/* If we don't care about NaNs we can reduce some of the comparisons      down to faster ones.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
name|code
operator|=
name|LE
expr_stmt|;
name|temp
operator|=
name|true_cond
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|code
operator|=
name|GE
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Now, reduce everything down to a GE.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE
case|:
break|break;
case|case
name|LE
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_ABS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|gen_rtx_ABS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|true_cond
operator|=
name|temp
expr_stmt|;
name|false_cond
operator|=
name|true_cond
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|rs6000_emit_minmax
parameter_list|(
name|dest
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|rtx
name|target
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|UMAX
condition|)
name|target
operator|=
name|emit_conditional_move
argument_list|(
name|dest
argument_list|,
name|GE
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|emit_conditional_move
argument_list|(
name|dest
argument_list|,
name|GE
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|dest
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the    function prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/* Return the first fixed-point register that is required to be    saved. 32 if none.  */
end_comment

begin_function
name|int
name|first_reg_to_save
parameter_list|()
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|13
init|;
name|first_reg
operator|<=
literal|31
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
operator|&&
operator|(
operator|!
name|call_used_regs
index|[
name|first_reg
index|]
operator|||
operator|(
name|first_reg
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|==
literal|1
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|current_function_profile
condition|)
block|{
comment|/* AIX must save/restore every register that contains a parameter 	 before/after the .__mcount call plus an additional register 	 for the static chain, if needed; use registers from 30 down to 22 	 to do this.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
condition|)
block|{
name|int
name|last_parm_reg
decl_stmt|,
name|profile_first_reg
decl_stmt|;
comment|/* Figure out last used parameter register.  The proper thing 	     to do is to walk incoming args of the function.  A function 	     might have live parameter registers even if it has no 	     incoming args.  */
for|for
control|(
name|last_parm_reg
operator|=
literal|10
init|;
name|last_parm_reg
operator|>
literal|2
operator|&&
operator|!
name|regs_ever_live
index|[
name|last_parm_reg
index|]
condition|;
name|last_parm_reg
operator|--
control|)
empty_stmt|;
comment|/* Calculate first reg for saving parameter registers 	     and static chain. 	     Skip reg 31 which may contain the frame pointer.  */
name|profile_first_reg
operator|=
operator|(
literal|33
operator|-
name|last_parm_reg
operator|-
operator|(
name|current_function_needs_context
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* Need to skip another reg to account for R31 being PICBASE              (when flag_pic is set) or R30 being used as the frame              pointer (when flag_pic is not set).  */
operator|--
name|profile_first_reg
expr_stmt|;
endif|#
directive|endif
comment|/* Do not save frame pointer if no parameters needs to be saved.  */
if|if
condition|(
name|profile_first_reg
operator|==
literal|31
condition|)
name|profile_first_reg
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|first_reg
operator|>
name|profile_first_reg
condition|)
name|first_reg
operator|=
name|profile_first_reg
expr_stmt|;
block|}
comment|/* SVR4 may need one register to preserve the static chain.  */
elseif|else
if|if
condition|(
name|current_function_needs_context
condition|)
block|{
comment|/* Skip reg 31 which may contain the frame pointer.  */
if|if
condition|(
name|first_reg
operator|>
literal|30
condition|)
name|first_reg
operator|=
literal|30
expr_stmt|;
block|}
block|}
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
operator|&&
operator|(
name|first_reg
operator|>
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
return|return
name|RS6000_PIC_OFFSET_TABLE_REGNUM
return|;
endif|#
directive|endif
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Similar, for FP regs.  */
end_comment

begin_function
name|int
name|first_fp_reg_to_save
parameter_list|()
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|14
operator|+
literal|32
init|;
name|first_reg
operator|<=
literal|63
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
condition|)
break|break;
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Similar, for AltiVec regs.  */
end_comment

begin_function
specifier|static
name|int
name|first_altivec_reg_to_save
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Stack frame remains as is unless we are in AltiVec ABI.  */
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
condition|)
return|return
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
return|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
operator|+
literal|20
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
break|break;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return a 32-bit mask of the AltiVec registers we need to set in    VRSAVE.  Bit n of the return value is 1 if Vn is live.  The MSB in    the 32-bit word is 0.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|compute_vrsave_mask
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|;
comment|/* First, find out if we use _any_ altivec registers.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|mask
operator||=
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
name|mask
return|;
comment|/* Next, add all registers that are call-clobbered.  We do this      because post-reload register optimizers such as regrename_optimize      may choose to use them.  They never change the register class      chosen by reload, so cannot create new uses of altivec registers      if there were none before, so the early exit above is safe.  */
comment|/* ??? Alternately, we could define HARD_REGNO_RENAME_OK to disallow      altivec registers not saved in the mask, which might well make the      adjustments below more effective in eliding the save/restore of      VRSAVE in small functions.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|mask
operator||=
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Next, remove the argument registers from the set.  These must      be in the VRSAVE mask set by the caller, so we don't need to add      them in again.  More importantly, the mask we compute here is      used to generate CLOBBERs in the set_vrsave insn, and we do not      wish the argument registers to die.  */
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|args_info
operator|.
name|vregno
init|;
name|i
operator|>=
name|ALTIVEC_ARG_MIN_REG
condition|;
operator|--
name|i
control|)
name|mask
operator|&=
operator|~
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Similarly, remove the return value from the set.  */
block|{
name|bool
name|yes
init|=
name|false
decl_stmt|;
name|diddle_return_value
argument_list|(
name|is_altivec_return_reg
argument_list|,
operator|&
name|yes
argument_list|)
expr_stmt|;
if|if
condition|(
name|yes
condition|)
name|mask
operator|&=
operator|~
name|ALTIVEC_REG_BIT
argument_list|(
name|ALTIVEC_ARG_RETURN
argument_list|)
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|is_altivec_return_reg
parameter_list|(
name|reg
parameter_list|,
name|xyes
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|void
modifier|*
name|xyes
decl_stmt|;
block|{
name|bool
modifier|*
name|yes
init|=
operator|(
name|bool
operator|*
operator|)
name|xyes
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|==
name|ALTIVEC_ARG_RETURN
condition|)
operator|*
name|yes
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the stack information for the current function.  This is    complicated by having two separate calling sequences, the AIX calling    sequence and the V.4 calling sequence.     AIX (and Darwin/Mac OS X) stack frames look like: 							  32-bit  64-bit 	SP---->	+---------------------------------------+ 		| back chain to caller			| 0	  0 		+---------------------------------------+ 		| saved CR				| 4       8 (8-11) 		+---------------------------------------+ 		| saved LR				| 8       16 		+---------------------------------------+ 		| reserved for compilers		| 12      24 		+---------------------------------------+ 		| reserved for binders			| 16      32 		+---------------------------------------+ 		| saved TOC pointer			| 20      40 		+---------------------------------------+ 		| Parameter save area (P)		| 24      48 		+---------------------------------------+ 		| Alloca space (A)			| 24+P    etc. 		+---------------------------------------+ 		| Local variable space (L)		| 24+P+A 		+---------------------------------------+ 		| Float/int conversion temporary (X)	| 24+P+A+L 		+---------------------------------------+ 		| Save area for AltiVec registers (W)	| 24+P+A+L+X 		+---------------------------------------+ 		| AltiVec alignment padding (Y)		| 24+P+A+L+X+W 		+---------------------------------------+ 		| Save area for VRSAVE register (Z)	| 24+P+A+L+X+W+Y 		+---------------------------------------+ 		| Save area for GP registers (G)	| 24+P+A+X+L+X+W+Y+Z 		+---------------------------------------+ 		| Save area for FP registers (F)	| 24+P+A+X+L+X+W+Y+Z+G 		+---------------------------------------+ 	old SP->| back chain to caller's caller		| 		+---------------------------------------+     The required alignment for AIX configurations is two words (i.e., 8    or 16 bytes).      V.4 stack frames look like:  	SP---->	+---------------------------------------+ 		| back chain to caller			| 0 		+---------------------------------------+ 		| caller's saved LR			| 4 		+---------------------------------------+ 		| Parameter save area (P)		| 8 		+---------------------------------------+ 		| Alloca space (A)			| 8+P 		+---------------------------------------+     		| Varargs save area (V)			| 8+P+A 		+---------------------------------------+     		| Local variable space (L)		| 8+P+A+V 		+---------------------------------------+     		| Float/int conversion temporary (X)	| 8+P+A+V+L 		+---------------------------------------+ 		| Save area for AltiVec registers (W)	| 8+P+A+V+L+X 		+---------------------------------------+ 		| AltiVec alignment padding (Y)		| 8+P+A+V+L+X+W 		+---------------------------------------+ 		| Save area for VRSAVE register (Z)	| 8+P+A+V+L+X+W+Y 		+---------------------------------------+ 		| saved CR (C)				| 8+P+A+V+L+X+W+Y+Z 		+---------------------------------------+     		| Save area for GP registers (G)	| 8+P+A+V+L+X+W+Y+Z+C 		+---------------------------------------+     		| Save area for FP registers (F)	| 8+P+A+V+L+X+W+Y+Z+C+G 		+---------------------------------------+ 	old SP->| back chain to caller's caller		| 		+---------------------------------------+     The required alignment for V.4 is 16 bytes, or 8 bytes if -meabi is    given.  (But note below and in sysv4.h that we require only 8 and    may round up the size of our stack frame anyways.  The historical    reason is early versions of powerpc-linux which didn't properly    align the stack at program startup.  A happy side-effect is that    -mno-eabi libraries can be used with -meabi programs.)     The EABI configuration defaults to the V.4 layout, unless    -mcall-aix is used, in which case the AIX layout is used.  However,    the stack alignment requirements may differ.  If -mno-eabi is not    given, the required stack alignment is 8 bytes; if -mno-eabi is    given, the required alignment is 16 bytes.  (But see V.4 comment    above.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ABI_STACK_BOUNDARY
end_ifndef

begin_define
define|#
directive|define
name|ABI_STACK_BOUNDARY
value|STACK_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|rs6000_stack_t
modifier|*
name|rs6000_stack_info
parameter_list|()
block|{
specifier|static
name|rs6000_stack_t
name|info
decl_stmt|,
name|zero_info
decl_stmt|;
name|rs6000_stack_t
modifier|*
name|info_ptr
init|=
operator|&
name|info
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_POWERPC64
condition|?
literal|8
else|:
literal|4
decl_stmt|;
name|enum
name|rs6000_abi
name|abi
decl_stmt|;
name|int
name|ehrd_size
decl_stmt|;
name|int
name|total_raw_size
decl_stmt|;
comment|/* Zero all fields portably.  */
name|info
operator|=
name|zero_info
expr_stmt|;
comment|/* Select which calling sequence.  */
name|info_ptr
operator|->
name|abi
operator|=
name|abi
operator|=
name|DEFAULT_ABI
expr_stmt|;
comment|/* Calculate which registers need to be saved& save area size.  */
name|info_ptr
operator|->
name|first_gp_reg_save
operator|=
name|first_reg_to_save
argument_list|()
expr_stmt|;
comment|/* Assume that we will have to save RS6000_PIC_OFFSET_TABLE_REGNUM,       even if it currently looks like we won't.  */
if|if
condition|(
operator|(
operator|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|||
operator|(
name|flag_pic
operator|==
literal|1
operator|&&
name|abi
operator|==
name|ABI_V4
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|abi
operator|==
name|ABI_DARWIN
operator|)
operator|)
operator|&&
name|info_ptr
operator|->
name|first_gp_reg_save
operator|>
name|RS6000_PIC_OFFSET_TABLE_REGNUM
condition|)
name|info_ptr
operator|->
name|gp_size
operator|=
name|reg_size
operator|*
operator|(
literal|32
operator|-
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|gp_size
operator|=
name|reg_size
operator|*
operator|(
literal|32
operator|-
name|info_ptr
operator|->
name|first_gp_reg_save
operator|)
expr_stmt|;
name|info_ptr
operator|->
name|first_fp_reg_save
operator|=
name|first_fp_reg_to_save
argument_list|()
expr_stmt|;
name|info_ptr
operator|->
name|fp_size
operator|=
literal|8
operator|*
operator|(
literal|64
operator|-
name|info_ptr
operator|->
name|first_fp_reg_save
operator|)
expr_stmt|;
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|=
name|first_altivec_reg_to_save
argument_list|()
expr_stmt|;
name|info_ptr
operator|->
name|altivec_size
operator|=
literal|16
operator|*
operator|(
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
operator|-
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|)
expr_stmt|;
comment|/* Does this function call anything?  */
name|info_ptr
operator|->
name|calls_p
operator|=
operator|(
operator|!
name|current_function_is_leaf
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ra_needs_full_frame
operator|)
expr_stmt|;
comment|/* Determine if we need to save the link register.  */
if|if
condition|(
name|rs6000_ra_ever_killed
argument_list|()
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|current_function_profile
operator|)
ifdef|#
directive|ifdef
name|TARGET_RELOCATABLE
operator|||
operator|(
name|TARGET_RELOCATABLE
operator|&&
operator|(
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
endif|#
directive|endif
operator|||
operator|(
name|info_ptr
operator|->
name|first_fp_reg_save
operator|!=
literal|64
operator|&&
operator|!
name|FP_SAVE_INLINE
argument_list|(
name|info_ptr
operator|->
name|first_fp_reg_save
argument_list|)
operator|)
operator|||
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|<=
name|LAST_ALTIVEC_REGNO
operator|||
operator|(
name|abi
operator|==
name|ABI_V4
operator|&&
name|current_function_calls_alloca
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
operator|)
operator|||
name|info_ptr
operator|->
name|calls_p
condition|)
block|{
name|info_ptr
operator|->
name|lr_save_p
operator|=
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|LINK_REGISTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Determine if we need to save the condition code registers.  */
if|if
condition|(
name|regs_ever_live
index|[
name|CR2_REGNO
index|]
operator|||
name|regs_ever_live
index|[
name|CR3_REGNO
index|]
operator|||
name|regs_ever_live
index|[
name|CR4_REGNO
index|]
condition|)
block|{
name|info_ptr
operator|->
name|cr_save_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|abi
operator|==
name|ABI_V4
condition|)
name|info_ptr
operator|->
name|cr_size
operator|=
name|reg_size
expr_stmt|;
block|}
comment|/* If the current function calls __builtin_eh_return, then we need      to allocate stack space for registers that will hold data for      the exception handler.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
operator|!=
name|INVALID_REGNUM
condition|;
operator|++
name|i
control|)
continue|continue;
name|ehrd_size
operator|=
name|i
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
name|ehrd_size
operator|=
literal|0
expr_stmt|;
comment|/* Determine various sizes.  */
name|info_ptr
operator|->
name|reg_size
operator|=
name|reg_size
expr_stmt|;
name|info_ptr
operator|->
name|fixed_size
operator|=
name|RS6000_SAVE_AREA
expr_stmt|;
name|info_ptr
operator|->
name|varargs_size
operator|=
name|RS6000_VARARGS_AREA
expr_stmt|;
name|info_ptr
operator|->
name|vars_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|get_frame_size
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|parm_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|current_function_outgoing_args_size
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
block|{
name|info_ptr
operator|->
name|vrsave_mask
operator|=
name|compute_vrsave_mask
argument_list|()
expr_stmt|;
name|info_ptr
operator|->
name|vrsave_size
operator|=
name|info_ptr
operator|->
name|vrsave_mask
condition|?
literal|4
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|info_ptr
operator|->
name|vrsave_mask
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|vrsave_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Calculate the offsets.  */
switch|switch
condition|(
name|abi
condition|)
block|{
case|case
name|ABI_NONE
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
case|case
name|ABI_AIX_NODESC
case|:
case|case
name|ABI_DARWIN
case|:
name|info_ptr
operator|->
name|fp_save_offset
operator|=
operator|-
name|info_ptr
operator|->
name|fp_size
expr_stmt|;
name|info_ptr
operator|->
name|gp_save_offset
operator|=
name|info_ptr
operator|->
name|fp_save_offset
operator|-
name|info_ptr
operator|->
name|gp_size
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
block|{
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|info_ptr
operator|->
name|vrsave_size
expr_stmt|;
comment|/* Align stack so vector save area is on a quadword boundary.  */
if|if
condition|(
name|info_ptr
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|16
operator|-
operator|(
operator|-
name|info_ptr
operator|->
name|vrsave_save_offset
operator|%
literal|16
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
name|info_ptr
operator|->
name|vrsave_save_offset
operator|-
name|info_ptr
operator|->
name|altivec_padding_size
operator|-
name|info_ptr
operator|->
name|altivec_size
expr_stmt|;
comment|/* Adjust for AltiVec case.  */
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|altivec_save_offset
operator|-
name|ehrd_size
expr_stmt|;
block|}
else|else
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|ehrd_size
expr_stmt|;
name|info_ptr
operator|->
name|cr_save_offset
operator|=
name|reg_size
expr_stmt|;
comment|/* first word when 64-bit.  */
name|info_ptr
operator|->
name|lr_save_offset
operator|=
literal|2
operator|*
name|reg_size
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
name|info_ptr
operator|->
name|fp_save_offset
operator|=
operator|-
name|info_ptr
operator|->
name|fp_size
expr_stmt|;
name|info_ptr
operator|->
name|gp_save_offset
operator|=
name|info_ptr
operator|->
name|fp_save_offset
operator|-
name|info_ptr
operator|->
name|gp_size
expr_stmt|;
name|info_ptr
operator|->
name|cr_save_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|info_ptr
operator|->
name|cr_size
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
block|{
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
name|info_ptr
operator|->
name|cr_save_offset
operator|-
name|info_ptr
operator|->
name|vrsave_size
expr_stmt|;
comment|/* Align stack so vector save area is on a quadword boundary.  */
if|if
condition|(
name|info_ptr
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|16
operator|-
operator|(
operator|-
name|info_ptr
operator|->
name|vrsave_save_offset
operator|%
literal|16
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
name|info_ptr
operator|->
name|vrsave_save_offset
operator|-
name|info_ptr
operator|->
name|altivec_padding_size
operator|-
name|info_ptr
operator|->
name|altivec_size
expr_stmt|;
comment|/* Adjust for AltiVec case.  */
name|info_ptr
operator|->
name|toc_save_offset
operator|=
name|info_ptr
operator|->
name|altivec_save_offset
operator|-
name|info_ptr
operator|->
name|toc_size
expr_stmt|;
block|}
else|else
name|info_ptr
operator|->
name|toc_save_offset
operator|=
name|info_ptr
operator|->
name|cr_save_offset
operator|-
name|info_ptr
operator|->
name|toc_size
expr_stmt|;
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|toc_save_offset
operator|-
name|ehrd_size
expr_stmt|;
name|info_ptr
operator|->
name|lr_save_offset
operator|=
name|reg_size
expr_stmt|;
break|break;
block|}
name|info_ptr
operator|->
name|save_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|info_ptr
operator|->
name|fp_size
operator|+
name|info_ptr
operator|->
name|gp_size
operator|+
name|info_ptr
operator|->
name|altivec_size
operator|+
name|info_ptr
operator|->
name|altivec_padding_size
operator|+
name|info_ptr
operator|->
name|vrsave_size
operator|+
name|ehrd_size
operator|+
name|info_ptr
operator|->
name|cr_size
operator|+
name|info_ptr
operator|->
name|lr_size
operator|+
name|info_ptr
operator|->
name|vrsave_size
operator|+
name|info_ptr
operator|->
name|toc_size
argument_list|,
operator|(
name|TARGET_ALTIVEC_ABI
operator|||
name|ABI_DARWIN
operator|)
condition|?
literal|16
else|:
literal|8
argument_list|)
expr_stmt|;
name|total_raw_size
operator|=
operator|(
name|info_ptr
operator|->
name|vars_size
operator|+
name|info_ptr
operator|->
name|parm_size
operator|+
name|info_ptr
operator|->
name|save_size
operator|+
name|info_ptr
operator|->
name|varargs_size
operator|+
name|info_ptr
operator|->
name|fixed_size
operator|)
expr_stmt|;
name|info_ptr
operator|->
name|total_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|total_raw_size
argument_list|,
name|ABI_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Determine if we need to allocate any stack frame:       For AIX we need to push the stack if a frame pointer is needed      (because the stack might be dynamically adjusted), if we are      debugging, if we make calls, or if the sum of fp_save, gp_save,      and local variables are more than the space needed to save all      non-volatile registers: 32-bit: 18*8 + 19*4 = 220 or 64-bit: 18*8      + 18*8 = 288 (GPR13 reserved).       For V.4 we don't have the stack cushion that AIX uses, but assume      that the debugger can handle stackless frames.  */
if|if
condition|(
name|info_ptr
operator|->
name|calls_p
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|abi
operator|==
name|ABI_V4
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
name|total_raw_size
operator|>
name|info_ptr
operator|->
name|fixed_size
expr_stmt|;
else|else
name|info_ptr
operator|->
name|push_p
operator|=
operator|(
name|frame_pointer_needed
operator|||
operator|(
name|abi
operator|!=
name|ABI_DARWIN
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
operator|)
operator|||
operator|(
operator|(
name|total_raw_size
operator|-
name|info_ptr
operator|->
name|fixed_size
operator|)
operator|>
operator|(
name|TARGET_32BIT
condition|?
literal|220
else|:
literal|288
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Zero offsets if we're not saving those registers.  */
if|if
condition|(
name|info_ptr
operator|->
name|fp_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|fp_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|gp_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|gp_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
operator|||
name|info_ptr
operator|->
name|altivec_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
operator|||
name|info_ptr
operator|->
name|vrsave_mask
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info_ptr
operator|->
name|lr_save_p
condition|)
name|info_ptr
operator|->
name|lr_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info_ptr
operator|->
name|cr_save_p
condition|)
name|info_ptr
operator|->
name|cr_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info_ptr
operator|->
name|toc_save_p
condition|)
name|info_ptr
operator|->
name|toc_save_offset
operator|=
literal|0
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_function
name|void
name|debug_stack_info
parameter_list|(
name|info
parameter_list|)
name|rs6000_stack_t
modifier|*
name|info
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|abi_string
decl_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
name|info
operator|=
name|rs6000_stack_info
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nStack information for function %s:\n"
argument_list|,
operator|(
operator|(
name|current_function_decl
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
else|:
literal|"<unknown>"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|abi
condition|)
block|{
default|default:
name|abi_string
operator|=
literal|"Unknown"
expr_stmt|;
break|break;
case|case
name|ABI_NONE
case|:
name|abi_string
operator|=
literal|"NONE"
expr_stmt|;
break|break;
case|case
name|ABI_AIX
case|:
case|case
name|ABI_AIX_NODESC
case|:
name|abi_string
operator|=
literal|"AIX"
expr_stmt|;
break|break;
case|case
name|ABI_DARWIN
case|:
name|abi_string
operator|=
literal|"Darwin"
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
name|abi_string
operator|=
literal|"V.4"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tABI                 = %5s\n"
argument_list|,
name|abi_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tALTIVEC ABI extensions enabled.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_gp_reg_save
operator|!=
literal|32
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_gp_reg_save   = %5d\n"
argument_list|,
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_fp_reg_save   = %5d\n"
argument_list|,
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_altivec_reg_save
operator|<=
name|LAST_ALTIVEC_REGNO
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_altivec_reg_save = %5d\n"
argument_list|,
name|info
operator|->
name|first_altivec_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlr_save_p           = %5d\n"
argument_list|,
name|info
operator|->
name|lr_save_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_save_p           = %5d\n"
argument_list|,
name|info
operator|->
name|cr_save_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|toc_save_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttoc_save_p          = %5d\n"
argument_list|,
name|info
operator|->
name|toc_save_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_mask
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_mask         = 0x%x\n"
argument_list|,
name|info
operator|->
name|vrsave_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|push_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tpush_p              = %5d\n"
argument_list|,
name|info
operator|->
name|push_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|calls_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcalls_p             = %5d\n"
argument_list|,
name|info
operator|->
name|calls_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|gp_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tgp_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|gp_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fp_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfp_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|fp_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_save_offset = %5d\n"
argument_list|,
name|info
operator|->
name|altivec_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_save_offset  = %5d\n"
argument_list|,
name|info
operator|->
name|vrsave_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlr_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|lr_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|cr_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|toc_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttoc_save_offset     = %5d\n"
argument_list|,
name|info
operator|->
name|toc_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|varargs_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvarargs_save_offset = %5d\n"
argument_list|,
name|info
operator|->
name|varargs_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|total_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttotal_size          = %5d\n"
argument_list|,
name|info
operator|->
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|varargs_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvarargs_size        = %5d\n"
argument_list|,
name|info
operator|->
name|varargs_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vars_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvars_size           = %5d\n"
argument_list|,
name|info
operator|->
name|vars_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|parm_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tparm_size           = %5d\n"
argument_list|,
name|info
operator|->
name|parm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fixed_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfixed_size          = %5d\n"
argument_list|,
name|info
operator|->
name|fixed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|gp_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tgp_size             = %5d\n"
argument_list|,
name|info
operator|->
name|gp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fp_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfp_size             = %5d\n"
argument_list|,
name|info
operator|->
name|fp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_size        = %5d\n"
argument_list|,
name|info
operator|->
name|altivec_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_size         = %5d\n"
argument_list|,
name|info
operator|->
name|vrsave_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_padding_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_padding_size= %5d\n"
argument_list|,
name|info
operator|->
name|altivec_padding_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlr_size             = %5d\n"
argument_list|,
name|info
operator|->
name|lr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_size             = %5d\n"
argument_list|,
name|info
operator|->
name|cr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|toc_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttoc_size            = %5d\n"
argument_list|,
name|info
operator|->
name|toc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|save_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsave_size           = %5d\n"
argument_list|,
name|info
operator|->
name|save_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|reg_size
operator|!=
literal|4
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\treg_size            = %5d\n"
argument_list|,
name|info
operator|->
name|reg_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|rs6000_return_addr
parameter_list|(
name|count
parameter_list|,
name|frame
parameter_list|)
name|int
name|count
decl_stmt|;
name|rtx
name|frame
decl_stmt|;
block|{
comment|/* Currently we don't optimize very well between prolog and body      code and for PIC code the code can be actually quite bad, so      don't try to be too clever here.  */
if|if
condition|(
name|count
operator|!=
literal|0
operator|||
name|flag_pic
operator|!=
literal|0
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX_NODESC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|ra_needs_full_frame
operator|=
literal|1
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|copy_to_reg
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|frame
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|RETURN_ADDRESS_OFFSET
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rs6000_ra_ever_killed
parameter_list|()
block|{
name|rtx
name|top
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
name|current_function_is_thunk
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|has_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ra_needs_full_frame
condition|)
return|return
name|regs_ever_live
index|[
name|LINK_REGISTER_REGNUM
index|]
return|;
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|top
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
return|return
name|reg_set_between_p
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|,
name|top
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a REG_MAYBE_DEAD note to the insn.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_maybe_dead
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit instructions needed to load the TOC register.    This is only needed when TARGET_TOC, TARGET_MINIMAL_TOC, and there is    a constant pool; or for SVR4 -fpic.  */
end_comment

begin_function
name|void
name|rs6000_emit_load_toc_table
parameter_list|(
name|fromprolog
parameter_list|)
name|int
name|fromprolog
decl_stmt|;
block|{
name|rtx
name|dest
decl_stmt|;
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RS6000_PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
condition|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|rtx
name|temp
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_v4_pic_si
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|rtx
name|tempLR
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|temp0
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|symF
decl_stmt|;
comment|/* possibly create the toc section */
if|if
condition|(
operator|!
name|toc_initialized
condition|)
block|{
name|toc_section
argument_list|()
expr_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fromprolog
condition|)
block|{
name|rtx
name|symL
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCF"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|symF
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCL"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|symL
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1
argument_list|(
name|tempLR
argument_list|,
name|symF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|tempLR
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_2
argument_list|(
name|temp0
argument_list|,
name|dest
argument_list|,
name|symL
argument_list|,
name|symF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tocsym
decl_stmt|;
specifier|static
name|int
name|reload_toc_labelno
init|=
literal|0
decl_stmt|;
name|tocsym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|toc_label_name
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCG"
argument_list|,
name|reload_toc_labelno
operator|++
argument_list|)
expr_stmt|;
name|symF
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1b
argument_list|(
name|tempLR
argument_list|,
name|symF
argument_list|,
name|tocsym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|tempLR
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|temp0
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dest
argument_list|,
name|temp0
argument_list|,
name|dest
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|0
operator|&&
name|TARGET_MINIMAL_TOC
condition|)
block|{
comment|/* This is for AIX code running in non-PIC ELF.  */
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|rtx
name|realsym
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCTOC"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|realsym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|dest
argument_list|,
name|realsym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|dest
argument_list|,
name|dest
argument_list|,
name|realsym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_32BIT
condition|)
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_aix_si
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_aix_di
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|get_TOC_alias_set
parameter_list|()
block|{
specifier|static
name|int
name|set
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set
operator|==
operator|-
literal|1
condition|)
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* This retuns nonzero if the current function uses the TOC.  This is    determined by the presence of (unspec ... 7), which is generated by    the various load_toc_* patterns.  */
end_comment

begin_function
name|int
name|uses_TOC
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|7
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|rtx
name|create_TOC_reference
parameter_list|(
name|symbol
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|TOC_REGISTER
argument_list|)
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|symbol
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|toc_label_name
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_AIX
end_if

begin_comment
comment|/* __throw will restore its own return address to be the same as the    return address of the function that the throw is being made to.    This is unfortunate, because we want to check the original    return address to see if we need to restore the TOC.    So we have to squirrel it away here.      This is used only in compiling __throw and __rethrow.      Most of this code should be removed by CSE.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|insn_after_throw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This does the saving...  */
end_comment

begin_function
name|void
name|rs6000_aix_emit_builtin_unwind_init
parameter_list|()
block|{
name|rtx
name|mem
decl_stmt|;
name|rtx
name|stack_top
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|opcode_addr
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|insn_after_throw
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|stack_top
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_top
argument_list|,
name|GEN_INT
argument_list|(
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|opcode_addr
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|insn_after_throw
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|opcode_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit insns to _restore_ the TOC register, at runtime (specifically    in _eh.o).  Only used on AIX.     The idea is that on AIX, function calls look like this: 	bl  somefunction-trampoline 	lwz r2,20(sp)     and later, 	somefunction-trampoline: 	stw r2,20(sp) 	 ... load function address in the count register ... 	bctr    or like this, if the linker determines that this is not a cross-module call    and so the TOC need not be restored: 	bl  somefunction 	nop    or like this, if the compiler could determine that this is not a    cross-module call: 	bl  somefunction    now, the tricky bit here is that register 2 is saved and restored    by the _linker_, so we can't readily generate debugging information    for it.  So we need to go back up the call chain looking at the    insns at return addresses to see which calls saved the TOC register    and so see where it gets restored from.     Oh, and all this gets done in RTL inside the eh_epilogue pattern,    just before the actual epilogue.     On the bright side, this incurs no space or time overhead unless an    exception is thrown, except for the extra code in libgcc.a.       The parameter STACKSIZE is a register containing (at runtime)    the amount to be popped off the stack in addition to the stack frame    of this routine (which will be __throw or __rethrow, and so is    guaranteed to have a stack frame).  */
end_comment

begin_function
name|void
name|rs6000_emit_eh_toc_restore
parameter_list|(
name|stacksize
parameter_list|)
name|rtx
name|stacksize
decl_stmt|;
block|{
name|rtx
name|top_of_stack
decl_stmt|;
name|rtx
name|bottom_of_stack
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|tocompare
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|opcode
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|opcode_addr
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|loop_start
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|no_toc_restore_needed
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|loop_exit
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|bottom_of_stack
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|top_of_stack
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|bottom_of_stack
argument_list|,
name|stacksize
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tocompare
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|TARGET_32BIT
condition|?
literal|0x80410014
else|:
literal|0xE8410028
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_after_throw
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|opcode
argument_list|,
name|insn_after_throw
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_BEG
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|opcode
argument_list|,
name|tocompare
argument_list|,
name|NE
argument_list|,
literal|1
argument_list|,
name|SImode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|no_toc_restore_needed
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|bottom_of_stack
argument_list|,
name|GEN_INT
argument_list|(
literal|5
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|no_toc_restore_needed
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|top_of_stack
argument_list|,
name|bottom_of_stack
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|Pmode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|loop_exit
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|bottom_of_stack
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|bottom_of_stack
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|bottom_of_stack
argument_list|,
name|GEN_INT
argument_list|(
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|opcode_addr
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|opcode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|opcode_addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_CONT
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_END
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_exit
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_AIX */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This ties together stack memory (MEM with an alias set of    rs6000_sr_alias_set) and the change to the stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_emit_stack_tie
parameter_list|()
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_stack_tie
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the correct code for allocating stack space, as insns.    If COPY_R12, make sure a copy of the old frame is left in r12.    The generated code may use hard register 0 as a temporary.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_emit_allocate_stack
parameter_list|(
name|size
parameter_list|,
name|copy_r12
parameter_list|)
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|int
name|copy_r12
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|stack_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|tmp_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|todec
init|=
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_function_limit_stack
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|>
literal|1
operator|&&
name|REGNO
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|<=
literal|31
condition|)
block|{
name|emit_insn
argument_list|(
name|Pmode
operator|==
name|SImode
condition|?
name|gen_addsi3
argument_list|(
name|tmp_reg
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|tmp_reg
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cond_trap
argument_list|(
name|LTU
argument_list|,
name|stack_reg
argument_list|,
name|tmp_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|TARGET_32BIT
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
name|rtx
name|toload
init|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|tmp_reg
argument_list|,
name|toload
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|tmp_reg
argument_list|,
name|tmp_reg
argument_list|,
name|toload
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cond_trap
argument_list|(
name|LTU
argument_list|,
name|stack_reg
argument_list|,
name|tmp_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"stack limit expression is not supported"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_r12
operator|||
operator|!
name|TARGET_UPDATE
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
argument_list|,
name|stack_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_UPDATE
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|32767
condition|)
block|{
comment|/* Need a note here so that try_split doesn't get confused.  */
if|if
condition|(
name|get_last_insn
argument_list|()
operator|==
name|NULL_RTX
condition|)
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|tmp_reg
argument_list|,
name|todec
argument_list|)
expr_stmt|;
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|todec
operator|=
name|tmp_reg
expr_stmt|;
block|}
if|if
condition|(
name|Pmode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_movsi_update
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|,
name|stack_reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_movdi_update
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|,
name|stack_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Pmode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|stack_reg
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a RTX_FRAME_RELATED note so that dwarf2out_frame_debug_expr    knows that:       (mem (plus (blah) (regXX)))     is really:       (mem (plus (blah) (const VALUE_OF_REGXX))).  */
end_comment

begin_function
specifier|static
name|void
name|altivec_frame_fixup
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
block|{
name|rtx
name|real
decl_stmt|;
name|real
operator|=
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|real
operator|=
name|replace_rtx
argument_list|(
name|real
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|real
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced    with (plus:P (reg 1) VAL), and with REG2 replaced with RREG if REG2    is not NULL.  It would be nice if dwarf2out_frame_debug_expr could    deduce these equivalences by itself so it wasn't necessary to hold    its hand so much.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_frame_related
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|,
name|reg2
parameter_list|,
name|rreg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|rtx
name|reg2
decl_stmt|;
name|rtx
name|rreg
decl_stmt|;
block|{
name|rtx
name|real
decl_stmt|,
name|temp
decl_stmt|;
name|real
operator|=
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|real
operator|=
name|replace_rtx
argument_list|(
name|real
argument_list|,
name|reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We expect that 'real' is either a SET or a PARALLEL containing      SETs (and possibly other stuff).  In a PARALLEL, all the SETs      are important so they all have to be marked RTX_FRAME_RELATED_P.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|real
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|set
init|=
name|real
decl_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|real
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|real
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|real
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|real
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|set
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg2
operator|!=
name|NULL_RTX
condition|)
name|real
operator|=
name|replace_rtx
argument_list|(
name|real
argument_list|,
name|reg2
argument_list|,
name|rreg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|real
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns an insn that has a vrsave set operation with the    appropriate CLOBBERs.  */
end_comment

begin_function
specifier|static
name|rtx
name|generate_set_vrsave
parameter_list|(
name|reg
parameter_list|,
name|info
parameter_list|,
name|epiloguep
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rs6000_stack_t
modifier|*
name|info
decl_stmt|;
name|int
name|epiloguep
decl_stmt|;
block|{
name|int
name|nclobs
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|clobs
index|[
name|TOTAL_ALTIVEC_REGS
operator|+
literal|1
index|]
decl_stmt|;
name|rtx
name|vrsave
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|VRSAVE_REGNO
argument_list|)
decl_stmt|;
name|clobs
index|[
literal|0
index|]
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|vrsave
argument_list|,
name|gen_rtx_UNSPEC_VOLATILE
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|reg
argument_list|,
name|vrsave
argument_list|)
argument_list|,
literal|30
argument_list|)
argument_list|)
expr_stmt|;
name|nclobs
operator|=
literal|1
expr_stmt|;
comment|/* We need to clobber the registers in the mask so the scheduler      does not move sets to VRSAVE before sets of AltiVec registers.       However, if the function receives nonlocal gotos, reload will set      all call saved registers live.  We will end up with:       	(set (reg 999) (mem)) 	(parallel [ (set (reg vrsave) (unspec blah)) 		    (clobber (reg 999))])       The clobber will cause the store into reg 999 to be dead, and      flow will attempt to delete an epilogue insn.  In this case, we      need an unspec use/set of the register.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|!=
literal|0
operator|&&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|epiloguep
operator|||
name|call_used_regs
index|[
name|i
index|]
condition|)
name|clobs
index|[
name|nclobs
operator|++
index|]
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|clobs
index|[
name|nclobs
operator|++
index|]
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|27
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nclobs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nclobs
condition|;
operator|++
name|i
control|)
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|clobs
index|[
name|i
index|]
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit function prologue as insns.  */
end_comment

begin_function
name|void
name|rs6000_emit_prologue
parameter_list|()
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|TARGET_POWERPC64
condition|?
name|DImode
else|:
name|SImode
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_POWERPC64
condition|?
literal|8
else|:
literal|4
decl_stmt|;
name|rtx
name|sp_reg_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|frame_ptr_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|rtx
name|frame_reg_rtx
init|=
name|sp_reg_rtx
decl_stmt|;
name|rtx
name|cr_save_rtx
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|saving_FPRs_inline
decl_stmt|;
name|int
name|using_store_multiple
decl_stmt|;
name|HOST_WIDE_INT
name|sp_offset
init|=
literal|0
decl_stmt|;
name|using_store_multiple
operator|=
operator|(
name|TARGET_MULTIPLE
operator|&&
operator|!
name|TARGET_POWERPC64
operator|&&
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|31
operator|)
expr_stmt|;
name|saving_FPRs_inline
operator|=
operator|(
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|||
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
operator|)
expr_stmt|;
comment|/* For V.4, update stack before we do any saving and set back pointer.  */
if|if
condition|(
name|info
operator|->
name|push_p
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|total_size
operator|<
literal|32767
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
else|else
name|frame_reg_rtx
operator|=
name|frame_ptr_rtx
expr_stmt|;
name|rs6000_emit_allocate_stack
argument_list|(
name|info
operator|->
name|total_size
argument_list|,
operator|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
operator|&&
operator|(
name|info
operator|->
name|cr_save_p
operator|||
name|info
operator|->
name|lr_save_p
operator|||
name|info
operator|->
name|first_fp_reg_save
operator|<
literal|64
operator|||
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|32
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
condition|)
name|rs6000_emit_stack_tie
argument_list|()
expr_stmt|;
block|}
comment|/* Save AltiVec registers if needed.  */
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|info
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* There should be a non inline version of this, for when we 	 are saving lots of vector registers.  */
for|for
control|(
name|i
operator|=
name|info
operator|->
name|first_altivec_reg_save
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|rtx
name|areg
decl_stmt|,
name|savereg
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|info
operator|->
name|altivec_save_offset
operator|+
name|sp_offset
operator|+
literal|16
operator|*
operator|(
name|i
operator|-
name|info
operator|->
name|first_altivec_reg_save
operator|)
expr_stmt|;
name|savereg
operator|=
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|areg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|areg
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* AltiVec addressing mode is [reg+reg].  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|areg
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|savereg
argument_list|)
expr_stmt|;
name|altivec_frame_fixup
argument_list|(
name|insn
argument_list|,
name|areg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* VRSAVE is a bit vector representing which AltiVec registers      are used.  The OS uses this to determine which vector      registers to save on a context switch.  We need to save      VRSAVE on the stack frame, add whatever AltiVec registers we      used in this function, and do the corresponding magic in the      epilogue.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|info
operator|->
name|vrsave_mask
operator|!=
literal|0
condition|)
block|{
name|rtx
name|reg
decl_stmt|,
name|mem
decl_stmt|,
name|vrsave
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* Get VRSAVE onto a GPR.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|vrsave
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|VRSAVE_REGNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MACHO
condition|)
name|emit_insn
argument_list|(
name|gen_get_vrsave_internal
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|vrsave
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save VRSAVE.  */
name|offset
operator|=
name|info
operator|->
name|vrsave_save_offset
operator|+
name|sp_offset
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Include the registers in the mask.  */
name|emit_insn
argument_list|(
name|gen_iorsi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|info
operator|->
name|vrsave_mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|generate_set_vrsave
argument_list|(
name|reg
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we use the link register, get it into r0.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we need to save CR, put it into r12.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
operator|&&
name|frame_reg_rtx
operator|!=
name|frame_ptr_rtx
condition|)
block|{
name|cr_save_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movesi_from_cr
argument_list|(
name|cr_save_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do any required saving of fpr's.  If only one or two to save, do      it ourselves.  Otherwise, call function.  */
if|if
condition|(
name|saving_FPRs_inline
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|rname
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|alloc_rname
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
operator|+
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rname
argument_list|,
literal|"%s%d%s"
argument_list|,
name|SAVE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|SAVE_FP_SUFFIX
argument_list|)
expr_stmt|;
name|alloc_rname
operator|=
name|ggc_strdup
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|alloc_rname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Save GPRs.  This is done as a PARALLEL if we are using      the store-multiple instructions.  */
if|if
condition|(
name|using_store_multiple
condition|)
block|{
name|rtvec
name|p
decl_stmt|,
name|dwarfp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
name|dwarfp
operator|=
name|rtvec_alloc
argument_list|(
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|)
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|==
literal|1
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ??? There's no need to emit actual instructions here, but it's the      easiest way to get the frame unwind information emitted.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|regno
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_reg_rtx
argument_list|,
name|info
operator|->
name|ehrd_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save lr if we used it.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* This should not be of rs6000_sr_alias_set, because of 	 __builtin_return_address.  */
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save CR if we use any that must be preserved.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|cr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
comment|/* If r12 was used to hold the original sp, copy cr into r0 now 	 that it's free.  */
if|if
condition|(
name|REGNO
argument_list|(
name|frame_reg_rtx
argument_list|)
operator|==
literal|12
condition|)
block|{
name|cr_save_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movesi_from_cr
argument_list|(
name|cr_save_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|cr_save_rtx
argument_list|)
expr_stmt|;
comment|/* Now, there's no way that dwarf2out_frame_debug_expr is going 	 to understand '(unspec:SI [(reg:CC 68) ...] 19)'.  But that's 	 OK.  All we have to do is specify that _one_ condition code 	 register is saved in this stack slot.  The thrower's epilogue 	 will then restore all the call-saved registers. 	 We use CR2_REGNO (70) to be compatible with gcc-2.95 on Linux.  */
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|cr_save_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|CR2_REGNO
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update stack and set back pointer unless this is V.4,       for which it was done previously.  */
if|if
condition|(
name|info
operator|->
name|push_p
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
name|rs6000_emit_allocate_stack
argument_list|(
name|info
operator|->
name|total_size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Set frame pointer, if needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|sp_reg_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are using RS6000_PIC_OFFSET_TABLE_REGNUM, we need to set it up.  */
if|if
condition|(
operator|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|&&
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|==
literal|1
operator|&&
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|)
condition|)
block|{
comment|/* If emit_load_toc_table will use the link register, we need to save        it.  We use R11 for this purpose because emit_load_toc_table        can use register 0.  This allows us to use a plain 'blr' to return        from the procedure more often.  */
name|int
name|save_LR_around_toc_setup
init|=
operator|(
name|TARGET_ELF
operator|&&
name|flag_pic
operator|!=
literal|0
operator|&&
operator|!
name|info
operator|->
name|lr_save_p
operator|&&
name|EXIT_BLOCK_PTR
operator|->
name|pred
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|save_LR_around_toc_setup
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|11
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_emit_load_toc_table
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_LR_around_toc_setup
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
condition|)
block|{
name|rtx
name|dest
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
decl_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_macho_picbase
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RS6000_PIC_OFFSET_TABLE_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_stack_info
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Write .extern for any function we will call to save and restore      fp values.  */
if|if
condition|(
name|info
operator|->
name|first_fp_reg_save
operator|<
literal|64
operator|&&
operator|!
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.extern %s%d%s\n\t.extern %s%d%s\n"
argument_list|,
name|SAVE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|SAVE_FP_SUFFIX
argument_list|,
name|RESTORE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|RESTORE_FP_SUFFIX
argument_list|)
expr_stmt|;
comment|/* Write .extern for AIX common mode routines, if needed.  */
if|if
condition|(
operator|!
name|TARGET_POWER
operator|&&
operator|!
name|TARGET_POWERPC
operator|&&
operator|!
name|common_mode_defined
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.extern __mulh\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __mull\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __divss\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __divus\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __quoss\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __quous\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|common_mode_defined
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HAVE_prologue
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* A NOTE_INSN_DELETED is supposed to be at the start and end of 	 the "toplevel" insn chain.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|rs6000_emit_prologue
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Expand INSN_ADDRESSES so final() doesn't crash. */
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|addr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_rtx_list
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|file
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
name|rs6000_pic_labelno
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit function epilogue as insns.     At present, dwarf2out_frame_debug_expr doesn't understand    register restores, so we don't bother setting RTX_FRAME_RELATED_P    anywhere in the epilogue.  Most of the insns below would in any case    need special notes to explain where r11 is in relation to the stack.  */
end_comment

begin_function
name|void
name|rs6000_emit_epilogue
parameter_list|(
name|sibcall
parameter_list|)
name|int
name|sibcall
decl_stmt|;
block|{
name|rs6000_stack_t
modifier|*
name|info
decl_stmt|;
name|int
name|restoring_FPRs_inline
decl_stmt|;
name|int
name|using_load_multiple
decl_stmt|;
name|int
name|using_mfcr_multiple
decl_stmt|;
name|int
name|use_backchain_to_restore_sp
decl_stmt|;
name|int
name|sp_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|sp_reg_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|frame_reg_rtx
init|=
name|sp_reg_rtx
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|TARGET_POWERPC64
condition|?
name|DImode
else|:
name|SImode
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_POWERPC64
condition|?
literal|8
else|:
literal|4
decl_stmt|;
name|int
name|i
decl_stmt|;
name|info
operator|=
name|rs6000_stack_info
argument_list|()
expr_stmt|;
name|using_load_multiple
operator|=
operator|(
name|TARGET_MULTIPLE
operator|&&
operator|!
name|TARGET_POWERPC64
operator|&&
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|31
operator|)
expr_stmt|;
name|restoring_FPRs_inline
operator|=
operator|(
name|sibcall
operator|||
name|current_function_calls_eh_return
operator|||
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|||
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
operator|)
expr_stmt|;
name|use_backchain_to_restore_sp
operator|=
operator|(
name|frame_pointer_needed
operator|||
name|current_function_calls_alloca
operator|||
name|info
operator|->
name|total_size
operator|>
literal|32767
operator|)
expr_stmt|;
name|using_mfcr_multiple
operator|=
operator|(
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC601
operator|||
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC603
operator|||
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC750
operator|||
name|optimize_size
operator|)
expr_stmt|;
comment|/* If we have a frame pointer, a call to alloca,  or a large stack      frame, restore the old stack pointer using the backchain.  Otherwise,      we know what size to update it with.  */
if|if
condition|(
name|use_backchain_to_restore_sp
condition|)
block|{
comment|/* Under V.4, don't reset the stack pointer until after we're done 	 loading the saved registers.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
name|frame_reg_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|frame_reg_rtx
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|sp_reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|push_p
condition|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
else|else
block|{
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|total_size
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|total_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore AltiVec registers if needed.  */
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|info
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|first_altivec_reg_save
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|areg
decl_stmt|,
name|mem
decl_stmt|;
name|areg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|areg
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|altivec_save_offset
operator|+
name|sp_offset
operator|+
literal|16
operator|*
operator|(
name|i
operator|-
name|info
operator|->
name|first_altivec_reg_save
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* AltiVec addressing mode is [reg+reg].  */
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|areg
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|V4SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore VRSAVE if needed.  */
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|info
operator|->
name|vrsave_mask
operator|!=
literal|0
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|,
name|reg
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|vrsave_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|generate_set_vrsave
argument_list|(
name|reg
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the old lr if we saved it.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Get the old cr if we saved it.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|cr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Set LR here to try to overlap restores below.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load exception handler data registers, if needed.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|;
name|regno
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_reg_rtx
argument_list|,
name|info
operator|->
name|ehrd_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore GPRs.  This is done as a PARALLEL if we are using      the load-multiple instructions.  */
if|if
condition|(
name|using_load_multiple
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|)
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|==
literal|1
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Restore fpr's if we need to do it without calling a function.  */
if|if
condition|(
name|restoring_FPRs_inline
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* If we saved cr, restore it here.  Just those that were used.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|r12_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|using_mfcr_multiple
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|using_mfcr_multiple
operator|&&
name|count
operator|>
literal|1
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
block|{
name|rtvec
name|r
init|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|r12_rtx
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
literal|1
operator|<<
operator|(
literal|7
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|ndx
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
operator|+
name|i
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|CCmode
argument_list|,
name|r
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|!=
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi_to_cr_one
argument_list|(
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
operator|+
name|i
argument_list|)
argument_list|,
name|r12_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is V.4, unwind the stack pointer after all of the loads      have been done.  We need to emit a block here so that sched      doesn't decide to move the sp change before the register restores      (which may not have any obvious dependency on the stack).  This      doesn't hurt performance, because there is no scheduling that can      be done after this point.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
condition|)
name|rs6000_emit_stack_tie
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_backchain_to_restore_sp
condition|)
block|{
name|emit_move_insn
argument_list|(
name|sp_reg_rtx
argument_list|,
name|frame_reg_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp_offset
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|Pmode
operator|==
name|SImode
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|rtx
name|sa
init|=
name|EH_RETURN_STACKADJ_RTX
decl_stmt|;
name|emit_insn
argument_list|(
name|Pmode
operator|==
name|SImode
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|sa
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sibcall
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|restoring_FPRs_inline
condition|)
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|3
operator|+
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have to restore more than two FP registers, branch to the 	 restore function.  It will return to our caller.  */
if|if
condition|(
operator|!
name|restoring_FPRs_inline
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|rname
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|alloc_rname
decl_stmt|;
name|sprintf
argument_list|(
name|rname
argument_list|,
literal|"%s%d%s"
argument_list|,
name|RESTORE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|RESTORE_FP_SUFFIX
argument_list|)
expr_stmt|;
name|alloc_rname
operator|=
name|ggc_strdup
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|alloc_rname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|3
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
name|int
name|optional_tbtab
init|=
operator|(
name|optimize_size
operator|||
name|TARGET_ELF
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_epilogue
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write anything except 	 the trace table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
comment|/* This is slightly ugly, but at least we don't have two 	     copies of the epilogue-emitting code.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* A NOTE_INSN_DELETED is supposed to be at the start 	     and end of the "toplevel" insn chain.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|rs6000_emit_epilogue
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Expand INSN_ADDRESSES so final() doesn't crash. */
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|addr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_rtx_list
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|file
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Output a traceback table here.  See /usr/include/sys/debug.h for info      on its format.       We don't output a traceback table if -finhibit-size-directive was      used.  The documentation for -finhibit-size-directive reads      ``don't output a @code{.size} assembler directive, or anything      else that would cause trouble if the function is split in the      middle, and the two halves are placed at locations far apart in      memory.''  The traceback table has this property, since it      includes the offset from the start of the function to the      traceback table itself.       System V.4 Powerpc's (and the embedded ABI derived from it) use a      different traceback table.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
specifier|const
name|char
modifier|*
name|fname
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|language_string
init|=
name|lang_hooks
operator|.
name|name
decl_stmt|;
name|int
name|fixed_parms
init|=
literal|0
decl_stmt|,
name|float_parms
init|=
literal|0
decl_stmt|,
name|parm_info
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|*
name|fname
operator|==
literal|'.'
condition|)
comment|/* V.4 encodes . in the name */
name|fname
operator|++
expr_stmt|;
comment|/* Need label immediately before tbtab, so we can compute its offset 	 from the function start.  */
if|if
condition|(
operator|*
name|fname
operator|==
literal|'*'
condition|)
operator|++
name|fname
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LT"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* The .tbtab pseudo-op can only be used for the first eight 	 expressions, since it can't handle the possibly variable 	 length fields that follow.  However, if you omit the optional 	 fields, the assembler outputs zeros for all optional fields 	 anyways, giving each variable length field is minimum length 	 (as defined in sys/debug.h).  Thus we can not use the .tbtab 	 pseudo-op at all.  */
comment|/* An all-zero word flags the start of the tbtab, for debuggers 	 that have to find it by searching forward from the entry 	 point or from the current pc.  */
name|fputs
argument_list|(
literal|"\t.long 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Tbtab format type.  Use format type 0.  */
name|fputs
argument_list|(
literal|"\t.byte 0,"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Language type.  Unfortunately, there doesn't seem to be any 	 official way to get this info, so we use language_string.  C 	 is 0.  C++ is 9.  No number defined for Obj-C, so use the 	 value for C for now.  There is no official value for Java,          although IBM appears to be using 13.  There is no official value 	 for Chill, so we've chosen 44 pseudo-randomly.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Objective-C"
argument_list|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
condition|)
name|i
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Pascal"
argument_list|)
condition|)
name|i
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
condition|)
name|i
operator|=
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Java"
argument_list|)
condition|)
name|i
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU CHILL"
argument_list|)
condition|)
name|i
operator|=
literal|44
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 8 single bit fields: global linkage (not set for C extern linkage, 	 apparently a PL/I convention?), out-of-line epilogue/prologue, offset 	 from start of procedure stored in tbtab, internal function, function 	 has controlled storage, function has no toc, function uses fp, 	 function logs/aborts fp operations.  */
comment|/* Assume that fp operations are used if any fp reg must be saved.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
name|optional_tbtab
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
operator|)
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 6 bitfields: function is interrupt handler, name present in 	 proc table, function calls alloca, on condition directives 	 (controls stack walks, 3 bits), saves condition reg, saves 	 link reg.  */
comment|/* The `function calls alloca' bit seems to be set whenever reg 31 is 	 set up as a frame pointer, even when there is no alloca call.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
operator|(
name|optional_tbtab
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|optional_tbtab
operator|&
name|frame_pointer_needed
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|info
operator|->
name|cr_save_p
operator|<<
literal|1
operator|)
operator||
operator|(
name|info
operator|->
name|lr_save_p
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 3 bitfields: saves backchain, fixup code, number of fpr saved 	 (6 bits).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
name|info
operator|->
name|push_p
operator|<<
literal|7
operator|)
operator||
operator|(
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
operator|)
argument_list|)
expr_stmt|;
comment|/* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
literal|32
operator|-
name|first_reg_to_save
argument_list|()
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optional_tbtab
condition|)
block|{
comment|/* Compute the parameter info from the function decl argument 	     list.  */
name|tree
name|decl
decl_stmt|;
name|int
name|next_parm_info_bit
init|=
literal|31
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|rtx
name|parameter
init|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|parameter
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|parameter
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|int
name|bits
decl_stmt|;
name|float_parms
operator|++
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|bits
operator|=
literal|0x2
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
name|bits
operator|=
literal|0x3
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If only one bit will fit, don't or in this entry.  */
if|if
condition|(
name|next_parm_info_bit
operator|>
literal|0
condition|)
name|parm_info
operator||=
operator|(
name|bits
operator|<<
operator|(
name|next_parm_info_bit
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|next_parm_info_bit
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fixed_parms
operator|+=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|next_parm_info_bit
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Number of fixed point parameters.  */
comment|/* This is actually the number of words of fixed point parameters; thus 	 an 8 byte struct counts as 2; and thus the maximum value is 8.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|fixed_parms
argument_list|)
expr_stmt|;
comment|/* 2 bitfields: number of floating point parameters (7 bits), parameters 	 all on stack.  */
comment|/* This is actually the number of fp registers that hold parameters; 	 and thus the maximum value is 13.  */
comment|/* Set parameters on stack bit if parameters are not in their original 	 registers, regardless of whether they are on the stack?  Xlc 	 seems to set the bit when not optimizing.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
operator|(
name|float_parms
operator|<<
literal|1
operator|)
operator||
operator|(
operator|!
name|optimize
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optional_tbtab
condition|)
return|return;
comment|/* Optional fields follow.  Some are variable length.  */
comment|/* Parameter types, left adjusted bit fields: 0 fixed, 10 single float, 	 11 double float.  */
comment|/* There is an entry for each parameter in a register, in the order that 	 they occur in the parameter list.  Any intervening arguments on the 	 stack are ignored.  If the list overflows a long (max possible length 	 34 bits) then completely leave off all elements that don't fit.  */
comment|/* Only emit this long if there was at least one parameter.  */
if|if
condition|(
name|fixed_parms
operator|||
name|float_parms
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long %d\n"
argument_list|,
name|parm_info
argument_list|)
expr_stmt|;
comment|/* Offset from start of code to tb table.  */
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LT"
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_AIX
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|#
directive|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
literal|"-."
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_AIX
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|#
directive|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Interrupt handler mask.  */
comment|/* Omit this long, since we never set the interrupt handler bit 	 above.  */
comment|/* Number of CTL (controlled storage) anchors.  */
comment|/* Omit this long, since the has_ctl bit is never set above.  */
comment|/* Displacement into stack of each CTL anchor.  */
comment|/* Omit this list of longs, because there are no CTL anchors.  */
comment|/* Length of function name.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.short %d\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Function name.  */
name|assemble_string
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register for alloca automatic storage; this is always reg 31. 	 Only emit this if the alloca bit was set above.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fputs
argument_list|(
literal|"\t.byte 31\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.align 2\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement that outputs the assembler code for a thunk    function, used to implement C++ virtual function calls with    multiple inheritance.  The thunk acts as a wrapper around a virtual    function, adjusting the implicit object parameter before handing    control off to the real function.     First, emit code to add the integer DELTA to the location that    contains the incoming first argument.  Assume that this argument    contains a pointer, and is the one used to pass the `this' pointer    in C++.  This is the incoming argument *before* the function    prologue, e.g. `%o0' on a sparc.  The addition must preserve the    values of all other incoming arguments.     After the addition, emit code to jump to FUNCTION, which is a    `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does    not touch the return address.  Hence returning from FUNCTION will    return to whoever called the current `thunk'.     The effect must be as if FUNCTION had been called directly with the    adjusted first argument.  This macro is responsible for emitting    all of the code for a thunk function; output_function_prologue()    and output_function_epilogue() are not invoked.     The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already    been extracted from it.)  It might possibly be useful on some    targets, but probably not.     If you do not define this macro, the target-independent code in the    C++ frontend will generate a less efficient heavyweight thunk that    calls FUNCTION instead of jumping to it.  The generic approach does    not support varargs.  */
end_comment

begin_function
name|void
name|output_mi_thunk
parameter_list|(
name|file
parameter_list|,
name|thunk_fndecl
parameter_list|,
name|delta
parameter_list|,
name|function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|thunk_fndecl
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|tree
name|function
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|this_reg
init|=
name|reg_names
index|[
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
condition|?
literal|4
else|:
literal|3
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|const
name|char
modifier|*
name|r0
init|=
name|reg_names
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|toc
init|=
name|reg_names
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|schain
init|=
name|reg_names
index|[
literal|11
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|r12
init|=
name|reg_names
index|[
literal|12
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|static
name|int
name|labelno
init|=
literal|0
decl_stmt|;
comment|/* Small constants that can be done by one add instruction.  */
if|if
condition|(
name|delta
operator|>=
operator|-
literal|32768
operator|&&
name|delta
operator|<=
literal|32767
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_NEW_MNEMONICS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcal %s,%d(%s)\n"
argument_list|,
name|this_reg
argument_list|,
name|delta
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddi %s,%s,%d\n"
argument_list|,
name|this_reg
argument_list|,
name|this_reg
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
comment|/* 64-bit constants.  If "int" is 32 bits, we'll never hit this abort.  */
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|(
name|delta
operator|<
operator|-
literal|2147483647
operator|-
literal|1
operator|||
name|delta
operator|>
literal|2147483647
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Large constants that can be done by one addis instruction.  */
elseif|else
if|if
condition|(
operator|(
name|delta
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cau|addis} %s,%s,%d\n"
argument_list|,
name|this_reg
argument_list|,
name|this_reg
argument_list|,
name|delta
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* 32-bit constants that can be done by an add and addis instruction.  */
else|else
block|{
comment|/* Break into two pieces, propagating the sign bit from the low 	 word to the upper word.  */
name|int
name|delta_low
init|=
operator|(
operator|(
name|delta
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|int
name|delta_high
init|=
operator|(
name|delta
operator|-
name|delta_low
operator|)
operator|>>
literal|16
decl_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cau|addis} %s,%s,%d\n"
argument_list|,
name|this_reg
argument_list|,
name|this_reg
argument_list|,
name|delta_high
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_NEW_MNEMONICS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcal %s,%d(%s)\n"
argument_list|,
name|this_reg
argument_list|,
name|delta_low
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddi %s,%s,%d\n"
argument_list|,
name|this_reg
argument_list|,
name|this_reg
argument_list|,
name|delta_low
argument_list|)
expr_stmt|;
block|}
comment|/* Get the prefix in front of the names.  */
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
name|prefix
operator|=
literal|"."
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
case|case
name|ABI_AIX_NODESC
case|:
name|prefix
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* If the function is compiled in this module, jump to it directly.      Otherwise, load up its address and jump to it.  */
name|fname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_file_function_operand
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"longcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tb %s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
condition|)
name|fputs
argument_list|(
literal|"@local"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
comment|/* Set up a TOC entry for the function.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"Lthunk"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|toc_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"Lthunk"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|labelno
operator|++
expr_stmt|;
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|TARGET_32BIT
condition|?
literal|"\t.long "
else|:
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs
argument_list|(
literal|"\t.tc "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"[TC],"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
condition|)
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
name|text_section
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|asm_fprintf
argument_list|(
name|file
argument_list|,
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|"\t{l|lwz} %s,%s(%s)\n"
else|:
literal|"\tld %s,%s(%s)\n"
argument_list|,
name|r12
argument_list|,
name|TARGET_ELF
condition|?
literal|".LCTOC0@toc"
else|:
literal|".LCTOC..1"
argument_list|,
name|toc
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|"\t{l|lwz} %s,"
else|:
literal|"\tld %s,"
argument_list|,
name|r12
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|&&
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"-(.LCTOC1)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)\n"
argument_list|,
name|TARGET_MINIMAL_TOC
condition|?
name|r12
else|:
name|toc
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|"\t{l|lwz} %s,0(%s)\n"
else|:
literal|"\tld %s,0(%s)\n"
argument_list|,
name|r0
argument_list|,
name|r12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|"\t{l|lwz} %s,4(%s)\n"
else|:
literal|"\tld %s,8(%s)\n"
argument_list|,
name|toc
argument_list|,
name|r12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtctr %s\n"
argument_list|,
name|r0
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|"\t{l|lwz} %s,8(%s)\n"
else|:
literal|"\tld %s,16(%s)\n"
argument_list|,
name|schain
argument_list|,
name|r12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbctr\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABI_AIX_NODESC
case|:
case|case
name|ABI_V4
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tb %s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|fputs
argument_list|(
literal|"@plt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|TARGET_MACHO
case|case
name|ABI_DARWIN
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tb %s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|machopic_name_defined_p
argument_list|(
name|fname
argument_list|)
condition|)
name|assemble_name
argument_list|(
name|file
argument_list|,
name|machopic_stub_name
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A quick summary of the various types of 'constant-pool tables'    under PowerPC:     Target	Flags		Name		One table per	    AIX		(none)		AIX TOC		object file    AIX		-mfull-toc	AIX TOC		object file    AIX		-mminimal-toc	AIX minimal TOC	translation unit    SVR4/EABI	(none)		SVR4 SDATA	object file    SVR4/EABI	-fpic		SVR4 pic	object file    SVR4/EABI	-fPIC		SVR4 PIC	translation unit    SVR4/EABI	-mrelocatable	EABI TOC	function    SVR4/EABI	-maix		AIX TOC		object file    SVR4/EABI	-maix -mminimal-toc  				AIX minimal TOC	translation unit     Name			Reg.	Set by	entries	      contains: 					made by	 addrs?	fp?	sum?     AIX TOC		2	crt0	as	 Y	option	option    AIX minimal TOC	30	prolog	gcc	 Y	Y	option    SVR4 SDATA		13	crt0	gcc	 N	Y	N    SVR4 pic		30	prolog	ld	 Y	not yet	N    SVR4 PIC		30	prolog	gcc	 Y	option	option    EABI TOC		30	prolog	gcc	 Y	option	option  */
end_comment

begin_comment
comment|/* Hash table stuff for keeping track of TOC entries.  */
end_comment

begin_struct
struct|struct
name|toc_hash_struct
block|{
comment|/* `key' will satisfy CONSTANT_P; in fact, it will satisfy      ASM_OUTPUT_SPECIAL_POOL_ENTRY_P.  */
name|rtx
name|key
decl_stmt|;
name|enum
name|machine_mode
name|key_mode
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|htab_t
name|toc_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash functions for the hash table.  */
end_comment

begin_function
specifier|static
name|unsigned
name|rs6000_hash_constant
parameter_list|(
name|k
parameter_list|)
name|rtx
name|k
decl_stmt|;
block|{
name|unsigned
name|result
init|=
operator|(
name|GET_CODE
argument_list|(
name|k
argument_list|)
operator|<<
literal|3
operator|)
operator|^
name|GET_MODE
argument_list|(
name|k
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|k
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|flen
init|=
name|strlen
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|int
name|fidx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|k
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|result
operator|*
literal|1231
operator|+
name|X0INT
argument_list|(
name|XEXP
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|3
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|k
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|fidx
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|k
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|fidx
operator|=
literal|3
expr_stmt|;
else|else
name|fidx
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|fidx
operator|<
name|flen
condition|;
name|fidx
operator|++
control|)
switch|switch
condition|(
name|format
index|[
name|fidx
index|]
condition|)
block|{
case|case
literal|'s'
case|:
block|{
name|unsigned
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|result
operator|*
literal|613
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|str
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
name|result
operator|=
name|result
operator|*
literal|1231
operator|+
name|rs6000_hash_constant
argument_list|(
name|XEXP
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|XINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|XWINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|XWINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
operator|>>
name|CHAR_BIT
operator|*
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|toc_hash_function
parameter_list|(
name|hash_entry
parameter_list|)
specifier|const
name|void
modifier|*
name|hash_entry
decl_stmt|;
block|{
specifier|const
name|struct
name|toc_hash_struct
modifier|*
name|thc
init|=
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|hash_entry
decl_stmt|;
return|return
name|rs6000_hash_constant
argument_list|(
name|thc
operator|->
name|key
argument_list|)
operator|^
name|thc
operator|->
name|key_mode
return|;
block|}
end_function

begin_comment
comment|/* Compare H1 and H2 for equivalence.  */
end_comment

begin_function
specifier|static
name|int
name|toc_hash_eq
parameter_list|(
name|h1
parameter_list|,
name|h2
parameter_list|)
specifier|const
name|void
modifier|*
name|h1
decl_stmt|;
specifier|const
name|void
modifier|*
name|h2
decl_stmt|;
block|{
name|rtx
name|r1
init|=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h1
operator|)
operator|->
name|key
decl_stmt|;
name|rtx
name|r2
init|=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h2
operator|)
operator|->
name|key
decl_stmt|;
if|if
condition|(
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h1
operator|)
operator|->
name|key_mode
operator|!=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h2
operator|)
operator|->
name|key_mode
condition|)
return|return
literal|0
return|;
comment|/* Gotcha:  One of these const_doubles will be in memory.      The other may be on the constant-pool chain.      So rtx_equal_p will think they are different...  */
if|if
condition|(
name|r1
operator|==
name|r2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|r2
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|r1
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|r2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|int
name|format_len
init|=
name|strlen
argument_list|(
name|GET_RTX_FORMAT
argument_list|(
name|CONST_DOUBLE
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|format_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XWINT
argument_list|(
name|r1
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|r2
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|r1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|r2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
else|else
return|return
name|rtx_equal_p
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark the hash table-entry HASH_ENTRY.  */
end_comment

begin_function
specifier|static
name|int
name|toc_hash_mark_entry
parameter_list|(
name|hash_slot
parameter_list|,
name|unused
parameter_list|)
name|void
modifier|*
modifier|*
name|hash_slot
decl_stmt|;
name|void
modifier|*
name|unused
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|struct
name|toc_hash_struct
modifier|*
name|hash_entry
init|=
operator|*
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|*
operator|)
name|hash_slot
decl_stmt|;
name|rtx
name|r
init|=
name|hash_entry
operator|->
name|key
decl_stmt|;
name|ggc_set_mark
argument_list|(
name|hash_entry
argument_list|)
expr_stmt|;
comment|/* For CODE_LABELS, we don't want to drag in the whole insn chain...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|ggc_set_mark
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|ggc_set_mark
argument_list|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ggc_mark_rtx
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark all the elements of the TOC hash-table *HT.  */
end_comment

begin_function
specifier|static
name|void
name|toc_hash_mark_table
parameter_list|(
name|vht
parameter_list|)
name|void
modifier|*
name|vht
decl_stmt|;
block|{
name|htab_t
modifier|*
name|ht
init|=
name|vht
decl_stmt|;
name|htab_traverse
argument_list|(
operator|*
name|ht
argument_list|,
name|toc_hash_mark_entry
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These are the names given by the C++ front-end to vtables, and    vtable-like objects.  Ideally, this logic should not be here;    instead, there should be some programmatic way of inquiring as    to whether or not an object is a vtable.  */
end_comment

begin_define
define|#
directive|define
name|VTABLE_NAME_P
parameter_list|(
name|NAME
parameter_list|)
define|\
value|(strncmp ("_vt.", name, strlen("_vt.")) == 0		\   || strncmp ("_ZTV", name, strlen ("_ZTV")) == 0	\   || strncmp ("_ZTT", name, strlen ("_ZTT")) == 0	\   || strncmp ("_ZTC", name, strlen ("_ZTC")) == 0)
end_define

begin_function
name|void
name|rs6000_output_symbol_ref
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
comment|/* Currently C++ toc references to vtables can be emitted before it      is decided whether the vtable is public or private.  If this is      the case, then the linker will eventually complain that there is      a reference to an unknown section.  Thus, for vtables only,       we emit the TOC reference to reference the symbol and not the      section.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|VTABLE_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a TOC entry.  We derive the entry name from what is being    written.  */
end_comment

begin_function
name|void
name|output_toc
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|labelno
parameter_list|,
name|mode
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|rtx
name|base
init|=
name|x
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TARGET_NO_TOC
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* When the linker won't eliminate them, don't output duplicate      TOC entries (this happens on AIX if there is any kind of TOC,      and on SVR4 under -fPIC or -mrelocatable).  */
if|if
condition|(
name|TARGET_TOC
condition|)
block|{
name|struct
name|toc_hash_struct
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|found
decl_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|key
operator|=
name|x
expr_stmt|;
name|h
operator|->
name|key_mode
operator|=
name|mode
expr_stmt|;
name|h
operator|->
name|labelno
operator|=
name|labelno
expr_stmt|;
name|found
operator|=
name|htab_find_slot
argument_list|(
name|toc_hash_table
argument_list|,
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|found
operator|==
name|NULL
condition|)
operator|*
name|found
operator|=
name|h
expr_stmt|;
else|else
comment|/* This is indeed a duplicate.   	       Set this label equal to that label.  */
block|{
name|fputs
argument_list|(
literal|"\t.set "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
operator|(
operator|*
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|*
operator|)
name|found
operator|)
operator|->
name|labelno
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we're going to put a double constant in the TOC, make sure it's      aligned properly when strict alignment is on.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|STRICT_ALIGNMENT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|64
operator|&&
operator|!
operator|(
name|TARGET_NO_FP_IN_TOC
operator|&&
operator|!
name|TARGET_MINIMAL_TOC
operator|)
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* Handle FP constants specially.  Note that if we have a minimal      TOC, things we put here aren't actually in the TOC, so we can allow      FP constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|k
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FD_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FD_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx,0x%lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FS_%lx[TC],"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx00000000\n"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FS_%lx[TC],"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx\n"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
block|{
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|high
operator|=
operator|(
name|low
operator|&
literal|0x80000000
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
block|}
else|#
directive|else
block|{
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
name|high
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TOC entries are always Pmode-sized, but since this 	 is a bigendian machine then if we're putting smaller 	 integer constants in the TOC we have to pad them. 	 (This is still a win over putting the constants in 	 a separate constant pool, because then we'd have 	 to have both a TOC entry _and_ the actual constant.)  	 For a 32-bit target, CONST_INT values are loaded and shifted 	 entirely within `low' and can be stored in one TOC entry.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|POINTER_SIZE
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* It would be easy to make this work, but it doesn't now.  */
if|if
condition|(
name|POINTER_SIZE
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|lshift_double
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|POINTER_SIZE
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|POINTER_SIZE
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc ID_%lx_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx\n"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|POINTER_SIZE
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc ID_%lx_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx,0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc IS_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|name
operator|=
name|XSTR
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|real_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|TARGET_32BIT
condition|?
literal|"\t.long "
else|:
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc %s"
argument_list|,
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".N%d"
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".P%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"[TC],"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Currently C++ toc references to vtables can be emitted before it      is decided whether the vtable is public or private.  If this is      the case, then the linker will eventually complain that there is      a TOC reference to an unknown section.  Thus, for vtables only,      we emit the TOC reference to reference the symbol and not the      section.  */
if|if
condition|(
name|VTABLE_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an assembler pseudo-op to write an ASCII string of N characters    starting at P to FILE.     On the RS/6000, we have to do this using the .byte operation and    write out special characters outside the quoted string.    Also, the assembler is broken; very long strings are truncated,    so we must artificially break them up early.  */
end_comment

begin_function
name|void
name|output_ascii
parameter_list|(
name|file
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|for_string
init|=
literal|"\t.byte \""
decl_stmt|;
specifier|const
name|char
modifier|*
name|for_decimal
init|=
literal|"\t.byte "
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_close
init|=
name|NULL
decl_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
if|if
condition|(
name|for_string
condition|)
name|fputs
argument_list|(
name|for_string
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Write two quotes to get one.  */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|++
name|count_string
expr_stmt|;
block|}
name|for_string
operator|=
name|NULL
expr_stmt|;
name|for_decimal
operator|=
literal|"\"\n\t.byte "
expr_stmt|;
name|to_close
operator|=
literal|"\"\n"
expr_stmt|;
operator|++
name|count_string
expr_stmt|;
if|if
condition|(
name|count_string
operator|>=
literal|512
condition|)
block|{
name|fputs
argument_list|(
name|to_close
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|for_string
operator|=
literal|"\t.byte \""
expr_stmt|;
name|for_decimal
operator|=
literal|"\t.byte "
expr_stmt|;
name|to_close
operator|=
name|NULL
expr_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|for_decimal
condition|)
name|fputs
argument_list|(
name|for_decimal
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|for_string
operator|=
literal|"\n\t.byte \""
expr_stmt|;
name|for_decimal
operator|=
literal|", "
expr_stmt|;
name|to_close
operator|=
literal|"\n"
expr_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now close the string if we have written one.  Then end the line.  */
if|if
condition|(
name|to_close
condition|)
name|fputs
argument_list|(
name|to_close
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a unique section name for FILENAME for a section type    represented by SECTION_DESC.  Output goes into BUF.     SECTION_DESC can be any string, as long as it is different for each    possible section type.     We name the section in the same manner as xlc.  The name begins with an    underscore followed by the filename (after stripping any leading directory    names) with the last period replaced by the string SECTION_DESC.  If    FILENAME does not contain a period, SECTION_DESC is appended to the end of    the name.  */
end_comment

begin_function
name|void
name|rs6000_gen_section_name
parameter_list|(
name|buf
parameter_list|,
name|filename
parameter_list|,
name|section_desc
parameter_list|)
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|section_desc
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|after_last_slash
decl_stmt|,
modifier|*
name|last_period
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|after_last_slash
operator|=
name|filename
expr_stmt|;
for|for
control|(
name|q
operator|=
name|filename
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'/'
condition|)
name|after_last_slash
operator|=
name|q
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
name|last_period
operator|=
name|q
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|after_last_slash
argument_list|)
operator|+
name|strlen
argument_list|(
name|section_desc
argument_list|)
operator|+
literal|2
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|q
operator|=
name|after_last_slash
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|==
name|last_period
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|section_desc
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|section_desc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
block|}
if|if
condition|(
name|last_period
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|section_desc
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit profile function.  */
end_comment

begin_function
name|void
name|output_profile_hook
parameter_list|(
name|labelno
parameter_list|)
name|int
name|labelno
decl_stmt|;
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|label_name
decl_stmt|;
name|rtx
name|fun
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|label_name
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fun
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_name
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|init_one_libfunc
argument_list|(
name|RS6000_MCOUNT
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|fun
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
condition|)
block|{
specifier|const
name|char
modifier|*
name|mcount_name
init|=
name|RS6000_MCOUNT
decl_stmt|;
name|int
name|caller_addr_regno
init|=
name|LINK_REGISTER_REGNUM
decl_stmt|;
comment|/* Be conservative and always set this, at least for now.  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* For PIC code, set up a stub and collect the caller's address 	 from r0, which is where the prologue puts it.  */
if|if
condition|(
name|flag_pic
condition|)
block|{
name|mcount_name
operator|=
name|machopic_stub_name
argument_list|(
name|mcount_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_uses_pic_offset_table
condition|)
name|caller_addr_regno
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|mcount_name
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|caller_addr_regno
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write function profiler code.  */
end_comment

begin_function
name|void
name|output_function_profiler
parameter_list|(
name|file
parameter_list|,
name|labelno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_V4
case|:
case|case
name|ABI_AIX_NODESC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|fputs
argument_list|(
literal|"\tbl _GLOBAL_OFFSET_TABLE_@local-4\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,4(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{l|lwz} %s,"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"@got(%s)\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|>
literal|1
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,4(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Now, we need to get the address of the label.  */
name|fputs
argument_list|(
literal|"\tbl 1f\n\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-.\n1:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{l|lwz} %s,0(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cax|add} %s,%s,%s\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{liu|lis} %s,"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@ha\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,4(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cal|la} %s,"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"@l(%s)\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_needs_context
condition|)
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmr %s,%s\n"
argument_list|,
name|reg_names
index|[
literal|30
index|]
argument_list|,
name|reg_names
index|[
name|STATIC_CHAIN_REGNUM
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbl %s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_needs_context
condition|)
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmr %s,%s\n"
argument_list|,
name|reg_names
index|[
name|STATIC_CHAIN_REGNUM
index|]
argument_list|,
name|reg_names
index|[
literal|30
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABI_AIX
case|:
case|case
name|ABI_DARWIN
case|:
comment|/* Don't do anything, done in output_profile_hook ().  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Data dependency; DEP_INSN writes a register that INSN reads 	 some cycles later.  */
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_JMPREG
case|:
comment|/* Tell the first scheduling pass about the latency between 	     a mtctr and bctr (and mtlr and br/blr).  The first 	     scheduling pass will not know about this latency since 	     the mtctr instruction, which has the latency associated 	     to it, will be generated by reload.  */
return|return
name|TARGET_POWER
condition|?
literal|5
else|:
literal|4
return|;
case|case
name|TYPE_BRANCH
case|:
comment|/* Leave some extra cycles between a compare and its 	     dependent branch, to inhibit expensive mispredicts.  */
if|if
condition|(
operator|(
name|rs6000_cpu_attr
operator|==
name|CPU_PPC750
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC7400
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC7450
operator|)
operator|&&
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|&&
operator|(
name|INSN_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_DELAYED_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_FPCOMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_CR_LOGICAL
operator|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
default|default:
break|break;
block|}
comment|/* Fall out to return default cost.  */
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* A C statement (sans semicolon) to update the integer scheduling    priority INSN_PRIORITY (INSN).  Reduce the priority to execute the    INSN earlier, increase the priority to execute INSN later.  Do not    define this macro if you do not need to adjust the scheduling    priorities of insns.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_adjust_priority
parameter_list|(
name|insn
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
comment|/* On machines (like the 750) which have asymmetric integer units,      where one integer unit can do multiply and divides and the other      can't, reduce the priority of multiply/divide so it is scheduled      before other integer operations.  */
if|#
directive|if
literal|0
block|if (! INSN_P (insn))     return priority;    if (GET_CODE (PATTERN (insn)) == USE)     return priority;    switch (rs6000_cpu_attr) {   case CPU_PPC750:     switch (get_attr_type (insn))       {       default: 	break;        case TYPE_IMUL:       case TYPE_IDIV: 	fprintf (stderr, "priority was %#x (%d) before adjustment\n", 		 priority, priority); 	if (priority>= 0&& priority< 0x01000000) 	  priority>>= 3; 	break;       }   }
endif|#
directive|endif
return|return
name|priority
return|;
block|}
end_function

begin_comment
comment|/* Return how many instructions the machine can issue per cycle.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_issue_rate
parameter_list|()
block|{
switch|switch
condition|(
name|rs6000_cpu_attr
condition|)
block|{
case|case
name|CPU_RIOS1
case|:
comment|/* ? */
case|case
name|CPU_RS64A
case|:
case|case
name|CPU_PPC601
case|:
comment|/* ? */
case|case
name|CPU_PPC7450
case|:
return|return
literal|3
return|;
case|case
name|CPU_PPC603
case|:
case|case
name|CPU_PPC750
case|:
case|case
name|CPU_PPC7400
case|:
return|return
literal|2
return|;
case|case
name|CPU_RIOS2
case|:
case|case
name|CPU_PPC604
case|:
case|case
name|CPU_PPC604E
case|:
case|case
name|CPU_PPC620
case|:
case|case
name|CPU_PPC630
case|:
return|return
literal|4
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Length in units of the trampoline for entering a nested function.  */
end_comment

begin_function
name|int
name|rs6000_trampoline_size
parameter_list|()
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
name|ret
operator|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|12
else|:
literal|24
expr_stmt|;
break|break;
case|case
name|ABI_DARWIN
case|:
case|case
name|ABI_V4
case|:
case|case
name|ABI_AIX_NODESC
case|:
name|ret
operator|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|40
else|:
literal|48
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|rs6000_initialize_trampoline
parameter_list|(
name|addr
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|rtx
name|fnaddr
decl_stmt|;
name|rtx
name|cxt
decl_stmt|;
block|{
name|enum
name|machine_mode
name|pmode
init|=
name|Pmode
decl_stmt|;
name|int
name|regsize
init|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|rtx
name|ctx_reg
init|=
name|force_reg
argument_list|(
name|pmode
argument_list|,
name|cxt
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Macros to shorten the code expansions below.  */
define|#
directive|define
name|MEM_DEREF
parameter_list|(
name|addr
parameter_list|)
value|gen_rtx_MEM (pmode, memory_address (pmode, addr))
define|#
directive|define
name|MEM_PLUS
parameter_list|(
name|addr
parameter_list|,
name|offset
parameter_list|)
define|\
value|gen_rtx_MEM (pmode, memory_address (pmode, plus_constant (addr, offset)))
comment|/* Under AIX, just build the 3 word function descriptor */
case|case
name|ABI_AIX
case|:
block|{
name|rtx
name|fn_reg
init|=
name|gen_reg_rtx
argument_list|(
name|pmode
argument_list|)
decl_stmt|;
name|rtx
name|toc_reg
init|=
name|gen_reg_rtx
argument_list|(
name|pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|fn_reg
argument_list|,
name|MEM_DEREF
argument_list|(
name|fnaddr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|toc_reg
argument_list|,
name|MEM_PLUS
argument_list|(
name|fnaddr
argument_list|,
name|regsize
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_DEREF
argument_list|(
name|addr
argument_list|)
argument_list|,
name|fn_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_PLUS
argument_list|(
name|addr
argument_list|,
name|regsize
argument_list|)
argument_list|,
name|toc_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_PLUS
argument_list|(
name|addr
argument_list|,
literal|2
operator|*
name|regsize
argument_list|)
argument_list|,
name|ctx_reg
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Under V.4/eabi/darwin, __trampoline_setup does the real work.  */
case|case
name|ABI_DARWIN
case|:
case|case
name|ABI_V4
case|:
case|case
name|ABI_AIX_NODESC
case|:
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|SImode
argument_list|,
literal|"__trampoline_setup"
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|,
name|addr
argument_list|,
name|pmode
argument_list|,
name|GEN_INT
argument_list|(
name|rs6000_trampoline_size
argument_list|()
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|fnaddr
argument_list|,
name|pmode
argument_list|,
name|ctx_reg
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|rs6000_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"longcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|rs6000_handle_longcall_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle a "longcall" attribute; arguments as in struct    attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_handle_longcall_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a reference suitable for calling a function with the    longcall attribute.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|rs6000_longcall_ref
parameter_list|(
name|call_ref
parameter_list|)
name|rtx
name|call_ref
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|call_name
decl_stmt|;
name|tree
name|node
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_ref
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|call_ref
return|;
comment|/* System V adds '.' to the internal name, so skip them.  */
name|call_name
operator|=
name|XSTR
argument_list|(
name|call_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|call_name
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
operator|*
name|call_name
operator|==
literal|'.'
condition|)
name|call_name
operator|++
expr_stmt|;
name|node
operator|=
name|get_identifier
argument_list|(
name|call_name
argument_list|)
expr_stmt|;
name|call_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|call_ref
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C statement or statements to switch to the appropriate section    for output of RTX in mode MODE.  You can assume that RTX is some    kind of constant in RTL.  The argument MODE is redundant except in    the case of a `const_int' rtx.  Select the section by calling    `text_section' or one of the alternatives for other sections.     Do not define this macro if you put all constants in the read-only    data section.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USING_ELFOS_H
end_ifdef

begin_function
name|void
name|rs6000_select_rtx_section
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
name|toc_section
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|)
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|const_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A C statement or statements to switch to the appropriate    section for output of DECL.  DECL is either a `VAR_DECL' node    or a constant of some sort.  RELOC indicates whether forming    the initial value of DECL requires link-time relocations.  */
end_comment

begin_function
name|void
name|rs6000_select_section
parameter_list|(
name|decl
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|needs_sdata
decl_stmt|;
name|int
name|readonly
decl_stmt|;
specifier|static
name|void
argument_list|(
argument|* const sec_funcs[
literal|4
argument|]
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|=
block|{
operator|&
name|const_section
block|,
operator|&
name|sdata2_section
block|,
operator|&
name|data_section
block|,
operator|&
name|sdata_section
block|}
expr_stmt|;
name|needs_sdata
operator|=
operator|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|g_switch_value
operator|&&
name|rs6000_sdata
operator|!=
name|SDATA_NONE
operator|&&
operator|(
name|rs6000_sdata
operator|!=
name|SDATA_DATA
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
name|readonly
operator|=
operator|!
name|flag_writable_strings
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|readonly
operator|=
operator|(
operator|!
operator|(
operator|(
name|flag_pic
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|)
operator|&&
name|reloc
operator|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|readonly
operator|=
operator|(
operator|!
operator|(
operator|(
name|flag_pic
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|)
operator|&&
name|reloc
operator|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
else|else
name|readonly
operator|=
operator|!
operator|(
operator|(
name|flag_pic
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|)
operator|&&
name|reloc
operator|)
expr_stmt|;
if|if
condition|(
name|needs_sdata
operator|&&
name|rs6000_sdata
operator|!=
name|SDATA_EABI
condition|)
name|readonly
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|sec_funcs
index|[
operator|(
name|readonly
condition|?
literal|0
else|:
literal|2
operator|)
operator|+
operator|(
name|needs_sdata
condition|?
literal|1
else|:
literal|0
operator|)
index|]
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A C statement to build up a unique section name, expressed as a    STRING_CST node, and assign it to DECL_SECTION_NAME (decl).    RELOC indicates whether the initial value of EXP requires    link-time relocations.  If you do not define this macro, GCC will use    the symbol name prefixed by `.' as the section name.  Note - this    macro can now be called for uninitialized data items as well as    initialised data and functions.  */
end_comment

begin_function
name|void
name|rs6000_unique_section
parameter_list|(
name|decl
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|sec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|prefixes
index|[
literal|7
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|".rodata."
block|,
literal|".gnu.linkonce.r."
block|}
block|,
block|{
literal|".sdata2."
block|,
literal|".gnu.linkonce.s2."
block|}
block|,
block|{
literal|".data."
block|,
literal|".gnu.linkonce.d."
block|}
block|,
block|{
literal|".sdata."
block|,
literal|".gnu.linkonce.s."
block|}
block|,
block|{
literal|".bss."
block|,
literal|".gnu.linkonce.b."
block|}
block|,
block|{
literal|".sbss."
block|,
literal|".gnu.linkonce.sb."
block|}
block|,
block|{
literal|".text."
block|,
literal|".gnu.linkonce.t."
block|}
block|}
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|sec
operator|=
literal|6
expr_stmt|;
else|else
block|{
name|int
name|readonly
decl_stmt|;
name|int
name|needs_sdata
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
name|readonly
operator|=
operator|!
name|flag_writable_strings
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|readonly
operator|=
operator|(
operator|!
operator|(
operator|(
name|flag_pic
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|)
operator|&&
name|reloc
operator|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
name|readonly
operator|=
operator|!
operator|(
operator|(
name|flag_pic
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|)
operator|&&
name|reloc
operator|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|needs_sdata
operator|=
operator|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|g_switch_value
operator|&&
name|rs6000_sdata
operator|!=
name|SDATA_NONE
operator|&&
operator|(
name|rs6000_sdata
operator|!=
name|SDATA_DATA
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|sec
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|readonly
condition|)
name|sec
operator|=
literal|2
expr_stmt|;
else|else
name|sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needs_sdata
condition|)
block|{
comment|/* .sdata2 is only for EABI.  */
if|if
condition|(
name|sec
operator|==
literal|0
operator|&&
name|rs6000_sdata
operator|!=
name|SDATA_EABI
condition|)
name|sec
operator|=
literal|2
expr_stmt|;
name|sec
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|STRIP_NAME_ENCODING
argument_list|(
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|prefixes
index|[
name|sec
index|]
index|[
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are referencing a function that is static or is known to be    in this file, make the SYMBOL_REF special.  We can use this to indicate    that we can branch to this function without emitting a no-op after the    call.  For real AIX calling sequences, we also replace the    function name with the real name (1 or 2 leading .'s), rather than    the function descriptor name.  This saves a lot of overriding code    to read the prefixes.  */
end_comment

begin_function
name|void
name|rs6000_encode_section_info
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|rtx
name|sym_ref
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|SYMBOL_REF_FLAG
argument_list|(
name|sym_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
name|size_t
name|len1
init|=
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|)
condition|?
literal|1
else|:
literal|2
decl_stmt|;
name|size_t
name|len2
init|=
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|alloca
argument_list|(
name|len1
operator|+
name|len2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|+
name|len1
argument_list|,
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|str
argument_list|,
name|len1
operator|+
name|len2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rs6000_sdata
operator|!=
name|SDATA_NONE
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|section_name
init|=
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|section_name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|section_name
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|name
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|section_name
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|section_name
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|g_switch_value
operator|)
operator|||
operator|(
name|name
operator|&&
operator|(
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".sdata"
argument_list|)
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".sdata2"
argument_list|)
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata2"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".sbss"
argument_list|)
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".sbss2"
argument_list|)
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss2"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".PPC.EMB.sdata0"
argument_list|)
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PPC.EMB.sdata0"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".PPC.EMB.sbss0"
argument_list|)
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|sym_ref
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USING_ELFOS_H */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.     r0 is special and we must not select it as an address    register by this routine since our caller will try to    increment the returned register via an "la" instruction.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rs6000_fatal_bad_address
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
name|fatal_insn
argument_list|(
literal|"bad address"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to register all of our global variables with the garbage    collector.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_add_gc_roots
parameter_list|()
block|{
name|ggc_add_rtx_root
argument_list|(
operator|&
name|rs6000_compare_op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|rs6000_compare_op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|toc_hash_table
operator|=
name|htab_create
argument_list|(
literal|1021
argument_list|,
name|toc_hash_function
argument_list|,
name|toc_hash_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|toc_hash_table
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|toc_hash_table
argument_list|)
argument_list|,
name|toc_hash_mark_table
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
name|machopic_add_gc_roots
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_endif
unit|int symbolic_operand (op)      rtx op; {   switch (GET_CODE (op))     {     case SYMBOL_REF:     case LABEL_REF:       return 1;     case CONST:       op = XEXP (op, 0);       return (GET_CODE (op) == SYMBOL_REF || 	      (GET_CODE (XEXP (op, 0)) == SYMBOL_REF 	       || GET_CODE (XEXP (op, 0)) == LABEL_REF)&& GET_CODE (XEXP (op, 1)) == CONST_INT);     default:       return 0;     } }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RS6000_LONG_BRANCH
end_ifdef

begin_decl_stmt
specifier|static
name|tree
name|stub_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ADD_COMPILER_STUB adds the compiler generated stub for handling     procedure calls to the linked list.  */
end_comment

begin_function
name|void
name|add_compiler_stub
parameter_list|(
name|label_name
parameter_list|,
name|function_name
parameter_list|,
name|line_number
parameter_list|)
name|tree
name|label_name
decl_stmt|;
name|tree
name|function_name
decl_stmt|;
name|int
name|line_number
decl_stmt|;
block|{
name|tree
name|stub
init|=
name|build_tree_list
argument_list|(
name|function_name
argument_list|,
name|label_name
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|stub
argument_list|)
operator|=
name|build_int_2
argument_list|(
name|line_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|stub
argument_list|)
operator|=
name|stub_list
expr_stmt|;
name|stub_list
operator|=
name|stub
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|STUB_LABEL_NAME
parameter_list|(
name|STUB
parameter_list|)
value|TREE_VALUE (STUB)
end_define

begin_define
define|#
directive|define
name|STUB_FUNCTION_NAME
parameter_list|(
name|STUB
parameter_list|)
value|TREE_PURPOSE (STUB)
end_define

begin_define
define|#
directive|define
name|STUB_LINE_NUMBER
parameter_list|(
name|STUB
parameter_list|)
value|TREE_INT_CST_LOW (TREE_TYPE (STUB))
end_define

begin_comment
comment|/* OUTPUT_COMPILER_STUB outputs the compiler generated stub for    handling procedure calls from the linked list and initializes the    linked list.  */
end_comment

begin_function
name|void
name|output_compiler_stub
parameter_list|()
block|{
name|char
name|tmp_buf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|label_buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|tree
name|tmp_stub
decl_stmt|,
name|stub
decl_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
for|for
control|(
name|stub
operator|=
name|stub_list
init|;
name|stub
condition|;
name|stub
operator|=
name|TREE_CHAIN
argument_list|(
name|stub
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s:\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|STUB_LABEL_NAME
argument_list|(
name|stub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.stabd 68,0,%d\n"
argument_list|,
name|STUB_LINE_NUMBER
argument_list|(
name|stub
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|STUB_FUNCTION_NAME
argument_list|(
name|stub
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|strcpy
argument_list|(
name|label_buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|STUB_FUNCTION_NAME
argument_list|(
name|stub
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|label_buf
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|label_buf
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|STUB_FUNCTION_NAME
argument_list|(
name|stub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tmp_buf
argument_list|,
literal|"lis r12,hi16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|")\n\tori r12,r12,lo16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|")\n\tmtctr r12\n\tbctr"
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|tmp_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.stabd 68,0,%d\n"
argument_list|,
name|STUB_LINE_NUMBER
argument_list|(
name|stub
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
block|}
name|stub_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NO_PREVIOUS_DEF checks in the link list whether the function name is    already there or not.  */
end_comment

begin_function
name|int
name|no_previous_def
parameter_list|(
name|function_name
parameter_list|)
name|tree
name|function_name
decl_stmt|;
block|{
name|tree
name|stub
decl_stmt|;
for|for
control|(
name|stub
operator|=
name|stub_list
init|;
name|stub
condition|;
name|stub
operator|=
name|TREE_CHAIN
argument_list|(
name|stub
argument_list|)
control|)
if|if
condition|(
name|function_name
operator|==
name|STUB_FUNCTION_NAME
argument_list|(
name|stub
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* GET_PREV_LABEL gets the label name from the previous definition of    the function.  */
end_comment

begin_function
name|tree
name|get_prev_label
parameter_list|(
name|function_name
parameter_list|)
name|tree
name|function_name
decl_stmt|;
block|{
name|tree
name|stub
decl_stmt|;
for|for
control|(
name|stub
operator|=
name|stub_list
init|;
name|stub
condition|;
name|stub
operator|=
name|TREE_CHAIN
argument_list|(
name|stub
argument_list|)
control|)
if|if
condition|(
name|function_name
operator|==
name|STUB_FUNCTION_NAME
argument_list|(
name|stub
argument_list|)
condition|)
return|return
name|STUB_LABEL_NAME
argument_list|(
name|stub
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* INSN is either a function call or a millicode call.  It may have an    unconditional jump in its delay slot.       CALL_DEST is the routine we are calling.  */
end_comment

begin_function
name|char
modifier|*
name|output_call
parameter_list|(
name|insn
parameter_list|,
name|call_dest
parameter_list|,
name|operand_number
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|call_dest
decl_stmt|;
name|int
name|operand_number
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_dest
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|TARGET_LONG_BRANCH
operator|&&
operator|!
name|flag_pic
condition|)
block|{
name|tree
name|labelname
decl_stmt|;
name|tree
name|funname
init|=
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|call_dest
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|no_previous_def
argument_list|(
name|funname
argument_list|)
condition|)
block|{
name|int
name|line_number
decl_stmt|;
name|rtx
name|label_rtx
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|char
modifier|*
name|label_buf
decl_stmt|,
name|temp_buf
index|[
literal|256
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|temp_buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|label_buf
operator|=
name|temp_buf
index|[
literal|0
index|]
operator|==
literal|'*'
condition|?
name|temp_buf
operator|+
literal|1
else|:
name|temp_buf
expr_stmt|;
name|labelname
operator|=
name|get_identifier
argument_list|(
name|label_buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
condition|)
name|line_number
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_compiler_stub
argument_list|(
name|labelname
argument_list|,
name|funname
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
block|}
else|else
name|labelname
operator|=
name|get_prev_label
argument_list|(
name|funname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"jbsr %%z%d,%.246s"
argument_list|,
name|operand_number
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|labelname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bl %%z%d"
argument_list|,
name|operand_number
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RS6000_LONG_BRANCH */
end_comment

begin_define
define|#
directive|define
name|GEN_LOCAL_LABEL_FOR_SYMBOL
parameter_list|(
name|BUF
parameter_list|,
name|SYMBOL
parameter_list|,
name|LENGTH
parameter_list|,
name|N
parameter_list|)
define|\
value|do {								\     const char *const symbol_ = (SYMBOL);			\     char *buffer_ = (BUF);					\     if (symbol_[0] == '"')					\       {								\         sprintf(buffer_, "\"L%d$%s", (N), symbol_+1);		\       }								\     else if (name_needs_quotes(symbol_))			\       {								\         sprintf(buffer_, "\"L%d$%s\"", (N), symbol_);		\       }								\     else							\       {								\         sprintf(buffer_, "L%d$%s", (N), symbol_);		\       }								\   } while (0)
end_define

begin_comment
comment|/* Generate PIC and indirect symbol stubs.  */
end_comment

begin_function
name|void
name|machopic_output_stub
parameter_list|(
name|file
parameter_list|,
name|symb
parameter_list|,
name|stub
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|symb
decl_stmt|,
decl|*
name|stub
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|symbol_name
decl_stmt|,
modifier|*
name|lazy_ptr_name
decl_stmt|;
name|char
modifier|*
name|local_label_0
decl_stmt|;
specifier|static
name|int
name|label
init|=
literal|0
decl_stmt|;
comment|/* Lose our funky encoding stuff so it doesn't contaminate the stub.  */
name|STRIP_NAME_ENCODING
argument_list|(
name|symb
argument_list|,
name|symb
argument_list|)
expr_stmt|;
name|label
operator|+=
literal|1
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_SYMBOL_NAME_FOR_SYMBOL
argument_list|(
name|symbol_name
argument_list|,
name|symb
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|lazy_ptr_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_LAZY_PTR_NAME_FOR_SYMBOL
argument_list|(
name|lazy_ptr_name
argument_list|,
name|symb
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|local_label_0
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_LOCAL_LABEL_FOR_SYMBOL
argument_list|(
name|local_label_0
argument_list|,
name|symb
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
name|machopic_picsymbol_stub_section
argument_list|()
expr_stmt|;
else|else
name|machopic_symbol_stub_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr r0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbcl 20,31,%s\n"
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n\tmflr r11\n"
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddis r11,r11,ha16(%s-%s)\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtlr r0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlwz r12,lo16(%s-%s)(r11)\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtctr r12\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddi r11,r11,lo16(%s-%s)\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbctr\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"non-pure not supported\n"
argument_list|)
expr_stmt|;
name|machopic_lazy_symbol_ptr_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long dyld_stub_binding_helper\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already    position-independent, we return ORIG.  Newly generated    position-independent addresses go into a reg.  This is REG if non    zero, otherwise we allocate register(s) as necessary.  */
end_comment

begin_define
define|#
directive|define
name|SMALL_INT
parameter_list|(
name|X
parameter_list|)
value|((unsigned) (INTVAL(X) + 0x8000)< 0x10000)
end_define

begin_function
name|rtx
name|rs6000_machopic_legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
operator|&&
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|mem
init|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
decl_stmt|;
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|mem
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
return|;
block|}
block|}
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/* Fall back on generic machopic code.  */
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|orig
argument_list|,
name|mode
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is just a placeholder to make linking work without having to    add this to the generic Darwin EXTRA_SECTIONS.  If -mcall-aix is    ever needed for Darwin (not too likely!) this would have to get a    real definition.  */
end_comment

begin_function
name|void
name|toc_section
parameter_list|()
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_MACHO */
end_comment

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_function
specifier|static
name|unsigned
name|int
name|rs6000_elf_section_type_flags
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|unsigned
name|int
name|flags
init|=
name|default_section_type_flags
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
name|flags
operator||=
name|SECTION_WRITE
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Record an element in the table of global constructors.  SYMBOL is    a SYMBOL_REF of the function to be called; PRIORITY is a number    between 0 and MAX_INIT_PRIORITY.     This differs from default_named_section_asm_out_constructor in    that we have special handling for -mrelocatable.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_asm_out_constructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".ctors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".ctors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper                   order; constructors are run from right to left, and the                   linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.long ("
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")@fixup\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_elf_asm_out_destructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".dtors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".dtors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper                   order; constructors are run from right to left, and the                   linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.long ("
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")@fixup\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_function
specifier|static
name|void
name|xcoff_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.csect %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

