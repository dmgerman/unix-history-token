begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IBM RS/6000.    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,     2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_if
if|#
directive|if
name|TARGET_XCOFF
end_if

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* get declarations of xcoff_*_section_name */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_NO_PROTOTYPE
end_ifndef

begin_define
define|#
directive|define
name|TARGET_NO_PROTOTYPE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EASY_VECTOR_15
parameter_list|(
name|n
parameter_list|)
value|((n)>= -16&& (n)<= 15)
end_define

begin_define
define|#
directive|define
name|EASY_VECTOR_15_ADD_SELF
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0x10&& (n)<= 0x1e \&& !((n)& 1))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_comment
comment|/* Structure used to define the rs6000 stack */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rs6000_stack
block|{
name|int
name|first_gp_reg_save
decl_stmt|;
comment|/* first callee saved GP register used */
name|int
name|first_fp_reg_save
decl_stmt|;
comment|/* first callee saved FP register used */
name|int
name|first_altivec_reg_save
decl_stmt|;
comment|/* first callee saved AltiVec register used */
name|int
name|lr_save_p
decl_stmt|;
comment|/* true if the link reg needs to be saved */
name|int
name|cr_save_p
decl_stmt|;
comment|/* true if the CR reg needs to be saved */
name|unsigned
name|int
name|vrsave_mask
decl_stmt|;
comment|/* mask of vec registers to save */
name|int
name|toc_save_p
decl_stmt|;
comment|/* true if the TOC needs to be saved */
name|int
name|push_p
decl_stmt|;
comment|/* true if we need to allocate stack space */
name|int
name|calls_p
decl_stmt|;
comment|/* true if the function makes any calls */
name|enum
name|rs6000_abi
name|abi
decl_stmt|;
comment|/* which ABI to use */
name|int
name|gp_save_offset
decl_stmt|;
comment|/* offset to save GP regs from initial SP */
name|int
name|fp_save_offset
decl_stmt|;
comment|/* offset to save FP regs from initial SP */
name|int
name|altivec_save_offset
decl_stmt|;
comment|/* offset to save AltiVec regs from initial SP */
name|int
name|lr_save_offset
decl_stmt|;
comment|/* offset to save LR from initial SP */
name|int
name|cr_save_offset
decl_stmt|;
comment|/* offset to save CR from initial SP */
name|int
name|vrsave_save_offset
decl_stmt|;
comment|/* offset to save VRSAVE from initial SP */
name|int
name|spe_gp_save_offset
decl_stmt|;
comment|/* offset to save spe 64-bit gprs  */
name|int
name|toc_save_offset
decl_stmt|;
comment|/* offset to save the TOC pointer */
name|int
name|varargs_save_offset
decl_stmt|;
comment|/* offset to save the varargs registers */
name|int
name|ehrd_offset
decl_stmt|;
comment|/* offset to EH return data */
name|int
name|reg_size
decl_stmt|;
comment|/* register size (4 or 8) */
name|int
name|varargs_size
decl_stmt|;
comment|/* size to hold V.4 args passed in regs */
name|HOST_WIDE_INT
name|vars_size
decl_stmt|;
comment|/* variable save area size */
name|int
name|parm_size
decl_stmt|;
comment|/* outgoing parameter size */
name|int
name|save_size
decl_stmt|;
comment|/* save area size */
name|int
name|fixed_size
decl_stmt|;
comment|/* fixed size of stack frame */
name|int
name|gp_size
decl_stmt|;
comment|/* size of saved GP registers */
name|int
name|fp_size
decl_stmt|;
comment|/* size of saved FP registers */
name|int
name|altivec_size
decl_stmt|;
comment|/* size of saved AltiVec registers */
name|int
name|cr_size
decl_stmt|;
comment|/* size to hold CR if not in save_size */
name|int
name|lr_size
decl_stmt|;
comment|/* size to hold LR if not in save_size */
name|int
name|vrsave_size
decl_stmt|;
comment|/* size to hold VRSAVE if not in save_size */
name|int
name|altivec_padding_size
decl_stmt|;
comment|/* size of altivec alignment padding if 				   not in save_size */
name|int
name|spe_gp_size
decl_stmt|;
comment|/* size of 64-bit GPR save size for SPE */
name|int
name|spe_padding_size
decl_stmt|;
name|int
name|toc_size
decl_stmt|;
comment|/* size to hold TOC if not in save_size */
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
comment|/* total bytes allocated for stack */
name|int
name|spe_64bit_regs_used
decl_stmt|;
block|}
name|rs6000_stack_t
typedef|;
end_typedef

begin_comment
comment|/* Target cpu type */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|rs6000_cpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rs6000_cpu_select
name|rs6000_select
index|[
literal|3
index|]
init|=
block|{
comment|/* switch		name,			tune	arch */
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"--with-cpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mcpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mtune="
block|,
literal|1
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Always emit branch hint bits.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|bool
name|rs6000_always_hint
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Schedule instructions for group formation.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|bool
name|rs6000_sched_groups
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Support adjust_priority scheduler hook     and -mprioritize-restricted-insns= option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_sched_restricted_insns_priority_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_sched_restricted_insns_priority
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support for -msched-costly-dep option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_sched_costly_dep_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|rs6000_dependence_cost
name|rs6000_sched_costly_dep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support for -minsert-sched-nops option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_sched_insert_nops_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|rs6000_nop_insertion
name|rs6000_sched_insert_nops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of long double */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_long_double_size_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_long_double_type_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether -mabi=altivec has appeared */
end_comment

begin_decl_stmt
name|int
name|rs6000_altivec_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether VRSAVE instructions should be generated.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_altivec_vrsave
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String from -mvrsave= option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_altivec_vrsave_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want SPE ABI extensions.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_spe_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether isel instructions should be generated.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_isel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether SPE simd instructions should be generated.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_spe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if floating point operations are done in the GPRs.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_float_gprs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String from -mfloat-gprs=.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_float_gprs_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String from -misel=.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_isel_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String from -mspe=.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_spe_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero once AIX common-mode calls have been defined.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|common_mode_defined
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|rs6000_compare_op0
decl_stmt|,
name|rs6000_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_compare_fp_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label number of label created for -mrelocatable, to call to so we can    get the address of the GOT section */
end_comment

begin_decl_stmt
name|int
name|rs6000_pic_labelno
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USING_ELFOS_H
end_ifdef

begin_comment
comment|/* Which abi to adhere to */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_abi_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Semantics of the small data area */
end_comment

begin_decl_stmt
name|enum
name|rs6000_sdata_type
name|rs6000_sdata
init|=
name|SDATA_DATA
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which small data model to use */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_sdata_name
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter for labels which are to be placed in .fixup.  */
end_comment

begin_decl_stmt
name|int
name|fixuplabelno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bit size of immediate TLS offsets and string from which it is decoded.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_tls_size
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_tls_size_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ABI enumeration available for subtarget to use.  */
end_comment

begin_decl_stmt
name|enum
name|rs6000_abi
name|rs6000_current_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ABI string from -mabi= option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_abi_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug flags */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_debug_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_debug_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug stack applications */
end_comment

begin_decl_stmt
name|int
name|rs6000_debug_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug argument handling */
end_comment

begin_comment
comment|/* Opaque types.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|opaque_V2SI_type_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|opaque_V2SF_type_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|opaque_p_V2SI_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* AltiVec requires a few more basic types in addition to the vector    types already defined in tree.c.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|bool_char_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* __bool char */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|bool_short_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* __bool short */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|bool_int_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* __bool int */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pixel_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* __pixel */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|bool_V16QI_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* __vector __bool char */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|bool_V8HI_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* __vector __bool short */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|bool_V4SI_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* __vector __bool int */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pixel_V8HI_type_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* __vector __pixel */
end_comment

begin_decl_stmt
name|int
name|rs6000_warn_altivec_long
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On by default. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_warn_altivec_long_switch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_traceback_name
decl_stmt|;
end_decl_stmt

begin_enum
specifier|static
enum|enum
block|{
name|traceback_default
init|=
literal|0
block|,
name|traceback_none
block|,
name|traceback_part
block|,
name|traceback_full
block|}
name|rs6000_traceback
enum|;
end_enum

begin_comment
comment|/* Flag to say the TOC is initialized */
end_comment

begin_decl_stmt
name|int
name|toc_initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|toc_label_name
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alias set for saves and restores from the rs6000 stack.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|rs6000_sr_alias_set
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Call distance, overridden by -mlongcall and #pragma longcall(1).    The only place that looks at this is rs6000_set_default_type_attributes;    everywhere else should rely on the presence or absence of a longcall    attribute on the function declaration.  Exception: init_cumulative_args    looks at it too, for libcalls.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_default_long_calls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_longcall_switch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control alignment for fields within structures.  */
end_comment

begin_comment
comment|/* String from -malign-XXXXX.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_alignment_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_alignment_flags
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|builtin_description
block|{
comment|/* mask is not const because we're going to alter it below.  This      nonsense will go away when we rewrite the -march infrastructure      to give us more target flag bits.  */
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|rs6000_builtins
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|bool
name|rs6000_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|num_insns_constant_wide
parameter_list|(
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_condition_mode
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_generate_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_maybe_dead
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_emit_stack_tie
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_frame_related
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_synthesize_frame_save
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|spe_func_has_64bit_regs_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_frame_save
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_frame_mem_offset
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_emit_allocate_stack
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|rs6000_hash_constant
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|toc_hash_function
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|toc_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|constant_pool_expr_1
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|constant_pool_expr_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|toc_relative_expr_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|legitimate_small_data_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|legitimate_offset_address_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|legitimate_indexed_address_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|legitimate_indirect_address_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|macho_lo_sum_memory_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|legitimate_lo_sum_address_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|rs6000_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_assemble_integer
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
end_ifdef

begin_function_decl
specifier|static
name|void
name|rs6000_assemble_visibility
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|rs6000_ra_ever_killed
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rs6000_handle_longcall_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rs6000_handle_altivec_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_mangle_fundamental_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|attribute_spec
name|rs6000_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rs6000_set_default_type_attributes
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_emit_set_long_const
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_return_in_memory
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_function_decl
specifier|static
name|unsigned
name|int
name|rs6000_elf_section_type_flags
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_elf_asm_out_constructor
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_elf_asm_out_destructor
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|rs6000_elf_end_indicate_exec_stack
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rs6000_elf_select_section
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_elf_unique_section
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_elf_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|rs6000_elf_encode_section_info
argument_list|(
name|tree
argument_list|,
name|rtx
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|rs6000_elf_in_small_data_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET_XCOFF
end_if

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_asm_globalize_label
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_select_section
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_unique_section
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_xcoff_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|rs6000_xcoff_section_type_flags
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_file_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_function_decl
specifier|static
name|bool
name|rs6000_binds_local_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|rs6000_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_variable_issue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_microcoded_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_dispatch_slot_restricted
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_cracked_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_branch_slot_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_adjust_priority
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_is_costly_dependence
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_next_active_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|insn_terminates_group_p
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|group_termination
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_costly_group
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|force_new_group
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|redefine_groups
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pad_groups
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_sched_finish
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_use_sched_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_expand_ternop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|altivec_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_common_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_init_libfuncs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_mask_for_builtins
parameter_list|(
name|struct
name|builtin_description
modifier|*
parameter_list|,
name|int
parameter_list|,
name|enum
name|rs6000_builtins
parameter_list|,
name|enum
name|rs6000_builtins
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spe_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_expand_stv_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_expand_predicate_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_expand_evsel_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_emit_int_cmove
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rs6000_stack_t
modifier|*
name|rs6000_stack_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_stack_info
parameter_list|(
name|rs6000_stack_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_ld_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_st_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_dst_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_abs_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_predicate_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_lv_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_stv_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_parse_abi_options
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_parse_alignment_option
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_parse_tls_size_option
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_parse_yes_no_option
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|first_altivec_reg_to_save
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|compute_vrsave_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|is_altivec_return_reg
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|generate_set_vrsave
parameter_list|(
name|rtx
parameter_list|,
name|rs6000_stack_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|easy_vector_constant
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|easy_vector_same
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|easy_vector_splat_const
parameter_list|(
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_ev64_opaque_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_dwarf_register_span
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_legitimize_tls_address
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|tls_model
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_tls_get_addr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_got_sym
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|rs6000_tls_symbol_ref_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_complex_function_value
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_spe_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_mixed_function_arg
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_move_block_from_reg
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|nregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_function_decl
specifier|static
name|void
name|macho_branch_islands
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_compiler_branch_island
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|no_previous_def
parameter_list|(
name|tree
name|function_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_prev_label
parameter_list|(
name|tree
name|function_name
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|tree
name|rs6000_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hash table stuff for keeping track of TOC entries.  */
end_comment

begin_decl_stmt
name|struct
name|toc_hash_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* `key' will satisfy CONSTANT_P; in fact, it will satisfy      ASM_OUTPUT_SPECIAL_POOL_ENTRY_P.  */
name|rtx
name|key
decl_stmt|;
name|enum
name|machine_mode
name|key_mode
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct toc_hash_struct))
argument_list|)
name|htab_t
name|toc_hash_table
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Default register names.  */
end_comment

begin_decl_stmt
name|char
name|rs6000_reg_names
index|[]
index|[
literal|8
index|]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"mq"
block|,
literal|"lr"
block|,
literal|"ctr"
block|,
literal|"ap"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"xer"
block|,
comment|/* AltiVec registers.  */
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"vrsave"
block|,
literal|"vscr"
block|,
comment|/* SPE registers.  */
literal|"spe_acc"
block|,
literal|"spefscr"
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_REGNAMES
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|alt_reg_names
index|[]
index|[
literal|8
index|]
init|=
block|{
literal|"%r0"
block|,
literal|"%r1"
block|,
literal|"%r2"
block|,
literal|"%r3"
block|,
literal|"%r4"
block|,
literal|"%r5"
block|,
literal|"%r6"
block|,
literal|"%r7"
block|,
literal|"%r8"
block|,
literal|"%r9"
block|,
literal|"%r10"
block|,
literal|"%r11"
block|,
literal|"%r12"
block|,
literal|"%r13"
block|,
literal|"%r14"
block|,
literal|"%r15"
block|,
literal|"%r16"
block|,
literal|"%r17"
block|,
literal|"%r18"
block|,
literal|"%r19"
block|,
literal|"%r20"
block|,
literal|"%r21"
block|,
literal|"%r22"
block|,
literal|"%r23"
block|,
literal|"%r24"
block|,
literal|"%r25"
block|,
literal|"%r26"
block|,
literal|"%r27"
block|,
literal|"%r28"
block|,
literal|"%r29"
block|,
literal|"%r30"
block|,
literal|"%r31"
block|,
literal|"%f0"
block|,
literal|"%f1"
block|,
literal|"%f2"
block|,
literal|"%f3"
block|,
literal|"%f4"
block|,
literal|"%f5"
block|,
literal|"%f6"
block|,
literal|"%f7"
block|,
literal|"%f8"
block|,
literal|"%f9"
block|,
literal|"%f10"
block|,
literal|"%f11"
block|,
literal|"%f12"
block|,
literal|"%f13"
block|,
literal|"%f14"
block|,
literal|"%f15"
block|,
literal|"%f16"
block|,
literal|"%f17"
block|,
literal|"%f18"
block|,
literal|"%f19"
block|,
literal|"%f20"
block|,
literal|"%f21"
block|,
literal|"%f22"
block|,
literal|"%f23"
block|,
literal|"%f24"
block|,
literal|"%f25"
block|,
literal|"%f26"
block|,
literal|"%f27"
block|,
literal|"%f28"
block|,
literal|"%f29"
block|,
literal|"%f30"
block|,
literal|"%f31"
block|,
literal|"mq"
block|,
literal|"lr"
block|,
literal|"ctr"
block|,
literal|"ap"
block|,
literal|"%cr0"
block|,
literal|"%cr1"
block|,
literal|"%cr2"
block|,
literal|"%cr3"
block|,
literal|"%cr4"
block|,
literal|"%cr5"
block|,
literal|"%cr6"
block|,
literal|"%cr7"
block|,
literal|"xer"
block|,
comment|/* AltiVec registers.  */
literal|"%v0"
block|,
literal|"%v1"
block|,
literal|"%v2"
block|,
literal|"%v3"
block|,
literal|"%v4"
block|,
literal|"%v5"
block|,
literal|"%v6"
block|,
literal|"%v7"
block|,
literal|"%v8"
block|,
literal|"%v9"
block|,
literal|"%v10"
block|,
literal|"%v11"
block|,
literal|"%v12"
block|,
literal|"%v13"
block|,
literal|"%v14"
block|,
literal|"%v15"
block|,
literal|"%v16"
block|,
literal|"%v17"
block|,
literal|"%v18"
block|,
literal|"%v19"
block|,
literal|"%v20"
block|,
literal|"%v21"
block|,
literal|"%v22"
block|,
literal|"%v23"
block|,
literal|"%v24"
block|,
literal|"%v25"
block|,
literal|"%v26"
block|,
literal|"%v27"
block|,
literal|"%v28"
block|,
literal|"%v29"
block|,
literal|"%v30"
block|,
literal|"%v31"
block|,
literal|"vrsave"
block|,
literal|"vscr"
block|,
comment|/* SPE registers.  */
literal|"spe_acc"
block|,
literal|"spefscr"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MASK_STRICT_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|MASK_STRICT_ALIGN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_PROFILE_KERNEL
end_ifndef

begin_define
define|#
directive|define
name|TARGET_PROFILE_KERNEL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The VRSAVE bitmask puts bit %v0 as the most significant bit.  */
end_comment

begin_define
define|#
directive|define
name|ALTIVEC_REG_BIT
parameter_list|(
name|REGNO
parameter_list|)
value|(0x80000000>> ((REGNO) - FIRST_ALTIVEC_REGNO))
end_define

begin_comment
comment|/* Return 1 for a symbol ref for a thread-local storage symbol.  */
end_comment

begin_define
define|#
directive|define
name|RS6000_SYMBOL_REF_TLS_P
parameter_list|(
name|RTX
parameter_list|)
define|\
value|(GET_CODE (RTX) == SYMBOL_REF&& SYMBOL_REF_TLS_MODEL (RTX) != 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|rs6000_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
value|rs6000_set_default_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|DOUBLE_INT_ASM_OP
end_define

begin_comment
comment|/* Default unaligned ops are only provided for ELF.  Find the ops needed    for non-ELF systems.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
end_ifndef

begin_if
if|#
directive|if
name|TARGET_XCOFF
end_if

begin_comment
comment|/* For XCOFF.  rs6000_assemble_integer will handle unaligned DIs on    64-bit targets.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.vbyte\t2,"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.vbyte\t4,"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\t.vbyte\t8,"
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* For Darwin.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.short\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.long\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This hook deals with fixups for relocatable code and DI-mode objects    in 64-bit code.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|rs6000_assemble_integer
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ASSEMBLE_VISIBILITY
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ASSEMBLE_VISIBILITY
value|rs6000_assemble_visibility
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|HAVE_AS_TLS
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|rs6000_tls_referenced_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|rs6000_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|rs6000_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
value|rs6000_use_dfa_pipeline_interface
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|rs6000_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|rs6000_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|rs6000_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_PRIORITY
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_PRIORITY
value|rs6000_adjust_priority
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_IS_COSTLY_DEPENDENCE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_IS_COSTLY_DEPENDENCE
value|rs6000_is_costly_dependence
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FINISH
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FINISH
value|rs6000_sched_finish
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
value|rs6000_use_sched_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|rs6000_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|rs6000_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
end_undef

begin_define
define|#
directive|define
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
value|rs6000_mangle_fundamental_type
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_LIBFUNCS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_LIBFUNCS
value|rs6000_init_libfuncs
end_define

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_undef
undef|#
directive|undef
name|TARGET_BINDS_LOCAL_P
end_undef

begin_define
define|#
directive|define
name|TARGET_BINDS_LOCAL_P
value|rs6000_binds_local_p
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|rs6000_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|rs6000_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|rs6000_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|hook_int_rtx_0
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_OPAQUE_P
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_OPAQUE_P
value|is_ev64_opaque_type
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DWARF_REGISTER_SPAN
end_undef

begin_define
define|#
directive|define
name|TARGET_DWARF_REGISTER_SPAN
value|rs6000_dwarf_register_span
end_define

begin_comment
comment|/* On rs6000, function arguments are promoted, as are function return    values.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_ARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_ARGS
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_RETURN
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_RETURN
value|hook_bool_tree_true
end_define

begin_comment
comment|/* Structure return values are passed as an extra parameter.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_STRUCT_VALUE_RTX
end_undef

begin_define
define|#
directive|define
name|TARGET_STRUCT_VALUE_RTX
value|hook_rtx_tree_int_null
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MEMORY
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MEMORY
value|rs6000_return_in_memory
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SETUP_INCOMING_VARARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SETUP_INCOMING_VARARGS
value|setup_incoming_varargs
end_define

begin_comment
comment|/* Always strict argument naming on rs6000.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_STRICT_ARGUMENT_NAMING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRICT_ARGUMENT_NAMING
value|hook_bool_CUMULATIVE_ARGS_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PRETEND_OUTGOING_VARARGS_NAMED
end_undef

begin_define
define|#
directive|define
name|TARGET_PRETEND_OUTGOING_VARARGS_NAMED
value|hook_bool_CUMULATIVE_ARGS_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SPLIT_COMPLEX_ARG
end_undef

begin_define
define|#
directive|define
name|TARGET_SPLIT_COMPLEX_ARG
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BUILD_BUILTIN_VA_LIST
end_undef

begin_define
define|#
directive|define
name|TARGET_BUILD_BUILTIN_VA_LIST
value|rs6000_build_builtin_va_list
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Override command line options.  Mostly we process the processor    type and sometimes adjust other TARGET_ options.  */
end_comment

begin_function
name|void
name|rs6000_override_options
parameter_list|(
specifier|const
name|char
modifier|*
name|default_cpu
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|rs6000_cpu_select
modifier|*
name|ptr
decl_stmt|;
name|int
name|set_masks
decl_stmt|;
comment|/* Simplifications for entries below.  */
enum|enum
block|{
name|POWERPC_BASE_MASK
init|=
name|MASK_POWERPC
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWERPC_7400_MASK
init|=
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_ALTIVEC
block|}
enum|;
comment|/* This table occasionally claims that a processor does not support      a particular feature even though it does, but the feature is slower      than the alternative.  Thus, it shouldn't be relied on as a      complete description of the processor's support.         Please keep this list in order, and don't forget to update the      documentation in invoke.texi when adding a new processor or      flag.  */
specifier|static
struct|struct
name|ptt
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Canonical processor name.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
comment|/* Processor type enum value.  */
specifier|const
name|int
name|target_enable
decl_stmt|;
comment|/* Target flags to enable.  */
block|}
decl|const
name|processor_target_table
index|[]
init|=
block|{
block|{
literal|"401"
block|,
name|PROCESSOR_PPC403
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"403"
block|,
name|PROCESSOR_PPC403
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_STRICT_ALIGN
block|}
block|,
block|{
literal|"405"
block|,
name|PROCESSOR_PPC405
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"405fp"
block|,
name|PROCESSOR_PPC405
block|,
name|POWERPC_BASE_MASK
block|}
block|,
block|{
literal|"440"
block|,
name|PROCESSOR_PPC440
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"440fp"
block|,
name|PROCESSOR_PPC440
block|,
name|POWERPC_BASE_MASK
block|}
block|,
block|{
literal|"505"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
block|}
block|,
block|{
literal|"601"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|POWERPC_BASE_MASK
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"602"
block|,
name|PROCESSOR_PPC603
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"603"
block|,
name|PROCESSOR_PPC603
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"603e"
block|,
name|PROCESSOR_PPC603
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"604"
block|,
name|PROCESSOR_PPC604
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"604e"
block|,
name|PROCESSOR_PPC604e
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"620"
block|,
name|PROCESSOR_PPC620
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"630"
block|,
name|PROCESSOR_PPC630
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"740"
block|,
name|PROCESSOR_PPC750
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"7400"
block|,
name|PROCESSOR_PPC7400
block|,
name|POWERPC_7400_MASK
block|}
block|,
block|{
literal|"7450"
block|,
name|PROCESSOR_PPC7450
block|,
name|POWERPC_7400_MASK
block|}
block|,
block|{
literal|"750"
block|,
name|PROCESSOR_PPC750
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"801"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"821"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"823"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"8540"
block|,
name|PROCESSOR_PPC8540
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"860"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"970"
block|,
name|PROCESSOR_POWER4
block|,
name|POWERPC_7400_MASK
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"common"
block|,
name|PROCESSOR_COMMON
block|,
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"ec603e"
block|,
name|PROCESSOR_PPC603
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"G3"
block|,
name|PROCESSOR_PPC750
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"G4"
block|,
name|PROCESSOR_PPC7450
block|,
name|POWERPC_7400_MASK
block|}
block|,
block|{
literal|"G5"
block|,
name|PROCESSOR_POWER4
block|,
name|POWERPC_7400_MASK
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"power"
block|,
name|PROCESSOR_POWER
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"power2"
block|,
name|PROCESSOR_POWER
block|,
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"power3"
block|,
name|PROCESSOR_PPC630
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"power4"
block|,
name|PROCESSOR_POWER4
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"power5"
block|,
name|PROCESSOR_POWER5
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"powerpc"
block|,
name|PROCESSOR_POWERPC
block|,
name|POWERPC_BASE_MASK
block|}
block|,
block|{
literal|"powerpc64"
block|,
name|PROCESSOR_POWERPC64
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"rios"
block|,
name|PROCESSOR_RIOS1
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rios1"
block|,
name|PROCESSOR_RIOS1
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rios2"
block|,
name|PROCESSOR_RIOS2
block|,
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rsc"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rsc1"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rs64a"
block|,
name|PROCESSOR_RS64A
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_POWERPC64
block|}
block|,       }
struct|;
specifier|const
name|size_t
name|ptt_size
init|=
name|ARRAY_SIZE
argument_list|(
name|processor_target_table
argument_list|)
decl_stmt|;
comment|/* Some OSs don't support saving the high part of 64-bit registers on      context switch.  Other OSs don't support saving Altivec registers.      On those OSs, we don't touch the MASK_POWERPC64 or MASK_ALTIVEC      settings; if the user wants either, the user must explicitly specify      them and we won't interfere with the user's specification.  */
enum|enum
block|{
name|POWER_MASKS
init|=
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|POWERPC_MASKS
init|=
operator|(
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
operator||
name|MASK_ALTIVEC
operator||
name|MASK_MFCRF
operator|)
block|}
enum|;
name|set_masks
operator|=
name|POWER_MASKS
operator||
name|POWERPC_MASKS
operator||
name|MASK_SOFT_FLOAT
expr_stmt|;
ifdef|#
directive|ifdef
name|OS_MISSING_POWERPC64
if|if
condition|(
name|OS_MISSING_POWERPC64
condition|)
name|set_masks
operator|&=
operator|~
name|MASK_POWERPC64
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OS_MISSING_ALTIVEC
if|if
condition|(
name|OS_MISSING_ALTIVEC
condition|)
name|set_masks
operator|&=
operator|~
name|MASK_ALTIVEC
expr_stmt|;
endif|#
directive|endif
comment|/* Don't override by the processor default if given explicitly.  */
name|set_masks
operator|&=
operator|~
name|target_flags_explicit
expr_stmt|;
comment|/* Identify the processor type.  */
name|rs6000_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|default_cpu
expr_stmt|;
name|rs6000_cpu
operator|=
name|TARGET_POWERPC64
condition|?
name|PROCESSOR_DEFAULT64
else|:
name|PROCESSOR_DEFAULT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rs6000_select
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
operator|&
name|rs6000_select
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptt_size
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|string
argument_list|,
name|processor_target_table
index|[
name|j
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|set_tune_p
condition|)
name|rs6000_cpu
operator|=
name|processor_target_table
index|[
name|j
index|]
operator|.
name|processor
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|set_arch_p
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|set_masks
expr_stmt|;
name|target_flags
operator||=
operator|(
name|processor_target_table
index|[
name|j
index|]
operator|.
name|target_enable
operator|&
name|set_masks
operator|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|ptt_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_E500
condition|)
name|rs6000_isel
operator|=
literal|1
expr_stmt|;
comment|/* If we are optimizing big endian systems for space, use the load/store      multiple and string instructions.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|optimize_size
condition|)
name|target_flags
operator||=
operator|~
name|target_flags_explicit
operator|&
operator|(
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator|)
expr_stmt|;
comment|/* Don't allow -mmultiple or -mstring on little endian systems      unless the cpu is a 750, because the hardware doesn't support the      instructions used in little endian mode, and causes an alignment      trap.  The 750 does not cause an alignment trap (except when the      target is unaligned).  */
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|rs6000_cpu
operator|!=
name|PROCESSOR_PPC750
condition|)
block|{
if|if
condition|(
name|TARGET_MULTIPLE
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_MULTIPLE
expr_stmt|;
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_MULTIPLE
operator|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"-mmultiple is not supported on little endian systems"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_STRING
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_STRING
expr_stmt|;
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_STRING
operator|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"-mstring is not supported on little endian systems"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set debug flags */
if|if
condition|(
name|rs6000_debug_name
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"all"
argument_list|)
condition|)
name|rs6000_debug_stack
operator|=
name|rs6000_debug_arg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"stack"
argument_list|)
condition|)
name|rs6000_debug_stack
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"arg"
argument_list|)
condition|)
name|rs6000_debug_arg
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown -mdebug-%s switch"
argument_list|,
name|rs6000_debug_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rs6000_traceback_name
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|rs6000_traceback_name
argument_list|,
literal|"full"
argument_list|,
literal|4
argument_list|)
condition|)
name|rs6000_traceback
operator|=
name|traceback_full
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|rs6000_traceback_name
argument_list|,
literal|"part"
argument_list|,
literal|4
argument_list|)
condition|)
name|rs6000_traceback
operator|=
name|traceback_part
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|rs6000_traceback_name
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
condition|)
name|rs6000_traceback
operator|=
name|traceback_none
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown -mtraceback arg `%s'; expecting `full', `partial' or `none'"
argument_list|,
name|rs6000_traceback_name
argument_list|)
expr_stmt|;
block|}
comment|/* Set size of long double */
name|rs6000_long_double_type_size
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|rs6000_long_double_size_string
condition|)
block|{
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|size
init|=
name|strtol
argument_list|(
name|rs6000_long_double_size_string
argument_list|,
operator|&
name|tail
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
literal|'\0'
operator|||
operator|(
name|size
operator|!=
literal|64
operator|&&
name|size
operator|!=
literal|128
operator|)
condition|)
name|error
argument_list|(
literal|"Unknown switch -mlong-double-%s"
argument_list|,
name|rs6000_long_double_size_string
argument_list|)
expr_stmt|;
else|else
name|rs6000_long_double_type_size
operator|=
name|size
expr_stmt|;
block|}
comment|/* Set Altivec ABI as default for powerpc64 linux.  */
if|if
condition|(
name|TARGET_ELF
operator|&&
name|TARGET_64BIT
condition|)
block|{
name|rs6000_altivec_abi
operator|=
literal|1
expr_stmt|;
name|rs6000_altivec_vrsave
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle -mabi= options.  */
name|rs6000_parse_abi_options
argument_list|()
expr_stmt|;
comment|/* Handle -malign-XXXXX option.  */
name|rs6000_parse_alignment_option
argument_list|()
expr_stmt|;
comment|/* Handle generic -mFOO=YES/NO options.  */
name|rs6000_parse_yes_no_option
argument_list|(
literal|"vrsave"
argument_list|,
name|rs6000_altivec_vrsave_string
argument_list|,
operator|&
name|rs6000_altivec_vrsave
argument_list|)
expr_stmt|;
name|rs6000_parse_yes_no_option
argument_list|(
literal|"isel"
argument_list|,
name|rs6000_isel_string
argument_list|,
operator|&
name|rs6000_isel
argument_list|)
expr_stmt|;
name|rs6000_parse_yes_no_option
argument_list|(
literal|"spe"
argument_list|,
name|rs6000_spe_string
argument_list|,
operator|&
name|rs6000_spe
argument_list|)
expr_stmt|;
name|rs6000_parse_yes_no_option
argument_list|(
literal|"float-gprs"
argument_list|,
name|rs6000_float_gprs_string
argument_list|,
operator|&
name|rs6000_float_gprs
argument_list|)
expr_stmt|;
comment|/* Handle -mtls-size option.  */
name|rs6000_parse_tls_size_option
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SUBTARGET_OVERRIDE_OPTIONS
name|SUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUBSUBTARGET_OVERRIDE_OPTIONS
name|SUBSUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TARGET_E500
condition|)
block|{
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
name|error
argument_list|(
literal|"AltiVec and E500 instructions cannot coexist"
argument_list|)
expr_stmt|;
comment|/* The e500 does not have string instructions, and we set 	 MASK_STRING above when optimizing for size.  */
if|if
condition|(
operator|(
name|target_flags
operator|&
name|MASK_STRING
operator|)
operator|!=
literal|0
condition|)
name|target_flags
operator|=
name|target_flags
operator|&
operator|~
name|MASK_STRING
expr_stmt|;
comment|/* No SPE means 64-bit long doubles, even if an E500.  */
if|if
condition|(
name|rs6000_spe_string
operator|!=
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|rs6000_spe_string
argument_list|,
literal|"no"
argument_list|)
condition|)
name|rs6000_long_double_type_size
operator|=
literal|64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs6000_select
index|[
literal|1
index|]
operator|.
name|string
operator|!=
name|NULL
condition|)
block|{
comment|/* For the powerpc-eabispe configuration, we set all these by 	 default, so let's unset them if we manually set another 	 CPU that is not the E500.  */
if|if
condition|(
name|rs6000_abi_string
operator|==
literal|0
condition|)
name|rs6000_spe_abi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rs6000_spe_string
operator|==
literal|0
condition|)
name|rs6000_spe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rs6000_float_gprs_string
operator|==
literal|0
condition|)
name|rs6000_float_gprs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rs6000_isel_string
operator|==
literal|0
condition|)
name|rs6000_isel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rs6000_long_double_size_string
operator|==
literal|0
condition|)
name|rs6000_long_double_type_size
operator|=
literal|64
expr_stmt|;
block|}
name|rs6000_always_hint
operator|=
operator|(
name|rs6000_cpu
operator|!=
name|PROCESSOR_POWER4
operator|&&
name|rs6000_cpu
operator|!=
name|PROCESSOR_POWER5
operator|)
expr_stmt|;
name|rs6000_sched_groups
operator|=
operator|(
name|rs6000_cpu
operator|==
name|PROCESSOR_POWER4
operator|||
name|rs6000_cpu
operator|==
name|PROCESSOR_POWER5
operator|)
expr_stmt|;
comment|/* Handle -m(no-)longcall option.  This is a bit of a cheap hack,      using TARGET_OPTIONS to handle a toggle switch, but we're out of      bits in target_flags so TARGET_SWITCHES cannot be used.      Assumption here is that rs6000_longcall_switch points into the      text of the complete option, rather than being a copy, so we can      scan back for the presence or absence of the no- modifier.  */
if|if
condition|(
name|rs6000_longcall_switch
condition|)
block|{
specifier|const
name|char
modifier|*
name|base
init|=
name|rs6000_longcall_switch
decl_stmt|;
while|while
condition|(
name|base
index|[
operator|-
literal|1
index|]
operator|!=
literal|'m'
condition|)
name|base
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|rs6000_longcall_switch
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|rs6000_default_long_calls
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|!=
literal|'n'
operator|)
expr_stmt|;
block|}
comment|/* Handle -m(no-)warn-altivec-long similarly.  */
if|if
condition|(
name|rs6000_warn_altivec_long_switch
condition|)
block|{
specifier|const
name|char
modifier|*
name|base
init|=
name|rs6000_warn_altivec_long_switch
decl_stmt|;
while|while
condition|(
name|base
index|[
operator|-
literal|1
index|]
operator|!=
literal|'m'
condition|)
name|base
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|rs6000_warn_altivec_long_switch
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|"invalid option `%s'"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|rs6000_warn_altivec_long
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|!=
literal|'n'
operator|)
expr_stmt|;
block|}
comment|/* Handle -mprioritize-restricted-insns option.  */
name|rs6000_sched_restricted_insns_priority
operator|=
operator|(
name|rs6000_sched_groups
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rs6000_sched_restricted_insns_priority_str
condition|)
name|rs6000_sched_restricted_insns_priority
operator|=
name|atoi
argument_list|(
name|rs6000_sched_restricted_insns_priority_str
argument_list|)
expr_stmt|;
comment|/* Handle -msched-costly-dep option.  */
name|rs6000_sched_costly_dep
operator|=
operator|(
name|rs6000_sched_groups
condition|?
name|store_to_load_dep_costly
else|:
name|no_dep_costly
operator|)
expr_stmt|;
if|if
condition|(
name|rs6000_sched_costly_dep_str
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|,
literal|"no"
argument_list|)
condition|)
name|rs6000_sched_costly_dep
operator|=
name|no_dep_costly
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|,
literal|"all"
argument_list|)
condition|)
name|rs6000_sched_costly_dep
operator|=
name|all_deps_costly
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|,
literal|"true_store_to_load"
argument_list|)
condition|)
name|rs6000_sched_costly_dep
operator|=
name|true_store_to_load_dep_costly
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|,
literal|"store_to_load"
argument_list|)
condition|)
name|rs6000_sched_costly_dep
operator|=
name|store_to_load_dep_costly
expr_stmt|;
else|else
name|rs6000_sched_costly_dep
operator|=
name|atoi
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|)
expr_stmt|;
block|}
comment|/* Handle -minsert-sched-nops option.  */
name|rs6000_sched_insert_nops
operator|=
operator|(
name|rs6000_sched_groups
condition|?
name|sched_finish_regroup_exact
else|:
name|sched_finish_none
operator|)
expr_stmt|;
if|if
condition|(
name|rs6000_sched_insert_nops_str
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_insert_nops_str
argument_list|,
literal|"no"
argument_list|)
condition|)
name|rs6000_sched_insert_nops
operator|=
name|sched_finish_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_insert_nops_str
argument_list|,
literal|"pad"
argument_list|)
condition|)
name|rs6000_sched_insert_nops
operator|=
name|sched_finish_pad_groups
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_insert_nops_str
argument_list|,
literal|"regroup_exact"
argument_list|)
condition|)
name|rs6000_sched_insert_nops
operator|=
name|sched_finish_regroup_exact
expr_stmt|;
else|else
name|rs6000_sched_insert_nops
operator|=
name|atoi
argument_list|(
name|rs6000_sched_insert_nops_str
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_REGNAMES
comment|/* If the user desires alternate register names, copy in the      alternate names now.  */
if|if
condition|(
name|TARGET_REGNAMES
condition|)
name|memcpy
argument_list|(
name|rs6000_reg_names
argument_list|,
name|alt_reg_names
argument_list|,
sizeof|sizeof
argument_list|(
name|rs6000_reg_names
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TARGET_AIX_STRUCT_RET last, after the ABI is determined.      If -maix-struct-return or -msvr4-struct-return was explicitly      used, don't override with the ABI default.  */
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_AIX_STRUCT_RET
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|!
name|DRAFT_V4_STRUCT_RET
condition|)
name|target_flags
operator|=
operator|(
name|target_flags
operator|&
operator|~
name|MASK_AIX_STRUCT_RET
operator|)
expr_stmt|;
else|else
name|target_flags
operator||=
name|MASK_AIX_STRUCT_RET
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_LONG_DOUBLE_128
operator|&&
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
condition|)
name|REAL_MODE_FORMAT
argument_list|(
name|TFmode
argument_list|)
operator|=
operator|&
name|ibm_extended_format
expr_stmt|;
comment|/* Allocate an alias set for register saves& restores from stack.  */
name|rs6000_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_TOC
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|toc_label_name
argument_list|,
literal|"LCTOC"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We can only guarantee the availability of DI pseudo-ops when      assembling for 64-bit targets.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|aligned_op
operator|.
name|di
operator|=
name|NULL
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
operator|.
name|di
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set maximum branch target alignment at two instructions, eight bytes.  */
name|align_jumps_max_skip
operator|=
literal|8
expr_stmt|;
name|align_loops_max_skip
operator|=
literal|8
expr_stmt|;
comment|/* Arrange to save and restore machine status around nested functions.  */
name|init_machine_status
operator|=
name|rs6000_init_machine_status
expr_stmt|;
comment|/* We should always be splitting complex arguments, but we can't break      Linux and Darwin ABIs at the moment.  For now, only AIX is fixed.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
condition|)
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle generic options of the form -mfoo=yes/no.    NAME is the option name.    VALUE is the option value.    FLAG is the pointer to the flag where to store a 1 or 0, depending on    whether the option value is 'yes' or 'no' respectively.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_parse_yes_no_option
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|flag
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"yes"
argument_list|)
condition|)
operator|*
name|flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"no"
argument_list|)
condition|)
operator|*
name|flag
operator|=
literal|0
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown -m%s= option specified: '%s'"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle -mabi= options.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_parse_abi_options
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|rs6000_abi_string
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_abi_string
argument_list|,
literal|"altivec"
argument_list|)
condition|)
block|{
name|rs6000_altivec_abi
operator|=
literal|1
expr_stmt|;
name|rs6000_spe_abi
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_abi_string
argument_list|,
literal|"no-altivec"
argument_list|)
condition|)
name|rs6000_altivec_abi
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_abi_string
argument_list|,
literal|"spe"
argument_list|)
condition|)
block|{
name|rs6000_spe_abi
operator|=
literal|1
expr_stmt|;
name|rs6000_altivec_abi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_SPE_ABI
condition|)
name|error
argument_list|(
literal|"not configured for ABI: '%s'"
argument_list|,
name|rs6000_abi_string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_abi_string
argument_list|,
literal|"no-spe"
argument_list|)
condition|)
name|rs6000_spe_abi
operator|=
literal|0
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown ABI specified: '%s'"
argument_list|,
name|rs6000_abi_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle -malign-XXXXXX options.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_parse_alignment_option
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|rs6000_alignment_string
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_alignment_string
argument_list|,
literal|"power"
argument_list|)
condition|)
name|rs6000_alignment_flags
operator|=
name|MASK_ALIGN_POWER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_alignment_string
argument_list|,
literal|"natural"
argument_list|)
condition|)
name|rs6000_alignment_flags
operator|=
name|MASK_ALIGN_NATURAL
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown -malign-XXXXX option specified: '%s'"
argument_list|,
name|rs6000_alignment_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Validate and record the size specified with the -mtls-size option.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_parse_tls_size_option
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|rs6000_tls_size_string
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rs6000_tls_size_string
argument_list|,
literal|"16"
argument_list|)
operator|==
literal|0
condition|)
name|rs6000_tls_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rs6000_tls_size_string
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
name|rs6000_tls_size
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rs6000_tls_size_string
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
name|rs6000_tls_size
operator|=
literal|64
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value `%s' for -mtls-size switch"
argument_list|,
name|rs6000_tls_size_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|optimization_options
parameter_list|(
name|int
name|level
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Do anything needed at the start of the asm file.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|buffer
decl_stmt|;
name|struct
name|rs6000_cpu_select
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|default_cpu
init|=
name|TARGET_CPU_DEFAULT
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
name|asm_out_file
decl_stmt|;
name|default_file_start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_BI_ARCH
if|if
condition|(
operator|(
name|TARGET_DEFAULT
operator|^
name|target_flags
operator|)
operator|&
name|MASK_64BIT
condition|)
name|default_cpu
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_verbose_asm
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\n%s rs6000/powerpc options:"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|rs6000_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|default_cpu
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rs6000_select
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
operator|&
name|rs6000_select
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s %s%s"
argument_list|,
name|start
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
name|ptr
operator|->
name|string
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USING_ELFOS_H
switch|switch
condition|(
name|rs6000_sdata
condition|)
block|{
case|case
name|SDATA_NONE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=none"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_DATA
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=data"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_SYSV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=sysv"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_EABI
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=eabi"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rs6000_sdata
operator|&&
name|g_switch_value
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -G "
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|start
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|start
operator|==
literal|'\0'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if this function is known to have a null epilogue.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|reload_completed
condition|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|first_gp_reg_save
operator|==
literal|32
operator|&&
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|&&
name|info
operator|->
name|first_altivec_reg_save
operator|==
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
operator|&&
operator|!
name|info
operator|->
name|lr_save_p
operator|&&
operator|!
name|info
operator|->
name|cr_save_p
operator|&&
name|info
operator|->
name|vrsave_mask
operator|==
literal|0
operator|&&
operator|!
name|info
operator|->
name|push_p
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 always.  */
end_comment

begin_function
name|int
name|any_operand
parameter_list|(
name|rtx
name|op
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if op is the count register.  */
end_comment

begin_function
name|int
name|count_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|COUNT_REGISTER_REGNUM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if op is an altivec register.  */
end_comment

begin_function
name|int
name|altivec_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>
name|FIRST_PSEUDO_REGISTER
operator|||
name|ALTIVEC_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xer_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XER_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a signed 8-bit constant.  Int multiplication    by such constants completes more quickly.  */
end_comment

begin_function
name|int
name|s8bit_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
operator|-
literal|128
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<=
literal|127
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that can fit in a D field.  */
end_comment

begin_function
name|int
name|short_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar for an unsigned D field.  */
end_comment

begin_function
name|int
name|u_short_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|'K'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a CONST_INT that cannot fit in a signed D field.  */
end_comment

begin_function
name|int
name|non_short_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a CONST_INT that is a positive value    and an exact power of 2.  */
end_comment

begin_function
name|int
name|exact_log2_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a register that is not special (i.e., not MQ,    ctr, or lr).  */
end_comment

begin_function
name|int
name|gpc_reg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
name|XER_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|MQ_REGNO
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a pseudo-register or a register denoting a    CR field.  */
end_comment

begin_function
name|int
name|cc_reg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a pseudo-register or a register denoting a    CR field that isn't CR0.  */
end_comment

begin_function
name|int
name|cc_reg_not_cr0_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|CR_REGNO_NOT_CR0_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a constant integer valid for a D-field or    a non-special register.  If a register, it must be in the proper    mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_short_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|short_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, except check if the negation of the constant would be    valid for a D-field.  Don't allow a constant zero, since all the    patterns that call this predicate use "addic r1,r2,-constant" on    a constant value to set a carry when r2 is greater or equal to    "constant".  That doesn't work for zero.  */
end_comment

begin_function
name|int
name|reg_or_neg_short_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'P'
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
return|;
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a constant integer valid for a DS-field or    a non-special register.  If a register, it must be in the proper    mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_aligned_short_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|short_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|3
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or an integer whose    high-order 16 bits are zero.  */
end_comment

begin_function
name|int
name|reg_or_u_short_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|u_short_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or ANY    constant integer.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or ANY    32-bit signed constant integer.  */
end_comment

begin_function
name|int
name|reg_or_arith_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|32
operator|&&
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x80000000
argument_list|)
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0x100000000ll
operator|)
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or a 32-bit    signed constant integer valid for 64-bit addition.  */
end_comment

begin_function
name|int
name|reg_or_add_cint64_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x7fff8000
else|#
directive|else
operator|&&
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x80008000
argument_list|)
operator|<
literal|0x100000000ll
operator|)
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or a 32-bit    signed constant integer valid for 64-bit subtraction.  */
end_comment

begin_function
name|int
name|reg_or_sub_cint64_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
operator|&&
operator|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
operator|<
literal|0x7fff8000
else|#
directive|else
operator|&&
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
operator|+
literal|0x80008000
argument_list|)
operator|<
literal|0x100000000ll
operator|)
endif|#
directive|endif
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or ANY    32-bit unsigned constant integer.  */
end_comment

begin_function
name|int
name|reg_or_logical_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|||
name|mode
operator|!=
name|DImode
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
return|;
block|}
else|else
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is an operand that can be loaded via the GOT.  */
end_comment

begin_function
name|int
name|got_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a simple references that can be loaded via    the GOT (labels involving addition aren't allowed).  */
end_comment

begin_function
name|int
name|got_no_const_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of instructions it takes to form a constant in an    integer register.  */
end_comment

begin_function
specifier|static
name|int
name|num_insns_constant_wide
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
comment|/* signed constant loadable with {cal|addi} */
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|value
argument_list|,
literal|'I'
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* constant loadable with {cau|addis} */
elseif|else
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|value
argument_list|,
literal|'L'
argument_list|)
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
elseif|else
if|if
condition|(
name|TARGET_POWERPC64
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|value
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
name|value
operator|>>
literal|31
decl_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
operator|||
name|high
operator|==
operator|-
literal|1
condition|)
return|return
literal|2
return|;
name|high
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
else|else
return|return
literal|2
return|;
block|}
end_function

begin_function
name|int
name|num_insns_constant
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>>
literal|31
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>>
literal|31
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|2
return|;
else|else
endif|#
directive|endif
return|return
name|num_insns_constant_wide
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|mode
operator|==
name|SFmode
condition|)
block|{
name|long
name|l
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|int
name|endian
init|=
operator|(
name|WORDS_BIG_ENDIAN
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|DImode
condition|)
block|{
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|high
operator|=
name|l
index|[
name|endian
index|]
expr_stmt|;
name|low
operator|=
name|l
index|[
literal|1
operator|-
name|endian
index|]
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_32BIT
condition|)
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|)
return|;
else|else
block|{
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|>=
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
return|;
elseif|else
if|if
condition|(
name|high
operator|==
operator|-
literal|1
operator|&&
name|low
operator|<
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
return|;
elseif|else
if|if
condition|(
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|low
operator|==
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a CONST_DOUBLE and it can be put into a    register with one instruction per word.  We only do this if we can    safely read CONST_DOUBLE_{LOW,HIGH}.  */
end_comment

begin_function
name|int
name|easy_fp_constant
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|mode
operator|!=
name|DImode
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Consider all constants with -msoft-float to be easy.  */
if|if
condition|(
operator|(
name|TARGET_SOFT_FLOAT
operator|||
operator|!
name|TARGET_FPRS
operator|)
operator|&&
name|mode
operator|!=
name|DImode
condition|)
return|return
literal|1
return|;
comment|/* If we are using V.4 style PIC, consider all constants to be hard.  */
if|if
condition|(
name|flag_pic
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|TARGET_RELOCATABLE
comment|/* Similarly if we are using -mrelocatable, consider all constants      to be hard.  */
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
block|{
name|long
name|k
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
literal|0
index|]
argument_list|)
operator|==
literal|1
operator|&&
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
literal|1
index|]
argument_list|)
operator|==
literal|1
operator|&&
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
literal|2
index|]
argument_list|)
operator|==
literal|1
operator|&&
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
literal|3
index|]
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
block|{
name|long
name|k
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
literal|0
index|]
argument_list|)
operator|==
literal|1
operator|&&
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|k
index|[
literal|1
index|]
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
name|long
name|l
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|num_insns_constant_wide
argument_list|(
name|l
argument_list|)
operator|==
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
operator|(
name|TARGET_POWERPC64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_insns_constant
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|)
operator|<=
literal|2
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
return|return
literal|1
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the constant for the splat instrunction, if exists.  */
end_comment

begin_function
specifier|static
name|int
name|easy_vector_splat_const
parameter_list|(
name|int
name|cst
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V4SImode
case|:
if|if
condition|(
name|EASY_VECTOR_15
argument_list|(
name|cst
argument_list|)
operator|||
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|cst
argument_list|)
condition|)
return|return
name|cst
return|;
if|if
condition|(
operator|(
name|cst
operator|&
literal|0xffff
operator|)
operator|!=
operator|(
operator|(
name|cst
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
condition|)
break|break;
name|cst
operator|=
name|cst
operator|>>
literal|16
expr_stmt|;
case|case
name|V8HImode
case|:
if|if
condition|(
name|EASY_VECTOR_15
argument_list|(
name|cst
argument_list|)
operator|||
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|cst
argument_list|)
condition|)
return|return
name|cst
return|;
if|if
condition|(
operator|(
name|cst
operator|&
literal|0xff
operator|)
operator|!=
operator|(
operator|(
name|cst
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
condition|)
break|break;
name|cst
operator|=
name|cst
operator|>>
literal|8
expr_stmt|;
case|case
name|V16QImode
case|:
if|if
condition|(
name|EASY_VECTOR_15
argument_list|(
name|cst
argument_list|)
operator|||
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|cst
argument_list|)
condition|)
return|return
name|cst
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if all elements of a vector have the same value.  */
end_comment

begin_function
specifier|static
name|int
name|easy_vector_same
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|units
decl_stmt|,
name|i
decl_stmt|,
name|cst
decl_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|cst
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|cst
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|units
operator|&&
name|easy_vector_splat_const
argument_list|(
name|cst
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a CONST_INT and can be put into a    register without using memory.  */
end_comment

begin_function
name|int
name|easy_vector_constant
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|cst
decl_stmt|,
name|cst2
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_VECTOR
operator|||
operator|(
operator|!
name|TARGET_ALTIVEC
operator|&&
operator|!
name|TARGET_SPE
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|zero_constant
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
operator|(
name|TARGET_ALTIVEC
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|TARGET_SPE
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_VECTOR_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_SPE
operator|&&
name|mode
operator|==
name|V1DImode
condition|)
return|return
literal|0
return|;
name|cst
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cst2
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Limit SPE vectors to 15 bits signed.  These we can generate with:        li r0, CONSTANT1        evmergelo r0, r0, r0        li r0, CONSTANT2       I don't know how efficient it would be to allow bigger constants,      considering we'll have an extra 'ori' for every 'li'.  I doubt 5      instructions is better than a 64-bit memory load, but I don't      have the e500 timing specs.  */
if|if
condition|(
name|TARGET_SPE
operator|&&
name|mode
operator|==
name|V2SImode
operator|&&
name|cst
operator|>=
operator|-
literal|0x7fff
operator|&&
name|cst
operator|<=
literal|0x7fff
operator|&&
name|cst2
operator|>=
operator|-
literal|0x7fff
operator|&&
name|cst2
operator|<=
literal|0x7fff
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|easy_vector_same
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|cst
operator|=
name|easy_vector_splat_const
argument_list|(
name|cst
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|cst
argument_list|)
operator|||
name|EASY_VECTOR_15
argument_list|(
name|cst
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Same as easy_vector_constant but only for EASY_VECTOR_15_ADD_SELF.  */
end_comment

begin_function
name|int
name|easy_vector_constant_add_self
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|cst
decl_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|easy_vector_same
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|cst
operator|=
name|easy_vector_splat_const
argument_list|(
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|cst
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate easy_vector_constant out of a easy_vector_constant_add_self.  */
end_comment

begin_function
name|rtx
name|gen_easy_vector_constant_add_self
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|units
decl_stmt|;
name|rtvec
name|v
decl_stmt|;
name|units
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|rtvec_alloc
argument_list|(
name|units
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_raw_CONST_VECTOR
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|output_vec_const_move
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|cst
decl_stmt|,
name|cst2
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|vec
decl_stmt|;
name|dest
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|vec
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|cst
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cst2
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
block|{
if|if
condition|(
name|zero_constant
argument_list|(
name|vec
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|"vxor %0,%0,%0"
return|;
elseif|else
if|if
condition|(
name|easy_vector_constant
argument_list|(
name|vec
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|cst
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V4SImode
case|:
if|if
condition|(
name|EASY_VECTOR_15
argument_list|(
name|cst
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|cst
argument_list|)
expr_stmt|;
return|return
literal|"vspltisw %0,%1"
return|;
block|}
elseif|else
if|if
condition|(
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|cst
argument_list|)
condition|)
return|return
literal|"#"
return|;
name|cst
operator|=
name|cst
operator|>>
literal|16
expr_stmt|;
case|case
name|V8HImode
case|:
if|if
condition|(
name|EASY_VECTOR_15
argument_list|(
name|cst
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|cst
argument_list|)
expr_stmt|;
return|return
literal|"vspltish %0,%1"
return|;
block|}
elseif|else
if|if
condition|(
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|cst
argument_list|)
condition|)
return|return
literal|"#"
return|;
name|cst
operator|=
name|cst
operator|>>
literal|8
expr_stmt|;
case|case
name|V16QImode
case|:
if|if
condition|(
name|EASY_VECTOR_15
argument_list|(
name|cst
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|cst
argument_list|)
expr_stmt|;
return|return
literal|"vspltisb %0,%1"
return|;
block|}
elseif|else
if|if
condition|(
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|cst
argument_list|)
condition|)
return|return
literal|"#"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_SPE
condition|)
block|{
comment|/* Vector constant 0 is handled as a splitter of V2SI, and in the 	 pattern of V1DI, V4HI, and V2SF.  	 FIXME: We should probably return # and add post reload 	 splitters for these, but this way is so easy ;-).       */
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|cst
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|cst2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cst
operator|==
name|cst2
condition|)
return|return
literal|"li %0,%1\n\tevmergelo %0,%0,%0"
return|;
else|else
return|return
literal|"li %0,%1\n\tevmergelo %0,%0,%0\n\tli %0,%2"
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is the constant 0.  This works for scalars    as well as vectors.  */
end_comment

begin_function
name|int
name|zero_constant
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is 0.0.  */
end_comment

begin_function
name|int
name|zero_fp_constant
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is in volatile memory.  Note that during    the RTL generation phase, memory_operand does not return TRUE for    volatile memory references.  So this function allows us to    recognize volatile references where its safe.  */
end_comment

begin_function
name|int
name|volatile_mem_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reload_completed
condition|)
return|return
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|reload_in_progress
condition|)
return|return
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is an offsettable memory operand.  */
end_comment

begin_function
name|int
name|offsettable_mem_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
name|reload_completed
operator|||
name|reload_in_progress
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either an easy FP constant (see above) or    memory.  */
end_comment

begin_function
name|int
name|mem_or_easy_const_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|easy_fp_constant
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a non-special register or an item    that can be used as the operand of a `mode' add insn.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|||
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
operator|)
return|;
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant but not a valid add_operand.  */
end_comment

begin_function
name|int
name|non_add_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'I'
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'L'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a non-special register or a constant that    can be used as the operand of an OR or XOR insn on the RS/6000.  */
end_comment

begin_function
name|int
name|logical_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|HOST_WIDE_INT
name|opl
decl_stmt|,
name|oph
decl_stmt|;
if|if
condition|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|opl
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|<=
literal|32
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|opl
operator|<
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|opl
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|oph
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|oph
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|opl
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffff
operator|)
operator|==
literal|0
operator|||
operator|(
name|opl
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffff0000
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if C is a constant that is not a logical operand (as    above), but could be split into one.  */
end_comment

begin_function
name|int
name|non_logical_cint_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|&&
operator|!
name|logical_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|reg_or_logical_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if C is a constant that can be encoded in a 32-bit mask on the    RS/6000.  It is if there are no more than two 1->0 or 0->1 transitions.    Reject all ones and all zeros, since these should have been optimized    away and confuse the making of MB and ME.  */
end_comment

begin_function
name|int
name|mask_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Fail in 64-bit mode if the mask wraps around because the upper      32-bits of the mask will all be 1s, contrary to GCC's internal view.  */
if|if
condition|(
name|TARGET_POWERPC64
operator|&&
operator|(
name|c
operator|&
literal|0x80000001
operator|)
operator|==
literal|0x80000001
condition|)
return|return
literal|0
return|;
comment|/* We don't change the number of transitions by inverting,      so make sure we start with the LS bit zero.  */
if|if
condition|(
name|c
operator|&
literal|1
condition|)
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Reject all zeros or all ones.  */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Find the first transition.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* Invert to look for a second transition.  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Erase first transition.  */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/* Find the second transition (if any).  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* Match if all the bits above are 1's (or c is zero).  */
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for the PowerPC64 rlwinm corner case.  */
end_comment

begin_function
name|int
name|mask_operand_wrap
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0x80000001
operator|)
operator|!=
literal|0x80000001
condition|)
return|return
literal|0
return|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a constant that is a PowerPC64 mask.    It is if there are no more than one 1->0 or 0->1 transitions.    Reject all zeros, since zero should have been optimized away and    confuses the making of MB and ME.  */
end_comment

begin_function
name|int
name|mask64_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Reject all zeros.  */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We don't change the number of transitions by inverting, 	 so make sure we start with the LS bit zero.  */
if|if
condition|(
name|c
operator|&
literal|1
condition|)
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Find the transition, and check that all bits above are 1's.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* Match if all the bits above are 1's (or c is zero).  */
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like mask64_operand, but allow up to three transitions.  This    predicate is used by insn patterns that generate two rldicl or    rldicr machine insns.  */
end_comment

begin_function
name|int
name|mask64_2_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Disallow all zeros.  */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We don't change the number of transitions by inverting, 	 so make sure we start with the LS bit zero.  */
if|if
condition|(
name|c
operator|&
literal|1
condition|)
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Find the first transition.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* Invert to look for a second transition.  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Erase first transition.  */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/* Find the second transition.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* Invert to look for a third transition.  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Erase second transition.  */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/* Find the third transition (if any).  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* Match if all the bits above are 1's (or c is zero).  */
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generates shifts and masks for a pair of rldicl or rldicr insns to    implement ANDing by the mask IN.  */
end_comment

begin_function
name|void
name|build_mask64_2_operands
parameter_list|(
name|rtx
name|in
parameter_list|,
name|rtx
modifier|*
name|out
parameter_list|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|unsigned
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|;
name|int
name|shift
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|1
condition|)
block|{
comment|/* Assume c initially something like 0x00fff000000fffff.  The idea 	 is to rotate the word so that the middle ^^^^^^ group of zeros 	 is at the MS end and can be cleared with an rldicl mask.  We then 	 rotate back and clear off the MS    ^^ group of zeros with a 	 second rldicl.  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0xff000ffffff00000 */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* lsb == 0x0000000000100000 */
name|m1
operator|=
operator|-
name|lsb
expr_stmt|;
comment|/*  m1 == 0xfffffffffff00000 */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0x00fff000000fffff */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/*   c == 0x00fff00000000000 */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* lsb == 0x0000100000000000 */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0xff000fffffffffff */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/*   c == 0xff00000000000000 */
name|shift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|lsb
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|shift
operator|++
expr_stmt|;
comment|/* shift == 44 on exit from loop */
name|m1
operator|<<=
literal|64
operator|-
name|shift
expr_stmt|;
comment|/*  m1 == 0xffffff0000000000 */
name|m1
operator|=
operator|~
name|m1
expr_stmt|;
comment|/*  m1 == 0x000000ffffffffff */
name|m2
operator|=
operator|~
name|c
expr_stmt|;
comment|/*  m2 == 0x00ffffffffffffff */
block|}
else|else
block|{
comment|/* Assume c initially something like 0xff000f0000000000.  The idea 	 is to rotate the word so that the     ^^^  middle group of zeros 	 is at the LS end and can be cleared with an rldicr mask.  We then 	 rotate back and clear off the LS group of ^^^^^^^^^^ zeros with 	 a second rldicr.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* lsb == 0x0000010000000000 */
name|m2
operator|=
operator|-
name|lsb
expr_stmt|;
comment|/*  m2 == 0xffffff0000000000 */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0x00fff0ffffffffff */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/*   c == 0x00fff00000000000 */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* lsb == 0x0000100000000000 */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0xff000fffffffffff */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/*   c == 0xff00000000000000 */
name|shift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|lsb
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|shift
operator|++
expr_stmt|;
comment|/* shift == 44 on exit from loop */
name|m1
operator|=
operator|~
name|c
expr_stmt|;
comment|/*  m1 == 0x00ffffffffffffff */
name|m1
operator|>>=
name|shift
expr_stmt|;
comment|/*  m1 == 0x0000000000000fff */
name|m1
operator|=
operator|~
name|m1
expr_stmt|;
comment|/*  m1 == 0xfffffffffffff000 */
block|}
comment|/* Note that when we only have two 0->1 and 1->0 transitions, one of the      masks will be all 1's.  We are guaranteed more than one transition.  */
name|out
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
literal|64
operator|-
name|shift
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|shift
argument_list|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|GEN_INT
argument_list|(
name|m2
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|in
expr_stmt|;
operator|(
name|void
operator|)
name|out
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a non-special register or a constant    that can be used as the operand of a PowerPC64 logical AND insn.  */
end_comment

begin_function
name|int
name|and64_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|CR0_REGNO
index|]
condition|)
comment|/* CR0 not available, don't do andi./andis.  */
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
return|return
operator|(
name|logical_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like the above, but also match constants that can be implemented    with two rldicl or rldicr insns.  */
end_comment

begin_function
name|int
name|and64_2_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|CR0_REGNO
index|]
condition|)
comment|/* CR0 not available, don't do andi./andis.  */
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask64_2_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
return|return
name|logical_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask64_2_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a non-special register or a    constant that can be used as the operand of an RS/6000 logical AND insn.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|CR0_REGNO
index|]
condition|)
comment|/* CR0 not available, don't do andi./andis.  */
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
return|return
operator|(
name|logical_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a general register or memory operand.  */
end_comment

begin_function
name|int
name|reg_or_mem_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|macho_lo_sum_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|volatile_mem_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a general register or memory operand without    pre_inc or pre_dec which produces invalid form of PowerPC lwa    instruction.  */
end_comment

begin_function
name|int
name|lwa_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|inner
init|=
name|op
decl_stmt|;
if|if
condition|(
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
return|return
name|gpc_reg_operand
argument_list|(
name|inner
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|memory_operand
argument_list|(
name|inner
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PRE_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PRE_DEC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|%
literal|4
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand, used inside a MEM, is a SYMBOL_REF.  */
end_comment

begin_function
name|int
name|symbol_ref_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|||
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand, used inside a MEM, is a valid first argument    to CALL.  This is a SYMBOL_REF, a pseudo-register, LR or CTR.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|LINK_REGISTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|COUNT_REGISTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a SYMBOL_REF for a function known to be in    this file.  */
end_comment

begin_function
name|int
name|current_file_function_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|||
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
operator|(
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|op
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this operand is a valid input for a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* Memory is always valid.  */
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
literal|1
return|;
comment|/* For floating-point, easy constants are valid.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
name|easy_fp_constant
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Allow any integer constant.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Allow easy vector constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|easy_vector_constant
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* For floating-point or multi-word mode, the only remaining valid type      is a register.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
comment|/* The only cases left are integral modes one word or smaller (we      do not get called for MODE_CC values).  These can be in any      register.  */
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* A SYMBOL_REF referring to the TOC is valid.  */
if|if
condition|(
name|legitimate_constant_pool_address_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* A constant pool expression (relative to the TOC) is valid */
if|if
condition|(
name|toc_relative_expr_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* V.4 allows SYMBOL_REFs and CONSTs that are in the small data region      to be valid.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|)
operator|&&
name|small_data_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Darwin, AIX increases natural record alignment to doubleword if the first    field is an FP double while the FP fields remain word aligned.  */
end_comment

begin_function
name|unsigned
name|int
name|rs6000_special_round_type_align
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|computed
parameter_list|,
name|int
name|specified
parameter_list|)
block|{
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Skip all the static variables only if ABI is greater than      1 or equal to 0.   */
while|while
condition|(
name|field
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL
operator|||
name|field
operator|==
name|type
operator|||
name|DECL_MODE
argument_list|(
name|field
argument_list|)
operator|!=
name|DFmode
condition|)
return|return
name|MAX
argument_list|(
name|computed
argument_list|,
name|specified
argument_list|)
return|;
return|return
name|MAX
argument_list|(
name|MAX
argument_list|(
name|computed
argument_list|,
name|specified
argument_list|)
argument_list|,
literal|64
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an operand in small memory on V.4/eabi.  */
end_comment

begin_function
name|int
name|small_data_operand
parameter_list|(
name|rtx
name|op
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|TARGET_ELF
name|rtx
name|sym_ref
decl_stmt|;
if|if
condition|(
name|rs6000_sdata
operator|==
name|SDATA_NONE
operator|||
name|rs6000_sdata
operator|==
name|SDATA_DATA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|sym_ref
operator|=
name|op
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
else|else
block|{
name|rtx
name|sum
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|summand
decl_stmt|;
comment|/* We have to be careful here, because it is the referenced address         that must be 32k from _SDA_BASE_, not just the symbol.  */
name|summand
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|summand
operator|<
literal|0
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|summand
operator|>
name|g_switch_value
condition|)
return|return
literal|0
return|;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|SYMBOL_REF_SMALL_P
argument_list|(
name|sym_ref
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return true, if operand is a memory operand and has a    displacement divisible by 4.  */
end_comment

begin_function
name|int
name|word_offset_memref_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|off
operator|%
literal|4
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a (MEM (PLUS (REG) (offset))) where offset    is not divisible by four.  */
end_comment

begin_function
name|int
name|invalid_gpr_mem
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|long
name|off
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|off
operator|&
literal|3
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if operand is a hard register that can be used as a base    register.  */
end_comment

begin_function
name|int
name|base_reg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|regno
operator|!=
literal|0
operator|&&
name|regno
operator|<=
literal|31
return|;
block|}
end_function

begin_comment
comment|/* Return true if either operand is a general purpose register.  */
end_comment

begin_function
name|bool
name|gpr_or_gpr_p
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
return|return
operator|(
operator|(
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|INT_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|INT_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address.  */
end_comment

begin_function
specifier|static
name|int
name|constant_pool_expr_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
modifier|*
name|have_sym
parameter_list|,
name|int
modifier|*
name|have_toc
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|RS6000_SYMBOL_REF_TLS_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|op
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
operator|*
name|have_sym
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|toc_label_name
argument_list|)
condition|)
block|{
operator|*
name|have_toc
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
operator|(
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
operator|&&
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
operator|)
return|;
case|case
name|CONST
case|:
return|return
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|constant_pool_expr_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|have_sym
init|=
literal|0
decl_stmt|;
name|int
name|have_toc
init|=
literal|0
decl_stmt|;
return|return
name|constant_pool_expr_1
argument_list|(
name|op
argument_list|,
operator|&
name|have_sym
argument_list|,
operator|&
name|have_toc
argument_list|)
operator|&&
name|have_sym
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|toc_relative_expr_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|have_sym
init|=
literal|0
decl_stmt|;
name|int
name|have_toc
init|=
literal|0
decl_stmt|;
return|return
name|constant_pool_expr_1
argument_list|(
name|op
argument_list|,
operator|&
name|have_sym
argument_list|,
operator|&
name|have_toc
argument_list|)
operator|&&
name|have_toc
return|;
block|}
end_function

begin_comment
comment|/* SPE offset addressing is limited to 5-bits worth of double words.  */
end_comment

begin_define
define|#
directive|define
name|SPE_CONST_OFFSET_OK
parameter_list|(
name|x
parameter_list|)
value|(((x)& ~0xf8) == 0)
end_define

begin_function
name|bool
name|legitimate_constant_pool_address_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
operator|(
name|TARGET_TOC
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|TARGET_MINIMAL_TOC
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TOC_REGISTER
operator|)
operator|&&
name|constant_pool_expr_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|legitimate_small_data_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
return|return
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|!
name|flag_pic
operator|&&
operator|!
name|TARGET_TOC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|)
operator|&&
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|legitimate_offset_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|extra
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|false
return|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
comment|/* AltiVec vector modes.  Only reg+reg addressing is valid here, 	 which leaves the only valid constant offset of zero, which by 	 canonicalization rules is also invalid.  */
return|return
name|false
return|;
case|case
name|V4HImode
case|:
case|case
name|V2SImode
case|:
case|case
name|V1DImode
case|:
case|case
name|V2SFmode
case|:
comment|/* SPE vector modes.  */
return|return
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
return|;
case|case
name|DFmode
case|:
case|case
name|DImode
case|:
comment|/* Both DFmode and DImode may end up in gprs.  If gprs are 32-bit, 	 then we need to load/store at both offset and offset+4.  */
if|if
condition|(
operator|!
name|TARGET_POWERPC64
condition|)
name|extra
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
case|case
name|TImode
case|:
if|if
condition|(
operator|!
name|TARGET_POWERPC64
condition|)
name|extra
operator|=
literal|12
expr_stmt|;
else|else
name|extra
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|offset
operator|+=
literal|0x8000
expr_stmt|;
return|return
operator|(
name|offset
operator|<
literal|0x10000
operator|)
operator|&&
operator|(
name|offset
operator|+
name|extra
operator|<
literal|0x10000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|legitimate_indexed_address_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|||
operator|!
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|(
operator|(
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|,
name|strict
argument_list|)
operator|&&
name|INT_REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|,
name|strict
argument_list|)
operator|)
operator|||
operator|(
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|,
name|strict
argument_list|)
operator|&&
name|INT_REG_OK_FOR_INDEX_P
argument_list|(
name|op0
argument_list|,
name|strict
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|legitimate_indirect_address_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|,
name|strict
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|macho_lo_sum_memory_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_MACHO
operator|||
operator|!
name|flag_pic
operator|||
name|mode
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|false
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LO_SUM
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|legitimate_lo_sum_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LO_SUM
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
return|return
name|false
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|||
name|TARGET_MACHO
condition|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_DARWIN
operator|&&
name|flag_pic
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TARGET_TOC
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|32
operator|&&
operator|!
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|mode
operator|==
name|DFmode
operator|)
condition|)
return|return
name|false
return|;
return|return
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This is used from only one place: `memory_address' in explow.c.     OLDX is the address as it was before break_out_memory_refs was    called.  In some cases it is useful to look at this to decide what    needs to be done.     MODE is passed so that this function can use GO_IF_LEGITIMATE_ADDRESS.     It is always safe for this function to do nothing.  It exists to    recognize opportunities to optimize the output.     On RS/6000, first check for the sum of a register with a constant    integer that is out of range.  If so, generate code to add the    constant with the low-order 16 bits masked to the register and force    this result into another register (this can be done with `cau').    Then generate an address of REG+(CONST&0xffff), allowing for the    possibility of bit 16 being a one.     Then check for the sum of a register and something not constant, try to    load the other things into a register and return the sum.  */
end_comment

begin_function
name|rtx
name|rs6000_legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|enum
name|tls_model
name|model
init|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|model
operator|!=
literal|0
condition|)
return|return
name|rs6000_legitimize_tls_address
argument_list|(
name|x
argument_list|,
name|model
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
condition|)
block|{
name|HOST_WIDE_INT
name|high_int
decl_stmt|,
name|low_int
decl_stmt|;
name|rtx
name|sum
decl_stmt|;
name|low_int
operator|=
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|high_int
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|low_int
expr_stmt|;
name|sum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high_int
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum
argument_list|,
name|GEN_INT
argument_list|(
name|low_int
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|)
operator|||
name|TARGET_POWERPC64
operator|||
operator|(
name|mode
operator|!=
name|DFmode
operator|&&
name|mode
operator|!=
name|TFmode
operator|)
operator|)
operator|&&
operator|(
name|TARGET_POWERPC64
operator|||
name|mode
operator|!=
name|DImode
operator|)
operator|&&
name|mode
operator|!=
name|TImode
condition|)
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|reg
decl_stmt|;
comment|/* Make sure both operands are registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
name|reg
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* We accept [reg + reg] and [reg + OFFSET].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|!
name|SPE_CONST_OFFSET_OK
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|)
condition|)
name|op2
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ELF
operator|&&
name|TARGET_32BIT
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
operator|||
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|)
operator|&&
name|mode
operator|==
name|DFmode
operator|)
operator|)
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|reg
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|x
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MACHO
operator|&&
name|TARGET_32BIT
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
if|#
directive|if
name|TARGET_MACHO
operator|&&
operator|!
name|MACHO_DYNAMIC_NO_PIC_P
endif|#
directive|endif
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|)
operator|||
name|mode
operator|!=
name|DFmode
operator|)
operator|&&
name|mode
operator|!=
name|DImode
operator|&&
name|mode
operator|!=
name|TImode
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|reg
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|x
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_TOC
operator|&&
name|constant_pool_expr_p
argument_list|(
name|x
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
return|return
name|create_TOC_reference
argument_list|(
name|x
argument_list|)
return|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_function
name|void
name|rs6000_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|fputs
argument_list|(
literal|"\t.long\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@dtprel+0x8000"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for the tls_get_addr function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|rs6000_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|rs6000_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs6000_tls_symbol
condition|)
name|rs6000_tls_symbol
operator|=
name|init_one_libfunc
argument_list|(
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
return|return
name|rs6000_tls_symbol
return|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for TLS GOT references.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|rs6000_got_symbol
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|rs6000_got_sym
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs6000_got_symbol
condition|)
block|{
name|rs6000_got_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|rs6000_got_symbol
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|rs6000_got_symbol
argument_list|)
operator||=
name|SYMBOL_FLAG_EXTERNAL
expr_stmt|;
block|}
return|return
name|rs6000_got_symbol
return|;
block|}
end_function

begin_comment
comment|/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute    this (thread-local) address.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_legitimize_tls_address
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|enum
name|tls_model
name|model
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|insn
decl_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_LOCAL_EXEC
operator|&&
name|rs6000_tls_size
operator|==
literal|16
condition|)
block|{
name|rtx
name|tlsreg
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|tlsreg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_tls_tprel_64
argument_list|(
name|dest
argument_list|,
name|tlsreg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tlsreg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_tls_tprel_32
argument_list|(
name|dest
argument_list|,
name|tlsreg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_LOCAL_EXEC
operator|&&
name|rs6000_tls_size
operator|==
literal|32
condition|)
block|{
name|rtx
name|tlsreg
decl_stmt|,
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|tlsreg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_tls_tprel_ha_64
argument_list|(
name|tmp
argument_list|,
name|tlsreg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tlsreg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_tls_tprel_ha_32
argument_list|(
name|tmp
argument_list|,
name|tlsreg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_tprel_lo_64
argument_list|(
name|dest
argument_list|,
name|tmp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_tprel_lo_32
argument_list|(
name|dest
argument_list|,
name|tmp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|r3
decl_stmt|,
name|got
decl_stmt|,
name|tga
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|eqv
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|got
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|TOC_REGISTER
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
name|got
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RS6000_PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|gsym
init|=
name|rs6000_got_sym
argument_list|()
decl_stmt|;
name|got
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|0
condition|)
name|rs6000_emit_move
argument_list|(
name|got
argument_list|,
name|gsym
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|tempLR
decl_stmt|,
name|tmp3
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
name|tempLR
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|first
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1b
argument_list|(
name|tempLR
argument_list|,
name|gsym
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp1
argument_list|,
name|tempLR
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp2
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|tmp3
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|emit_move_insn
argument_list|(
name|got
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|gsym
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LIBCALL
argument_list|,
name|last
argument_list|,
name|REG_NOTES
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_RETVAL
argument_list|,
name|first
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_GLOBAL_DYNAMIC
condition|)
block|{
name|r3
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_gd_64
argument_list|(
name|r3
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_gd_32
argument_list|(
name|r3
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|tga
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|rs6000_tls_get_addr
argument_list|()
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_call_value
argument_list|(
name|r3
argument_list|,
name|tga
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|r3
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|,
name|r3
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|r3
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_ld_64
argument_list|(
name|r3
argument_list|,
name|got
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_ld_32
argument_list|(
name|r3
argument_list|,
name|got
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|tga
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|rs6000_tls_get_addr
argument_list|()
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_call_value
argument_list|(
name|r3
argument_list|,
name|tga
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|r3
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLD
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|tmp1
argument_list|,
name|r3
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs6000_tls_size
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_dtprel_64
argument_list|(
name|dest
argument_list|,
name|tmp1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_dtprel_32
argument_list|(
name|dest
argument_list|,
name|tmp1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs6000_tls_size
operator|==
literal|32
condition|)
block|{
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_dtprel_ha_64
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_dtprel_ha_32
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_dtprel_lo_64
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_dtprel_lo_32
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_got_dtprel_64
argument_list|(
name|tmp2
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_got_dtprel_32
argument_list|(
name|tmp2
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp2
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* IE, or 64 bit offset LE.  */
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_got_tprel_64
argument_list|(
name|tmp2
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_got_tprel_32
argument_list|(
name|tmp2
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_tls_64
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_tls_32
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is a SYMBOL_REF for a TLS symbol.  This is used in    instruction definitions.  */
end_comment

begin_function
name|int
name|rs6000_tls_symbol_ref
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|RS6000_SYMBOL_REF_TLS_P
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X contains a thread-local symbol.  */
end_comment

begin_function
name|bool
name|rs6000_tls_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAVE_TLS
condition|)
return|return
name|false
return|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|rs6000_tls_symbol_ref_1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if *X is a thread-local symbol.  This is the same as    rs6000_tls_symbol_ref except for the type of the unused argument.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|rs6000_tls_symbol_ref_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|RS6000_SYMBOL_REF_TLS_P
argument_list|(
operator|*
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The convention appears to be to define this wherever it is used.    With legitimize_reload_address now defined here, REG_MODE_OK_FOR_BASE_P    is now used here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REG_MODE_OK_FOR_BASE_P
end_ifndef

begin_define
define|#
directive|define
name|REG_MODE_OK_FOR_BASE_P
parameter_list|(
name|REGNO
parameter_list|,
name|MODE
parameter_list|)
value|REG_OK_FOR_BASE_P (REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to    replace the input X, or the original X if no replacement is called for.    The output parameter *WIN is 1 if the calling macro should goto WIN,    0 if it should not.     For RS/6000, we wish to handle large displacements off a base    register by splitting the addend across an addiu/addis and the mem insn.    This cuts number of extra insns needed from 3 to 1.     On Darwin, we use this to generate code for floating point constants.    A movsf_low is generated so we wind up with 2 instructions rather than 3.    The Darwin code is inside #if TARGET_MACHO because only then is    machopic_function_base_name() defined.  */
end_comment

begin_function
name|rtx
name|rs6000_legitimize_reload_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|opnum
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|ind_levels
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|win
parameter_list|)
block|{
comment|/* We must recognize output that we have already generated ourselves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* Result of previous invocation of this function on Darwin 	 floating point constant.  */
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
operator|(
name|val
operator|-
name|low
operator|)
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
decl_stmt|;
comment|/* Check for 32-bit overflow.  */
if|if
condition|(
name|high
operator|+
name|low
operator|!=
name|val
condition|)
block|{
operator|*
name|win
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* Reload the high part into a base reg; leave the low part          in the mem directly.  */
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|flag_pic
operator|||
name|MACHO_DYNAMIC_NO_PIC_P
operator|)
comment|/* Don't do this for TFmode, since the result isn't offsettable.  */
operator|&&
name|mode
operator|!=
name|TFmode
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
block|{
name|rtx
name|offset
init|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|x
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TARGET_TOC
operator|&&
name|constant_pool_expr_p
argument_list|(
name|x
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|)
block|{
operator|(
name|x
operator|)
operator|=
name|create_TOC_reference
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
operator|*
name|win
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression    that is a valid memory address for an instruction.    The MODE argument is the machine mode for the MEM expression    that wants to use this address.     On the RS/6000, there are four valid address: a SYMBOL_REF that    refers to a constant pool entry of an address (or the sum of it    plus a constant), a short (16-bit signed) constant plus a register,    the sum of two registers, or a register indirect, possibly with an    auto-increment.  For DFmode and DImode with a constant plus register,    we must ensure that both words are addressable or PowerPC64 with offset    word aligned.     For modes spanning multiple registers (DFmode in 32-bit GPRs,    32-bit DImode, TImode), indexed addressing cannot be used because    adjacent memory cells are accessed by adding word-sized offsets    during assembly output.  */
end_comment

begin_function
name|int
name|rs6000_legitimate_address
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|reg_ok_strict
parameter_list|)
block|{
if|if
condition|(
name|RS6000_SYMBOL_REF_TLS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|legitimate_indirect_address_p
argument_list|(
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_DEC
operator|)
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|TARGET_UPDATE
operator|&&
name|legitimate_indirect_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|legitimate_small_data_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|legitimate_constant_pool_address_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If not REG_OK_STRICT (before reload) let pass any stack offset.  */
if|if
condition|(
operator|!
name|reg_ok_strict
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|legitimate_offset_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mode
operator|!=
name|TImode
operator|&&
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|)
operator|||
name|TARGET_POWERPC64
operator|||
operator|(
name|mode
operator|!=
name|DFmode
operator|&&
name|mode
operator|!=
name|TFmode
operator|)
operator|)
operator|&&
operator|(
name|TARGET_POWERPC64
operator|||
name|mode
operator|!=
name|DImode
operator|)
operator|&&
name|legitimate_indexed_address_p
argument_list|(
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|legitimate_lo_sum_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Go to LABEL if ADDR (a legitimate address expression)    has an effect that depends on the machine mode it is used for.     On the RS/6000 this is true of all integral offsets (since AltiVec    modes don't allow them) or is a pre-increment or decrement.     ??? Except that due to conceptual problems in offsettable_address_p    we can't really report the problems of integral offsets.  So leave    this assuming that the adjustable offset must be valid for the     sub-words of a TFmode operand, which is what we had before.  */
end_comment

begin_function
name|bool
name|rs6000_mode_dependent_address
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|val
operator|+
literal|12
operator|+
literal|0x8000
operator|>=
literal|0x10000
return|;
block|}
break|break;
case|case
name|LO_SUM
case|:
return|return
name|true
return|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
return|return
name|TARGET_UPDATE
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to output insns to set TARGET equal to the constant C if it can    be done in less than N insns.  Do all computations in MODE.    Returns the place where the output has been placed if it can be    done and the insns have been emitted.  If it would take more than N    insns, zero is returned and no insns and emitted.  */
end_comment

begin_function
name|rtx
name|rs6000_emit_set_const
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|source
parameter_list|,
name|int
name|n
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|,
name|insn
decl_stmt|,
name|set
decl_stmt|;
name|HOST_WIDE_INT
name|c0
decl_stmt|,
name|c1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
block|{
name|result
operator|=
name|no_new_pseudos
condition|?
name|dest
else|:
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|result
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|source
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|result
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|source
argument_list|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c0
operator|=
name|INTVAL
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|-
operator|(
name|c0
operator|<
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|c0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|-
operator|(
name|c0
operator|<
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|c0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|source
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|rs6000_emit_set_long_const
argument_list|(
name|dest
argument_list|,
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Having failed to find a 3 insn sequence in rs6000_emit_set_const,    fall back to a straight forward decomposition.  We do this to avoid    exponential run times encountered when looking for longer sequences    with rs6000_emit_set_const.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_emit_set_long_const
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|HOST_WIDE_INT
name|c1
parameter_list|,
name|HOST_WIDE_INT
name|c2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_POWERPC64
condition|)
block|{
name|rtx
name|operand1
decl_stmt|,
name|operand2
decl_stmt|;
name|operand1
operator|=
name|operand_subword_force
argument_list|(
name|dest
argument_list|,
name|WORDS_BIG_ENDIAN
operator|==
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|operand2
operator|=
name|operand_subword_force
argument_list|(
name|dest
argument_list|,
name|WORDS_BIG_ENDIAN
operator|!=
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operand1
argument_list|,
name|GEN_INT
argument_list|(
name|c1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operand2
argument_list|,
name|GEN_INT
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|ud1
decl_stmt|,
name|ud2
decl_stmt|,
name|ud3
decl_stmt|,
name|ud4
decl_stmt|;
name|ud1
operator|=
name|c1
operator|&
literal|0xffff
expr_stmt|;
name|ud2
operator|=
operator|(
name|c1
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|c2
operator|=
name|c1
operator|>>
literal|32
expr_stmt|;
endif|#
directive|endif
name|ud3
operator|=
name|c2
operator|&
literal|0xffff
expr_stmt|;
name|ud4
operator|=
operator|(
name|c2
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
name|ud3
operator|==
literal|0xffff
operator|&&
name|ud2
operator|==
literal|0xffff
operator|&&
operator|(
name|ud1
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
name|ud3
operator|==
literal|0
operator|&&
name|ud2
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud1
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud1
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud1
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
name|ud3
operator|==
literal|0xffff
operator|&&
operator|(
name|ud2
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
name|ud3
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud2
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud2
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud2
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
operator|(
name|ud3
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud3
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud3
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud3
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud3
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud2
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ud4
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud4
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud4
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud3
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud2
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
operator|<<
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Emit a move from SOURCE to DEST in mode MODE.  */
end_comment

begin_function
name|void
name|rs6000_emit_move
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|source
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|source
expr_stmt|;
comment|/* Sanity checks.  Check that we get CONST_DOUBLE only when we should.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* FIXME.  This should never happen.  */
comment|/* Since it seems that it does, do the safe thing and convert 	 to a CONST_INT.  */
name|operands
index|[
literal|1
index|]
operator|=
name|gen_int_mode
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check if GCC is setting up a block move that will end up using FP      registers as temporaries.  We must make sure this is acceptable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|DImode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|DImode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|SImode
argument_list|,
operator|(
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>
literal|32
condition|?
literal|32
else|:
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|SImode
argument_list|,
operator|(
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>
literal|32
condition|?
literal|32
else|:
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|)
argument_list|)
operator|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|optimize
operator|>
literal|0
operator|&&
operator|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|SImode
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|word_mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|SFmode
operator|&&
operator|!
name|TARGET_POWERPC
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regnum
operator|=
name|true_regnum
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
name|regnum
operator|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|regnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If operands[1] is a register, on POWER it may have 	 double-precision data in it, so truncate it to single 	 precision.  */
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|regnum
argument_list|)
operator|||
name|regnum
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|newreg
decl_stmt|;
name|newreg
operator|=
operator|(
name|no_new_pseudos
condition|?
name|operands
index|[
literal|1
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_aux_truncdfsf2
argument_list|(
name|newreg
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|newreg
expr_stmt|;
block|}
block|}
comment|/* Recognize the case where operand[1] is a reference to thread-local      data and load its address to a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|enum
name|tls_model
name|model
init|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|model
operator|!=
literal|0
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|rs6000_legitimize_tls_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|model
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the case where reload calls us with an invalid address.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
operator|(
operator|!
name|general_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|||
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
goto|goto
name|emit_set
goto|;
comment|/* Handle the case of CONSTANT_P_RTX.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
goto|goto
name|emit_set
goto|;
comment|/* 128-bit constant floating-point values on Darwin should really be      loaded as two parts.  */
if|if
condition|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|TARGET_LONG_DOUBLE_128
operator|&&
name|mode
operator|==
name|TFmode
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* DImode is used, not DFmode, because simplify_gen_subreg doesn't 	 know how to get a DFmode SUBREG of a TFmode.  */
name|rs6000_emit_move
argument_list|(
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|rs6000_emit_move
argument_list|(
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME:  In the long term, this switch statement should go away      and be replaced by a sequence of tests based on things like      mode == Pmode.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HImode
case|:
case|case
name|QImode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
case|case
name|DFmode
case|:
case|case
name|SFmode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|easy_fp_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V2SFmode
case|:
case|case
name|V2SImode
case|:
case|case
name|V1DImode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|easy_vector_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|DImode
case|:
comment|/* Use default pattern for address of ELF small data */
if|if
condition|(
name|TARGET_ELF
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST
operator|)
operator|&&
name|small_data_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|flag_pic
operator|==
literal|1
operator|&&
name|got_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi_got
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|TARGET_ELF
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|HIGH
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|rtx
name|target
init|=
operator|(
name|no_new_pseudos
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
comment|/* If this is a function address on -mcall-aixdesc, 	     convert it to the address of the descriptor.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|XSTR
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new_ref
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
name|name
operator|++
expr_stmt|;
name|new_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|new_ref
argument_list|)
operator|=
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|new_ref
argument_list|)
operator|=
name|SYMBOL_REF_FLAGS
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SYMBOL_REF_USED
argument_list|(
name|new_ref
argument_list|)
operator|=
name|SYMBOL_REF_USED
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SYMBOL_REF_DECL
argument_list|(
name|new_ref
argument_list|)
operator|=
name|SYMBOL_REF_DECL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|new_ref
expr_stmt|;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
condition|)
block|{
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
block|{
comment|/* Take care of any required data indirection.  */
name|operands
index|[
literal|1
index|]
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
index|[
literal|0
index|]
operator|!=
name|operands
index|[
literal|1
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_low
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is a SYMBOL_REF that refers to a constant pool entry, 	 and we have put it in the TOC, we just need to make a TOC-relative 	 reference to it.  */
if|if
condition|(
name|TARGET_TOC
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|constant_pool_expr_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|create_TOC_reference
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|!
name|easy_fp_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|num_insns_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|>
literal|2
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|HIGH
operator|&&
operator|!
name|legitimate_constant_pool_address_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|toc_relative_expr_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Emit a USE operation so that the constant isn't deleted if 	     expensive optimizations are turned on because nobody 	     references it.  This should only be done for operands that 	     contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set. 	     This should not be done for operands that contain LABEL_REFs. 	     For now, we just handle the obvious case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|LABEL_REF
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* Darwin uses a special PIC legitimizer.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|MACHOPIC_INDIRECT
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
index|[
literal|0
index|]
operator|!=
name|operands
index|[
literal|1
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If we are to limit the number of things we put in the TOC and 	     this is a symbol plus a constant we can add in one insn, 	     just put the symbol in the TOC and add the constant.  Don't do 	     this if reload is in progress.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST
operator|&&
name|TARGET_NO_SUM_IN_TOC
operator|&&
operator|!
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|add_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|rtx
name|sym
init|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|other
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|sym
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|sym
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|sym
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_TOC
operator|&&
name|constant_pool_expr_p
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|create_TOC_reference
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|get_TOC_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TImode
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_POWER
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|SImode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Above, we may have called force_const_mem which may have returned      an invalid address.  If we can, fix this up; otherwise, reload will      have to deal with it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|validize_mem
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_set
label|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we can use a floating-point register to pass this arg.  */
end_comment

begin_define
define|#
directive|define
name|USE_FP_FOR_ARG_P
parameter_list|(
name|CUM
parameter_list|,
name|MODE
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|(GET_MODE_CLASS (MODE) == MODE_FLOAT		\&& (CUM)->fregno<= FP_ARG_MAX_REG		\&& TARGET_HARD_FLOAT&& TARGET_FPRS)
end_define

begin_comment
comment|/* Nonzero if we can use an AltiVec register to pass this arg.  */
end_comment

begin_define
define|#
directive|define
name|USE_ALTIVEC_FOR_ARG_P
parameter_list|(
name|CUM
parameter_list|,
name|MODE
parameter_list|,
name|TYPE
parameter_list|,
name|NAMED
parameter_list|)
define|\
value|(ALTIVEC_VECTOR_MODE (MODE)				\&& (CUM)->vregno<= ALTIVEC_ARG_MAX_REG		\&& TARGET_ALTIVEC_ABI				\&& (NAMED))
end_define

begin_comment
comment|/* Return a nonzero value to say to return the function value in    memory, just as large structures are always returned.  TYPE will be    the data type of the value, and FNTYPE will be the type of the    function doing the returning, or @code{NULL} for libcalls.     The AIX ABI for the RS/6000 specifies that all structures are    returned in memory.  The Darwin ABI does the same.  The SVR4 ABI    specifies that structures<= 8 bytes are returned in r3/r4, but a    draft put them in memory, and GCC used to implement the draft    instead of the final standard.  Therefore, TARGET_AIX_STRUCT_RET    controls this instead of DEFAULT_ABI; V.4 targets needing backward    compatibility can change DRAFT_V4_STRUCT_RET to override the    default, and -m switches get the final word.  See    rs6000_override_options for more details.     The PPC32 SVR4 ABI uses IEEE double extended for long double, if 128-bit    long double support is enabled.  These values are returned in memory.     int_size_in_bytes returns -1 for variable size objects, which go in    memory always.  The cast to unsigned makes -1> 8.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TARGET_AIX_STRUCT_RET
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.     For incoming args we set the number of arguments in the prototype large    so we never return a PARALLEL.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|tree
name|fntype
parameter_list|,
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|incoming
parameter_list|,
name|int
name|libcall
parameter_list|,
name|int
name|n_named_args
parameter_list|)
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cumulative
decl_stmt|;
operator|*
name|cum
operator|=
name|zero_cumulative
expr_stmt|;
name|cum
operator|->
name|words
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|fregno
operator|=
name|FP_ARG_MIN_REG
expr_stmt|;
name|cum
operator|->
name|vregno
operator|=
name|ALTIVEC_ARG_MIN_REG
expr_stmt|;
name|cum
operator|->
name|prototype
operator|=
operator|(
name|fntype
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
expr_stmt|;
name|cum
operator|->
name|call_cookie
operator|=
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|libcall
operator|)
condition|?
name|CALL_LIBCALL
else|:
name|CALL_NORMAL
operator|)
expr_stmt|;
name|cum
operator|->
name|sysv_gregno
operator|=
name|GP_ARG_MIN_REG
expr_stmt|;
name|cum
operator|->
name|stdarg
operator|=
name|fntype
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
expr_stmt|;
name|cum
operator|->
name|nargs_prototype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|incoming
operator|||
name|cum
operator|->
name|prototype
condition|)
name|cum
operator|->
name|nargs_prototype
operator|=
name|n_named_args
expr_stmt|;
comment|/* Check for a longcall attribute.  */
if|if
condition|(
operator|(
operator|!
name|fntype
operator|&&
name|rs6000_default_long_calls
operator|)
operator|||
operator|(
name|fntype
operator|&&
name|lookup_attribute
argument_list|(
literal|"longcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"shortcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|)
condition|)
name|cum
operator|->
name|call_cookie
operator||=
name|CALL_LONG
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" ret code = %s,"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cum
operator|->
name|call_cookie
operator|&
name|CALL_LONG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" longcall,"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" proto = %d, nargs = %d\n"
argument_list|,
name|cum
operator|->
name|prototype
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fntype
operator|&&
operator|!
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot return value in vector register because"
literal|" altivec instructions are disabled, use -maltivec"
literal|" to enable them."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If defined, a C expression which determines whether, and in which    direction, to pad out an argument with extra space.  The value    should be of type `enum direction': either `upward' to pad above    the argument, `downward' to pad below, or `none' to inhibit    padding.     For the AIX ABI structs are always stored left shifted in their    argument slot.  */
end_comment

begin_function
name|enum
name|direction
name|function_arg_padding
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|AGGREGATE_PADDING_FIXED
define|#
directive|define
name|AGGREGATE_PADDING_FIXED
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AGGREGATES_PAD_UPWARD_ALWAYS
define|#
directive|define
name|AGGREGATES_PAD_UPWARD_ALWAYS
value|0
endif|#
directive|endif
if|if
condition|(
operator|!
name|AGGREGATE_PADDING_FIXED
condition|)
block|{
comment|/* GCC used to pass structures of the same size as integer types as 	 if they were in fact integers, ignoring FUNCTION_ARG_PADDING. 	 ie. Structures of size 1 or 2 (or 4 when TARGET_64BIT) were 	 passed padded downward, except that -mstrict-align further 	 muddied the water in that multi-component structures of 2 and 4 	 bytes in size were passed padded upward.  	 The following arranges for best compatibility with previous 	 versions of gcc, but removes the -mstrict-align dependency.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
operator|||
name|size
operator|==
literal|2
operator|||
name|size
operator|==
literal|4
condition|)
return|return
name|downward
return|;
block|}
return|return
name|upward
return|;
block|}
if|if
condition|(
name|AGGREGATES_PAD_UPWARD_ALWAYS
condition|)
block|{
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|upward
return|;
block|}
comment|/* Fall back to the default.  */
return|return
name|DEFAULT_FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If defined, a C expression that gives the alignment boundary, in bits,    of an argument with the specified mode and type.  If it is not defined,     PARM_BOUNDARY is used for all arguments.        V.4 wants long longs to be double word aligned.  */
end_comment

begin_function
name|int
name|function_arg_boundary
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|128
return|;
else|else
return|return
name|PARM_BOUNDARY
return|;
block|}
end_function

begin_comment
comment|/* Compute the size (in words) of a function argument.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|rs6000_arg_size
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_32BIT
condition|)
return|return
operator|(
name|size
operator|+
literal|3
operator|)
operator|>>
literal|2
return|;
else|else
return|return
operator|(
name|size
operator|+
literal|7
operator|)
operator|>>
literal|3
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    (TYPE is null for libcalls where that information may not be available.)     Note that for args passed by reference, function_arg will be called    with MODE and TYPE set to that of the pointer to the arg, not the arg    itself.  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|cum
operator|->
name|nargs_prototype
operator|--
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|bool
name|stack
init|=
name|false
decl_stmt|;
if|if
condition|(
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
condition|)
block|{
name|cum
operator|->
name|vregno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC
condition|)
name|error
argument_list|(
literal|"Cannot pass argument in vector register because"
literal|" altivec instructions are disabled, use -maltivec"
literal|" to enable them."
argument_list|)
expr_stmt|;
comment|/* PowerPC64 Linux and AIX allocate GPRs for a vector argument 	     even if it is going to be passed in a vector register.   	     Darwin does the same for variable-argument functions.  */
if|if
condition|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|TARGET_64BIT
operator|)
operator|||
operator|(
name|cum
operator|->
name|stdarg
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_V4
operator|)
condition|)
name|stack
operator|=
name|true
expr_stmt|;
block|}
else|else
name|stack
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|stack
condition|)
block|{
name|int
name|align
decl_stmt|;
comment|/* Vector parameters must be 16-byte aligned.  This places 	     them at 2 mod 4 in terms of words in 32-bit mode, since 	     the parameter save area starts at offset 24 from the 	     stack.  In 64-bit mode, they just have to start on an 	     even word, since the parameter save area is 16-byte 	     aligned.  Space for GPRs is reserved even if the argument 	     will be passed in memory.  */
if|if
condition|(
name|TARGET_32BIT
condition|)
name|align
operator|=
operator|(
literal|2
operator|-
name|cum
operator|->
name|words
operator|)
operator|&
literal|3
expr_stmt|;
else|else
name|align
operator|=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|align
operator|+
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, align=%d, "
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nargs = %4d, proto = %d, mode = %4s\n"
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|,
name|cum
operator|->
name|prototype
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|TARGET_SPE
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|cum
operator|->
name|stdarg
operator|&&
name|cum
operator|->
name|sysv_gregno
operator|<=
name|GP_ARG_MAX_REG
condition|)
name|cum
operator|->
name|sysv_gregno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
operator|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
name|cum
operator|->
name|fregno
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
name|cum
operator|->
name|words
operator|+=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|gregno
init|=
name|cum
operator|->
name|sysv_gregno
decl_stmt|;
comment|/* Long long and SPE vectors are put in (r3,r4), (r5,r6), 	     (r7,r8) or (r9,r10).  As does any other 2 word item such 	     as complex int due to a historical mistake.  */
if|if
condition|(
name|n_words
operator|==
literal|2
condition|)
name|gregno
operator|+=
operator|(
literal|1
operator|-
name|gregno
operator|)
operator|&
literal|1
expr_stmt|;
comment|/* Multi-reg args are not split between registers and stack.  */
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|>
name|GP_ARG_MAX_REG
condition|)
block|{
comment|/* Long long and SPE vectors are aligned on the stack. 		 So are other 2 word items such as complex int due to 		 a historical mistake.  */
if|if
condition|(
name|n_words
operator|==
literal|2
condition|)
name|cum
operator|->
name|words
operator|+=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|n_words
expr_stmt|;
block|}
comment|/* Note: continuing to accumulate gregno past when we've started 	     spilling to the stack indicates the fact that we've started 	     spilling to the stack to expand_builtin_saveregs.  */
name|cum
operator|->
name|sysv_gregno
operator|=
name|gregno
operator|+
name|n_words
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, fregno = %2d, "
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gregno = %2d, nargs = %4d, proto = %d, "
argument_list|,
name|cum
operator|->
name|sysv_gregno
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|,
name|cum
operator|->
name|prototype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mode = %4s, named = %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|function_arg_boundary
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|/
name|PARM_BOUNDARY
operator|-
literal|1
decl_stmt|;
comment|/* The simple alignment calculation here works because 	 function_arg_boundary / PARM_BOUNDARY will only be 1 or 2. 	 If we ever want to handle alignments larger than 8 bytes for 	 32-bit or 16 bytes for 64-bit, then we'll need to take into 	 account the offset to the start of the parm save area.  */
name|align
operator|&=
name|cum
operator|->
name|words
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|align
operator|+
name|n_words
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
name|cum
operator|->
name|fregno
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, fregno = %2d, "
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nargs = %4d, proto = %d, mode = %4s, "
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|,
name|cum
operator|->
name|prototype
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"named = %d, align = %d\n"
argument_list|,
name|named
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine where to put a SIMD argument on the SPE.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_spe_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|cum
operator|->
name|stdarg
condition|)
block|{
name|int
name|gregno
init|=
name|cum
operator|->
name|sysv_gregno
decl_stmt|;
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* SPE vectors are put in odd registers.  */
if|if
condition|(
name|n_words
operator|==
literal|2
operator|&&
operator|(
name|gregno
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|gregno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|<=
name|GP_ARG_MAX_REG
condition|)
block|{
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|enum
name|machine_mode
name|m
init|=
name|SImode
decl_stmt|;
name|r1
operator|=
name|gen_rtx_REG
argument_list|(
name|m
argument_list|,
name|gregno
argument_list|)
expr_stmt|;
name|r1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|m
argument_list|,
name|r1
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|r2
operator|=
name|gen_rtx_REG
argument_list|(
name|m
argument_list|,
name|gregno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|r2
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|m
argument_list|,
name|r2
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
else|else
block|{
if|if
condition|(
name|cum
operator|->
name|sysv_gregno
operator|<=
name|GP_ARG_MAX_REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|sysv_gregno
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine where to place an argument in 64-bit mode with 32-bit ABI.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_mixed_function_arg
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|align_words
parameter_list|)
block|{
name|int
name|n_units
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|rtx
name|rvec
index|[
name|GP_ARG_NUM_REG
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|align_words
operator|>=
name|GP_ARG_NUM_REG
condition|)
return|return
name|NULL_RTX
return|;
name|n_units
operator|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Optimize the simple case where the arg fits in one gpr, except in      the case of BLKmode due to assign_parms assuming that registers are      BITS_PER_WORD wide.  */
if|if
condition|(
name|n_units
operator|==
literal|0
operator|||
operator|(
name|n_units
operator|==
literal|1
operator|&&
name|mode
operator|!=
name|BLKmode
operator|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
return|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|align_words
operator|+
name|n_units
operator|>
name|GP_ARG_NUM_REG
condition|)
comment|/* Not all of the arg fits in gprs.  Say that it goes in memory too,        using a magic NULL_RTX component.        FIXME: This is not strictly correct.  Only some of the arg        belongs in memory, not all of it.  However, there isn't any way        to do this currently, apart from building rtx descriptions for        the pieces of memory we want stored.  Due to bugs in the generic        code we can't use the normal function_arg_partial_nregs scheme        with the PARALLEL arg description we emit here.        In any case, the code to store the whole arg to memory is often        more efficient than code to store pieces, and we know that space        is available in the right place for the whole arg.  */
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|rtx
name|r
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
decl_stmt|;
name|rtx
name|off
init|=
name|GEN_INT
argument_list|(
name|i
operator|++
operator|*
literal|4
argument_list|)
decl_stmt|;
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|align_words
operator|<
name|GP_ARG_NUM_REG
operator|&&
operator|--
name|n_units
operator|!=
literal|0
condition|)
do|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|k
argument_list|,
name|rvec
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).     On RS/6000 the first eight words of non-FP are normally in registers    and the rest are pushed.  Under AIX, the first 13 FP args are in registers.    Under V.4, the first 8 FP args are in registers.     If this is floating-point and no prototype is specified, we use    both an FP and integer register (or possibly FP reg and stack).  Library    functions (when CALL_LIBCALL is set) always have the proper types for args,    so we can pass the FP value just in one register.  emit_library_function    doesn't support PARALLEL anyway.     Note that for args passed by reference, function_arg will be called    with MODE and TYPE set to that of the pointer to the arg, not the arg    itself.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|enum
name|rs6000_abi
name|abi
init|=
name|DEFAULT_ABI
decl_stmt|;
comment|/* Return a marker to indicate whether CR1 needs to set or clear the      bit that V.4 uses to say fp args were passed in registers.      Assume that we don't need the marker for software floating point,      or compiler generated library calls.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|abi
operator|==
name|ABI_V4
operator|&&
name|cum
operator|->
name|nargs_prototype
operator|<
literal|0
operator|&&
operator|(
name|cum
operator|->
name|call_cookie
operator|&
name|CALL_LIBCALL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cum
operator|->
name|prototype
operator|||
name|TARGET_NO_PROTOTYPE
operator|)
condition|)
block|{
comment|/* For the SPE, we need to crxor CR6 always.  */
if|if
condition|(
name|TARGET_SPE_ABI
condition|)
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|call_cookie
operator||
name|CALL_V4_SET_FP_ARGS
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|call_cookie
operator||
operator|(
operator|(
name|cum
operator|->
name|fregno
operator|==
name|FP_ARG_MIN_REG
operator|)
condition|?
name|CALL_V4_SET_FP_ARGS
else|:
name|CALL_V4_CLEAR_FP_ARGS
operator|)
argument_list|)
return|;
block|}
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|call_cookie
argument_list|)
return|;
block|}
if|if
condition|(
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
condition|)
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|cum
operator|->
name|prototype
condition|)
block|{
comment|/* Vector parameters get passed in vector register           and also in GPRs or memory, in absence of prototype.  */
name|int
name|align_words
decl_stmt|;
name|rtx
name|slot
decl_stmt|;
name|align_words
operator|=
operator|(
name|cum
operator|->
name|words
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|align_words
operator|>=
name|GP_ARG_NUM_REG
condition|)
block|{
name|slot
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|vregno
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|vregno
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|named
operator|||
name|abi
operator|==
name|ABI_V4
condition|)
return|return
name|NULL_RTX
return|;
else|else
block|{
comment|/* Vector parameters to varargs functions under AIX or Darwin 	     get passed in memory and possibly also in GPRs.  */
name|int
name|align
decl_stmt|,
name|align_words
decl_stmt|,
name|n_words
decl_stmt|;
name|enum
name|machine_mode
name|part_mode
decl_stmt|;
comment|/* Vector parameters must be 16-byte aligned.  This places them at 	     2 mod 4 in terms of words in 32-bit mode, since the parameter 	     save area starts at offset 24 from the stack.  In 64-bit mode, 	     they just have to start on an even word, since the parameter 	     save area is 16-byte aligned.  */
if|if
condition|(
name|TARGET_32BIT
condition|)
name|align
operator|=
operator|(
literal|2
operator|-
name|cum
operator|->
name|words
operator|)
operator|&
literal|3
expr_stmt|;
else|else
name|align
operator|=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|align_words
operator|=
name|cum
operator|->
name|words
operator|+
name|align
expr_stmt|;
comment|/* Out of registers?  Memory, then.  */
if|if
condition|(
name|align_words
operator|>=
name|GP_ARG_NUM_REG
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
condition|)
return|return
name|rs6000_mixed_function_arg
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|align_words
argument_list|)
return|;
comment|/* The vector value goes in GPRs.  Only the part of the 	     value in GPRs is reported here.  */
name|part_mode
operator|=
name|mode
expr_stmt|;
name|n_words
operator|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_words
operator|+
name|n_words
operator|>
name|GP_ARG_NUM_REG
condition|)
comment|/* Fortunately, there are only two possibilities, the value 	       is either wholly in GPRs or half in GPRs and half not.  */
name|part_mode
operator|=
name|DImode
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|part_mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|TARGET_SPE
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|rs6000_spe_function_arg
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
return|;
elseif|else
if|if
condition|(
name|abi
operator|==
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
operator|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
else|else
block|{
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|gregno
init|=
name|cum
operator|->
name|sysv_gregno
decl_stmt|;
comment|/* Long long and SPE vectors are put in (r3,r4), (r5,r6), 	     (r7,r8) or (r9,r10).  As does any other 2 word item such 	     as complex int due to a historical mistake.  */
if|if
condition|(
name|n_words
operator|==
literal|2
condition|)
name|gregno
operator|+=
operator|(
literal|1
operator|-
name|gregno
operator|)
operator|&
literal|1
expr_stmt|;
comment|/* Multi-reg args are not split between registers and stack.  */
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|>
name|GP_ARG_MAX_REG
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
condition|)
return|return
name|rs6000_mixed_function_arg
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|gregno
operator|-
name|GP_ARG_MIN_REG
argument_list|)
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|gregno
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|int
name|align
init|=
name|function_arg_boundary
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|/
name|PARM_BOUNDARY
operator|-
literal|1
decl_stmt|;
name|int
name|align_words
init|=
name|cum
operator|->
name|words
operator|+
operator|(
name|cum
operator|->
name|words
operator|&
name|align
operator|)
decl_stmt|;
if|if
condition|(
name|USE_FP_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|rtx
name|rvec
index|[
name|GP_ARG_NUM_REG
operator|+
literal|1
index|]
decl_stmt|;
name|rtx
name|r
decl_stmt|;
name|int
name|k
decl_stmt|;
name|bool
name|needs_psave
decl_stmt|;
name|enum
name|machine_mode
name|fmode
init|=
name|mode
decl_stmt|;
name|unsigned
name|long
name|n_fpreg
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|fregno
operator|+
name|n_fpreg
operator|>
name|FP_ARG_MAX_REG
operator|+
literal|1
condition|)
block|{
comment|/* Currently, we only ever need one reg here because complex 		 doubles are split.  */
if|if
condition|(
name|cum
operator|->
name|fregno
operator|!=
name|FP_ARG_MAX_REG
operator|||
name|fmode
operator|!=
name|TFmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Long double split over regs and memory.  */
name|fmode
operator|=
name|DFmode
expr_stmt|;
block|}
comment|/* Do we also need to pass this arg in the parameter save 	     area?  */
name|needs_psave
operator|=
operator|(
name|type
operator|&&
operator|(
name|cum
operator|->
name|nargs_prototype
operator|<=
literal|0
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|TARGET_XL_COMPAT
operator|&&
name|align_words
operator|>=
name|GP_ARG_NUM_REG
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_psave
operator|&&
name|mode
operator|==
name|fmode
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|fmode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
return|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needs_psave
condition|)
block|{
comment|/* Describe the part that goes in gprs or the stack. 		 This piece must come first, before the fprs.  */
if|if
condition|(
name|align_words
operator|<
name|GP_ARG_NUM_REG
condition|)
block|{
name|unsigned
name|long
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|align_words
operator|+
name|n_words
operator|>
name|GP_ARG_NUM_REG
operator|||
operator|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
operator|)
condition|)
block|{
comment|/* If this is partially on the stack, then we only 			 include the portion actually in registers here.  */
name|enum
name|machine_mode
name|rmode
init|=
name|TARGET_32BIT
condition|?
name|SImode
else|:
name|DImode
decl_stmt|;
name|rtx
name|off
decl_stmt|;
do|do
block|{
name|r
operator|=
name|gen_rtx_REG
argument_list|(
name|rmode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
expr_stmt|;
name|off
operator|=
name|GEN_INT
argument_list|(
name|k
operator|*
name|GET_MODE_SIZE
argument_list|(
name|rmode
argument_list|)
argument_list|)
expr_stmt|;
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|align_words
operator|<
name|GP_ARG_NUM_REG
operator|&&
operator|--
name|n_words
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* The whole arg fits in gprs.  */
name|r
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
expr_stmt|;
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* It's entirely in memory.  */
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Describe where this piece goes in the fprs.  */
name|r
operator|=
name|gen_rtx_REG
argument_list|(
name|fmode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
expr_stmt|;
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|k
argument_list|,
name|rvec
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|align_words
operator|<
name|GP_ARG_NUM_REG
condition|)
block|{
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
condition|)
return|return
name|rs6000_mixed_function_arg
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|align_words
argument_list|)
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
return|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For an arg passed partly in registers and partly in memory, this is    the number of registers used.  For args passed entirely in registers    or entirely in memory, zero.  When an arg is described by a PARALLEL,    perhaps using more than one register type, this function returns the    number of registers used by the first element of the PARALLEL.  */
end_comment

begin_function
name|int
name|function_arg_partial_nregs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|parm_offset
decl_stmt|;
name|int
name|align_words
decl_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
operator|&&
name|cum
operator|->
name|nargs_prototype
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
name|align
operator|=
name|function_arg_boundary
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|/
name|PARM_BOUNDARY
operator|-
literal|1
expr_stmt|;
name|parm_offset
operator|=
name|TARGET_32BIT
condition|?
literal|2
else|:
literal|0
expr_stmt|;
name|align_words
operator|=
name|cum
operator|->
name|words
operator|+
operator|(
operator|(
name|parm_offset
operator|-
name|cum
operator|->
name|words
operator|)
operator|&
name|align
operator|)
expr_stmt|;
if|if
condition|(
name|USE_FP_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
comment|/* If we are passing this arg in gprs as well, then this function 	 should return the number of gprs (or memory) partially passed, 	 *not* the number of fprs.  */
operator|&&
operator|!
operator|(
name|type
operator|&&
operator|(
name|cum
operator|->
name|nargs_prototype
operator|<=
literal|0
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|TARGET_XL_COMPAT
operator|&&
name|align_words
operator|>=
name|GP_ARG_NUM_REG
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fregno
operator|+
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|>
name|FP_ARG_MAX_REG
operator|+
literal|1
condition|)
name|ret
operator|=
name|FP_ARG_MAX_REG
operator|+
literal|1
operator|-
name|cum
operator|->
name|fregno
expr_stmt|;
elseif|else
if|if
condition|(
name|cum
operator|->
name|nargs_prototype
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|align_words
operator|<
name|GP_ARG_NUM_REG
operator|&&
name|GP_ARG_NUM_REG
operator|<
name|align_words
operator|+
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
name|ret
operator|=
name|GP_ARG_NUM_REG
operator|-
name|align_words
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_partial_nregs: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression that indicates when an argument must be passed by    reference.  If nonzero for an argument, a copy of that argument is    made in memory and a pointer to the argument is passed instead of    the argument itself.  The pointer is passed in whatever way is    appropriate for passing a pointer to that type.     Under V.4, aggregates and long double are passed by reference.     As an extension to all 32-bit ABIs, AltiVec vectors are passed by    reference unless the AltiVec vector extension ABI is in force.     As an extension to all ABIs, variable sized types are passed by    reference.  */
end_comment

begin_function
name|int
name|function_arg_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|mode
operator|==
name|TFmode
operator|)
operator|)
operator|||
operator|(
name|TARGET_32BIT
operator|&&
operator|!
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|type
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_move_block_from_reg
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|nregs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|TARGET_32BIT
condition|?
name|SImode
else|:
name|DImode
decl_stmt|;
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|reg_mode
argument_list|,
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|reg_mode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_completed
condition|)
block|{
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|reg_mode
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|tem
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|tem
operator|=
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|x
argument_list|,
name|BLKmode
argument_list|,
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|reg_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|replace_equiv_address
argument_list|(
name|tem
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform any needed actions needed for a function that is receiving a    variable number of arguments.      CUM is as above.     MODE and TYPE are the mode and type of the current parameter.     PRETEND_SIZE is a variable that should be set to the amount of stack    that must be pushed by the prolog to pretend that our caller pushed    it.     Normally, this macro will push all remaining incoming registers on the    stack and set PRETEND_SIZE to the length of the registers pushed.  */
end_comment

begin_function
specifier|static
name|void
name|setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|pretend_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|no_rtl
parameter_list|)
block|{
name|CUMULATIVE_ARGS
name|next_cum
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|rtx
name|save_area
init|=
name|NULL_RTX
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|first_reg_offset
decl_stmt|,
name|set
decl_stmt|;
comment|/* Skip the last named argument.  */
name|next_cum
operator|=
operator|*
name|cum
expr_stmt|;
name|function_arg_advance
argument_list|(
operator|&
name|next_cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
comment|/* Indicate to allocate space on the stack for varargs save area.  */
name|cfun
operator|->
name|machine
operator|->
name|sysv_varargs_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
condition|)
name|save_area
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
operator|-
name|RS6000_VARARGS_SIZE
argument_list|)
expr_stmt|;
name|first_reg_offset
operator|=
name|next_cum
operator|.
name|sysv_gregno
operator|-
name|GP_ARG_MIN_REG
expr_stmt|;
block|}
else|else
block|{
name|first_reg_offset
operator|=
name|next_cum
operator|.
name|words
expr_stmt|;
name|save_area
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|sysv_varargs_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
name|first_reg_offset
operator|+=
name|rs6000_arg_size
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
operator|&&
name|first_reg_offset
operator|<
name|GP_ARG_NUM_REG
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|first_reg_offset
operator|*
name|reg_size
argument_list|)
argument_list|)
operator|,
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|rs6000_move_block_from_reg
argument_list|(
name|GP_ARG_MIN_REG
operator|+
name|first_reg_offset
argument_list|,
name|mem
argument_list|,
name|GP_ARG_NUM_REG
operator|-
name|first_reg_offset
argument_list|)
expr_stmt|;
block|}
comment|/* Save FP registers if needed.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
operator|!
name|no_rtl
operator|&&
name|next_cum
operator|.
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
block|{
name|int
name|fregno
init|=
name|next_cum
operator|.
name|fregno
decl_stmt|;
name|rtx
name|cr1
init|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR1_REGNO
argument_list|)
decl_stmt|;
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|off
init|=
operator|(
name|GP_ARG_NUM_REG
operator|*
name|reg_size
operator|)
operator|+
operator|(
operator|(
name|fregno
operator|-
name|FP_ARG_MIN_REG
operator|)
operator|*
literal|8
operator|)
decl_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cr1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|fregno
argument_list|)
argument_list|)
expr_stmt|;
name|fregno
operator|++
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
block|}
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the va_list data type.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_res
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
comment|/* For AIX, prefer 'char *' because that's what the system      header files like.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
name|record
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"gpr"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"fpr"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* Give the two bytes of padding a name, so that -Wpadded won't warn on      every user file.  */
name|f_res
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"reserved"
argument_list|)
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_res
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_res
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_res
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement va_start.  */
end_comment

begin_function
name|void
name|rs6000_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
parameter_list|)
block|{
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_res
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
comment|/* Only SVR4 needs something special.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
block|{
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_res
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_res
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|words
operator|=
name|current_function_args_info
operator|.
name|words
expr_stmt|;
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|sysv_gregno
operator|-
name|GP_ARG_MIN_REG
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|fregno
operator|-
name|FP_ARG_MIN_REG
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: words = "
name|HOST_WIDE_INT_PRINT_DEC
literal|", n_gpr = "
name|HOST_WIDE_INT_PRINT_DEC
literal|", n_fpr = "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|words
argument_list|,
name|n_gpr
argument_list|,
name|n_fpr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|n_gpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|n_fpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the overflow area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|!=
literal|0
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|words
operator|*
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the register save area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|RS6000_VARARGS_SIZE
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|rtx
name|rs6000_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_res
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|reg
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|;
name|int
name|indirect_p
decl_stmt|,
name|size
decl_stmt|,
name|rsize
decl_stmt|,
name|n_reg
decl_stmt|,
name|sav_ofs
decl_stmt|,
name|sav_scale
decl_stmt|;
name|rtx
name|lab_false
decl_stmt|,
name|lab_over
decl_stmt|,
name|addr_rtx
decl_stmt|,
name|r
decl_stmt|;
name|int
name|align
decl_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
block|{
comment|/* Variable sized types are passed by reference, as are AltiVec 	 vectors when 32-bit and not using the AltiVec ABI extension.  */
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|TARGET_32BIT
operator|&&
operator|!
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|u
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Args grow upward.  */
name|t
operator|=
name|build
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build_int_2
argument_list|(
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|u
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|u
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|t
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|elem_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|elem_mode
init|=
name|TYPE_MODE
argument_list|(
name|elem_type
argument_list|)
decl_stmt|;
name|int
name|elem_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|elem_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|elem_size
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|rtx
name|real_part
decl_stmt|,
name|imag_part
decl_stmt|,
name|dest_real
decl_stmt|,
name|rr
decl_stmt|;
name|real_part
operator|=
name|rs6000_va_arg
argument_list|(
name|valist
argument_list|,
name|elem_type
argument_list|)
expr_stmt|;
name|imag_part
operator|=
name|rs6000_va_arg
argument_list|(
name|valist
argument_list|,
name|elem_type
argument_list|)
expr_stmt|;
comment|/* We're not returning the value here, but the address. 		 real_part and imag_part are not contiguous, and we know 		 there is space available to pack real_part next to 		 imag_part.  float _Complex is not promoted to 		 double _Complex by the default promotion rules that 		 promote float to double.  */
if|if
condition|(
literal|2
operator|*
name|elem_size
operator|>
name|UNITS_PER_WORD
condition|)
name|abort
argument_list|()
expr_stmt|;
name|real_part
operator|=
name|gen_rtx_MEM
argument_list|(
name|elem_mode
argument_list|,
name|real_part
argument_list|)
expr_stmt|;
name|imag_part
operator|=
name|gen_rtx_MEM
argument_list|(
name|elem_mode
argument_list|,
name|imag_part
argument_list|)
expr_stmt|;
name|dest_real
operator|=
name|adjust_address
argument_list|(
name|imag_part
argument_list|,
name|elem_mode
argument_list|,
operator|-
name|elem_size
argument_list|)
expr_stmt|;
name|rr
operator|=
name|gen_reg_rtx
argument_list|(
name|elem_mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|rr
argument_list|,
name|real_part
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest_real
argument_list|,
name|rr
argument_list|)
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|dest_real
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_res
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_res
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rsize
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|align
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
operator|||
operator|(
operator|!
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Aggregates, long doubles, and AltiVec vectors are passed by 	 reference.  */
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|0
expr_stmt|;
name|sav_scale
operator|=
literal|4
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
name|rsize
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|)
condition|)
block|{
comment|/* FP args go in FP registers, if present.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|fpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|8
operator|*
literal|4
expr_stmt|;
name|sav_scale
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
condition|)
name|align
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise into GP registers.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
name|rsize
expr_stmt|;
name|sav_ofs
operator|=
literal|0
expr_stmt|;
name|sav_scale
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|n_reg
operator|==
literal|2
condition|)
name|align
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Pull the value out of the saved registers....  */
name|lab_over
operator|=
name|NULL_RTX
expr_stmt|;
name|addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/*  AltiVec vectors never go in registers when -mabi=altivec.  */
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|align
operator|=
literal|16
expr_stmt|;
else|else
block|{
name|lab_false
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab_over
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Long long and SPE vectors are aligned in the registers. 	 As are any other 2 gpr item such as complex int due to a 	 historical mistake.  */
name|u
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|n_reg
operator|==
literal|2
condition|)
block|{
name|u
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|n_reg
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|u
argument_list|,
name|NULL_RTX
argument_list|,
name|QImode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
operator|-
name|n_reg
operator|+
literal|1
argument_list|)
argument_list|,
name|GE
argument_list|,
name|const1_rtx
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
name|t
operator|=
name|sav
expr_stmt|;
if|if
condition|(
name|sav_ofs
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|build_int_2
argument_list|(
name|sav_ofs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|n_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|u
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|u
argument_list|,
name|build_int_2
argument_list|(
name|sav_scale
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab_over
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab_false
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_reg
operator|>
literal|2
condition|)
block|{
comment|/* Ensure that we don't find any more args in regs. 	     Alignment has taken care of the n_reg == 2 case.  */
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ... otherwise out of the overflow area.  */
comment|/* Care for on-stack alignment if needed.  */
name|t
operator|=
name|ovf
expr_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|align
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|align
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|save_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lab_over
condition|)
name|emit_label
argument_list|(
name|lab_over
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
block|{
name|r
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|r
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|addr_rtx
return|;
block|}
end_function

begin_comment
comment|/* Builtins.  */
end_comment

begin_define
define|#
directive|define
name|def_builtin
parameter_list|(
name|MASK
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {								\   if ((MASK)& target_flags)					\     builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD,	\ 		      NULL, NULL_TREE);				\ } while (0)
end_define

begin_comment
comment|/* Simple ternary operations: VECd = foo (VECa, VECb, VECc).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_3arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmaddfp
block|,
literal|"__builtin_altivec_vmaddfp"
block|,
name|ALTIVEC_BUILTIN_VMADDFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmhaddshs
block|,
literal|"__builtin_altivec_vmhaddshs"
block|,
name|ALTIVEC_BUILTIN_VMHADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmhraddshs
block|,
literal|"__builtin_altivec_vmhraddshs"
block|,
name|ALTIVEC_BUILTIN_VMHRADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmladduhm
block|,
literal|"__builtin_altivec_vmladduhm"
block|,
name|ALTIVEC_BUILTIN_VMLADDUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumubm
block|,
literal|"__builtin_altivec_vmsumubm"
block|,
name|ALTIVEC_BUILTIN_VMSUMUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsummbm
block|,
literal|"__builtin_altivec_vmsummbm"
block|,
name|ALTIVEC_BUILTIN_VMSUMMBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumuhm
block|,
literal|"__builtin_altivec_vmsumuhm"
block|,
name|ALTIVEC_BUILTIN_VMSUMUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumshm
block|,
literal|"__builtin_altivec_vmsumshm"
block|,
name|ALTIVEC_BUILTIN_VMSUMSHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumuhs
block|,
literal|"__builtin_altivec_vmsumuhs"
block|,
name|ALTIVEC_BUILTIN_VMSUMUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumshs
block|,
literal|"__builtin_altivec_vmsumshs"
block|,
name|ALTIVEC_BUILTIN_VMSUMSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vnmsubfp
block|,
literal|"__builtin_altivec_vnmsubfp"
block|,
name|ALTIVEC_BUILTIN_VNMSUBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_4sf
block|,
literal|"__builtin_altivec_vperm_4sf"
block|,
name|ALTIVEC_BUILTIN_VPERM_4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_4si
block|,
literal|"__builtin_altivec_vperm_4si"
block|,
name|ALTIVEC_BUILTIN_VPERM_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_8hi
block|,
literal|"__builtin_altivec_vperm_8hi"
block|,
name|ALTIVEC_BUILTIN_VPERM_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_16qi
block|,
literal|"__builtin_altivec_vperm_16qi"
block|,
name|ALTIVEC_BUILTIN_VPERM_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_4sf
block|,
literal|"__builtin_altivec_vsel_4sf"
block|,
name|ALTIVEC_BUILTIN_VSEL_4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_4si
block|,
literal|"__builtin_altivec_vsel_4si"
block|,
name|ALTIVEC_BUILTIN_VSEL_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_8hi
block|,
literal|"__builtin_altivec_vsel_8hi"
block|,
name|ALTIVEC_BUILTIN_VSEL_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_16qi
block|,
literal|"__builtin_altivec_vsel_16qi"
block|,
name|ALTIVEC_BUILTIN_VSEL_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_16qi
block|,
literal|"__builtin_altivec_vsldoi_16qi"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_8hi
block|,
literal|"__builtin_altivec_vsldoi_8hi"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_4si
block|,
literal|"__builtin_altivec_vsldoi_4si"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_4sf
block|,
literal|"__builtin_altivec_vsldoi_4sf"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_4SF
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DST operations: void foo (void *, const int, const char).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_dst
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dst
block|,
literal|"__builtin_altivec_dst"
block|,
name|ALTIVEC_BUILTIN_DST
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dstt
block|,
literal|"__builtin_altivec_dstt"
block|,
name|ALTIVEC_BUILTIN_DSTT
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dstst
block|,
literal|"__builtin_altivec_dstst"
block|,
name|ALTIVEC_BUILTIN_DSTST
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dststt
block|,
literal|"__builtin_altivec_dststt"
block|,
name|ALTIVEC_BUILTIN_DSTSTT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple binary operations: VECc = foo (VECa, VECb).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv16qi3
block|,
literal|"__builtin_altivec_vaddubm"
block|,
name|ALTIVEC_BUILTIN_VADDUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv8hi3
block|,
literal|"__builtin_altivec_vadduhm"
block|,
name|ALTIVEC_BUILTIN_VADDUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv4si3
block|,
literal|"__builtin_altivec_vadduwm"
block|,
name|ALTIVEC_BUILTIN_VADDUWM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv4sf3
block|,
literal|"__builtin_altivec_vaddfp"
block|,
name|ALTIVEC_BUILTIN_VADDFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddcuw
block|,
literal|"__builtin_altivec_vaddcuw"
block|,
name|ALTIVEC_BUILTIN_VADDCUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddubs
block|,
literal|"__builtin_altivec_vaddubs"
block|,
name|ALTIVEC_BUILTIN_VADDUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddsbs
block|,
literal|"__builtin_altivec_vaddsbs"
block|,
name|ALTIVEC_BUILTIN_VADDSBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vadduhs
block|,
literal|"__builtin_altivec_vadduhs"
block|,
name|ALTIVEC_BUILTIN_VADDUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddshs
block|,
literal|"__builtin_altivec_vaddshs"
block|,
name|ALTIVEC_BUILTIN_VADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vadduws
block|,
literal|"__builtin_altivec_vadduws"
block|,
name|ALTIVEC_BUILTIN_VADDUWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddsws
block|,
literal|"__builtin_altivec_vaddsws"
block|,
name|ALTIVEC_BUILTIN_VADDSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_andv4si3
block|,
literal|"__builtin_altivec_vand"
block|,
name|ALTIVEC_BUILTIN_VAND
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vandc
block|,
literal|"__builtin_altivec_vandc"
block|,
name|ALTIVEC_BUILTIN_VANDC
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgub
block|,
literal|"__builtin_altivec_vavgub"
block|,
name|ALTIVEC_BUILTIN_VAVGUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsb
block|,
literal|"__builtin_altivec_vavgsb"
block|,
name|ALTIVEC_BUILTIN_VAVGSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavguh
block|,
literal|"__builtin_altivec_vavguh"
block|,
name|ALTIVEC_BUILTIN_VAVGUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsh
block|,
literal|"__builtin_altivec_vavgsh"
block|,
name|ALTIVEC_BUILTIN_VAVGSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavguw
block|,
literal|"__builtin_altivec_vavguw"
block|,
name|ALTIVEC_BUILTIN_VAVGUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsw
block|,
literal|"__builtin_altivec_vavgsw"
block|,
name|ALTIVEC_BUILTIN_VAVGSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcfux
block|,
literal|"__builtin_altivec_vcfux"
block|,
name|ALTIVEC_BUILTIN_VCFUX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcfsx
block|,
literal|"__builtin_altivec_vcfsx"
block|,
name|ALTIVEC_BUILTIN_VCFSX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpbfp
block|,
literal|"__builtin_altivec_vcmpbfp"
block|,
name|ALTIVEC_BUILTIN_VCMPBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequb
block|,
literal|"__builtin_altivec_vcmpequb"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequh
block|,
literal|"__builtin_altivec_vcmpequh"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequw
block|,
literal|"__builtin_altivec_vcmpequw"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpeqfp
block|,
literal|"__builtin_altivec_vcmpeqfp"
block|,
name|ALTIVEC_BUILTIN_VCMPEQFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgefp
block|,
literal|"__builtin_altivec_vcmpgefp"
block|,
name|ALTIVEC_BUILTIN_VCMPGEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtub
block|,
literal|"__builtin_altivec_vcmpgtub"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsb
block|,
literal|"__builtin_altivec_vcmpgtsb"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtuh
block|,
literal|"__builtin_altivec_vcmpgtuh"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsh
block|,
literal|"__builtin_altivec_vcmpgtsh"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtuw
block|,
literal|"__builtin_altivec_vcmpgtuw"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsw
block|,
literal|"__builtin_altivec_vcmpgtsw"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtfp
block|,
literal|"__builtin_altivec_vcmpgtfp"
block|,
name|ALTIVEC_BUILTIN_VCMPGTFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vctsxs
block|,
literal|"__builtin_altivec_vctsxs"
block|,
name|ALTIVEC_BUILTIN_VCTSXS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vctuxs
block|,
literal|"__builtin_altivec_vctuxs"
block|,
name|ALTIVEC_BUILTIN_VCTUXS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_umaxv16qi3
block|,
literal|"__builtin_altivec_vmaxub"
block|,
name|ALTIVEC_BUILTIN_VMAXUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv16qi3
block|,
literal|"__builtin_altivec_vmaxsb"
block|,
name|ALTIVEC_BUILTIN_VMAXSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_umaxv8hi3
block|,
literal|"__builtin_altivec_vmaxuh"
block|,
name|ALTIVEC_BUILTIN_VMAXUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv8hi3
block|,
literal|"__builtin_altivec_vmaxsh"
block|,
name|ALTIVEC_BUILTIN_VMAXSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_umaxv4si3
block|,
literal|"__builtin_altivec_vmaxuw"
block|,
name|ALTIVEC_BUILTIN_VMAXUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv4si3
block|,
literal|"__builtin_altivec_vmaxsw"
block|,
name|ALTIVEC_BUILTIN_VMAXSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv4sf3
block|,
literal|"__builtin_altivec_vmaxfp"
block|,
name|ALTIVEC_BUILTIN_VMAXFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghb
block|,
literal|"__builtin_altivec_vmrghb"
block|,
name|ALTIVEC_BUILTIN_VMRGHB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghh
block|,
literal|"__builtin_altivec_vmrghh"
block|,
name|ALTIVEC_BUILTIN_VMRGHH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghw
block|,
literal|"__builtin_altivec_vmrghw"
block|,
name|ALTIVEC_BUILTIN_VMRGHW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglb
block|,
literal|"__builtin_altivec_vmrglb"
block|,
name|ALTIVEC_BUILTIN_VMRGLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglh
block|,
literal|"__builtin_altivec_vmrglh"
block|,
name|ALTIVEC_BUILTIN_VMRGLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglw
block|,
literal|"__builtin_altivec_vmrglw"
block|,
name|ALTIVEC_BUILTIN_VMRGLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv16qi3
block|,
literal|"__builtin_altivec_vminub"
block|,
name|ALTIVEC_BUILTIN_VMINUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv16qi3
block|,
literal|"__builtin_altivec_vminsb"
block|,
name|ALTIVEC_BUILTIN_VMINSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv8hi3
block|,
literal|"__builtin_altivec_vminuh"
block|,
name|ALTIVEC_BUILTIN_VMINUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv8hi3
block|,
literal|"__builtin_altivec_vminsh"
block|,
name|ALTIVEC_BUILTIN_VMINSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv4si3
block|,
literal|"__builtin_altivec_vminuw"
block|,
name|ALTIVEC_BUILTIN_VMINUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv4si3
block|,
literal|"__builtin_altivec_vminsw"
block|,
name|ALTIVEC_BUILTIN_VMINSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv4sf3
block|,
literal|"__builtin_altivec_vminfp"
block|,
name|ALTIVEC_BUILTIN_VMINFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuleub
block|,
literal|"__builtin_altivec_vmuleub"
block|,
name|ALTIVEC_BUILTIN_VMULEUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulesb
block|,
literal|"__builtin_altivec_vmulesb"
block|,
name|ALTIVEC_BUILTIN_VMULESB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuleuh
block|,
literal|"__builtin_altivec_vmuleuh"
block|,
name|ALTIVEC_BUILTIN_VMULEUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulesh
block|,
literal|"__builtin_altivec_vmulesh"
block|,
name|ALTIVEC_BUILTIN_VMULESH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuloub
block|,
literal|"__builtin_altivec_vmuloub"
block|,
name|ALTIVEC_BUILTIN_VMULOUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulosb
block|,
literal|"__builtin_altivec_vmulosb"
block|,
name|ALTIVEC_BUILTIN_VMULOSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulouh
block|,
literal|"__builtin_altivec_vmulouh"
block|,
name|ALTIVEC_BUILTIN_VMULOUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulosh
block|,
literal|"__builtin_altivec_vmulosh"
block|,
name|ALTIVEC_BUILTIN_VMULOSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vnor
block|,
literal|"__builtin_altivec_vnor"
block|,
name|ALTIVEC_BUILTIN_VNOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_iorv4si3
block|,
literal|"__builtin_altivec_vor"
block|,
name|ALTIVEC_BUILTIN_VOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuhum
block|,
literal|"__builtin_altivec_vpkuhum"
block|,
name|ALTIVEC_BUILTIN_VPKUHUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuwum
block|,
literal|"__builtin_altivec_vpkuwum"
block|,
name|ALTIVEC_BUILTIN_VPKUWUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkpx
block|,
literal|"__builtin_altivec_vpkpx"
block|,
name|ALTIVEC_BUILTIN_VPKPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuhss
block|,
literal|"__builtin_altivec_vpkuhss"
block|,
name|ALTIVEC_BUILTIN_VPKUHSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkshss
block|,
literal|"__builtin_altivec_vpkshss"
block|,
name|ALTIVEC_BUILTIN_VPKSHSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuwss
block|,
literal|"__builtin_altivec_vpkuwss"
block|,
name|ALTIVEC_BUILTIN_VPKUWSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkswss
block|,
literal|"__builtin_altivec_vpkswss"
block|,
name|ALTIVEC_BUILTIN_VPKSWSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuhus
block|,
literal|"__builtin_altivec_vpkuhus"
block|,
name|ALTIVEC_BUILTIN_VPKUHUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkshus
block|,
literal|"__builtin_altivec_vpkshus"
block|,
name|ALTIVEC_BUILTIN_VPKSHUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuwus
block|,
literal|"__builtin_altivec_vpkuwus"
block|,
name|ALTIVEC_BUILTIN_VPKUWUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkswus
block|,
literal|"__builtin_altivec_vpkswus"
block|,
name|ALTIVEC_BUILTIN_VPKSWUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlb
block|,
literal|"__builtin_altivec_vrlb"
block|,
name|ALTIVEC_BUILTIN_VRLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlh
block|,
literal|"__builtin_altivec_vrlh"
block|,
name|ALTIVEC_BUILTIN_VRLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlw
block|,
literal|"__builtin_altivec_vrlw"
block|,
name|ALTIVEC_BUILTIN_VRLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslb
block|,
literal|"__builtin_altivec_vslb"
block|,
name|ALTIVEC_BUILTIN_VSLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslh
block|,
literal|"__builtin_altivec_vslh"
block|,
name|ALTIVEC_BUILTIN_VSLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslw
block|,
literal|"__builtin_altivec_vslw"
block|,
name|ALTIVEC_BUILTIN_VSLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsl
block|,
literal|"__builtin_altivec_vsl"
block|,
name|ALTIVEC_BUILTIN_VSL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslo
block|,
literal|"__builtin_altivec_vslo"
block|,
name|ALTIVEC_BUILTIN_VSLO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltb
block|,
literal|"__builtin_altivec_vspltb"
block|,
name|ALTIVEC_BUILTIN_VSPLTB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsplth
block|,
literal|"__builtin_altivec_vsplth"
block|,
name|ALTIVEC_BUILTIN_VSPLTH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltw
block|,
literal|"__builtin_altivec_vspltw"
block|,
name|ALTIVEC_BUILTIN_VSPLTW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrb
block|,
literal|"__builtin_altivec_vsrb"
block|,
name|ALTIVEC_BUILTIN_VSRB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrh
block|,
literal|"__builtin_altivec_vsrh"
block|,
name|ALTIVEC_BUILTIN_VSRH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrw
block|,
literal|"__builtin_altivec_vsrw"
block|,
name|ALTIVEC_BUILTIN_VSRW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrab
block|,
literal|"__builtin_altivec_vsrab"
block|,
name|ALTIVEC_BUILTIN_VSRAB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsrah
block|,
literal|"__builtin_altivec_vsrah"
block|,
name|ALTIVEC_BUILTIN_VSRAH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsraw
block|,
literal|"__builtin_altivec_vsraw"
block|,
name|ALTIVEC_BUILTIN_VSRAW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsr
block|,
literal|"__builtin_altivec_vsr"
block|,
name|ALTIVEC_BUILTIN_VSR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsro
block|,
literal|"__builtin_altivec_vsro"
block|,
name|ALTIVEC_BUILTIN_VSRO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv16qi3
block|,
literal|"__builtin_altivec_vsububm"
block|,
name|ALTIVEC_BUILTIN_VSUBUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv8hi3
block|,
literal|"__builtin_altivec_vsubuhm"
block|,
name|ALTIVEC_BUILTIN_VSUBUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv4si3
block|,
literal|"__builtin_altivec_vsubuwm"
block|,
name|ALTIVEC_BUILTIN_VSUBUWM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv4sf3
block|,
literal|"__builtin_altivec_vsubfp"
block|,
name|ALTIVEC_BUILTIN_VSUBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubcuw
block|,
literal|"__builtin_altivec_vsubcuw"
block|,
name|ALTIVEC_BUILTIN_VSUBCUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsububs
block|,
literal|"__builtin_altivec_vsububs"
block|,
name|ALTIVEC_BUILTIN_VSUBUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubsbs
block|,
literal|"__builtin_altivec_vsubsbs"
block|,
name|ALTIVEC_BUILTIN_VSUBSBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubuhs
block|,
literal|"__builtin_altivec_vsubuhs"
block|,
name|ALTIVEC_BUILTIN_VSUBUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubshs
block|,
literal|"__builtin_altivec_vsubshs"
block|,
name|ALTIVEC_BUILTIN_VSUBSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubuws
block|,
literal|"__builtin_altivec_vsubuws"
block|,
name|ALTIVEC_BUILTIN_VSUBUWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubsws
block|,
literal|"__builtin_altivec_vsubsws"
block|,
name|ALTIVEC_BUILTIN_VSUBSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4ubs
block|,
literal|"__builtin_altivec_vsum4ubs"
block|,
name|ALTIVEC_BUILTIN_VSUM4UBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4sbs
block|,
literal|"__builtin_altivec_vsum4sbs"
block|,
name|ALTIVEC_BUILTIN_VSUM4SBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4shs
block|,
literal|"__builtin_altivec_vsum4shs"
block|,
name|ALTIVEC_BUILTIN_VSUM4SHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum2sws
block|,
literal|"__builtin_altivec_vsum2sws"
block|,
name|ALTIVEC_BUILTIN_VSUM2SWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsumsws
block|,
literal|"__builtin_altivec_vsumsws"
block|,
name|ALTIVEC_BUILTIN_VSUMSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_xorv4si3
block|,
literal|"__builtin_altivec_vxor"
block|,
name|ALTIVEC_BUILTIN_VXOR
block|}
block|,
comment|/* Place holder, leave as first spe builtin.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddw
block|,
literal|"__builtin_spe_evaddw"
block|,
name|SPE_BUILTIN_EVADDW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evand
block|,
literal|"__builtin_spe_evand"
block|,
name|SPE_BUILTIN_EVAND
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evandc
block|,
literal|"__builtin_spe_evandc"
block|,
name|SPE_BUILTIN_EVANDC
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evdivws
block|,
literal|"__builtin_spe_evdivws"
block|,
name|SPE_BUILTIN_EVDIVWS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evdivwu
block|,
literal|"__builtin_spe_evdivwu"
block|,
name|SPE_BUILTIN_EVDIVWU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_eveqv
block|,
literal|"__builtin_spe_eveqv"
block|,
name|SPE_BUILTIN_EVEQV
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsadd
block|,
literal|"__builtin_spe_evfsadd"
block|,
name|SPE_BUILTIN_EVFSADD
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsdiv
block|,
literal|"__builtin_spe_evfsdiv"
block|,
name|SPE_BUILTIN_EVFSDIV
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsmul
block|,
literal|"__builtin_spe_evfsmul"
block|,
name|SPE_BUILTIN_EVFSMUL
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfssub
block|,
literal|"__builtin_spe_evfssub"
block|,
name|SPE_BUILTIN_EVFSSUB
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmergehi
block|,
literal|"__builtin_spe_evmergehi"
block|,
name|SPE_BUILTIN_EVMERGEHI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmergehilo
block|,
literal|"__builtin_spe_evmergehilo"
block|,
name|SPE_BUILTIN_EVMERGEHILO
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmergelo
block|,
literal|"__builtin_spe_evmergelo"
block|,
name|SPE_BUILTIN_EVMERGELO
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmergelohi
block|,
literal|"__builtin_spe_evmergelohi"
block|,
name|SPE_BUILTIN_EVMERGELOHI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegsmfaa
block|,
literal|"__builtin_spe_evmhegsmfaa"
block|,
name|SPE_BUILTIN_EVMHEGSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegsmfan
block|,
literal|"__builtin_spe_evmhegsmfan"
block|,
name|SPE_BUILTIN_EVMHEGSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegsmiaa
block|,
literal|"__builtin_spe_evmhegsmiaa"
block|,
name|SPE_BUILTIN_EVMHEGSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegsmian
block|,
literal|"__builtin_spe_evmhegsmian"
block|,
name|SPE_BUILTIN_EVMHEGSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegumiaa
block|,
literal|"__builtin_spe_evmhegumiaa"
block|,
name|SPE_BUILTIN_EVMHEGUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegumian
block|,
literal|"__builtin_spe_evmhegumian"
block|,
name|SPE_BUILTIN_EVMHEGUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmf
block|,
literal|"__builtin_spe_evmhesmf"
block|,
name|SPE_BUILTIN_EVMHESMF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmfa
block|,
literal|"__builtin_spe_evmhesmfa"
block|,
name|SPE_BUILTIN_EVMHESMFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmfaaw
block|,
literal|"__builtin_spe_evmhesmfaaw"
block|,
name|SPE_BUILTIN_EVMHESMFAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmfanw
block|,
literal|"__builtin_spe_evmhesmfanw"
block|,
name|SPE_BUILTIN_EVMHESMFANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmi
block|,
literal|"__builtin_spe_evmhesmi"
block|,
name|SPE_BUILTIN_EVMHESMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmia
block|,
literal|"__builtin_spe_evmhesmia"
block|,
name|SPE_BUILTIN_EVMHESMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmiaaw
block|,
literal|"__builtin_spe_evmhesmiaaw"
block|,
name|SPE_BUILTIN_EVMHESMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmianw
block|,
literal|"__builtin_spe_evmhesmianw"
block|,
name|SPE_BUILTIN_EVMHESMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessf
block|,
literal|"__builtin_spe_evmhessf"
block|,
name|SPE_BUILTIN_EVMHESSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessfa
block|,
literal|"__builtin_spe_evmhessfa"
block|,
name|SPE_BUILTIN_EVMHESSFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessfaaw
block|,
literal|"__builtin_spe_evmhessfaaw"
block|,
name|SPE_BUILTIN_EVMHESSFAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessfanw
block|,
literal|"__builtin_spe_evmhessfanw"
block|,
name|SPE_BUILTIN_EVMHESSFANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessiaaw
block|,
literal|"__builtin_spe_evmhessiaaw"
block|,
name|SPE_BUILTIN_EVMHESSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessianw
block|,
literal|"__builtin_spe_evmhessianw"
block|,
name|SPE_BUILTIN_EVMHESSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheumi
block|,
literal|"__builtin_spe_evmheumi"
block|,
name|SPE_BUILTIN_EVMHEUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheumia
block|,
literal|"__builtin_spe_evmheumia"
block|,
name|SPE_BUILTIN_EVMHEUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheumiaaw
block|,
literal|"__builtin_spe_evmheumiaaw"
block|,
name|SPE_BUILTIN_EVMHEUMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheumianw
block|,
literal|"__builtin_spe_evmheumianw"
block|,
name|SPE_BUILTIN_EVMHEUMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheusiaaw
block|,
literal|"__builtin_spe_evmheusiaaw"
block|,
name|SPE_BUILTIN_EVMHEUSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheusianw
block|,
literal|"__builtin_spe_evmheusianw"
block|,
name|SPE_BUILTIN_EVMHEUSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogsmfaa
block|,
literal|"__builtin_spe_evmhogsmfaa"
block|,
name|SPE_BUILTIN_EVMHOGSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogsmfan
block|,
literal|"__builtin_spe_evmhogsmfan"
block|,
name|SPE_BUILTIN_EVMHOGSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogsmiaa
block|,
literal|"__builtin_spe_evmhogsmiaa"
block|,
name|SPE_BUILTIN_EVMHOGSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogsmian
block|,
literal|"__builtin_spe_evmhogsmian"
block|,
name|SPE_BUILTIN_EVMHOGSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogumiaa
block|,
literal|"__builtin_spe_evmhogumiaa"
block|,
name|SPE_BUILTIN_EVMHOGUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogumian
block|,
literal|"__builtin_spe_evmhogumian"
block|,
name|SPE_BUILTIN_EVMHOGUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmf
block|,
literal|"__builtin_spe_evmhosmf"
block|,
name|SPE_BUILTIN_EVMHOSMF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmfa
block|,
literal|"__builtin_spe_evmhosmfa"
block|,
name|SPE_BUILTIN_EVMHOSMFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmfaaw
block|,
literal|"__builtin_spe_evmhosmfaaw"
block|,
name|SPE_BUILTIN_EVMHOSMFAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmfanw
block|,
literal|"__builtin_spe_evmhosmfanw"
block|,
name|SPE_BUILTIN_EVMHOSMFANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmi
block|,
literal|"__builtin_spe_evmhosmi"
block|,
name|SPE_BUILTIN_EVMHOSMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmia
block|,
literal|"__builtin_spe_evmhosmia"
block|,
name|SPE_BUILTIN_EVMHOSMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmiaaw
block|,
literal|"__builtin_spe_evmhosmiaaw"
block|,
name|SPE_BUILTIN_EVMHOSMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmianw
block|,
literal|"__builtin_spe_evmhosmianw"
block|,
name|SPE_BUILTIN_EVMHOSMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossf
block|,
literal|"__builtin_spe_evmhossf"
block|,
name|SPE_BUILTIN_EVMHOSSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossfa
block|,
literal|"__builtin_spe_evmhossfa"
block|,
name|SPE_BUILTIN_EVMHOSSFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossfaaw
block|,
literal|"__builtin_spe_evmhossfaaw"
block|,
name|SPE_BUILTIN_EVMHOSSFAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossfanw
block|,
literal|"__builtin_spe_evmhossfanw"
block|,
name|SPE_BUILTIN_EVMHOSSFANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossiaaw
block|,
literal|"__builtin_spe_evmhossiaaw"
block|,
name|SPE_BUILTIN_EVMHOSSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossianw
block|,
literal|"__builtin_spe_evmhossianw"
block|,
name|SPE_BUILTIN_EVMHOSSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhoumi
block|,
literal|"__builtin_spe_evmhoumi"
block|,
name|SPE_BUILTIN_EVMHOUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhoumia
block|,
literal|"__builtin_spe_evmhoumia"
block|,
name|SPE_BUILTIN_EVMHOUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhoumiaaw
block|,
literal|"__builtin_spe_evmhoumiaaw"
block|,
name|SPE_BUILTIN_EVMHOUMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhoumianw
block|,
literal|"__builtin_spe_evmhoumianw"
block|,
name|SPE_BUILTIN_EVMHOUMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhousiaaw
block|,
literal|"__builtin_spe_evmhousiaaw"
block|,
name|SPE_BUILTIN_EVMHOUSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhousianw
block|,
literal|"__builtin_spe_evmhousianw"
block|,
name|SPE_BUILTIN_EVMHOUSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmf
block|,
literal|"__builtin_spe_evmwhsmf"
block|,
name|SPE_BUILTIN_EVMWHSMF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmfa
block|,
literal|"__builtin_spe_evmwhsmfa"
block|,
name|SPE_BUILTIN_EVMWHSMFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmi
block|,
literal|"__builtin_spe_evmwhsmi"
block|,
name|SPE_BUILTIN_EVMWHSMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmia
block|,
literal|"__builtin_spe_evmwhsmia"
block|,
name|SPE_BUILTIN_EVMWHSMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssf
block|,
literal|"__builtin_spe_evmwhssf"
block|,
name|SPE_BUILTIN_EVMWHSSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssfa
block|,
literal|"__builtin_spe_evmwhssfa"
block|,
name|SPE_BUILTIN_EVMWHSSFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhumi
block|,
literal|"__builtin_spe_evmwhumi"
block|,
name|SPE_BUILTIN_EVMWHUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhumia
block|,
literal|"__builtin_spe_evmwhumia"
block|,
name|SPE_BUILTIN_EVMWHUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlsmiaaw
block|,
literal|"__builtin_spe_evmwlsmiaaw"
block|,
name|SPE_BUILTIN_EVMWLSMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlsmianw
block|,
literal|"__builtin_spe_evmwlsmianw"
block|,
name|SPE_BUILTIN_EVMWLSMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlssiaaw
block|,
literal|"__builtin_spe_evmwlssiaaw"
block|,
name|SPE_BUILTIN_EVMWLSSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlssianw
block|,
literal|"__builtin_spe_evmwlssianw"
block|,
name|SPE_BUILTIN_EVMWLSSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlumi
block|,
literal|"__builtin_spe_evmwlumi"
block|,
name|SPE_BUILTIN_EVMWLUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlumia
block|,
literal|"__builtin_spe_evmwlumia"
block|,
name|SPE_BUILTIN_EVMWLUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlumiaaw
block|,
literal|"__builtin_spe_evmwlumiaaw"
block|,
name|SPE_BUILTIN_EVMWLUMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlumianw
block|,
literal|"__builtin_spe_evmwlumianw"
block|,
name|SPE_BUILTIN_EVMWLUMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlusiaaw
block|,
literal|"__builtin_spe_evmwlusiaaw"
block|,
name|SPE_BUILTIN_EVMWLUSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlusianw
block|,
literal|"__builtin_spe_evmwlusianw"
block|,
name|SPE_BUILTIN_EVMWLUSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmf
block|,
literal|"__builtin_spe_evmwsmf"
block|,
name|SPE_BUILTIN_EVMWSMF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmfa
block|,
literal|"__builtin_spe_evmwsmfa"
block|,
name|SPE_BUILTIN_EVMWSMFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmfaa
block|,
literal|"__builtin_spe_evmwsmfaa"
block|,
name|SPE_BUILTIN_EVMWSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmfan
block|,
literal|"__builtin_spe_evmwsmfan"
block|,
name|SPE_BUILTIN_EVMWSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmi
block|,
literal|"__builtin_spe_evmwsmi"
block|,
name|SPE_BUILTIN_EVMWSMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmia
block|,
literal|"__builtin_spe_evmwsmia"
block|,
name|SPE_BUILTIN_EVMWSMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmiaa
block|,
literal|"__builtin_spe_evmwsmiaa"
block|,
name|SPE_BUILTIN_EVMWSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmian
block|,
literal|"__builtin_spe_evmwsmian"
block|,
name|SPE_BUILTIN_EVMWSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwssf
block|,
literal|"__builtin_spe_evmwssf"
block|,
name|SPE_BUILTIN_EVMWSSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwssfa
block|,
literal|"__builtin_spe_evmwssfa"
block|,
name|SPE_BUILTIN_EVMWSSFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwssfaa
block|,
literal|"__builtin_spe_evmwssfaa"
block|,
name|SPE_BUILTIN_EVMWSSFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwssfan
block|,
literal|"__builtin_spe_evmwssfan"
block|,
name|SPE_BUILTIN_EVMWSSFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwumi
block|,
literal|"__builtin_spe_evmwumi"
block|,
name|SPE_BUILTIN_EVMWUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwumia
block|,
literal|"__builtin_spe_evmwumia"
block|,
name|SPE_BUILTIN_EVMWUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwumiaa
block|,
literal|"__builtin_spe_evmwumiaa"
block|,
name|SPE_BUILTIN_EVMWUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwumian
block|,
literal|"__builtin_spe_evmwumian"
block|,
name|SPE_BUILTIN_EVMWUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evnand
block|,
literal|"__builtin_spe_evnand"
block|,
name|SPE_BUILTIN_EVNAND
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evnor
block|,
literal|"__builtin_spe_evnor"
block|,
name|SPE_BUILTIN_EVNOR
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evor
block|,
literal|"__builtin_spe_evor"
block|,
name|SPE_BUILTIN_EVOR
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evorc
block|,
literal|"__builtin_spe_evorc"
block|,
name|SPE_BUILTIN_EVORC
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evrlw
block|,
literal|"__builtin_spe_evrlw"
block|,
name|SPE_BUILTIN_EVRLW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evslw
block|,
literal|"__builtin_spe_evslw"
block|,
name|SPE_BUILTIN_EVSLW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsrws
block|,
literal|"__builtin_spe_evsrws"
block|,
name|SPE_BUILTIN_EVSRWS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsrwu
block|,
literal|"__builtin_spe_evsrwu"
block|,
name|SPE_BUILTIN_EVSRWU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfw
block|,
literal|"__builtin_spe_evsubfw"
block|,
name|SPE_BUILTIN_EVSUBFW
block|}
block|,
comment|/* SPE binary operations expecting a 5-bit unsigned literal.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddiw
block|,
literal|"__builtin_spe_evaddiw"
block|,
name|SPE_BUILTIN_EVADDIW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evrlwi
block|,
literal|"__builtin_spe_evrlwi"
block|,
name|SPE_BUILTIN_EVRLWI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evslwi
block|,
literal|"__builtin_spe_evslwi"
block|,
name|SPE_BUILTIN_EVSLWI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsrwis
block|,
literal|"__builtin_spe_evsrwis"
block|,
name|SPE_BUILTIN_EVSRWIS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsrwiu
block|,
literal|"__builtin_spe_evsrwiu"
block|,
name|SPE_BUILTIN_EVSRWIU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubifw
block|,
literal|"__builtin_spe_evsubifw"
block|,
name|SPE_BUILTIN_EVSUBIFW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssfaa
block|,
literal|"__builtin_spe_evmwhssfaa"
block|,
name|SPE_BUILTIN_EVMWHSSFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssmaa
block|,
literal|"__builtin_spe_evmwhssmaa"
block|,
name|SPE_BUILTIN_EVMWHSSMAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmfaa
block|,
literal|"__builtin_spe_evmwhsmfaa"
block|,
name|SPE_BUILTIN_EVMWHSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmiaa
block|,
literal|"__builtin_spe_evmwhsmiaa"
block|,
name|SPE_BUILTIN_EVMWHSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhusiaa
block|,
literal|"__builtin_spe_evmwhusiaa"
block|,
name|SPE_BUILTIN_EVMWHUSIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhumiaa
block|,
literal|"__builtin_spe_evmwhumiaa"
block|,
name|SPE_BUILTIN_EVMWHUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssfan
block|,
literal|"__builtin_spe_evmwhssfan"
block|,
name|SPE_BUILTIN_EVMWHSSFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssian
block|,
literal|"__builtin_spe_evmwhssian"
block|,
name|SPE_BUILTIN_EVMWHSSIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmfan
block|,
literal|"__builtin_spe_evmwhsmfan"
block|,
name|SPE_BUILTIN_EVMWHSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmian
block|,
literal|"__builtin_spe_evmwhsmian"
block|,
name|SPE_BUILTIN_EVMWHSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhusian
block|,
literal|"__builtin_spe_evmwhusian"
block|,
name|SPE_BUILTIN_EVMWHUSIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhumian
block|,
literal|"__builtin_spe_evmwhumian"
block|,
name|SPE_BUILTIN_EVMWHUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgssfaa
block|,
literal|"__builtin_spe_evmwhgssfaa"
block|,
name|SPE_BUILTIN_EVMWHGSSFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgsmfaa
block|,
literal|"__builtin_spe_evmwhgsmfaa"
block|,
name|SPE_BUILTIN_EVMWHGSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgsmiaa
block|,
literal|"__builtin_spe_evmwhgsmiaa"
block|,
name|SPE_BUILTIN_EVMWHGSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgumiaa
block|,
literal|"__builtin_spe_evmwhgumiaa"
block|,
name|SPE_BUILTIN_EVMWHGUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgssfan
block|,
literal|"__builtin_spe_evmwhgssfan"
block|,
name|SPE_BUILTIN_EVMWHGSSFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgsmfan
block|,
literal|"__builtin_spe_evmwhgsmfan"
block|,
name|SPE_BUILTIN_EVMWHGSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgsmian
block|,
literal|"__builtin_spe_evmwhgsmian"
block|,
name|SPE_BUILTIN_EVMWHGSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgumian
block|,
literal|"__builtin_spe_evmwhgumian"
block|,
name|SPE_BUILTIN_EVMWHGUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_brinc
block|,
literal|"__builtin_spe_brinc"
block|,
name|SPE_BUILTIN_BRINC
block|}
block|,
comment|/* Place-holder.  Leave as last binary SPE builtin.  */
block|{
literal|0
block|,
name|CODE_FOR_xorv2si3
block|,
literal|"__builtin_spe_evxor"
block|,
name|SPE_BUILTIN_EVXOR
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AltiVec predicates.  */
end_comment

begin_struct
struct|struct
name|builtin_description_predicates
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|rs6000_builtins
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description_predicates
name|bdesc_altivec_preds
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpbfp."
block|,
literal|"__builtin_altivec_vcmpbfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPBFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpeqfp."
block|,
literal|"__builtin_altivec_vcmpeqfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpgefp."
block|,
literal|"__builtin_altivec_vcmpgefp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGEFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpgtfp."
block|,
literal|"__builtin_altivec_vcmpgtfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpequw."
block|,
literal|"__builtin_altivec_vcmpequw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpgtsw."
block|,
literal|"__builtin_altivec_vcmpgtsw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpgtuw."
block|,
literal|"__builtin_altivec_vcmpgtuw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpgtuh."
block|,
literal|"__builtin_altivec_vcmpgtuh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpgtsh."
block|,
literal|"__builtin_altivec_vcmpgtsh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpequh."
block|,
literal|"__builtin_altivec_vcmpequh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpequb."
block|,
literal|"__builtin_altivec_vcmpequb_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUB_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpgtsb."
block|,
literal|"__builtin_altivec_vcmpgtsb_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSB_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpgtub."
block|,
literal|"__builtin_altivec_vcmpgtub_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUB_P
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SPE predicates.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_spe_predicates
index|[]
init|=
block|{
comment|/* Place-holder.  Leave as first.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpeq
block|,
literal|"__builtin_spe_evcmpeq"
block|,
name|SPE_BUILTIN_EVCMPEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpgts
block|,
literal|"__builtin_spe_evcmpgts"
block|,
name|SPE_BUILTIN_EVCMPGTS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpgtu
block|,
literal|"__builtin_spe_evcmpgtu"
block|,
name|SPE_BUILTIN_EVCMPGTU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmplts
block|,
literal|"__builtin_spe_evcmplts"
block|,
name|SPE_BUILTIN_EVCMPLTS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpltu
block|,
literal|"__builtin_spe_evcmpltu"
block|,
name|SPE_BUILTIN_EVCMPLTU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmpeq
block|,
literal|"__builtin_spe_evfscmpeq"
block|,
name|SPE_BUILTIN_EVFSCMPEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmpgt
block|,
literal|"__builtin_spe_evfscmpgt"
block|,
name|SPE_BUILTIN_EVFSCMPGT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmplt
block|,
literal|"__builtin_spe_evfscmplt"
block|,
name|SPE_BUILTIN_EVFSCMPLT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststeq
block|,
literal|"__builtin_spe_evfststeq"
block|,
name|SPE_BUILTIN_EVFSTSTEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststgt
block|,
literal|"__builtin_spe_evfststgt"
block|,
name|SPE_BUILTIN_EVFSTSTGT
block|}
block|,
comment|/* Place-holder.  Leave as last.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststlt
block|,
literal|"__builtin_spe_evfststlt"
block|,
name|SPE_BUILTIN_EVFSTSTLT
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SPE evsel predicates.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_spe_evsel
index|[]
init|=
block|{
comment|/* Place-holder.  Leave as first.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpgts
block|,
literal|"__builtin_spe_evsel_gts"
block|,
name|SPE_BUILTIN_EVSEL_CMPGTS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpgtu
block|,
literal|"__builtin_spe_evsel_gtu"
block|,
name|SPE_BUILTIN_EVSEL_CMPGTU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmplts
block|,
literal|"__builtin_spe_evsel_lts"
block|,
name|SPE_BUILTIN_EVSEL_CMPLTS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpltu
block|,
literal|"__builtin_spe_evsel_ltu"
block|,
name|SPE_BUILTIN_EVSEL_CMPLTU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpeq
block|,
literal|"__builtin_spe_evsel_eq"
block|,
name|SPE_BUILTIN_EVSEL_CMPEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmpgt
block|,
literal|"__builtin_spe_evsel_fsgt"
block|,
name|SPE_BUILTIN_EVSEL_FSCMPGT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmplt
block|,
literal|"__builtin_spe_evsel_fslt"
block|,
name|SPE_BUILTIN_EVSEL_FSCMPLT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmpeq
block|,
literal|"__builtin_spe_evsel_fseq"
block|,
name|SPE_BUILTIN_EVSEL_FSCMPEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststgt
block|,
literal|"__builtin_spe_evsel_fststgt"
block|,
name|SPE_BUILTIN_EVSEL_FSTSTGT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststlt
block|,
literal|"__builtin_spe_evsel_fststlt"
block|,
name|SPE_BUILTIN_EVSEL_FSTSTLT
block|}
block|,
comment|/* Place-holder.  Leave as last.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststeq
block|,
literal|"__builtin_spe_evsel_fststeq"
block|,
name|SPE_BUILTIN_EVSEL_FSTSTEQ
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ABS* operations.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_abs
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv4si2
block|,
literal|"__builtin_altivec_abs_v4si"
block|,
name|ALTIVEC_BUILTIN_ABS_V4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv8hi2
block|,
literal|"__builtin_altivec_abs_v8hi"
block|,
name|ALTIVEC_BUILTIN_ABS_V8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv4sf2
block|,
literal|"__builtin_altivec_abs_v4sf"
block|,
name|ALTIVEC_BUILTIN_ABS_V4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv16qi2
block|,
literal|"__builtin_altivec_abs_v16qi"
block|,
name|ALTIVEC_BUILTIN_ABS_V16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v4si
block|,
literal|"__builtin_altivec_abss_v4si"
block|,
name|ALTIVEC_BUILTIN_ABSS_V4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v8hi
block|,
literal|"__builtin_altivec_abss_v8hi"
block|,
name|ALTIVEC_BUILTIN_ABSS_V8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v16qi
block|,
literal|"__builtin_altivec_abss_v16qi"
block|,
name|ALTIVEC_BUILTIN_ABSS_V16QI
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple unary operations: VECb = foo (unsigned literal) or VECb =    foo (VECa).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vexptefp
block|,
literal|"__builtin_altivec_vexptefp"
block|,
name|ALTIVEC_BUILTIN_VEXPTEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vlogefp
block|,
literal|"__builtin_altivec_vlogefp"
block|,
name|ALTIVEC_BUILTIN_VLOGEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrefp
block|,
literal|"__builtin_altivec_vrefp"
block|,
name|ALTIVEC_BUILTIN_VREFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfim
block|,
literal|"__builtin_altivec_vrfim"
block|,
name|ALTIVEC_BUILTIN_VRFIM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfin
block|,
literal|"__builtin_altivec_vrfin"
block|,
name|ALTIVEC_BUILTIN_VRFIN
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfip
block|,
literal|"__builtin_altivec_vrfip"
block|,
name|ALTIVEC_BUILTIN_VRFIP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_ftruncv4sf2
block|,
literal|"__builtin_altivec_vrfiz"
block|,
name|ALTIVEC_BUILTIN_VRFIZ
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrsqrtefp
block|,
literal|"__builtin_altivec_vrsqrtefp"
block|,
name|ALTIVEC_BUILTIN_VRSQRTEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltisb
block|,
literal|"__builtin_altivec_vspltisb"
block|,
name|ALTIVEC_BUILTIN_VSPLTISB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltish
block|,
literal|"__builtin_altivec_vspltish"
block|,
name|ALTIVEC_BUILTIN_VSPLTISH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltisw
block|,
literal|"__builtin_altivec_vspltisw"
block|,
name|ALTIVEC_BUILTIN_VSPLTISW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhsb
block|,
literal|"__builtin_altivec_vupkhsb"
block|,
name|ALTIVEC_BUILTIN_VUPKHSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhpx
block|,
literal|"__builtin_altivec_vupkhpx"
block|,
name|ALTIVEC_BUILTIN_VUPKHPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhsh
block|,
literal|"__builtin_altivec_vupkhsh"
block|,
name|ALTIVEC_BUILTIN_VUPKHSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklsb
block|,
literal|"__builtin_altivec_vupklsb"
block|,
name|ALTIVEC_BUILTIN_VUPKLSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklpx
block|,
literal|"__builtin_altivec_vupklpx"
block|,
name|ALTIVEC_BUILTIN_VUPKLPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklsh
block|,
literal|"__builtin_altivec_vupklsh"
block|,
name|ALTIVEC_BUILTIN_VUPKLSH
block|}
block|,
comment|/* The SPE unary builtins must start with SPE_BUILTIN_EVABS and      end with SPE_BUILTIN_EVSUBFUSIAAW.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evabs
block|,
literal|"__builtin_spe_evabs"
block|,
name|SPE_BUILTIN_EVABS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddsmiaaw
block|,
literal|"__builtin_spe_evaddsmiaaw"
block|,
name|SPE_BUILTIN_EVADDSMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddssiaaw
block|,
literal|"__builtin_spe_evaddssiaaw"
block|,
name|SPE_BUILTIN_EVADDSSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddumiaaw
block|,
literal|"__builtin_spe_evaddumiaaw"
block|,
name|SPE_BUILTIN_EVADDUMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddusiaaw
block|,
literal|"__builtin_spe_evaddusiaaw"
block|,
name|SPE_BUILTIN_EVADDUSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcntlsw
block|,
literal|"__builtin_spe_evcntlsw"
block|,
name|SPE_BUILTIN_EVCNTLSW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcntlzw
block|,
literal|"__builtin_spe_evcntlzw"
block|,
name|SPE_BUILTIN_EVCNTLZW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evextsb
block|,
literal|"__builtin_spe_evextsb"
block|,
name|SPE_BUILTIN_EVEXTSB
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evextsh
block|,
literal|"__builtin_spe_evextsh"
block|,
name|SPE_BUILTIN_EVEXTSH
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsabs
block|,
literal|"__builtin_spe_evfsabs"
block|,
name|SPE_BUILTIN_EVFSABS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscfsf
block|,
literal|"__builtin_spe_evfscfsf"
block|,
name|SPE_BUILTIN_EVFSCFSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscfsi
block|,
literal|"__builtin_spe_evfscfsi"
block|,
name|SPE_BUILTIN_EVFSCFSI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscfuf
block|,
literal|"__builtin_spe_evfscfuf"
block|,
name|SPE_BUILTIN_EVFSCFUF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscfui
block|,
literal|"__builtin_spe_evfscfui"
block|,
name|SPE_BUILTIN_EVFSCFUI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctsf
block|,
literal|"__builtin_spe_evfsctsf"
block|,
name|SPE_BUILTIN_EVFSCTSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctsi
block|,
literal|"__builtin_spe_evfsctsi"
block|,
name|SPE_BUILTIN_EVFSCTSI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctsiz
block|,
literal|"__builtin_spe_evfsctsiz"
block|,
name|SPE_BUILTIN_EVFSCTSIZ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctuf
block|,
literal|"__builtin_spe_evfsctuf"
block|,
name|SPE_BUILTIN_EVFSCTUF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctui
block|,
literal|"__builtin_spe_evfsctui"
block|,
name|SPE_BUILTIN_EVFSCTUI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctuiz
block|,
literal|"__builtin_spe_evfsctuiz"
block|,
name|SPE_BUILTIN_EVFSCTUIZ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsnabs
block|,
literal|"__builtin_spe_evfsnabs"
block|,
name|SPE_BUILTIN_EVFSNABS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsneg
block|,
literal|"__builtin_spe_evfsneg"
block|,
name|SPE_BUILTIN_EVFSNEG
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmra
block|,
literal|"__builtin_spe_evmra"
block|,
name|SPE_BUILTIN_EVMRA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_negv2si2
block|,
literal|"__builtin_spe_evneg"
block|,
name|SPE_BUILTIN_EVNEG
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evrndw
block|,
literal|"__builtin_spe_evrndw"
block|,
name|SPE_BUILTIN_EVRNDW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfsmiaaw
block|,
literal|"__builtin_spe_evsubfsmiaaw"
block|,
name|SPE_BUILTIN_EVSUBFSMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfssiaaw
block|,
literal|"__builtin_spe_evsubfssiaaw"
block|,
name|SPE_BUILTIN_EVSUBFSSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfumiaaw
block|,
literal|"__builtin_spe_evsubfumiaaw"
block|,
name|SPE_BUILTIN_EVSUBFUMIAAW
block|}
block|,
comment|/* Place-holder.  Leave as last unary SPE builtin.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfusiaaw
block|,
literal|"__builtin_spe_evsubfusiaaw"
block|,
name|SPE_BUILTIN_EVSUBFUSIAAW
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
name|rs6000_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
comment|/* Builtin not supported on this processor.  */
return|return
literal|0
return|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_altivec_vspltisb
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vspltish
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vspltisw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsplatfi
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsplati
condition|)
block|{
comment|/* Only allow 5-bit *signed* literals.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|>
literal|0x1f
operator|||
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|<
operator|-
literal|0x1f
condition|)
block|{
name|error
argument_list|(
literal|"argument 1 must be a 5-bit signed literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_abs_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch1
decl_stmt|,
name|scratch2
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
comment|/* If we have invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|scratch1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|scratch2
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|scratch1
argument_list|,
name|scratch2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|rs6000_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
comment|/* Builtin not supported on this processor.  */
return|return
literal|0
return|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_altivec_vcfux
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vcfsx
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vctsxs
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vctuxs
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vspltb
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vsplth
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vspltw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evaddiw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evldd
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evldh
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evldw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlhhesplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlhhossplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlhhousplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwhe
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwhos
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwhou
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwhsplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwwsplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evrlwi
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evslwi
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsrwis
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsubifw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsrwiu
condition|)
block|{
comment|/* Only allow 5-bit unsigned literals.  */
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|~
literal|0x1f
condition|)
block|{
name|error
argument_list|(
literal|"argument 2 must be a 5-bit unsigned literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_predicate_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
specifier|const
name|char
modifier|*
name|opcode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch
decl_stmt|;
name|tree
name|cr6_form
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|SImode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|int
name|cr6_form_int
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cr6_form
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"argument 1 of __builtin_altivec_predicate must be a constant"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
name|cr6_form_int
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|cr6_form
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode0
operator|!=
name|mode1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we have invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|scratch
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* The vec_any* and vec_all* predicates use the same opcodes for two      different operations, but the bits in CR6 will be different      depending on what information we want.  So we have to play tricks      with CR6 to get the right bits out.       If you think this is disgusting, look at the specs for the      AltiVec predicates.  */
switch|switch
condition|(
name|cr6_form_int
condition|)
block|{
case|case
literal|0
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_zero
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_zero_reverse
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_lt
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_lt_reverse
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"argument 1 of __builtin_altivec_predicate is out of range"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_lv_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|addr
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|Pmode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|Pmode
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
comment|/* Builtin not supported on this processor.  */
return|return
literal|0
return|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|tmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|tmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|spe_expand_stv_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
comment|/* Invalid arguments.  Bail before doing anything stoopid!  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode2
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode0
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode1
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_stv_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|addr
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|Pmode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|Pmode
decl_stmt|;
comment|/* Invalid arguments.  Bail before doing anything stoopid!  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|tmode
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|tmode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|tmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|addr
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|rs6000_expand_ternop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
comment|/* Builtin not supported on this processor.  */
return|return
literal|0
return|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_altivec_vsldoi_4sf
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vsldoi_4si
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vsldoi_8hi
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vsldoi_16qi
condition|)
block|{
comment|/* Only allow 4-bit unsigned literals.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
operator|&
operator|~
literal|0xf
condition|)
block|{
name|error
argument_list|(
literal|"argument 3 must be a 4-bit unsigned literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand the lvx builtins.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_ld_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op0
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_16qi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_16qi
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_8hi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_8hi
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_4si
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_4si
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_4sf
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_4sf
expr_stmt|;
break|break;
default|default:
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand the stvx builtins.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_st_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_16qi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_16qi
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_8hi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_8hi
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_4si
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_4si
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_4sf
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_4sf
expr_stmt|;
break|break;
default|default:
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand the dst builtins.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_dst_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
comment|/* Handle DST variants.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_dst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_dst
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
block|{
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
comment|/* Invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
operator|&
operator|~
literal|0x3
condition|)
block|{
name|error
argument_list|(
literal|"argument to `%s' must be a 2-bit unsigned literal"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand the builtin in EXP and store the result in TARGET.  Store    true in *EXPANDEDP if we found a builtin to expand.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|struct
name|builtin_description_predicates
modifier|*
name|dp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|target
operator|=
name|altivec_expand_ld_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|expandedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expandedp
condition|)
return|return
name|target
return|;
name|target
operator|=
name|altivec_expand_st_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|expandedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expandedp
condition|)
return|return
name|target
return|;
name|target
operator|=
name|altivec_expand_dst_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|expandedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expandedp
condition|)
return|return
name|target
return|;
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_STVX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEBX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvebx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEHX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvehx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEWX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvewx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVXL
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvxl
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_MFVSCR
case|:
name|icode
operator|=
name|CODE_FOR_altivec_mfvscr
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ALTIVEC_BUILTIN_MTVSCR
case|:
name|icode
operator|=
name|CODE_FOR_altivec_mtvscr
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_DSSALL
case|:
name|emit_insn
argument_list|(
name|gen_altivec_dssall
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_DSS
case|:
name|icode
operator|=
name|CODE_FOR_altivec_dss
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|&
operator|~
literal|0x3
condition|)
block|{
name|error
argument_list|(
literal|"argument to dss must be a 2-bit unsigned literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_altivec_dss
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_COMPILETIME_ERROR
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"invalid parameter combination for `%s' AltiVec intrinsic"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
comment|/* Expand abs* operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_abs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_abs
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_abs_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Expand the AltiVec predicates.  */
name|dp
operator|=
operator|(
expr|struct
name|builtin_description_predicates
operator|*
operator|)
name|bdesc_altivec_preds
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_altivec_preds
argument_list|)
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_predicate_builtin
argument_list|(
name|dp
operator|->
name|icode
argument_list|,
name|dp
operator|->
name|opcode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* LV* are funky.  We initialized them differently.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_LVSL
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvsl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVSR
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvsr
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEBX
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvebx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEHX
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvehx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEWX
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvewx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVXL
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvxl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVX
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
default|default:
break|break;
comment|/* Fall through.  */
block|}
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Binops that need to be initialized manually, but can be expanded    automagically by rs6000_expand_binop_builtin.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_2arg_spe
index|[]
init|=
block|{
block|{
literal|0
block|,
name|CODE_FOR_spe_evlddx
block|,
literal|"__builtin_spe_evlddx"
block|,
name|SPE_BUILTIN_EVLDDX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldwx
block|,
literal|"__builtin_spe_evldwx"
block|,
name|SPE_BUILTIN_EVLDWX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldhx
block|,
literal|"__builtin_spe_evldhx"
block|,
name|SPE_BUILTIN_EVLDHX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhex
block|,
literal|"__builtin_spe_evlwhex"
block|,
name|SPE_BUILTIN_EVLWHEX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhoux
block|,
literal|"__builtin_spe_evlwhoux"
block|,
name|SPE_BUILTIN_EVLWHOUX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhosx
block|,
literal|"__builtin_spe_evlwhosx"
block|,
name|SPE_BUILTIN_EVLWHOSX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwwsplatx
block|,
literal|"__builtin_spe_evlwwsplatx"
block|,
name|SPE_BUILTIN_EVLWWSPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhsplatx
block|,
literal|"__builtin_spe_evlwhsplatx"
block|,
name|SPE_BUILTIN_EVLWHSPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhesplatx
block|,
literal|"__builtin_spe_evlhhesplatx"
block|,
name|SPE_BUILTIN_EVLHHESPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhousplatx
block|,
literal|"__builtin_spe_evlhhousplatx"
block|,
name|SPE_BUILTIN_EVLHHOUSPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhossplatx
block|,
literal|"__builtin_spe_evlhhossplatx"
block|,
name|SPE_BUILTIN_EVLHHOSSPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldd
block|,
literal|"__builtin_spe_evldd"
block|,
name|SPE_BUILTIN_EVLDD
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldw
block|,
literal|"__builtin_spe_evldw"
block|,
name|SPE_BUILTIN_EVLDW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldh
block|,
literal|"__builtin_spe_evldh"
block|,
name|SPE_BUILTIN_EVLDH
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhe
block|,
literal|"__builtin_spe_evlwhe"
block|,
name|SPE_BUILTIN_EVLWHE
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhou
block|,
literal|"__builtin_spe_evlwhou"
block|,
name|SPE_BUILTIN_EVLWHOU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhos
block|,
literal|"__builtin_spe_evlwhos"
block|,
name|SPE_BUILTIN_EVLWHOS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwwsplat
block|,
literal|"__builtin_spe_evlwwsplat"
block|,
name|SPE_BUILTIN_EVLWWSPLAT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhsplat
block|,
literal|"__builtin_spe_evlwhsplat"
block|,
name|SPE_BUILTIN_EVLWHSPLAT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhesplat
block|,
literal|"__builtin_spe_evlhhesplat"
block|,
name|SPE_BUILTIN_EVLHHESPLAT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhousplat
block|,
literal|"__builtin_spe_evlhhousplat"
block|,
name|SPE_BUILTIN_EVLHHOUSPLAT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhossplat
block|,
literal|"__builtin_spe_evlhhossplat"
block|,
name|SPE_BUILTIN_EVLHHOSSPLAT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand the builtin in EXP and store the result in TARGET.  Store    true in *EXPANDEDP if we found a builtin to expand.     This expands the SPE builtins that are not simple unary and binary    operations.  */
end_comment

begin_function
specifier|static
name|rtx
name|spe_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg0
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op0
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
comment|/* Syntax check for a 5-bit unsigned immediate.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|SPE_BUILTIN_EVSTDD
case|:
case|case
name|SPE_BUILTIN_EVSTDH
case|:
case|case
name|SPE_BUILTIN_EVSTDW
case|:
case|case
name|SPE_BUILTIN_EVSTWHE
case|:
case|case
name|SPE_BUILTIN_EVSTWHO
case|:
case|case
name|SPE_BUILTIN_EVSTWWE
case|:
case|case
name|SPE_BUILTIN_EVSTWWO
case|:
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|~
literal|0x1f
condition|)
block|{
name|error
argument_list|(
literal|"argument 2 must be a 5-bit unsigned literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* The evsplat*i instructions are not quite generic.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|SPE_BUILTIN_EVSPLATFI
case|:
return|return
name|rs6000_expand_unop_builtin
argument_list|(
name|CODE_FOR_spe_evsplatfi
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSPLATI
case|:
return|return
name|rs6000_expand_unop_builtin
argument_list|(
name|CODE_FOR_spe_evsplati
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
default|default:
break|break;
block|}
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg_spe
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg_spe
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|d
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|rs6000_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_predicates
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_predicates
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|d
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|spe_expand_predicate_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_evsel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_evsel
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|d
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|spe_expand_evsel_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|SPE_BUILTIN_EVSTDDX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstddx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDHX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdhx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDWX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdwx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWHEX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwhex
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWHOX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwhox
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWWEX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwwex
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWWOX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwwox
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDD
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdd
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDH
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdh
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDW
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdw
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWHE
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwhe
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWHO
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwho
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWWE
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwwe
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWWO
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwwo
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_MFSPEFSCR
case|:
name|icode
operator|=
name|CODE_FOR_spe_mfspefscr
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|SPE_BUILTIN_MTSPEFSCR
case|:
name|icode
operator|=
name|CODE_FOR_spe_mtspefscr
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
default|default:
break|break;
block|}
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|spe_expand_predicate_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|form
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|int
name|form_int
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|form
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"argument 1 of __builtin_spe_predicate must be a constant"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
name|form_int
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode0
operator|!=
name|mode1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|SImode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|SImode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|CCmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|scratch
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|const0_rtx
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* There are 4 variants for each predicate: _any_, _all_, _upper_,      _lower_.  We use one compare, but look in different bits of the      CR for each variant.       There are 2 elements in each SPE simd type (upper/lower).  The CR      bits are set as follows:       BIT0  | BIT 1  | BIT 2   | BIT 3      U     |   L    | (U | L) | (U& L)       So, for an "all" relationship, BIT 3 would be set.      For an "any" relationship, BIT 2 would be set.  Etc.       Following traditional nomenclature, these bits map to:       BIT0  | BIT 1  | BIT 2   | BIT 3      LT    | GT     | EQ      | OV       Later, we will generate rtl to look in the LT/EQ/EQ/OV bits.   */
switch|switch
condition|(
name|form_int
condition|)
block|{
comment|/* All variant.  OV bit.  */
case|case
literal|0
case|:
comment|/* We need to get to the OV bit, which is the ORDERED bit.  We 	 could generate (ordered:SI (reg:CC xx) (const_int 0)), but 	 that's ugly and will trigger a validate_condition_mode abort. 	 So let's just use another pattern.  */
name|emit_insn
argument_list|(
name|gen_move_from_CR_ov_bit
argument_list|(
name|target
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
comment|/* Any variant.  EQ bit.  */
case|case
literal|1
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
comment|/* Upper variant.  LT bit.  */
case|case
literal|2
case|:
name|code
operator|=
name|LT
expr_stmt|;
break|break;
comment|/* Lower variant.  GT bit.  */
case|case
literal|3
case|:
name|code
operator|=
name|GT
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"argument 1 of __builtin_spe_predicate is out of range"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|SImode
argument_list|,
name|scratch
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* The evsel builtins look like this:       e = __builtin_spe_evsel_OP (a, b, c, d);     and work like this:       e[upper] = a[upper] *OP* b[upper] ? c[upper] : d[upper];      e[lower] = a[lower] *OP* b[lower] ? c[lower] : d[lower]; */
end_comment

begin_function
specifier|static
name|rtx
name|spe_expand_evsel_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg3
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op3
init|=
name|expand_expr
argument_list|(
name|arg3
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|mode0
operator|!=
name|mode1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
operator|||
name|arg3
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode0
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|mode0
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode1
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op3
operator|,
name|mode1
operator|)
condition|)
name|op3
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op3
argument_list|)
expr_stmt|;
comment|/* Generate the compare.  */
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|CCmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|scratch
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|const0_rtx
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode0
operator|==
name|V2SImode
condition|)
name|emit_insn
argument_list|(
name|gen_spe_evsel
argument_list|(
name|target
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_spe_evsel_fs
argument_list|(
name|target
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|bool
name|success
decl_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
block|{
name|ret
operator|=
name|altivec_expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|TARGET_SPE
condition|)
block|{
name|ret
operator|=
name|spe_expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|TARGET_ALTIVEC
operator|||
name|TARGET_SPE
condition|)
block|{
comment|/* Handle simple unary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_1arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|rs6000_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Handle simple binary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|rs6000_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Handle simple ternary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_3arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_3arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|rs6000_expand_ternop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|opaque_V2SI_type_node
operator|=
name|copy_node
argument_list|(
name|V2SI_type_node
argument_list|)
expr_stmt|;
name|opaque_V2SF_type_node
operator|=
name|copy_node
argument_list|(
name|V2SF_type_node
argument_list|)
expr_stmt|;
name|opaque_p_V2SI_type_node
operator|=
name|build_pointer_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|)
expr_stmt|;
comment|/* The 'vector bool ...' types must be kept distinct from 'vector unsigned ...'      types, especially in C++ land.  Similarly, 'vector pixel' is distinct from+     'vector unsigned short'.  */
name|bool_char_type_node
operator|=
name|copy_node
argument_list|(
name|unsigned_intQI_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|bool_char_type_node
argument_list|)
operator|=
name|bool_char_type_node
expr_stmt|;
name|bool_short_type_node
operator|=
name|copy_node
argument_list|(
name|unsigned_intHI_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|bool_short_type_node
argument_list|)
operator|=
name|bool_short_type_node
expr_stmt|;
name|bool_int_type_node
operator|=
name|copy_node
argument_list|(
name|unsigned_intSI_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|bool_int_type_node
argument_list|)
operator|=
name|bool_int_type_node
expr_stmt|;
name|pixel_type_node
operator|=
name|copy_node
argument_list|(
name|unsigned_intHI_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|pixel_type_node
argument_list|)
operator|=
name|pixel_type_node
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__bool char"
argument_list|)
argument_list|,
name|bool_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__bool short"
argument_list|)
argument_list|,
name|bool_short_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__bool int"
argument_list|)
argument_list|,
name|bool_int_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__pixel"
argument_list|)
argument_list|,
name|pixel_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|bool_V16QI_type_node
operator|=
name|make_vector
argument_list|(
name|V16QImode
argument_list|,
name|bool_char_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bool_V8HI_type_node
operator|=
name|make_vector
argument_list|(
name|V8HImode
argument_list|,
name|bool_short_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bool_V4SI_type_node
operator|=
name|make_vector
argument_list|(
name|V4SImode
argument_list|,
name|bool_int_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pixel_V8HI_type_node
operator|=
name|make_vector
argument_list|(
name|V8HImode
argument_list|,
name|pixel_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector unsigned char"
argument_list|)
argument_list|,
name|unsigned_V16QI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector signed char"
argument_list|)
argument_list|,
name|V16QI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector __bool char"
argument_list|)
argument_list|,
name|bool_V16QI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector unsigned short"
argument_list|)
argument_list|,
name|unsigned_V8HI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector signed short"
argument_list|)
argument_list|,
name|V8HI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector __bool short"
argument_list|)
argument_list|,
name|bool_V8HI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector unsigned int"
argument_list|)
argument_list|,
name|unsigned_V4SI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector signed int"
argument_list|)
argument_list|,
name|V4SI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector __bool int"
argument_list|)
argument_list|,
name|bool_V4SI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector float"
argument_list|)
argument_list|,
name|V4SF_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector __pixel"
argument_list|)
argument_list|,
name|pixel_V8HI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE
condition|)
name|spe_init_builtins
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
name|altivec_init_builtins
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
operator|||
name|TARGET_SPE
condition|)
name|rs6000_common_init_builtins
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search through a set of builtins and enable the mask bits.    DESC is an array of builtins.    SIZE is the total number of builtins.    START is the builtin enum at which to start.    END is the builtin enum at which to end.  */
end_comment

begin_function
specifier|static
name|void
name|enable_mask_for_builtins
parameter_list|(
name|struct
name|builtin_description
modifier|*
name|desc
parameter_list|,
name|int
name|size
parameter_list|,
name|enum
name|rs6000_builtins
name|start
parameter_list|,
name|enum
name|rs6000_builtins
name|end
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|desc
index|[
name|i
index|]
operator|.
name|code
operator|==
name|start
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|size
condition|)
return|return;
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
comment|/* Flip all the bits on.  */
name|desc
index|[
name|i
index|]
operator|.
name|mask
operator|=
name|target_flags
expr_stmt|;
if|if
condition|(
name|desc
index|[
name|i
index|]
operator|.
name|code
operator|==
name|end
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|spe_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
name|tree
name|puint_type_node
init|=
name|build_pointer_type
argument_list|(
name|unsigned_type_node
argument_list|)
decl_stmt|;
name|tree
name|pushort_type_node
init|=
name|build_pointer_type
argument_list|(
name|short_unsigned_type_node
argument_list|)
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|v2si_ftype_4_v2si
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_4_v2sf
init|=
name|build_function_type
argument_list|(
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v2si_v2si
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v2sf_v2sf
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v2si_puint_int
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|puint_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v2si_puint_char
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|puint_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v2si_pv2si_int
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_p_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v2si_pv2si_char
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_p_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_int
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_void
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_pv2si_int
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_p_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_puint_int
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|puint_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_pushort_int
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pushort_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_signed_char
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|signed_char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The initialization of the simple binary and unary builtins is      done in rs6000_common_init_builtins, but we have to enable the      mask bits here manually because we have run out of `target_flags'      bits.  We really need to redesign this mask business.  */
name|enable_mask_for_builtins
argument_list|(
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
argument_list|,
name|SPE_BUILTIN_EVADDW
argument_list|,
name|SPE_BUILTIN_EVXOR
argument_list|)
expr_stmt|;
name|enable_mask_for_builtins
argument_list|(
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_1arg
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
argument_list|,
name|SPE_BUILTIN_EVABS
argument_list|,
name|SPE_BUILTIN_EVSUBFUSIAAW
argument_list|)
expr_stmt|;
name|enable_mask_for_builtins
argument_list|(
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_predicates
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_predicates
argument_list|)
argument_list|,
name|SPE_BUILTIN_EVCMPEQ
argument_list|,
name|SPE_BUILTIN_EVFSTSTLT
argument_list|)
expr_stmt|;
name|enable_mask_for_builtins
argument_list|(
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_evsel
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_evsel
argument_list|)
argument_list|,
name|SPE_BUILTIN_EVSEL_CMPGTS
argument_list|,
name|SPE_BUILTIN_EVSEL_FSTSTEQ
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__ev64_opaque__"
argument_list|)
argument_list|,
name|opaque_V2SI_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize irregular SPE builtins.  */
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_mtspefscr"
argument_list|,
name|void_ftype_int
argument_list|,
name|SPE_BUILTIN_MTSPEFSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_mfspefscr"
argument_list|,
name|int_ftype_void
argument_list|,
name|SPE_BUILTIN_MFSPEFSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstddx"
argument_list|,
name|void_ftype_v2si_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVSTDDX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdhx"
argument_list|,
name|void_ftype_v2si_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVSTDHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdwx"
argument_list|,
name|void_ftype_v2si_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVSTDWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwhex"
argument_list|,
name|void_ftype_v2si_puint_int
argument_list|,
name|SPE_BUILTIN_EVSTWHEX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwhox"
argument_list|,
name|void_ftype_v2si_puint_int
argument_list|,
name|SPE_BUILTIN_EVSTWHOX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwwex"
argument_list|,
name|void_ftype_v2si_puint_int
argument_list|,
name|SPE_BUILTIN_EVSTWWEX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwwox"
argument_list|,
name|void_ftype_v2si_puint_int
argument_list|,
name|SPE_BUILTIN_EVSTWWOX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdd"
argument_list|,
name|void_ftype_v2si_pv2si_char
argument_list|,
name|SPE_BUILTIN_EVSTDD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdh"
argument_list|,
name|void_ftype_v2si_pv2si_char
argument_list|,
name|SPE_BUILTIN_EVSTDH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdw"
argument_list|,
name|void_ftype_v2si_pv2si_char
argument_list|,
name|SPE_BUILTIN_EVSTDW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwhe"
argument_list|,
name|void_ftype_v2si_puint_char
argument_list|,
name|SPE_BUILTIN_EVSTWHE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwho"
argument_list|,
name|void_ftype_v2si_puint_char
argument_list|,
name|SPE_BUILTIN_EVSTWHO
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwwe"
argument_list|,
name|void_ftype_v2si_puint_char
argument_list|,
name|SPE_BUILTIN_EVSTWWE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwwo"
argument_list|,
name|void_ftype_v2si_puint_char
argument_list|,
name|SPE_BUILTIN_EVSTWWO
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evsplatfi"
argument_list|,
name|v2si_ftype_signed_char
argument_list|,
name|SPE_BUILTIN_EVSPLATFI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evsplati"
argument_list|,
name|v2si_ftype_signed_char
argument_list|,
name|SPE_BUILTIN_EVSPLATI
argument_list|)
expr_stmt|;
comment|/* Loads.  */
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlddx"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDDX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldwx"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldhx"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhex"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHEX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhoux"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHOUX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhosx"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHOSX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwwsplatx"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWWSPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhsplatx"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHSPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhesplatx"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHESPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhousplatx"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHOUSPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhossplatx"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHOSSPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldd"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldw"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldh"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhesplat"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHESPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhossplat"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHOSSPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhousplat"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHOUSPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhe"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhos"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHOS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhou"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHOU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhsplat"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHSPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwwsplat"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWWSPLAT
argument_list|)
expr_stmt|;
comment|/* Predicates.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_predicates
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_predicates
argument_list|)
condition|;
operator|++
name|i
operator|,
name|d
operator|++
control|)
block|{
name|tree
name|type
decl_stmt|;
switch|switch
condition|(
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
condition|)
block|{
case|case
name|V2SImode
case|:
name|type
operator|=
name|int_ftype_int_v2si_v2si
expr_stmt|;
break|break;
case|case
name|V2SFmode
case|:
name|type
operator|=
name|int_ftype_int_v2sf_v2sf
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Evsel predicates.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_evsel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_evsel
argument_list|)
condition|;
operator|++
name|i
operator|,
name|d
operator|++
control|)
block|{
name|tree
name|type
decl_stmt|;
switch|switch
condition|(
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
condition|)
block|{
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_4_v2si
expr_stmt|;
break|break;
case|case
name|V2SFmode
case|:
name|type
operator|=
name|v2sf_ftype_4_v2sf
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|altivec_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|struct
name|builtin_description_predicates
modifier|*
name|dp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|pfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|float_type_node
argument_list|)
decl_stmt|;
name|tree
name|pint_type_node
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pshort_type_node
init|=
name|build_pointer_type
argument_list|(
name|short_integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|tree
name|pvoid_type_node
init|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|float_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pcint_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pcshort_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|short_integer_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pcchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pcvoid_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_pcfloat
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|pcfloat_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pfloat_v4sf
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pfloat_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_pcint
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|pcint_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pint_v4si
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pint_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_pcshort
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|pcshort_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pshort_v8hi
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pshort_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_pcchar
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|pcchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pchar_v16qi
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pchar_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v4si
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_void
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_int
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_long_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_long_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_long_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v4si_long_pvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v16qi_long_pvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v8hi_long_pvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pcvoid_int_int
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_pcchar
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|pcchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_4sf"
argument_list|,
name|v4sf_ftype_pcfloat
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_4sf
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_4sf"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_4sf
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_4si"
argument_list|,
name|v4si_ftype_pcint
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_4si
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_4si"
argument_list|,
name|void_ftype_pint_v4si
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_4si
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_8hi"
argument_list|,
name|v8hi_ftype_pcshort
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_8hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_8hi"
argument_list|,
name|void_ftype_pshort_v8hi
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_8hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_16qi"
argument_list|,
name|v16qi_ftype_pcchar
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_16qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_16qi"
argument_list|,
name|void_ftype_pchar_v16qi
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_16qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_mtvscr"
argument_list|,
name|void_ftype_v4si
argument_list|,
name|ALTIVEC_BUILTIN_MTVSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_mfvscr"
argument_list|,
name|v8hi_ftype_void
argument_list|,
name|ALTIVEC_BUILTIN_MFVSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_dssall"
argument_list|,
name|void_ftype_void
argument_list|,
name|ALTIVEC_BUILTIN_DSSALL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_dss"
argument_list|,
name|void_ftype_int
argument_list|,
name|ALTIVEC_BUILTIN_DSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvsl"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVSL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvsr"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvebx"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEBX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvehx"
argument_list|,
name|v8hi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvewx"
argument_list|,
name|v4si_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvxl"
argument_list|,
name|v4si_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVXL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvx"
argument_list|,
name|v4si_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvx"
argument_list|,
name|void_ftype_v4si_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvewx"
argument_list|,
name|void_ftype_v4si_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvxl"
argument_list|,
name|void_ftype_v4si_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVXL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvebx"
argument_list|,
name|void_ftype_v16qi_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEBX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvehx"
argument_list|,
name|void_ftype_v8hi_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEHX
argument_list|)
expr_stmt|;
comment|/* See altivec.h for usage of "__builtin_altivec_compiletime_error".  */
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_compiletime_error"
argument_list|,
name|int_ftype_pcchar
argument_list|,
name|ALTIVEC_BUILTIN_COMPILETIME_ERROR
argument_list|)
expr_stmt|;
comment|/* Add the DST variants.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_dst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_dst
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|void_ftype_pcvoid_int_int
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
comment|/* Initialize the predicates.  */
name|dp
operator|=
operator|(
expr|struct
name|builtin_description_predicates
operator|*
operator|)
name|bdesc_altivec_preds
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_altivec_preds
argument_list|)
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|dp
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode1
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|int_ftype_int_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|int_ftype_int_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|int_ftype_int_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|int_ftype_int_v4sf_v4sf
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|dp
operator|->
name|mask
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|dp
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the abs* operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_abs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_abs
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_common_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_int
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_v2si
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf_v2sf
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SF_type_node
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_int_int
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SF_type_node
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SF_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2sf
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_char
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_int_char
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_char
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_int
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4si_int
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_int
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi_int
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_int
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v8hi_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v16qi_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Add the simple ternary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_3arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_3arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|,
name|mode3
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode3
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
comment|/* When all four are of the same mode.  */
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
operator|&&
name|mode2
operator|==
name|mode3
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_v16qi
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
operator|&&
name|mode3
operator|==
name|V16QImode
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_v16qi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_v16qi
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v16qi_v4si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v8hi_v4si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|V4SFmode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v4si
expr_stmt|;
comment|/* vchar, vchar, vchar, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_int
expr_stmt|;
comment|/* vshort, vshort, vshort, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_int
expr_stmt|;
comment|/* vint, vint, vint, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4si_v4si_int
expr_stmt|;
comment|/* vfloat, vfloat, vfloat, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_int
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the simple binary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
comment|/* When all three operands are of the same mode.  */
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_v2si_v2si
expr_stmt|;
break|break;
case|case
name|V2SFmode
case|:
name|type
operator|=
name|v2sf_ftype_v2sf_v2sf
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|type
operator|=
name|int_ftype_int_int
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* A few other combos we really don't want to do manually.  */
comment|/* vint, vfloat, vfloat.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|V4SFmode
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_v4sf
expr_stmt|;
comment|/* vshort, vchar, vchar.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v16qi_v16qi
expr_stmt|;
comment|/* vint, vshort, vshort.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v8hi
expr_stmt|;
comment|/* vshort, vint, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v8hi_ftype_v4si_v4si
expr_stmt|;
comment|/* vchar, vshort, vshort.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v16qi_ftype_v8hi_v8hi
expr_stmt|;
comment|/* vint, vchar, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v4si
expr_stmt|;
comment|/* vint, vchar, vchar.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v16qi
expr_stmt|;
comment|/* vint, vshort, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v4si
expr_stmt|;
comment|/* vint, vint, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4si_int
expr_stmt|;
comment|/* vshort, vshort, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v8hi_int
expr_stmt|;
comment|/* vchar, vchar, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_v16qi_int
expr_stmt|;
comment|/* vfloat, vint, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4si_int
expr_stmt|;
comment|/* vint, vfloat, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|SImode
operator|&&
name|mode2
operator|==
name|SImode
condition|)
name|type
operator|=
name|v2si_ftype_int_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|V2SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v2si_ftype_v2si_char
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v2si_ftype_int_char
expr_stmt|;
comment|/* int, x, x.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|SImode
condition|)
block|{
switch|switch
condition|(
name|mode1
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|int_ftype_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|int_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|int_ftype_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|int_ftype_v8hi_v8hi
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the simple unary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_1arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SFmode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v16qi
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|V2SImode
condition|)
name|type
operator|=
name|v2si_ftype_v2si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SFmode
operator|&&
name|mode1
operator|==
name|V2SFmode
condition|)
name|type
operator|=
name|v2sf_ftype_v2sf
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SFmode
operator|&&
name|mode1
operator|==
name|V2SImode
condition|)
name|type
operator|=
name|v2sf_ftype_v2si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|V2SFmode
condition|)
name|type
operator|=
name|v2si_ftype_v2sf
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v2si_ftype_char
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_HARD_FLOAT
condition|)
return|return;
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|TARGET_XCOFF
operator|&&
operator|!
name|TARGET_POWER2
operator|&&
operator|!
name|TARGET_POWERPC
condition|)
block|{
comment|/* AIX library routines for float->int conversion.  */
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|DFmode
argument_list|,
literal|"__itrunc"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|DFmode
argument_list|,
literal|"__uitrunc"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_qitrunc"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_quitrunc"
argument_list|)
expr_stmt|;
block|}
comment|/* AIX/Darwin/64-bit Linux quad floating point routines.  */
if|if
condition|(
operator|!
name|TARGET_XL_COMPAT
condition|)
block|{
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qadd"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qsub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qmul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qdiv"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_xlqadd"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_xlqsub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_xlqmul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_xlqdiv"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 32-bit SVR4 quad floating point routines.  */
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_add"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_sub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|neg_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_neg"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_mul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_div"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_PPC_GPOPT
operator|||
name|TARGET_POWER2
condition|)
name|set_optab_libfunc
argument_list|(
name|sqrt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_sqrt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_feq"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_fne"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_fgt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_fge"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_flt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_fle"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|SFmode
argument_list|,
literal|"_q_stoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|DFmode
argument_list|,
literal|"_q_dtoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|SFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_q_qtos"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|DFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_q_qtod"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_q_qtoi"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_q_qtou"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"_q_itoq"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a block move operation, and return 1 if successful.  Return 0    if we should let the compiler generate normal code.     operands[0] is the destination    operands[1] is the source    operands[2] is the length    operands[3] is the alignment */
end_comment

begin_define
define|#
directive|define
name|MAX_MOVE_REG
value|4
end_define

begin_function
name|int
name|expand_block_move
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|orig_dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|orig_src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|constp
init|=
operator|(
name|GET_CODE
argument_list|(
name|bytes_rtx
argument_list|)
operator|==
name|CONST_INT
operator|)
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|move_bytes
decl_stmt|;
name|rtx
name|stores
index|[
name|MAX_MOVE_REG
index|]
decl_stmt|;
name|int
name|num_reg
init|=
literal|0
decl_stmt|;
comment|/* If this is not a fixed size move, just call memcpy */
if|if
condition|(
operator|!
name|constp
condition|)
return|return
literal|0
return|;
comment|/* If this is not a fixed size alignment, abort */
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
expr_stmt|;
comment|/* Anything to move? */
name|bytes
operator|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* store_one_arg depends on expand_block_move to handle at least the size of      reg_parm_stack_space.  */
if|if
condition|(
name|bytes
operator|>
operator|(
name|TARGET_POWERPC64
condition|?
literal|64
else|:
literal|32
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|bytes
operator|>
literal|0
condition|;
name|offset
operator|+=
name|move_bytes
operator|,
name|bytes
operator|-=
name|move_bytes
control|)
block|{
union|union
block|{
name|rtx
function_decl|(
modifier|*
name|movstrsi
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|mov
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
block|}
name|gen_func
union|;
name|enum
name|machine_mode
name|mode
init|=
name|BLKmode
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|24
comment|/* move up to 32 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|9
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|10
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|11
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|12
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|32
operator|)
condition|?
literal|32
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movstrsi
operator|=
name|gen_movstrsi_8reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|16
comment|/* move up to 24 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|9
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|10
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|24
operator|)
condition|?
literal|24
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movstrsi
operator|=
name|gen_movstrsi_6reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|8
comment|/* move up to 16 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|16
operator|)
condition|?
literal|16
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movstrsi
operator|=
name|gen_movstrsi_4reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|8
operator|&&
name|TARGET_POWERPC64
comment|/* 64-bit loads and stores require word-aligned 		  displacements.  */
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|)
condition|)
block|{
name|move_bytes
operator|=
literal|8
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movdi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|4
operator|&&
operator|!
name|TARGET_POWERPC64
condition|)
block|{
comment|/* move up to 8 bytes at a time */
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|8
operator|)
condition|?
literal|8
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movstrsi
operator|=
name|gen_movstrsi_2reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|4
operator|&&
operator|(
name|align
operator|>=
literal|4
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
comment|/* move 4 bytes */
name|move_bytes
operator|=
literal|4
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movsi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|==
literal|2
operator|&&
operator|(
name|align
operator|>=
literal|2
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
comment|/* move 2 bytes */
name|move_bytes
operator|=
literal|2
expr_stmt|;
name|mode
operator|=
name|HImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movhi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|1
condition|)
block|{
comment|/* move up to 4 bytes at a time */
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|4
operator|)
condition|?
literal|4
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movstrsi
operator|=
name|gen_movstrsi_1reg
expr_stmt|;
block|}
else|else
comment|/* move 1 byte at a time */
block|{
name|move_bytes
operator|=
literal|1
expr_stmt|;
name|mode
operator|=
name|QImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movqi
expr_stmt|;
block|}
name|src
operator|=
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dest
operator|=
name|adjust_address
argument_list|(
name|orig_dest
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|rtx
name|tmp_reg
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_func
operator|.
name|mov
call|)
argument_list|(
name|tmp_reg
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|stores
index|[
name|num_reg
operator|++
index|]
operator|=
call|(
modifier|*
name|gen_func
operator|.
name|mov
call|)
argument_list|(
name|dest
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
name|num_reg
operator|>=
name|MAX_MOVE_REG
operator|||
name|bytes
operator|==
name|move_bytes
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_reg
condition|;
name|i
operator|++
control|)
name|emit_insn
argument_list|(
name|stores
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|num_reg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* Move the address into scratch registers.  The movstrsi 	     patterns require zero offset.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src_reg
init|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|src
operator|=
name|replace_equiv_address
argument_list|(
name|src
argument_list|,
name|src_reg
argument_list|)
expr_stmt|;
block|}
name|set_mem_size
argument_list|(
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|dest_reg
init|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|dest
operator|=
name|replace_equiv_address
argument_list|(
name|dest
argument_list|,
name|dest_reg
argument_list|)
expr_stmt|;
block|}
name|set_mem_size
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_func
operator|.
name|movstrsi
call|)
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
operator|&
literal|31
argument_list|)
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a load multiple operation.  It is known to be a    PARALLEL and the first section will be tested.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similar, but tests for store multiple.  Here, the second vector element    is a CLOBBER.  It will be tested later.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a string to perform a load_multiple operation.    operands[0] is the vector.    operands[1] is the source address.    operands[2] is the first destination register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|rs6000_output_load_multiple
parameter_list|(
name|rtx
name|operands
index|[
literal|3
index|]
parameter_list|)
block|{
comment|/* We have to handle the case where the pseudo used to contain the address      is assigned to one of the output registers.  */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|words
init|=
name|XVECLEN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|"{l|lwz} %2,0(%1)"
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
name|i
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|words
operator|-
literal|1
condition|)
block|{
name|xop
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
literal|4
operator|*
operator|(
name|words
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xop
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xop
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"{lsi|lswi} %2,%1,%0\n\t{l|lwz} %1,%0(%1)"
argument_list|,
name|xop
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xop
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
literal|4
operator|*
operator|(
name|words
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xop
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xop
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"{cal %1,4(%1)|addi %1,%1,4}\n\t{lsi|lswi} %2,%1,%0\n\t{l|lwz} %1,-4(%1)"
argument_list|,
name|xop
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|words
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
name|i
condition|)
block|{
name|xop
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|j
operator|*
literal|4
argument_list|)
expr_stmt|;
name|xop
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xop
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
name|j
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"{l|lwz} %2,%0(%1)"
argument_list|,
name|xop
argument_list|)
expr_stmt|;
block|}
name|xop
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|xop
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"{l|lwz} %1,%0(%1)"
argument_list|,
name|xop
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
return|return
literal|"{lsi|lswi} %2,%1,%N0"
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for a parallel vrsave operation.  */
end_comment

begin_function
name|int
name|vrsave_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|,
name|src_regno
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNSPEC_VOLATILE
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|!=
name|VRSAVE_REGNO
operator|&&
name|src_regno
operator|!=
name|VRSAVE_REGNO
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an PARALLEL suitable for mfcr.  */
end_comment

begin_function
name|int
name|mfcr_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XVECLEN
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|exp
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|unspec
decl_stmt|;
name|int
name|maskval
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|src_reg
operator|=
name|XVECEXP
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_reg
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|src_reg
argument_list|)
operator|!=
name|CCmode
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|src_reg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
operator|!
name|INT_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|unspec
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|maskval
operator|=
literal|1
operator|<<
operator|(
name|MAX_CR_REGNO
operator|-
name|REGNO
argument_list|(
name|src_reg
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|unspec
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|unspec
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_MOVESI_FROM_CR
operator|||
name|XVECLEN
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
operator|||
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|src_reg
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|maskval
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an PARALLEL suitable for mtcrf.  */
end_comment

begin_function
name|int
name|mtcrf_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XVECLEN
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
return|return
literal|0
return|;
name|src_reg
operator|=
name|XVECEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_reg
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|src_reg
argument_list|)
operator|!=
name|SImode
operator|||
operator|!
name|INT_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|src_reg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|exp
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|unspec
decl_stmt|;
name|int
name|maskval
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
name|CCmode
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|unspec
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|maskval
operator|=
literal|1
operator|<<
operator|(
name|MAX_CR_REGNO
operator|-
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|unspec
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|unspec
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_MOVESI_TO_CR
operator|||
name|XVECLEN
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
operator|||
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|src_reg
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|maskval
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an PARALLEL suitable for lmw.  */
end_comment

begin_function
name|int
name|lmw_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|unsigned
name|int
name|base_regno
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|>
literal|31
operator|||
name|count
operator|!=
literal|32
operator|-
operator|(
name|int
operator|)
name|dest_regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|legitimate_indirect_address_p
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|src_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_regno
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|legitimate_offset_address_p
argument_list|(
name|SImode
argument_list|,
name|src_addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|newaddr
decl_stmt|;
name|rtx
name|addr_reg
decl_stmt|;
name|HOST_WIDE_INT
name|newoffset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
condition|)
return|return
literal|0
return|;
name|newaddr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_indirect_address_p
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|newoffset
operator|=
literal|0
expr_stmt|;
name|addr_reg
operator|=
name|newaddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|legitimate_offset_address_p
argument_list|(
name|SImode
argument_list|,
name|newaddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|addr_reg
operator|=
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newoffset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|addr_reg
argument_list|)
operator|!=
name|base_regno
operator|||
name|newoffset
operator|!=
name|offset
operator|+
literal|4
operator|*
name|i
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an PARALLEL suitable for stmw.  */
end_comment

begin_function
name|int
name|stmw_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|unsigned
name|int
name|base_regno
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_regno
operator|>
literal|31
operator|||
name|count
operator|!=
literal|32
operator|-
operator|(
name|int
operator|)
name|src_regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|legitimate_indirect_address_p
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|dest_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_regno
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|legitimate_offset_address_p
argument_list|(
name|SImode
argument_list|,
name|dest_addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base_regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|newaddr
decl_stmt|;
name|rtx
name|addr_reg
decl_stmt|;
name|HOST_WIDE_INT
name|newoffset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
condition|)
return|return
literal|0
return|;
name|newaddr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_indirect_address_p
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|newoffset
operator|=
literal|0
expr_stmt|;
name|addr_reg
operator|=
name|newaddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|legitimate_offset_address_p
argument_list|(
name|SImode
argument_list|,
name|newaddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|addr_reg
operator|=
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newoffset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|addr_reg
argument_list|)
operator|!=
name|base_regno
operator|||
name|newoffset
operator|!=
name|offset
operator|+
literal|4
operator|*
name|i
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A validation routine: say whether CODE, a condition code, and MODE    match.  The other alternatives either don't make sense or should    never be generated.  */
end_comment

begin_function
specifier|static
name|void
name|validate_condition_mode
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* These don't make sense.  */
if|if
condition|(
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LE
operator|)
operator|&&
name|mode
operator|==
name|CCUNSmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|)
operator|&&
name|mode
operator|!=
name|CCUNSmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|CCFPmode
operator|&&
operator|(
name|code
operator|==
name|ORDERED
operator|||
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNLT
operator|||
name|code
operator|==
name|UNGE
operator|||
name|code
operator|==
name|UNLE
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* These should never be generated except for       flag_finite_math_only.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|&&
operator|!
name|flag_finite_math_only
operator|&&
operator|(
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNLT
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* These are invalid; the information is not there.  */
if|if
condition|(
name|mode
operator|==
name|CCEQmode
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|NE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operation that is valid for a branch insn.    We only check the opcode against the mode of the CC value here.  */
end_comment

begin_function
name|int
name|branch_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|cc_mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
literal|0
return|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|cc_mode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operation that is valid for a branch    insn and which is true if the corresponding bit in the CC register    is set.  */
end_comment

begin_function
name|int
name|branch_positive_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|branch_comparison_operator
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|UNORDERED
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operation that is valid for an scc    insn: it must be a positive comparison.  */
end_comment

begin_function
name|int
name|scc_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|branch_positive_comparison_operator
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|trap_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'<'
return|;
block|}
end_function

begin_function
name|int
name|boolean_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|)
return|;
block|}
end_function

begin_function
name|int
name|boolean_or_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|)
return|;
block|}
end_function

begin_function
name|int
name|min_max_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|SMIN
operator|||
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|UMIN
operator|||
name|code
operator|==
name|UMAX
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if ANDOP is a mask that has no bits on that are not in the    mask required to convert the result of a rotate insn into a shift    left insn of SHIFTOP bits.  Both are known to be SImode CONST_INT.  */
end_comment

begin_function
name|int
name|includes_lshift_p
parameter_list|(
name|rtx
name|shiftop
parameter_list|,
name|rtx
name|andop
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
decl_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTVAL
argument_list|(
name|andop
argument_list|)
operator|&
literal|0xffffffff
operator|&
operator|~
name|shift_mask
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar, but for right shift.  */
end_comment

begin_function
name|int
name|includes_rshift_p
parameter_list|(
name|rtx
name|shiftop
parameter_list|,
name|rtx
name|andop
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
decl_stmt|;
name|shift_mask
operator|>>=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTVAL
argument_list|(
name|andop
argument_list|)
operator|&
literal|0xffffffff
operator|&
operator|~
name|shift_mask
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ANDOP is a mask suitable for use with an rldic insn    to perform a left shift.  It must have exactly SHIFTOP least    significant 0's, then one or more 1's, then zero or more 0's.  */
end_comment

begin_function
name|int
name|includes_rldic_lshift_p
parameter_list|(
name|rtx
name|shiftop
parameter_list|,
name|rtx
name|andop
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask
decl_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
operator|~
literal|0
condition|)
return|return
literal|0
return|;
name|shift_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
comment|/* Find the least significant one bit.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* It must coincide with the LSB of the shift mask.  */
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask
condition|)
return|return
literal|0
return|;
comment|/* Invert to look for the next transition (if any).  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Remove the low group of ones (originally low group of zeros).  */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/* Again find the lsb, and check we have all 1's above.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|DImode
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|,
name|lsb
decl_stmt|;
name|HOST_WIDE_INT
name|shift_mask_low
decl_stmt|,
name|shift_mask_high
decl_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|low
operator|==
operator|~
literal|0
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
operator|~
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|&&
name|low
operator|==
literal|0
condition|)
block|{
name|shift_mask_high
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|>
literal|32
condition|)
name|shift_mask_high
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|-
literal|32
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask_high
operator|||
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
name|high
operator|=
operator|~
name|high
expr_stmt|;
name|high
operator|&=
operator|-
name|lsb
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
name|shift_mask_low
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask_low
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask_low
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
name|high
operator|=
operator|~
name|high
expr_stmt|;
name|low
operator|=
operator|~
name|low
expr_stmt|;
name|low
operator|&=
operator|-
name|lsb
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|&&
name|low
operator|==
literal|0
condition|)
block|{
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
return|return
name|low
operator|==
operator|-
name|lsb
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
operator|~
literal|0
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ANDOP is a mask suitable for use with an rldicr insn    to perform a left shift.  It must have SHIFTOP or more least    significant 0's, with the remainder of the word 1's.  */
end_comment

begin_function
name|int
name|includes_rldicr_lshift_p
parameter_list|(
name|rtx
name|shiftop
parameter_list|,
name|rtx
name|andop
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask
decl_stmt|;
name|shift_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|andop
argument_list|)
expr_stmt|;
comment|/* Find the least significant one bit.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* It must be covered by the shift mask. 	 This test also rejects c == 0.  */
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check we have all 1's above the transition, and reject all 1's.  */
return|return
name|c
operator|==
operator|-
name|lsb
operator|&&
name|lsb
operator|!=
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|DImode
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask_low
decl_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
block|{
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|shift_mask_high
decl_stmt|;
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
block|{
name|shift_mask_high
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|>
literal|32
condition|)
name|shift_mask_high
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|-
literal|32
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask_high
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
if|if
condition|(
name|high
operator|!=
operator|~
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|shift_mask_low
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask_low
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask_low
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|low
operator|==
operator|-
name|lsb
operator|&&
name|lsb
operator|!=
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if REGNO (reg1) == REGNO (reg2) - 1 making them candidates    for lfq and stfq insns.     Note reg1 and reg2 *must* be hard registers.  To be sure we will    abort if we are passed pseudo registers.  */
end_comment

begin_function
name|int
name|registers_ok_for_quad_peep
parameter_list|(
name|rtx
name|reg1
parameter_list|,
name|rtx
name|reg2
parameter_list|)
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg2
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if addr1 and addr2 are suitable for lfq or stfq insn.    addr1 and addr2 must be in consecutive memory locations    (addr2 == addr1 + 8).  */
end_comment

begin_function
name|int
name|addrs_ok_for_quad_peep
parameter_list|(
name|rtx
name|addr1
parameter_list|,
name|rtx
name|addr2
parameter_list|)
block|{
name|unsigned
name|int
name|reg1
decl_stmt|;
name|int
name|offset1
decl_stmt|;
comment|/* Extract an offset (if used) from the first addr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* If not a REG, return zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset must be constant!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
comment|/* This was a simple (mem (reg)) expression.  Offset is 0.  */
name|offset1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure the second address is a (mem (plus (reg) (const_int)))       or if it is (mem (reg)) then make sure that offset1 is -8 and the same        register as addr1.  */
if|if
condition|(
name|offset1
operator|==
operator|-
literal|8
operator|&&
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|==
name|REG
operator|&&
name|reg1
operator|==
name|REGNO
argument_list|(
name|addr2
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg1
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The offset for the second addr must be 8 more than the first addr.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|offset1
operator|+
literal|8
condition|)
return|return
literal|0
return|;
comment|/* All the tests passed.  addr1 and addr2 are valid for lfq or stfq      instructions.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the register class of a scratch register needed to copy IN into    or out of a register in CLASS in MODE.  If it can be done directly,    NO_REGS is returned.  INP is nonzero if we are loading the reg, zero    for storing.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|in
parameter_list|,
name|int
name|inp
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
if|#
directive|if
name|TARGET_MACHO
operator|&&
name|MACHOPIC_INDIRECT
endif|#
directive|endif
operator|)
condition|)
block|{
comment|/* We cannot copy a symbolic operand directly into anything          other than BASE_REGS for TARGET_ELF.  So indicate that a          register from BASE_REGS is needed as an intermediate          register.           	 On Darwin, pic addresses require a load from memory, which 	 needs a base register.  */
if|if
condition|(
name|class
operator|!=
name|BASE_REGS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|HIGH
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|CONST
operator|)
condition|)
return|return
name|BASE_REGS
return|;
block|}
comment|/* A 64-bit gpr load or store using an offset that isn't a multiple of      four needs a secondary reload.  */
if|if
condition|(
name|TARGET_POWERPC64
operator|&&
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|8
operator|&&
operator|(
operator|!
name|inp
operator|||
name|class
operator|!=
name|BASE_REGS
operator|)
operator|&&
name|invalid_gpr_mem
argument_list|(
name|in
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|BASE_REGS
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|regno
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We can place anything into GENERAL_REGS and can put GENERAL_REGS      into anything.  */
if|if
condition|(
name|class
operator|==
name|GENERAL_REGS
operator|||
name|class
operator|==
name|BASE_REGS
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|INT_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Constants, memory, and FP registers can go into FP registers.  */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|&&
operator|(
name|class
operator|==
name|FLOAT_REGS
operator|||
name|class
operator|==
name|NON_SPECIAL_REGS
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Memory, and AltiVec registers can go into AltiVec registers.  */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|ALTIVEC_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|&&
name|class
operator|==
name|ALTIVEC_REGS
condition|)
return|return
name|NO_REGS
return|;
comment|/* We can copy among the CR registers.  */
if|if
condition|(
operator|(
name|class
operator|==
name|CR_REGS
operator|||
name|class
operator|==
name|CR0_REGS
operator|)
operator|&&
name|regno
operator|>=
literal|0
operator|&&
name|CR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Otherwise, we need GENERAL_REGS.  */
return|return
name|GENERAL_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison operation, return the bit number in CCR to test.  We    know this is a valid comparison.       SCC_P is 1 if this is for an scc.  That means that %D will have been    used instead of %C, so the bits will be in different places.     Return -1 if OP isn't a valid comparison for some reason.  */
end_comment

begin_function
name|int
name|ccr_bit
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|scc_p
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
name|int
name|cc_regnum
decl_stmt|;
name|int
name|base_bit
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
operator|-
literal|1
return|;
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cc_regnum
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|base_bit
operator|=
literal|4
operator|*
operator|(
name|cc_regnum
operator|-
name|CR0_REGNO
operator|)
expr_stmt|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|cc_mode
argument_list|)
expr_stmt|;
comment|/* When generating a sCOND operation, only positive conditions are      allowed.  */
if|if
condition|(
name|scc_p
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|GT
operator|&&
name|code
operator|!=
name|LT
operator|&&
name|code
operator|!=
name|UNORDERED
operator|&&
name|code
operator|!=
name|GTU
operator|&&
name|code
operator|!=
name|LTU
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
operator|+
literal|2
return|;
case|case
name|EQ
case|:
return|return
name|base_bit
operator|+
literal|2
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNLE
case|:
return|return
name|base_bit
operator|+
literal|1
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNGE
case|:
return|return
name|base_bit
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
return|return
name|base_bit
operator|+
literal|3
return|;
case|case
name|GE
case|:
case|case
name|GEU
case|:
comment|/* If scc, we will have done a cror to put the bit in the 	 unordered position.  So test that bit.  For integer, this is ! LT 	 unless this is an scc insn.  */
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
return|;
case|case
name|LE
case|:
case|case
name|LEU
case|:
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
operator|+
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the GOT register.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|rs6000_got_register
parameter_list|(
name|rtx
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* The second flow pass currently (June 1999) can't update      regs_ever_live without disturbing other parts of the compiler, so      update it here to make the prolog/epilogue code happy.  */
if|if
condition|(
name|no_new_pseudos
operator|&&
operator|!
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|pic_offset_table_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to init struct machine_function.    This will be called, via a pointer variable,    from push_function_context.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|rs6000_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These macros test for integers and extract the low-order bits.  */
end_comment

begin_define
define|#
directive|define
name|INT_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)	\&& GET_MODE (X) == VOIDmode)
end_define

begin_define
define|#
directive|define
name|INT_LOWPART
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))
end_define

begin_function
name|int
name|extract_MB
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|INT_LOWPART
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* If the high bit is zero, the value is the first 1 bit we find      from the left.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
operator|++
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* If the high bit is set and the low bit is not, or the mask is all      1's, the value is zero.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0xffffffff
condition|)
return|return
literal|0
return|;
comment|/* Otherwise we have a wrap-around mask.  Look for the first 0 bit      from the right.  */
name|i
operator|=
literal|31
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|extract_ME
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|INT_LOWPART
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* If the low bit is zero, the value is the first 1 bit we find from      the right.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|i
operator|=
literal|30
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
operator|--
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* If the low bit is set and the high bit is not, or the mask is all      1's, the value is 31.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|||
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0xffffffff
condition|)
return|return
literal|31
return|;
comment|/* Otherwise we have a wrap-around mask.  Look for the first 0 bit      from the left.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
operator|++
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in some tls_ld pattern.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|rs6000_get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for rs6000_get_some_local_dynamic_name.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|str
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_define
define|#
directive|define
name|SMALL_DATA_RELOC
value|((rs6000_sdata == SDATA_EABI) ? "sda21" : "sdarel")
end_define

begin_define
define|#
directive|define
name|SMALL_DATA_REG
value|((rs6000_sdata == SDATA_EABI) ? 0 : 13)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SMALL_DATA_RELOC
value|"sda21"
end_define

begin_define
define|#
directive|define
name|SMALL_DATA_REG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|uval
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Write out an instruction after the call which may be replaced 	 with glue code by the loader.  This depends on the AIX version.  */
name|asm_fprintf
argument_list|(
name|file
argument_list|,
name|RS6000_CALL_GLUE
argument_list|)
expr_stmt|;
return|return;
comment|/* %a is output_address.  */
case|case
literal|'A'
case|:
comment|/* If X is a constant integer whose low-order 5 bits are zero, 	 write 'l'.  Otherwise, write 'r'.  This is a kludge to fix a bug 	 in the AIX assembler where "sri" with a zero shift count 	 writes a trash instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|31
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'r'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'b'
case|:
comment|/* If constant, low-order 16 bits of constant, unsigned. 	 Otherwise, write normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
comment|/* If the low-order bit is zero, write 'r'; otherwise, write 'l' 	 for 64-bit mask direction.  */
name|putc
argument_list|(
operator|(
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
literal|'r'
else|:
literal|'l'
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise 	 output_operand.  */
case|case
literal|'c'
case|:
comment|/* X is a CR register.  Print the number of the GT bit of the CR.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
comment|/* Like 'J' but get to the EQ bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Bit 1 is EQ bit.  */
name|i
operator|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* If we want bit 31, write a shift count of zero, not 32.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|==
literal|31
condition|?
literal|0
else|:
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'E'
case|:
comment|/* X is a CR register.  Print the number of the EQ bit of the CR */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'f'
case|:
comment|/* X is a CR register.  Print the shift count needed to move it 	 to the high-order four bits.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%f value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* Similar, but print the count for the rotate in the opposite 	 direction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%F value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|32
operator|-
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'G'
case|:
comment|/* X is a constant integer.  If it is negative, print "m", 	 otherwise print "z".  This is to make an aze or ame insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%G value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
condition|)
name|putc
argument_list|(
literal|'z'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'m'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'h'
case|:
comment|/* If constant, output low-order five bits.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|31
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* If constant, output low-order six bits.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|63
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
comment|/* Print `i' if this is a constant, else nothing.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|putc
argument_list|(
literal|'i'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'j'
case|:
comment|/* Write the bit number in CCR for jump.  */
name|i
operator|=
name|ccr_bit
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%j code"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
comment|/* Similar, but add one for shift count in rlinm for scc and pass 	 scc flag to `ccr_bit'.  */
name|i
operator|=
name|ccr_bit
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%J code"
argument_list|)
expr_stmt|;
else|else
comment|/* If we want bit 31, write a shift count of zero, not 32.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|==
literal|31
condition|?
literal|0
else|:
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'k'
case|:
comment|/* X must be a constant.  Write the 1's complement of the 	 constant.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%k value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|~
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'K'
case|:
comment|/* X must be a symbolic constant on ELF.  Write an 	 expression suitable for an 'addi' that adds in the low 16 	 bits of the MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
block|{
name|print_operand_address
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%K value"
argument_list|)
expr_stmt|;
name|print_operand_address
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* For GNU as, there must be a non-alphanumeric character 	     between 'l' and the number.  The '-' is added by 	     print_operand() already.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fputs
argument_list|(
literal|"+"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_operand
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* %l is output_asm_label.  */
case|case
literal|'L'
case|:
comment|/* Write second word of DImode or DFmode reference.  Works on register 	 or non-indexed memory only.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Handle possible auto-increment.  Since it is pre-increment and 	     we have already done it, we can just use an offset of word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'m'
case|:
comment|/* MB value for a mask operand.  */
if|if
condition|(
operator|!
name|mask_operand
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|extract_MB
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
comment|/* ME value for a mask operand.  */
if|if
condition|(
operator|!
name|mask_operand
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|extract_ME
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* %n outputs the negative of its operand.  */
case|case
literal|'N'
case|:
comment|/* Write the number of elements in the vector times 4.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
comment|/* Similar, but subtract 1 first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%O value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'p'
case|:
comment|/* X is a CONST_INT that is a power of two.  Output the logarithm.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
operator|||
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%p value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
comment|/* The operand must be an indirect memory reference.  The result 	 is the register name.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|32
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'q'
case|:
comment|/* This outputs the logical code corresponding to a boolean 	 expression.  The expression may have one or both operands 	 negated (if one, only the first one).  For condition register          logical operations, it will also treat the negated          CR codes as NOTs, but not handle NOTs of them.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|t
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tbl
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|"and"
block|,
literal|"andc"
block|,
literal|"nor"
block|}
block|,
block|{
literal|"or"
block|,
literal|"orc"
block|,
literal|"nand"
block|}
block|,
block|{
literal|"xor"
block|,
literal|"eqv"
block|,
literal|"xor"
block|}
block|}
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|AND
condition|)
name|t
operator|=
name|tbl
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|IOR
condition|)
name|t
operator|=
name|tbl
index|[
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|XOR
condition|)
name|t
operator|=
name|tbl
index|[
literal|2
index|]
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%q value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOT
condition|)
name|s
operator|=
name|t
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
name|s
operator|=
name|t
index|[
literal|2
index|]
expr_stmt|;
else|else
name|s
operator|=
name|t
index|[
literal|1
index|]
expr_stmt|;
block|}
name|fputs
argument_list|(
name|s
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'Q'
case|:
if|if
condition|(
name|TARGET_MFCRF
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
else|else
return|return;
case|case
literal|'R'
case|:
comment|/* X is a CR register.  Print the mask for `mtcrf'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|128
operator|>>
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
comment|/* Low 5 bits of 32 - value */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
literal|32
operator|-
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|)
operator|&
literal|31
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* PowerPC64 mask position.  All 0's is excluded. 	 CONST_INT 32-bit mask is considered sign-extended so any 	 transition must occur within the CONST_INT, not on the boundary.  */
if|if
condition|(
operator|!
name|mask64_operand
argument_list|(
name|x
argument_list|,
name|DImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%S value"
argument_list|)
expr_stmt|;
name|uval
operator|=
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|uval
operator|&
literal|1
condition|)
comment|/* Clear Left */
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|64
name|uval
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|64
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|64
expr_stmt|;
block|}
else|else
comment|/* Clear Right */
block|{
name|uval
operator|=
operator|~
name|uval
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|64
name|uval
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|64
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|63
expr_stmt|;
block|}
while|while
condition|(
name|uval
operator|!=
literal|0
condition|)
operator|--
name|i
operator|,
name|uval
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'t'
case|:
comment|/* Like 'J' but get to the OVERFLOW/UNORDERED bit.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Bit 3 is OV bit.  */
name|i
operator|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|3
expr_stmt|;
comment|/* If we want bit 31, write a shift count of zero, not 32.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|==
literal|31
condition|?
literal|0
else|:
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* Print the symbolic name of a branch target register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|LINK_REGISTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|COUNT_REGISTER_REGNUM
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%T value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|LINK_REGISTER_REGNUM
condition|)
name|fputs
argument_list|(
name|TARGET_NEW_MNEMONICS
condition|?
literal|"lr"
else|:
literal|"r"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"ctr"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'u'
case|:
comment|/* High-order 16 bits of constant for use in unsigned operand.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%u value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'v'
case|:
comment|/* High-order 16 bits of constant for use in signed operand.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%v value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'U'
case|:
comment|/* Print `u' if this has an auto-increment or auto-decrement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|)
condition|)
name|putc
argument_list|(
literal|'u'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'V'
case|:
comment|/* Print the trap code for this operand.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 4 */
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 24 */
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 16 */
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 20 */
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 8 */
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 12 */
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"llt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 2 */
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"lle"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 6 */
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"lgt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 1 */
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"lge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 5 */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
comment|/* If constant, low-order 16 bits of constant, signed.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
comment|/* MB value for a PowerPC64 rldic operand.  */
name|val
operator|=
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|?
name|INTVAL
argument_list|(
name|x
argument_list|)
else|:
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|<
literal|0
condition|)
break|break;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
comment|/* zero-extend high-part was all 0's */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|i
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
literal|0
condition|)
operator|--
name|i
expr_stmt|;
else|else
for|for
control|(
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|<
literal|0
condition|)
break|break;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'X'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|legitimate_indexed_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|putc
argument_list|(
literal|'x'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Y'
case|:
comment|/* Like 'L', for third word of TImode  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'z'
case|:
comment|/* X is a SYMBOL_REF.  Write out the name preceded by a 	 period and without any trailing data in brackets.  Used for function 	 names.  If we are configured for System V (or the embedded ABI) on 	 the PowerPC, do not emit the period, since those systems do not use 	 TOCs and the like.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
case|case
name|ABI_DARWIN
case|:
break|break;
block|}
block|}
if|if
condition|(
name|TARGET_AIX
condition|)
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Z'
case|:
comment|/* Like 'L', for last word of TImode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
literal|12
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* Print AltiVec or SPE memory operand.  */
case|case
literal|'y'
case|:
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_E500
condition|)
block|{
comment|/* Handle [reg].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Handle [reg+UIMM].  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%s)"
argument_list|,
name|x
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  Must be [reg+reg].  */
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* We need to handle PRE_INC and PRE_DEC here, since we need to 	     know the width from the mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%s)"
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%s)"
argument_list|,
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'&'
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|rs6000_get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the address of an operand.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_TOC
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
literal|"(%s)"
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_ELF
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@l(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET_MACHO
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lo16("
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|legitimate_constant_pool_address_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_AIX
operator|&&
operator|(
operator|!
name|TARGET_ELF
operator|||
operator|!
name|TARGET_MINIMAL_TOC
operator|)
condition|)
block|{
name|rtx
name|contains_minus
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|minus
decl_stmt|,
name|symref
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Find the (minus (sym) (toc)) buried in X, and temporarily 	     turn it into (sym) for output_addr_const.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MINUS
condition|)
name|contains_minus
operator|=
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|minus
operator|=
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symref
operator|=
name|XEXP
argument_list|(
name|minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
operator|=
name|symref
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
condition|)
block|{
name|char
modifier|*
name|newname
decl_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"@toc"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newname
argument_list|,
literal|"@toc"
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
operator|=
name|newname
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
condition|)
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
operator|=
name|minus
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Target hook for assembling integer objects.  The PowerPC version has    to handle fixup entries for relocatable code if RELOCATABLE_NEEDS_FIXUP    is defined.  It also needs to handle DI-mode objects on 64-bit    targets.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RELOCATABLE_NEEDS_FIXUP
comment|/* Special handling for SI values.  */
if|if
condition|(
name|RELOCATABLE_NEEDS_FIXUP
operator|&&
name|size
operator|==
literal|4
operator|&&
name|aligned_p
condition|)
block|{
specifier|extern
name|int
name|in_toc_section
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|static
name|int
name|recurse
init|=
literal|0
decl_stmt|;
comment|/* For -mrelocatable, we mark all addresses that need to be fixed up 	 in the .fixup section.  */
if|if
condition|(
name|TARGET_RELOCATABLE
operator|&&
operator|!
name|in_toc_section
argument_list|()
operator|&&
operator|!
name|in_text_section
argument_list|()
operator|&&
operator|!
name|recurse
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|recurse
operator|=
literal|1
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCP"
argument_list|,
name|fixuplabelno
argument_list|)
expr_stmt|;
name|fixuplabelno
operator|++
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t("
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|")@fixup\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t\".fixup\",\"aw\"\n"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n\t.previous\n"
argument_list|)
expr_stmt|;
name|recurse
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Remove initial .'s to turn a -mcall-aixdesc function 	 address into the address of the descriptor, not the function 	 itself.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
name|name
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
endif|#
directive|endif
comment|/* RELOCATABLE_NEEDS_FIXUP */
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
end_ifdef

begin_comment
comment|/* Emit an assembler directive to set symbol visibility for DECL to    VISIBILITY_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_assemble_visibility
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|vis
parameter_list|)
block|{
comment|/* Functions need to have their entry point symbol visibility set as      well as their descriptor symbol visibility.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|visibility_types
index|[]
init|=
block|{
name|NULL
block|,
literal|"internal"
block|,
literal|"hidden"
block|,
literal|"protected"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|;
name|name
operator|=
operator|(
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|type
operator|=
name|visibility_types
index|[
name|vis
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.%s\t%s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.%s\t.%s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|default_assemble_visibility
argument_list|(
name|decl
argument_list|,
name|vis
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|enum
name|rtx_code
name|rs6000_reverse_condition
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
comment|/* Reversal of FP compares takes care -- an ordered compare      becomes an unordered compare and vice versa.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|&&
operator|(
operator|!
name|flag_finite_math_only
operator|||
name|code
operator|==
name|UNLT
operator|||
name|code
operator|==
name|UNLE
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNGE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|)
condition|)
return|return
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
return|;
else|else
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a compare for CODE.  Return a brand-new rtx that    represents the result of the compare.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_generate_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|machine_mode
name|comp_mode
decl_stmt|;
name|rtx
name|compare_result
decl_stmt|;
if|if
condition|(
name|rs6000_compare_fp_p
condition|)
name|comp_mode
operator|=
name|CCFPmode
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
condition|)
name|comp_mode
operator|=
name|CCUNSmode
expr_stmt|;
else|else
name|comp_mode
operator|=
name|CCmode
expr_stmt|;
comment|/* First, the compare.  */
name|compare_result
operator|=
name|gen_reg_rtx
argument_list|(
name|comp_mode
argument_list|)
expr_stmt|;
comment|/* SPE FP compare instructions on the GPRs.  Yuck!  */
if|if
condition|(
operator|(
name|TARGET_E500
operator|&&
operator|!
name|TARGET_FPRS
operator|&&
name|TARGET_HARD_FLOAT
operator|)
operator|&&
name|rs6000_compare_fp_p
condition|)
block|{
name|rtx
name|cmp
decl_stmt|,
name|or1
decl_stmt|,
name|or2
decl_stmt|,
name|or_result
decl_stmt|,
name|compare_result2
decl_stmt|;
comment|/* Note: The E500 comparison instructions set the GT bit (x +         1), on success.  This explains the mess.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
case|case
name|NE
case|:
case|case
name|LTGT
case|:
name|cmp
operator|=
name|flag_finite_math_only
condition|?
name|gen_tstsfeq_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpsfeq_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|cmp
operator|=
name|flag_finite_math_only
condition|?
name|gen_tstsfgt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpsfgt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|cmp
operator|=
name|flag_finite_math_only
condition|?
name|gen_tstsflt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpsflt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Synthesize LE and GE from LT/GT || EQ.  */
if|if
condition|(
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GEU
condition|)
block|{
name|emit_insn
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
name|code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|code
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|code
operator|=
name|GT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|or1
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|or2
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|or_result
operator|=
name|gen_reg_rtx
argument_list|(
name|CCEQmode
argument_list|)
expr_stmt|;
name|compare_result2
operator|=
name|gen_reg_rtx
argument_list|(
name|CCFPmode
argument_list|)
expr_stmt|;
comment|/* Do the EQ.  */
name|cmp
operator|=
name|flag_finite_math_only
condition|?
name|gen_tstsfeq_gpr
argument_list|(
name|compare_result2
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpsfeq_gpr
argument_list|(
name|compare_result2
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
name|or1
operator|=
name|gen_rtx_GT
argument_list|(
name|SImode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|or2
operator|=
name|gen_rtx_GT
argument_list|(
name|SImode
argument_list|,
name|compare_result2
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* OR them together.  */
name|cmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|or_result
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|CCEQmode
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|or1
argument_list|,
name|or2
argument_list|)
argument_list|,
name|const_true_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|compare_result
operator|=
name|or_result
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LTGT
condition|)
name|code
operator|=
name|NE
expr_stmt|;
else|else
name|code
operator|=
name|EQ
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate XLC-compatible TFmode compare as PARALLEL with extra          CLOBBERs to match cmptf_internal2 pattern.  */
if|if
condition|(
name|comp_mode
operator|==
name|CCFPmode
operator|&&
name|TARGET_XL_COMPAT
operator|&&
name|GET_MODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
operator|==
name|TFmode
operator|&&
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|TARGET_LONG_DOUBLE_128
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|9
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|compare_result
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|comp_mode
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|compare_result
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|comp_mode
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Some kinds of FP comparisons need an OR operation;      under flag_finite_math_only we don't bother.  */
if|if
condition|(
name|rs6000_compare_fp_p
operator|&&
operator|!
name|flag_finite_math_only
operator|&&
operator|!
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_E500
operator|&&
operator|!
name|TARGET_FPRS
operator|)
operator|&&
operator|(
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNLT
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|or1
decl_stmt|,
name|or2
decl_stmt|;
name|rtx
name|or1_rtx
decl_stmt|,
name|or2_rtx
decl_stmt|,
name|compare2_rtx
decl_stmt|;
name|rtx
name|or_result
init|=
name|gen_reg_rtx
argument_list|(
name|CCEQmode
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
name|or1
operator|=
name|LT
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|or1
operator|=
name|GT
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|LTGT
case|:
name|or1
operator|=
name|LT
expr_stmt|;
name|or2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|LT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|validate_condition_mode
argument_list|(
name|or1
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|validate_condition_mode
argument_list|(
name|or2
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|or1_rtx
operator|=
name|gen_rtx
argument_list|(
name|or1
argument_list|,
name|SImode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|or2_rtx
operator|=
name|gen_rtx
argument_list|(
name|or2
argument_list|,
name|SImode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|compare2_rtx
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|CCEQmode
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|or1_rtx
argument_list|,
name|or2_rtx
argument_list|)
argument_list|,
name|const_true_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|or_result
argument_list|,
name|compare2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|compare_result
operator|=
name|or_result
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|compare_result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit the RTL for an sCOND pattern.  */
end_comment

begin_function
name|void
name|rs6000_emit_sCOND
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|result
parameter_list|)
block|{
name|rtx
name|condition_rtx
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
name|enum
name|rtx_code
name|cond_code
decl_stmt|;
name|condition_rtx
operator|=
name|rs6000_generate_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|cond_code
operator|=
name|GET_CODE
argument_list|(
name|condition_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_E500
operator|&&
name|rs6000_compare_fp_p
operator|&&
operator|!
name|TARGET_FPRS
operator|&&
name|TARGET_HARD_FLOAT
condition|)
block|{
name|rtx
name|t
decl_stmt|;
name|PUT_MODE
argument_list|(
name|condition_rtx
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|t
operator|=
name|XEXP
argument_list|(
name|condition_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_code
operator|!=
name|NE
operator|&&
name|cond_code
operator|!=
name|EQ
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond_code
operator|==
name|NE
condition|)
name|emit_insn
argument_list|(
name|gen_e500_flip_eq_bit
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_move_from_CR_eq_bit
argument_list|(
name|result
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cond_code
operator|==
name|NE
operator|||
name|cond_code
operator|==
name|GE
operator|||
name|cond_code
operator|==
name|LE
operator|||
name|cond_code
operator|==
name|GEU
operator|||
name|cond_code
operator|==
name|LEU
operator|||
name|cond_code
operator|==
name|ORDERED
operator|||
name|cond_code
operator|==
name|UNGE
operator|||
name|cond_code
operator|==
name|UNLE
condition|)
block|{
name|rtx
name|not_result
init|=
name|gen_reg_rtx
argument_list|(
name|CCEQmode
argument_list|)
decl_stmt|;
name|rtx
name|not_op
decl_stmt|,
name|rev_cond_rtx
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|condition_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rev_cond_rtx
operator|=
name|gen_rtx
argument_list|(
name|rs6000_reverse_condition
argument_list|(
name|cc_mode
argument_list|,
name|cond_code
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|condition_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|not_op
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|CCEQmode
argument_list|,
name|rev_cond_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|not_result
argument_list|,
name|not_op
argument_list|)
argument_list|)
expr_stmt|;
name|condition_rtx
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|not_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_POWERPC64
operator|&&
operator|(
name|op_mode
operator|==
name|DImode
operator|||
name|rs6000_compare_fp_p
operator|)
condition|)
block|{
name|PUT_MODE
argument_list|(
name|condition_rtx
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|result
argument_list|,
name|condition_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_MODE
argument_list|(
name|condition_rtx
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|result
argument_list|,
name|condition_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a branch of kind CODE to location LOC.  */
end_comment

begin_function
name|void
name|rs6000_emit_cbranch
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|loc
parameter_list|)
block|{
name|rtx
name|condition_rtx
decl_stmt|,
name|loc_ref
decl_stmt|;
name|condition_rtx
operator|=
name|rs6000_generate_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|loc_ref
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|condition_rtx
argument_list|,
name|loc_ref
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, which is    the operand number of the label, or -1 if the branch is really a    conditional return.       OP is the conditional expression.  XEXP (OP, 0) is assumed to be a    condition code register and its mode specifies what kind of    comparison we made.     REVERSED is nonzero if we should reverse the sense of the comparison.     INSN is the insn.  */
end_comment

begin_function
name|char
modifier|*
name|output_cbranch
parameter_list|(
name|rtx
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|reversed
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
literal|64
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
decl_stmt|;
name|int
name|cc_regno
init|=
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
operator|-
name|CR0_REGNO
decl_stmt|;
name|int
name|need_longbranch
init|=
name|label
operator|!=
name|NULL
operator|&&
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|==
literal|8
decl_stmt|;
name|int
name|really_reversed
init|=
name|reversed
operator|^
name|need_longbranch
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|ccode
decl_stmt|;
specifier|const
name|char
modifier|*
name|pred
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Work out which way this really branches.  We could use      reverse_condition_maybe_unordered here always but this      makes the resulting assembler clearer.  */
if|if
condition|(
name|really_reversed
condition|)
block|{
comment|/* Reversal of FP compares takes care -- an ordered compare 	 becomes an unordered compare and vice versa.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
condition|)
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TARGET_E500
operator|&&
operator|!
name|TARGET_FPRS
operator|&&
name|TARGET_HARD_FLOAT
operator|)
operator|&&
name|mode
operator|==
name|CCFPmode
condition|)
block|{
comment|/* The efscmp/tst* instructions twiddle bit 2, which maps nicely 	 to the GT bit.  */
if|if
condition|(
name|code
operator|==
name|EQ
condition|)
comment|/* Opposite of GT.  */
name|code
operator|=
name|GT
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NE
condition|)
name|code
operator|=
name|UNLE
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Not all of these are actually distinct opcodes, but 	 we distinguish them for clarity of the resulting assembler.  */
case|case
name|NE
case|:
case|case
name|LTGT
case|:
name|ccode
operator|=
literal|"ne"
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
name|ccode
operator|=
literal|"eq"
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|ccode
operator|=
literal|"ge"
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNGT
case|:
name|ccode
operator|=
literal|"gt"
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|ccode
operator|=
literal|"le"
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNLT
case|:
name|ccode
operator|=
literal|"lt"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|ccode
operator|=
literal|"un"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|ccode
operator|=
literal|"nu"
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|ccode
operator|=
literal|"nl"
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|ccode
operator|=
literal|"ng"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Maybe we have a guess as to how likely the branch is.        The old mnemonics don't have a way to specify this information.  */
name|pred
operator|=
literal|""
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|!=
name|NULL_RTX
condition|)
block|{
comment|/* PROB is the difference from 50%.  */
name|int
name|prob
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
comment|/* Only hint for highly probable/improbable branches on newer 	 cpus as static prediction overrides processor dynamic 	 prediction.  For older cpus we may as well always hint, but 	 assume not taken for branches that are very close to 50% as a 	 mispredicted taken branch is more expensive than a 	 mispredicted not-taken branch.  */
if|if
condition|(
name|rs6000_always_hint
operator|||
name|abs
argument_list|(
name|prob
argument_list|)
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
literal|48
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|prob
argument_list|)
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|20
operator|&&
operator|(
operator|(
name|prob
operator|>
literal|0
operator|)
operator|^
name|need_longbranch
operator|)
condition|)
name|pred
operator|=
literal|"+"
expr_stmt|;
else|else
name|pred
operator|=
literal|"-"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"{b%sr|b%slr%s} "
argument_list|,
name|ccode
argument_list|,
name|ccode
argument_list|,
name|pred
argument_list|)
expr_stmt|;
else|else
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"{b%s|b%s%s} "
argument_list|,
name|ccode
argument_list|,
name|ccode
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* We need to escape any '%' characters in the reg_names string.      Assume they'd only be the first character....  */
if|if
condition|(
name|reg_names
index|[
name|cc_regno
operator|+
name|CR0_REGNO
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'%'
expr_stmt|;
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|cc_regno
operator|+
name|CR0_REGNO
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
comment|/* If the branch distance was too far, we may have to use an 	 unconditional branch to go the distance.  */
if|if
condition|(
name|need_longbranch
condition|)
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|",$+8\n\tb %s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|",%s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return the string to flip the EQ bit on a CR.  */
end_comment

begin_function
name|char
modifier|*
name|output_e500_flip_eq_bit
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
literal|64
index|]
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* EQ bit.  */
name|a
operator|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|2
expr_stmt|;
name|b
operator|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|2
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"crnot %d,%d"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Emit a conditional move: move TRUE_COND to DEST if OP of the    operands of the last comparison is nonzero/true, FALSE_COND if it    is zero/false.  Return 0 if the hardware has no such operation.  */
end_comment

begin_function
name|int
name|rs6000_emit_cmove
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|op
parameter_list|,
name|rtx
name|true_cond
parameter_list|,
name|rtx
name|false_cond
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|rs6000_compare_op0
decl_stmt|;
name|rtx
name|op1
init|=
name|rs6000_compare_op1
decl_stmt|;
name|REAL_VALUE_TYPE
name|c1
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|result_mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* These modes should always match.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|compare_mode
comment|/* In the isel case however, we can use a compare immediate, so 	 op1 may be a small constant.  */
operator|&&
operator|(
operator|!
name|TARGET_ISEL
operator|||
operator|!
name|short_cint_operand
argument_list|(
name|op1
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|true_cond
argument_list|)
operator|!=
name|result_mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|false_cond
argument_list|)
operator|!=
name|result_mode
condition|)
return|return
literal|0
return|;
comment|/* First, work out if the hardware can do this at all, or      if it's too slow....  */
if|if
condition|(
operator|!
name|rs6000_compare_fp_p
condition|)
block|{
if|if
condition|(
name|TARGET_ISEL
condition|)
return|return
name|rs6000_emit_int_cmove
argument_list|(
name|dest
argument_list|,
name|op
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_E500
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
operator|!
name|TARGET_FPRS
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|compare_mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|0
return|;
comment|/* Eliminate half of the comparisons by switching operands, this      makes the remaining code simpler.  */
if|if
condition|(
name|code
operator|==
name|UNLT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|UNLE
condition|)
block|{
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|temp
operator|=
name|true_cond
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
block|}
comment|/* UNEQ and LTGT take four instructions for a comparison with zero,      it'll probably be faster to use a branch here too.  */
if|if
condition|(
name|code
operator|==
name|UNEQ
operator|&&
name|HONOR_NANS
argument_list|(
name|compare_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|c1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* We're going to try to implement comparisons by performing      a subtract, then comparing against zero.  Unfortunately,      Inf - Inf is NaN which is not zero, and so if we don't      know that the operand is finite and the comparison      would treat EQ different to UNORDERED, we can't do it.  */
if|if
condition|(
name|HONOR_INFINITIES
argument_list|(
name|compare_mode
argument_list|)
operator|&&
name|code
operator|!=
name|GT
operator|&&
name|code
operator|!=
name|UNGE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|real_isinf
argument_list|(
operator|&
name|c1
argument_list|)
operator|)
comment|/* Constructs of the form (a OP b ? a : b) are safe.  */
operator|&&
operator|(
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|false_cond
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|false_cond
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|true_cond
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|true_cond
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* At this point we know we can use fsel.  */
comment|/* Reduce the comparison to a comparison against zero.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
comment|/* If we don't care about NaNs we can reduce some of the comparisons      down to faster ones.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|compare_mode
argument_list|)
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
name|code
operator|=
name|LE
expr_stmt|;
name|temp
operator|=
name|true_cond
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|code
operator|=
name|GE
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Now, reduce everything down to a GE.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE
case|:
break|break;
case|case
name|LE
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_ABS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|gen_rtx_ABS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
comment|/* a UNGE 0<-> (a GE 0 || -a UNLT 0) */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|false_cond
operator|=
name|true_cond
expr_stmt|;
name|true_cond
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|GT
case|:
comment|/* a GT 0<-> (a GE 0&& -a UNLT 0) */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Same as above, but for ints (isel).  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_emit_int_cmove
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|op
parameter_list|,
name|rtx
name|true_cond
parameter_list|,
name|rtx
name|false_cond
parameter_list|)
block|{
name|rtx
name|condition_rtx
decl_stmt|,
name|cr
decl_stmt|;
comment|/* All isel implementations thus far are 32-bits.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
operator|!=
name|SImode
condition|)
return|return
literal|0
return|;
comment|/* We still have to do the compare, because isel doesn't do a      compare, it just looks at the CRx bits set by a previous compare      instruction.  */
name|condition_rtx
operator|=
name|rs6000_generate_compare
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|cr
operator|=
name|XEXP
argument_list|(
name|condition_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|cr
argument_list|)
operator|==
name|CCmode
condition|)
name|emit_insn
argument_list|(
name|gen_isel_signed
argument_list|(
name|dest
argument_list|,
name|condition_rtx
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|,
name|cr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_isel_unsigned
argument_list|(
name|dest
argument_list|,
name|condition_rtx
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|,
name|cr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|output_isel
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|NE
condition|)
block|{
name|PUT_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|reverse_condition
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"isel %0,%3,%2,%j1"
return|;
block|}
else|else
return|return
literal|"isel %0,%2,%3,%j1"
return|;
block|}
end_function

begin_function
name|void
name|rs6000_emit_minmax
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|c
decl_stmt|;
name|rtx
name|target
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|SMIN
condition|)
name|c
operator|=
name|GE
expr_stmt|;
else|else
name|c
operator|=
name|GEU
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|UMAX
condition|)
name|target
operator|=
name|emit_conditional_move
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|emit_conditional_move
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|dest
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit instructions to move SRC to DST.  Called by splitters for    multi-register moves.  It will emit at most one instruction for    each register that is accessed; that is, it won't emit li/lis pairs    (or equivalent for 64-bit code).  One of SRC or DST must be a hard    register.  */
end_comment

begin_function
name|void
name|rs6000_split_multireg_move
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
comment|/* The register number of the first register being moved.  */
name|int
name|reg
decl_stmt|;
comment|/* The mode that is to be moved.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The mode that the move is being done in, and its size.  */
name|enum
name|machine_mode
name|reg_mode
decl_stmt|;
name|int
name|reg_mode_size
decl_stmt|;
comment|/* The number of registers that will be moved.  */
name|int
name|nregs
decl_stmt|;
name|reg
operator|=
name|REG_P
argument_list|(
name|dst
argument_list|)
condition|?
name|REGNO
argument_list|(
name|dst
argument_list|)
else|:
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|reg
argument_list|)
condition|)
name|reg_mode
operator|=
name|DFmode
expr_stmt|;
elseif|else
if|if
condition|(
name|ALTIVEC_REGNO_P
argument_list|(
name|reg
argument_list|)
condition|)
name|reg_mode
operator|=
name|V16QImode
expr_stmt|;
else|else
name|reg_mode
operator|=
name|word_mode
expr_stmt|;
name|reg_mode_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|reg_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mode_size
operator|*
name|nregs
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|dst
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
block|{
comment|/* Move register range backwards, if we might have destructive 	 overlap.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nregs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|dst
argument_list|,
name|mode
argument_list|,
name|i
operator|*
name|reg_mode_size
argument_list|)
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|src
argument_list|,
name|mode
argument_list|,
name|i
operator|*
name|reg_mode_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|used_update
init|=
name|false
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|INT_REGNO_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|breg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
name|rtx
name|delta_rtx
decl_stmt|;
name|breg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta_rtx
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|?
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
else|:
name|GEN_INT
argument_list|(
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|breg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|offsettable_memref_p
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|rtx
name|newsrc
decl_stmt|,
name|basereg
decl_stmt|;
name|basereg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|basereg
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newsrc
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|newsrc
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|newsrc
expr_stmt|;
block|}
name|breg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|breg
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|breg
argument_list|)
operator|==
name|LO_SUM
condition|)
name|breg
operator|=
name|XEXP
argument_list|(
name|breg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the base register we are using to address memory is 	     also a destination reg, then change that register last.  */
if|if
condition|(
name|REG_P
argument_list|(
name|breg
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|breg
argument_list|)
operator|>=
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|breg
argument_list|)
operator|<
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|+
name|nregs
condition|)
name|j
operator|=
name|REGNO
argument_list|(
name|breg
argument_list|)
operator|-
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
operator|&&
name|INT_REGNO_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|breg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
name|rtx
name|delta_rtx
decl_stmt|;
name|breg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta_rtx
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|?
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
else|:
name|GEN_INT
argument_list|(
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have to update the breg before doing the store. 		 Use store with update, if available.  */
if|if
condition|(
name|TARGET_UPDATE
condition|)
block|{
name|rtx
name|nsrc
init|=
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|src
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_movsi_update
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|,
name|nsrc
argument_list|)
else|:
name|gen_movdi_update
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|,
name|nsrc
argument_list|)
argument_list|)
expr_stmt|;
name|used_update
operator|=
name|true
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|breg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|offsettable_memref_p
argument_list|(
name|dst
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Calculate index to next subword.  */
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|nregs
condition|)
name|j
operator|=
literal|0
expr_stmt|;
comment|/* If compiler already emitted move of first word by  	     store with update, no need to do anything.  */
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
name|used_update
condition|)
continue|continue;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|dst
argument_list|,
name|mode
argument_list|,
name|j
operator|*
name|reg_mode_size
argument_list|)
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|src
argument_list|,
name|mode
argument_list|,
name|j
operator|*
name|reg_mode_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the    function prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/* Return the first fixed-point register that is required to be    saved. 32 if none.  */
end_comment

begin_function
name|int
name|first_reg_to_save
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|13
init|;
name|first_reg
operator|<=
literal|31
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
operator|&&
operator|(
operator|!
name|call_used_regs
index|[
name|first_reg
index|]
operator|||
operator|(
name|first_reg
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|||
operator|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|)
operator|)
operator|)
condition|)
break|break;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
operator|&&
name|first_reg
operator|>
name|RS6000_PIC_OFFSET_TABLE_REGNUM
condition|)
return|return
name|RS6000_PIC_OFFSET_TABLE_REGNUM
return|;
endif|#
directive|endif
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Similar, for FP regs.  */
end_comment

begin_function
name|int
name|first_fp_reg_to_save
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|14
operator|+
literal|32
init|;
name|first_reg
operator|<=
literal|63
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
condition|)
break|break;
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Similar, for AltiVec regs.  */
end_comment

begin_function
specifier|static
name|int
name|first_altivec_reg_to_save
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Stack frame remains as is unless we are in AltiVec ABI.  */
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
condition|)
return|return
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
return|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
operator|+
literal|20
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
break|break;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return a 32-bit mask of the AltiVec registers we need to set in    VRSAVE.  Bit n of the return value is 1 if Vn is live.  The MSB in    the 32-bit word is 0.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|compute_vrsave_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|;
comment|/* First, find out if we use _any_ altivec registers.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|mask
operator||=
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
name|mask
return|;
comment|/* Next, remove the argument registers from the set.  These must      be in the VRSAVE mask set by the caller, so we don't need to add      them in again.  More importantly, the mask we compute here is      used to generate CLOBBERs in the set_vrsave insn, and we do not      wish the argument registers to die.  */
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|args_info
operator|.
name|vregno
operator|-
literal|1
init|;
name|i
operator|>=
name|ALTIVEC_ARG_MIN_REG
condition|;
operator|--
name|i
control|)
name|mask
operator|&=
operator|~
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Similarly, remove the return value from the set.  */
block|{
name|bool
name|yes
init|=
name|false
decl_stmt|;
name|diddle_return_value
argument_list|(
name|is_altivec_return_reg
argument_list|,
operator|&
name|yes
argument_list|)
expr_stmt|;
if|if
condition|(
name|yes
condition|)
name|mask
operator|&=
operator|~
name|ALTIVEC_REG_BIT
argument_list|(
name|ALTIVEC_ARG_RETURN
argument_list|)
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|is_altivec_return_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|xyes
parameter_list|)
block|{
name|bool
modifier|*
name|yes
init|=
operator|(
name|bool
operator|*
operator|)
name|xyes
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|==
name|ALTIVEC_ARG_RETURN
condition|)
operator|*
name|yes
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the stack information for the current function.  This is    complicated by having two separate calling sequences, the AIX calling    sequence and the V.4 calling sequence.     AIX (and Darwin/Mac OS X) stack frames look like: 							  32-bit  64-bit 	SP---->	+---------------------------------------+ 		| back chain to caller			| 0	  0 		+---------------------------------------+ 		| saved CR				| 4       8 (8-11) 		+---------------------------------------+ 		| saved LR				| 8       16 		+---------------------------------------+ 		| reserved for compilers		| 12      24 		+---------------------------------------+ 		| reserved for binders			| 16      32 		+---------------------------------------+ 		| saved TOC pointer			| 20      40 		+---------------------------------------+ 		| Parameter save area (P)		| 24      48 		+---------------------------------------+ 		| Alloca space (A)			| 24+P    etc. 		+---------------------------------------+ 		| Local variable space (L)		| 24+P+A 		+---------------------------------------+ 		| Float/int conversion temporary (X)	| 24+P+A+L 		+---------------------------------------+ 		| Save area for AltiVec registers (W)	| 24+P+A+L+X 		+---------------------------------------+ 		| AltiVec alignment padding (Y)		| 24+P+A+L+X+W 		+---------------------------------------+ 		| Save area for VRSAVE register (Z)	| 24+P+A+L+X+W+Y 		+---------------------------------------+ 		| Save area for GP registers (G)	| 24+P+A+X+L+X+W+Y+Z 		+---------------------------------------+ 		| Save area for FP registers (F)	| 24+P+A+X+L+X+W+Y+Z+G 		+---------------------------------------+ 	old SP->| back chain to caller's caller		| 		+---------------------------------------+     The required alignment for AIX configurations is two words (i.e., 8    or 16 bytes).      V.4 stack frames look like:  	SP---->	+---------------------------------------+ 		| back chain to caller			| 0 		+---------------------------------------+ 		| caller's saved LR			| 4 		+---------------------------------------+ 		| Parameter save area (P)		| 8 		+---------------------------------------+ 		| Alloca space (A)			| 8+P 		+---------------------------------------+     		| Varargs save area (V)			| 8+P+A 		+---------------------------------------+     		| Local variable space (L)		| 8+P+A+V 		+---------------------------------------+     		| Float/int conversion temporary (X)	| 8+P+A+V+L 		+---------------------------------------+ 		| Save area for AltiVec registers (W)	| 8+P+A+V+L+X 		+---------------------------------------+ 		| AltiVec alignment padding (Y)		| 8+P+A+V+L+X+W 		+---------------------------------------+ 		| Save area for VRSAVE register (Z)	| 8+P+A+V+L+X+W+Y 		+---------------------------------------+                 | SPE: area for 64-bit GP registers     |                 +---------------------------------------+                 | SPE alignment padding                 |                 +---------------------------------------+ 		| saved CR (C)				| 8+P+A+V+L+X+W+Y+Z 		+---------------------------------------+     		| Save area for GP registers (G)	| 8+P+A+V+L+X+W+Y+Z+C 		+---------------------------------------+     		| Save area for FP registers (F)	| 8+P+A+V+L+X+W+Y+Z+C+G 		+---------------------------------------+ 	old SP->| back chain to caller's caller		| 		+---------------------------------------+     The required alignment for V.4 is 16 bytes, or 8 bytes if -meabi is    given.  (But note below and in sysv4.h that we require only 8 and    may round up the size of our stack frame anyways.  The historical    reason is early versions of powerpc-linux which didn't properly    align the stack at program startup.  A happy side-effect is that    -mno-eabi libraries can be used with -meabi programs.)     The EABI configuration defaults to the V.4 layout.  However,    the stack alignment requirements may differ.  If -mno-eabi is not    given, the required stack alignment is 8 bytes; if -mno-eabi is    given, the required alignment is 16 bytes.  (But see V.4 comment    above.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ABI_STACK_BOUNDARY
end_ifndef

begin_define
define|#
directive|define
name|ABI_STACK_BOUNDARY
value|STACK_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|rs6000_stack_t
modifier|*
name|rs6000_stack_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|rs6000_stack_t
name|info
decl_stmt|,
name|zero_info
decl_stmt|;
name|rs6000_stack_t
modifier|*
name|info_ptr
init|=
operator|&
name|info
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|int
name|ehrd_size
decl_stmt|;
name|int
name|save_align
decl_stmt|;
name|HOST_WIDE_INT
name|non_fixed_size
decl_stmt|;
comment|/* Zero all fields portably.  */
name|info
operator|=
name|zero_info
expr_stmt|;
if|if
condition|(
name|TARGET_SPE
condition|)
block|{
comment|/* Cache value so we don't rescan instruction chain over and over.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|insn_chain_scanned_p
operator|==
literal|0
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|insn_chain_scanned_p
operator|=
literal|1
expr_stmt|;
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|=
operator|(
name|int
operator|)
name|spe_func_has_64bit_regs_p
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Select which calling sequence.  */
name|info_ptr
operator|->
name|abi
operator|=
name|DEFAULT_ABI
expr_stmt|;
comment|/* Calculate which registers need to be saved& save area size.  */
name|info_ptr
operator|->
name|first_gp_reg_save
operator|=
name|first_reg_to_save
argument_list|()
expr_stmt|;
comment|/* Assume that we will have to save RS6000_PIC_OFFSET_TABLE_REGNUM,       even if it currently looks like we won't.  */
if|if
condition|(
operator|(
operator|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|||
operator|(
name|flag_pic
operator|==
literal|1
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
operator|)
operator|&&
name|info_ptr
operator|->
name|first_gp_reg_save
operator|>
name|RS6000_PIC_OFFSET_TABLE_REGNUM
condition|)
name|info_ptr
operator|->
name|gp_size
operator|=
name|reg_size
operator|*
operator|(
literal|32
operator|-
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|gp_size
operator|=
name|reg_size
operator|*
operator|(
literal|32
operator|-
name|info_ptr
operator|->
name|first_gp_reg_save
operator|)
expr_stmt|;
comment|/* For the SPE, we have an additional upper 32-bits on each GPR.      Ideally we should save the entire 64-bits only when the upper      half is used in SIMD instructions.  Since we only record      registers live (not the size they are used in), this proves      difficult because we'd have to traverse the instruction chain at      the right time, taking reload into account.  This is a real pain,      so we opt to save the GPRs in 64-bits always if but one register      gets used in 64-bits.  Otherwise, all the registers in the frame      get saved in 32-bits.       So... since when we save all GPRs (except the SP) in 64-bits, the      traditional GP save area will be empty.  */
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|gp_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|first_fp_reg_save
operator|=
name|first_fp_reg_to_save
argument_list|()
expr_stmt|;
name|info_ptr
operator|->
name|fp_size
operator|=
literal|8
operator|*
operator|(
literal|64
operator|-
name|info_ptr
operator|->
name|first_fp_reg_save
operator|)
expr_stmt|;
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|=
name|first_altivec_reg_to_save
argument_list|()
expr_stmt|;
name|info_ptr
operator|->
name|altivec_size
operator|=
literal|16
operator|*
operator|(
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
operator|-
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|)
expr_stmt|;
comment|/* Does this function call anything?  */
name|info_ptr
operator|->
name|calls_p
operator|=
operator|(
operator|!
name|current_function_is_leaf
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ra_needs_full_frame
operator|)
expr_stmt|;
comment|/* Determine if we need to save the link register.  */
if|if
condition|(
name|rs6000_ra_ever_killed
argument_list|()
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|current_function_profile
operator|&&
operator|!
name|TARGET_PROFILE_KERNEL
operator|)
ifdef|#
directive|ifdef
name|TARGET_RELOCATABLE
operator|||
operator|(
name|TARGET_RELOCATABLE
operator|&&
operator|(
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
endif|#
directive|endif
operator|||
operator|(
name|info_ptr
operator|->
name|first_fp_reg_save
operator|!=
literal|64
operator|&&
operator|!
name|FP_SAVE_INLINE
argument_list|(
name|info_ptr
operator|->
name|first_fp_reg_save
argument_list|)
operator|)
operator|||
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|<=
name|LAST_ALTIVEC_REGNO
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|current_function_calls_alloca
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
operator|)
operator|||
name|info_ptr
operator|->
name|calls_p
condition|)
block|{
name|info_ptr
operator|->
name|lr_save_p
operator|=
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|LINK_REGISTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Determine if we need to save the condition code registers.  */
if|if
condition|(
name|regs_ever_live
index|[
name|CR2_REGNO
index|]
operator|||
name|regs_ever_live
index|[
name|CR3_REGNO
index|]
operator|||
name|regs_ever_live
index|[
name|CR4_REGNO
index|]
condition|)
block|{
name|info_ptr
operator|->
name|cr_save_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
name|info_ptr
operator|->
name|cr_size
operator|=
name|reg_size
expr_stmt|;
block|}
comment|/* If the current function calls __builtin_eh_return, then we need      to allocate stack space for registers that will hold data for      the exception handler.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
operator|!=
name|INVALID_REGNUM
condition|;
operator|++
name|i
control|)
continue|continue;
comment|/* SPE saves EH registers in 64-bits.  */
name|ehrd_size
operator|=
name|i
operator|*
operator|(
name|TARGET_SPE_ABI
operator|&&
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|?
name|UNITS_PER_SPE_WORD
else|:
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
else|else
name|ehrd_size
operator|=
literal|0
expr_stmt|;
comment|/* Determine various sizes.  */
name|info_ptr
operator|->
name|reg_size
operator|=
name|reg_size
expr_stmt|;
name|info_ptr
operator|->
name|fixed_size
operator|=
name|RS6000_SAVE_AREA
expr_stmt|;
name|info_ptr
operator|->
name|varargs_size
operator|=
name|RS6000_VARARGS_AREA
expr_stmt|;
name|info_ptr
operator|->
name|vars_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|get_frame_size
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|parm_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|current_function_outgoing_args_size
argument_list|,
name|TARGET_ALTIVEC
condition|?
literal|16
else|:
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|spe_gp_size
operator|=
literal|8
operator|*
operator|(
literal|32
operator|-
name|info_ptr
operator|->
name|first_gp_reg_save
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|spe_gp_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
name|info_ptr
operator|->
name|vrsave_mask
operator|=
name|compute_vrsave_mask
argument_list|()
expr_stmt|;
else|else
name|info_ptr
operator|->
name|vrsave_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_VRSAVE
operator|&&
name|info_ptr
operator|->
name|vrsave_mask
condition|)
name|info_ptr
operator|->
name|vrsave_size
operator|=
literal|4
expr_stmt|;
else|else
name|info_ptr
operator|->
name|vrsave_size
operator|=
literal|0
expr_stmt|;
comment|/* Calculate the offsets.  */
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
case|case
name|ABI_NONE
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
case|case
name|ABI_DARWIN
case|:
name|info_ptr
operator|->
name|fp_save_offset
operator|=
operator|-
name|info_ptr
operator|->
name|fp_size
expr_stmt|;
name|info_ptr
operator|->
name|gp_save_offset
operator|=
name|info_ptr
operator|->
name|fp_save_offset
operator|-
name|info_ptr
operator|->
name|gp_size
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
block|{
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|info_ptr
operator|->
name|vrsave_size
expr_stmt|;
comment|/* Align stack so vector save area is on a quadword boundary.  */
if|if
condition|(
name|info_ptr
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|16
operator|-
operator|(
operator|-
name|info_ptr
operator|->
name|vrsave_save_offset
operator|%
literal|16
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
name|info_ptr
operator|->
name|vrsave_save_offset
operator|-
name|info_ptr
operator|->
name|altivec_padding_size
operator|-
name|info_ptr
operator|->
name|altivec_size
expr_stmt|;
comment|/* Adjust for AltiVec case.  */
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|altivec_save_offset
operator|-
name|ehrd_size
expr_stmt|;
block|}
else|else
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|ehrd_size
expr_stmt|;
name|info_ptr
operator|->
name|cr_save_offset
operator|=
name|reg_size
expr_stmt|;
comment|/* first word when 64-bit.  */
name|info_ptr
operator|->
name|lr_save_offset
operator|=
literal|2
operator|*
name|reg_size
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
name|info_ptr
operator|->
name|fp_save_offset
operator|=
operator|-
name|info_ptr
operator|->
name|fp_size
expr_stmt|;
name|info_ptr
operator|->
name|gp_save_offset
operator|=
name|info_ptr
operator|->
name|fp_save_offset
operator|-
name|info_ptr
operator|->
name|gp_size
expr_stmt|;
name|info_ptr
operator|->
name|cr_save_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|info_ptr
operator|->
name|cr_size
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
comment|/* Align stack so SPE GPR save area is aligned on a            double-word boundary.  */
if|if
condition|(
name|info_ptr
operator|->
name|spe_gp_size
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|spe_padding_size
operator|=
literal|8
operator|-
operator|(
operator|-
name|info_ptr
operator|->
name|cr_save_offset
operator|%
literal|8
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|spe_padding_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|spe_gp_save_offset
operator|=
name|info_ptr
operator|->
name|cr_save_offset
operator|-
name|info_ptr
operator|->
name|spe_padding_size
operator|-
name|info_ptr
operator|->
name|spe_gp_size
expr_stmt|;
comment|/* Adjust for SPE case.  */
name|info_ptr
operator|->
name|toc_save_offset
operator|=
name|info_ptr
operator|->
name|spe_gp_save_offset
operator|-
name|info_ptr
operator|->
name|toc_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
block|{
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
name|info_ptr
operator|->
name|cr_save_offset
operator|-
name|info_ptr
operator|->
name|vrsave_size
expr_stmt|;
comment|/* Align stack so vector save area is on a quadword boundary.  */
if|if
condition|(
name|info_ptr
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|16
operator|-
operator|(
operator|-
name|info_ptr
operator|->
name|vrsave_save_offset
operator|%
literal|16
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
name|info_ptr
operator|->
name|vrsave_save_offset
operator|-
name|info_ptr
operator|->
name|altivec_padding_size
operator|-
name|info_ptr
operator|->
name|altivec_size
expr_stmt|;
comment|/* Adjust for AltiVec case.  */
name|info_ptr
operator|->
name|toc_save_offset
operator|=
name|info_ptr
operator|->
name|altivec_save_offset
operator|-
name|info_ptr
operator|->
name|toc_size
expr_stmt|;
block|}
else|else
name|info_ptr
operator|->
name|toc_save_offset
operator|=
name|info_ptr
operator|->
name|cr_save_offset
operator|-
name|info_ptr
operator|->
name|toc_size
expr_stmt|;
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|toc_save_offset
operator|-
name|ehrd_size
expr_stmt|;
name|info_ptr
operator|->
name|lr_save_offset
operator|=
name|reg_size
expr_stmt|;
break|break;
block|}
name|save_align
operator|=
operator|(
name|TARGET_ALTIVEC_ABI
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
name|info_ptr
operator|->
name|save_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|info_ptr
operator|->
name|fp_size
operator|+
name|info_ptr
operator|->
name|gp_size
operator|+
name|info_ptr
operator|->
name|altivec_size
operator|+
name|info_ptr
operator|->
name|altivec_padding_size
operator|+
name|info_ptr
operator|->
name|spe_gp_size
operator|+
name|info_ptr
operator|->
name|spe_padding_size
operator|+
name|ehrd_size
operator|+
name|info_ptr
operator|->
name|cr_size
operator|+
name|info_ptr
operator|->
name|lr_size
operator|+
name|info_ptr
operator|->
name|vrsave_size
operator|+
name|info_ptr
operator|->
name|toc_size
argument_list|,
name|save_align
argument_list|)
expr_stmt|;
name|non_fixed_size
operator|=
operator|(
name|info_ptr
operator|->
name|vars_size
operator|+
name|info_ptr
operator|->
name|parm_size
operator|+
name|info_ptr
operator|->
name|save_size
operator|+
name|info_ptr
operator|->
name|varargs_size
operator|)
expr_stmt|;
name|info_ptr
operator|->
name|total_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|non_fixed_size
operator|+
name|info_ptr
operator|->
name|fixed_size
argument_list|,
name|ABI_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Determine if we need to allocate any stack frame:       For AIX we need to push the stack if a frame pointer is needed      (because the stack might be dynamically adjusted), if we are      debugging, if we make calls, or if the sum of fp_save, gp_save,      and local variables are more than the space needed to save all      non-volatile registers: 32-bit: 18*8 + 19*4 = 220 or 64-bit: 18*8      + 18*8 = 288 (GPR13 reserved).       For V.4 we don't have the stack cushion that AIX uses, but assume      that the debugger can handle stackless frames.  */
if|if
condition|(
name|info_ptr
operator|->
name|calls_p
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
name|non_fixed_size
operator|!=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_pointer_needed
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_XCOFF
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
literal|1
expr_stmt|;
else|else
name|info_ptr
operator|->
name|push_p
operator|=
name|non_fixed_size
operator|>
operator|(
name|TARGET_32BIT
condition|?
literal|220
else|:
literal|288
operator|)
expr_stmt|;
comment|/* Zero offsets if we're not saving those registers.  */
if|if
condition|(
name|info_ptr
operator|->
name|fp_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|fp_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|gp_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|gp_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
operator|||
name|info_ptr
operator|->
name|altivec_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
operator|||
name|info_ptr
operator|->
name|vrsave_mask
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_SPE_ABI
operator|||
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|==
literal|0
operator|||
name|info_ptr
operator|->
name|spe_gp_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|spe_gp_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info_ptr
operator|->
name|lr_save_p
condition|)
name|info_ptr
operator|->
name|lr_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info_ptr
operator|->
name|cr_save_p
condition|)
name|info_ptr
operator|->
name|cr_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info_ptr
operator|->
name|toc_save_p
condition|)
name|info_ptr
operator|->
name|toc_save_offset
operator|=
literal|0
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Return true if the current function uses any GPRs in 64-bit SIMD    mode.  */
end_comment

begin_function
specifier|static
name|bool
name|spe_func_has_64bit_regs_p
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insns
decl_stmt|,
name|insn
decl_stmt|;
comment|/* Functions that save and restore all the call-saved registers will      need to save/restore the registers in 64-bits.  */
if|if
condition|(
name|current_function_calls_eh_return
operator|||
name|current_function_calls_setjmp
operator|||
name|current_function_has_nonlocal_goto
condition|)
return|return
name|true
return|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insns
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|i
decl_stmt|;
name|i
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|SET
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_stack_info
parameter_list|(
name|rs6000_stack_t
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|abi_string
decl_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
name|info
operator|=
name|rs6000_stack_info
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nStack information for function %s:\n"
argument_list|,
operator|(
operator|(
name|current_function_decl
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
else|:
literal|"<unknown>"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|abi
condition|)
block|{
default|default:
name|abi_string
operator|=
literal|"Unknown"
expr_stmt|;
break|break;
case|case
name|ABI_NONE
case|:
name|abi_string
operator|=
literal|"NONE"
expr_stmt|;
break|break;
case|case
name|ABI_AIX
case|:
name|abi_string
operator|=
literal|"AIX"
expr_stmt|;
break|break;
case|case
name|ABI_DARWIN
case|:
name|abi_string
operator|=
literal|"Darwin"
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
name|abi_string
operator|=
literal|"V.4"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tABI                 = %5s\n"
argument_list|,
name|abi_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tALTIVEC ABI extensions enabled.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tSPE ABI extensions enabled.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_gp_reg_save
operator|!=
literal|32
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_gp_reg_save   = %5d\n"
argument_list|,
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_fp_reg_save   = %5d\n"
argument_list|,
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_altivec_reg_save
operator|<=
name|LAST_ALTIVEC_REGNO
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_altivec_reg_save = %5d\n"
argument_list|,
name|info
operator|->
name|first_altivec_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlr_save_p           = %5d\n"
argument_list|,
name|info
operator|->
name|lr_save_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_save_p           = %5d\n"
argument_list|,
name|info
operator|->
name|cr_save_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|toc_save_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttoc_save_p          = %5d\n"
argument_list|,
name|info
operator|->
name|toc_save_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_mask
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_mask         = 0x%x\n"
argument_list|,
name|info
operator|->
name|vrsave_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|push_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tpush_p              = %5d\n"
argument_list|,
name|info
operator|->
name|push_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|calls_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcalls_p             = %5d\n"
argument_list|,
name|info
operator|->
name|calls_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|gp_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tgp_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|gp_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fp_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfp_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|fp_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_save_offset = %5d\n"
argument_list|,
name|info
operator|->
name|altivec_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|spe_gp_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tspe_gp_save_offset  = %5d\n"
argument_list|,
name|info
operator|->
name|spe_gp_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_save_offset  = %5d\n"
argument_list|,
name|info
operator|->
name|vrsave_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlr_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|lr_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|cr_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|toc_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttoc_save_offset     = %5d\n"
argument_list|,
name|info
operator|->
name|toc_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|varargs_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvarargs_save_offset = %5d\n"
argument_list|,
name|info
operator|->
name|varargs_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|total_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttotal_size          = "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|info
operator|->
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|varargs_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvarargs_size        = %5d\n"
argument_list|,
name|info
operator|->
name|varargs_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vars_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvars_size           = "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|info
operator|->
name|vars_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|parm_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tparm_size           = %5d\n"
argument_list|,
name|info
operator|->
name|parm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fixed_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfixed_size          = %5d\n"
argument_list|,
name|info
operator|->
name|fixed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|gp_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tgp_size             = %5d\n"
argument_list|,
name|info
operator|->
name|gp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|spe_gp_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tspe_gp_size         = %5d\n"
argument_list|,
name|info
operator|->
name|spe_gp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fp_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfp_size             = %5d\n"
argument_list|,
name|info
operator|->
name|fp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_size        = %5d\n"
argument_list|,
name|info
operator|->
name|altivec_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_size         = %5d\n"
argument_list|,
name|info
operator|->
name|vrsave_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_padding_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_padding_size= %5d\n"
argument_list|,
name|info
operator|->
name|altivec_padding_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|spe_padding_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tspe_padding_size    = %5d\n"
argument_list|,
name|info
operator|->
name|spe_padding_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlr_size             = %5d\n"
argument_list|,
name|info
operator|->
name|lr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_size             = %5d\n"
argument_list|,
name|info
operator|->
name|cr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|toc_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttoc_size            = %5d\n"
argument_list|,
name|info
operator|->
name|toc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|save_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsave_size           = %5d\n"
argument_list|,
name|info
operator|->
name|save_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|reg_size
operator|!=
literal|4
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\treg_size            = %5d\n"
argument_list|,
name|info
operator|->
name|reg_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|rs6000_return_addr
parameter_list|(
name|int
name|count
parameter_list|,
name|rtx
name|frame
parameter_list|)
block|{
comment|/* Currently we don't optimize very well between prolog and body      code and for PIC code the code can be actually quite bad, so      don't try to be too clever here.  */
if|if
condition|(
name|count
operator|!=
literal|0
operator|||
operator|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|flag_pic
operator|)
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|ra_needs_full_frame
operator|=
literal|1
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|copy_to_reg
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|frame
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|RETURN_ADDRESS_OFFSET
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|cfun
operator|->
name|machine
operator|->
name|ra_need_lr
operator|=
literal|1
expr_stmt|;
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Say whether a function is a candidate for sibcall handling or not.    We do not allow indirect calls to be optimized into sibling calls.    Also, we can't do it if there are any vector parameters; there's    nowhere to put the VRsave code so it works; note that functions with    vector parameters are required to have a prototype, so the argument    type info must be available here.  (The tail recursion case can work    with vector parameters, but there's no way to distinguish here.) */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
if|if
condition|(
name|TARGET_ALTIVEC_VRSAVE
condition|)
block|{
for|for
control|(
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|type
condition|;
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|||
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|attr_list
init|=
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"longcall"
argument_list|,
name|attr_list
argument_list|)
operator|||
name|lookup_attribute
argument_list|(
literal|"shortcall"
argument_list|,
name|attr_list
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rs6000_ra_ever_killed
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|top
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|current_function_is_thunk
condition|)
return|return
literal|0
return|;
comment|/* regs_ever_live has LR marked as used if any sibcalls are present,      but this should not force saving and restoring in the      pro/epilogue.  Likewise, reg_set_between_p thinks a sibcall      clobbers LR, so that is inappropriate.  */
comment|/* Also, the prologue can generate a store into LR that      doesn't really count, like this:          move LR->R0         bcl to set PIC register         move LR->R31         move R0->LR       When we're called from the epilogue, we need to avoid counting      this as a store.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|top
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|top
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|FIND_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|reg
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|set_of
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|prologue_epilogue_contains
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a REG_MAYBE_DEAD note to the insn.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_maybe_dead
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit instructions needed to load the TOC register.    This is only needed when TARGET_TOC, TARGET_MINIMAL_TOC, and there is    a constant pool; or for SVR4 -fpic.  */
end_comment

begin_function
name|void
name|rs6000_emit_load_toc_table
parameter_list|(
name|int
name|fromprolog
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|insn
decl_stmt|;
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RS6000_PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|rtx
name|temp
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_v4_pic_si
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ELF
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|rtx
name|tempLR
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|temp0
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
comment|/* possibly create the toc section */
if|if
condition|(
operator|!
name|toc_initialized
condition|)
block|{
name|toc_section
argument_list|()
expr_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fromprolog
condition|)
block|{
name|rtx
name|symF
decl_stmt|,
name|symL
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCF"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|symF
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCL"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|symL
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1
argument_list|(
name|tempLR
argument_list|,
name|symF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|tempLR
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_2
argument_list|(
name|temp0
argument_list|,
name|dest
argument_list|,
name|symL
argument_list|,
name|symF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tocsym
decl_stmt|;
name|tocsym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|toc_label_name
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1b
argument_list|(
name|tempLR
argument_list|,
name|tocsym
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|tempLR
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp0
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dest
argument_list|,
name|temp0
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ELF
operator|&&
operator|!
name|TARGET_AIX
operator|&&
name|flag_pic
operator|==
literal|0
operator|&&
name|TARGET_MINIMAL_TOC
condition|)
block|{
comment|/* This is for AIX code running in non-PIC ELF32.  */
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|rtx
name|realsym
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCTOC"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|realsym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|dest
argument_list|,
name|realsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|dest
argument_list|,
name|dest
argument_list|,
name|realsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
if|if
condition|(
name|TARGET_32BIT
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_aix_si
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_aix_di
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit instructions to restore the link register after determining where    its value has been stored.  */
end_comment

begin_function
name|void
name|rs6000_emit_eh_reg_restore
parameter_list|(
name|rtx
name|source
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|source
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|scratch
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|frame_rtx
init|=
name|stack_pointer_rtx
decl_stmt|;
name|HOST_WIDE_INT
name|sp_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
operator|||
name|current_function_calls_alloca
operator|||
name|info
operator|->
name|total_size
operator|>
literal|32767
condition|)
block|{
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|frame_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|frame_rtx
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|push_p
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|frame_rtx
argument_list|,
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|set
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|get_TOC_alias_set
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|set
operator|==
operator|-
literal|1
condition|)
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* This returns nonzero if the current function uses the TOC.  This is    determined by the presence of (use (unspec ... UNSPEC_TOC)), which    is generated by the ABI_V4 load_toc_* patterns.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_function
specifier|static
name|int
name|uses_TOC
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|USE
condition|)
block|{
name|sub
operator|=
name|XEXP
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TOC
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|rtx
name|create_TOC_reference
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|TOC_REGISTER
argument_list|)
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|symbol
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|toc_label_name
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If _Unwind_* has been called from within the same module,    toc register is not guaranteed to be saved to 40(1) on function    entry.  Save it there in that case.  */
end_comment

begin_function
name|void
name|rs6000_aix_emit_builtin_unwind_init
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|mem
decl_stmt|;
name|rtx
name|stack_top
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|opcode_addr
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|opcode
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|tocompare
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|no_toc_save_needed
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|stack_top
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_top
argument_list|,
name|GEN_INT
argument_list|(
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|opcode_addr
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|opcode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|opcode_addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tocompare
argument_list|,
name|gen_int_mode
argument_list|(
name|TARGET_32BIT
condition|?
literal|0x80410014
else|:
literal|0xE8410028
argument_list|,
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|opcode
argument_list|,
name|tocompare
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|SImode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|no_toc_save_needed
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_top
argument_list|,
name|GEN_INT
argument_list|(
literal|5
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|no_toc_save_needed
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This ties together stack memory (MEM with an alias set of    rs6000_sr_alias_set) and the change to the stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_emit_stack_tie
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_stack_tie
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the correct code for allocating stack space, as insns.    If COPY_R12, make sure a copy of the old frame is left in r12.    The generated code may use hard register 0 as a temporary.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_emit_allocate_stack
parameter_list|(
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|copy_r12
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|stack_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|tmp_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|todec
init|=
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_function_limit_stack
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|>
literal|1
operator|&&
name|REGNO
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|<=
literal|31
condition|)
block|{
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|tmp_reg
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|tmp_reg
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cond_trap
argument_list|(
name|LTU
argument_list|,
name|stack_reg
argument_list|,
name|tmp_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|TARGET_32BIT
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
name|rtx
name|toload
init|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|tmp_reg
argument_list|,
name|toload
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|tmp_reg
argument_list|,
name|tmp_reg
argument_list|,
name|toload
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cond_trap
argument_list|(
name|LTU
argument_list|,
name|stack_reg
argument_list|,
name|tmp_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"stack limit expression is not supported"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_r12
operator|||
operator|!
name|TARGET_UPDATE
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
argument_list|,
name|stack_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_UPDATE
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|32767
condition|)
block|{
comment|/* Need a note here so that try_split doesn't get confused.  */
if|if
condition|(
name|get_last_insn
argument_list|()
operator|==
name|NULL_RTX
condition|)
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|tmp_reg
argument_list|,
name|todec
argument_list|)
expr_stmt|;
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|todec
operator|=
name|tmp_reg
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_movsi_update
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|,
name|stack_reg
argument_list|)
else|:
name|gen_movdi_update
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|,
name|stack_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|stack_reg
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced    with (plus:P (reg 1) VAL), and with REG2 replaced with RREG if REG2    is not NULL.  It would be nice if dwarf2out_frame_debug_expr could    deduce these equivalences by itself so it wasn't necessary to hold    its hand so much.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_frame_related
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|,
name|rtx
name|reg2
parameter_list|,
name|rtx
name|rreg
parameter_list|)
block|{
name|rtx
name|real
decl_stmt|,
name|temp
decl_stmt|;
comment|/* copy_rtx will not make unique copies of registers, so we need to      ensure we don't have unwanted sharing here.  */
if|if
condition|(
name|reg
operator|==
name|reg2
condition|)
name|reg
operator|=
name|gen_raw_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|rreg
condition|)
name|reg
operator|=
name|gen_raw_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|real
operator|=
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg2
operator|!=
name|NULL_RTX
condition|)
name|real
operator|=
name|replace_rtx
argument_list|(
name|real
argument_list|,
name|reg2
argument_list|,
name|rreg
argument_list|)
expr_stmt|;
name|real
operator|=
name|replace_rtx
argument_list|(
name|real
argument_list|,
name|reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We expect that 'real' is either a SET or a PARALLEL containing      SETs (and possibly other stuff).  In a PARALLEL, all the SETs      are important so they all have to be marked RTX_FRAME_RELATED_P.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|real
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|set
init|=
name|real
decl_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|real
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|real
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|real
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|real
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|set
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_SPE
condition|)
name|real
operator|=
name|spe_synthesize_frame_save
argument_list|(
name|real
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|real
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an SPE frame note, return a PARALLEL of SETs with the    original note, plus a synthetic register save.  */
end_comment

begin_function
specifier|static
name|rtx
name|spe_synthesize_frame_save
parameter_list|(
name|rtx
name|real
parameter_list|)
block|{
name|rtx
name|synth
decl_stmt|,
name|offset
decl_stmt|,
name|reg
decl_stmt|,
name|real2
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|real
argument_list|)
operator|!=
name|SET
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|real
argument_list|)
argument_list|)
operator|!=
name|V2SImode
condition|)
return|return
name|real
return|;
comment|/* For the SPE, registers saved in 64-bits, get a PARALLEL for their      frame related note.  The parallel contains a set of the register      being saved, and another set to a synthetic register (n+1200).      This is so we can differentiate between 64-bit and 32-bit saves.      Words cannot describe this nastiness.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|real
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|real
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|real
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Transform:        (set (mem (plus (reg x) (const y)))             (reg z))      into:        (set (mem (plus (reg x) (const y+4)))             (reg z+1200))   */
name|real2
operator|=
name|copy_rtx
argument_list|(
name|real
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|real2
argument_list|)
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SET_SRC
argument_list|(
name|real2
argument_list|)
expr_stmt|;
name|real2
operator|=
name|replace_rtx
argument_list|(
name|real2
argument_list|,
name|reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|synth
operator|=
name|copy_rtx
argument_list|(
name|real2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|real2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|real2
operator|=
name|replace_rtx
argument_list|(
name|real2
argument_list|,
name|offset
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|SET_SRC
argument_list|(
name|synth
argument_list|)
expr_stmt|;
name|synth
operator|=
name|replace_rtx
argument_list|(
name|synth
argument_list|,
name|reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
literal|1200
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|synth
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|synth
operator|=
name|replace_rtx
argument_list|(
name|synth
argument_list|,
name|offset
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|+
operator|(
name|BYTES_BIG_ENDIAN
condition|?
literal|0
else|:
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|synth
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|real2
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|real
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|synth
argument_list|,
name|real2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|real
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|real2
argument_list|,
name|synth
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|real
return|;
block|}
end_function

begin_comment
comment|/* Returns an insn that has a vrsave set operation with the    appropriate CLOBBERs.  */
end_comment

begin_function
specifier|static
name|rtx
name|generate_set_vrsave
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rs6000_stack_t
modifier|*
name|info
parameter_list|,
name|int
name|epiloguep
parameter_list|)
block|{
name|int
name|nclobs
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|clobs
index|[
name|TOTAL_ALTIVEC_REGS
operator|+
literal|1
index|]
decl_stmt|;
name|rtx
name|vrsave
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|VRSAVE_REGNO
argument_list|)
decl_stmt|;
name|clobs
index|[
literal|0
index|]
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|vrsave
argument_list|,
name|gen_rtx_UNSPEC_VOLATILE
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|reg
argument_list|,
name|vrsave
argument_list|)
argument_list|,
literal|30
argument_list|)
argument_list|)
expr_stmt|;
name|nclobs
operator|=
literal|1
expr_stmt|;
comment|/* We need to clobber the registers in the mask so the scheduler      does not move sets to VRSAVE before sets of AltiVec registers.       However, if the function receives nonlocal gotos, reload will set      all call saved registers live.  We will end up with:       	(set (reg 999) (mem)) 	(parallel [ (set (reg vrsave) (unspec blah)) 		    (clobber (reg 999))])       The clobber will cause the store into reg 999 to be dead, and      flow will attempt to delete an epilogue insn.  In this case, we      need an unspec use/set of the register.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|epiloguep
operator|||
name|call_used_regs
index|[
name|i
index|]
condition|)
name|clobs
index|[
name|nclobs
operator|++
index|]
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|clobs
index|[
name|nclobs
operator|++
index|]
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|27
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nclobs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nclobs
condition|;
operator|++
name|i
control|)
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|clobs
index|[
name|i
index|]
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Save a register into the frame, and emit RTX_FRAME_RELATED_P notes.    Save REGNO into [FRAME_REG + OFFSET] in mode MODE.  */
end_comment

begin_function
specifier|static
name|void
name|emit_frame_save
parameter_list|(
name|rtx
name|frame_reg
parameter_list|,
name|rtx
name|frame_ptr
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|int
name|offset
parameter_list|,
name|HOST_WIDE_INT
name|total_size
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|,
name|offset_rtx
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|,
name|addr
decl_stmt|,
name|int_rtx
decl_stmt|;
name|rtx
name|replacea
decl_stmt|,
name|replaceb
decl_stmt|;
name|int_rtx
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* Some cases that need register indexed addressing.  */
if|if
condition|(
operator|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|TARGET_SPE_ABI
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
operator|)
condition|)
block|{
comment|/* Whomever calls us must make sure r11 is available in the          flow path of instructions in the prologue.  */
name|offset_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset_rtx
argument_list|,
name|int_rtx
argument_list|)
expr_stmt|;
name|replacea
operator|=
name|offset_rtx
expr_stmt|;
name|replaceb
operator|=
name|int_rtx
expr_stmt|;
block|}
else|else
block|{
name|offset_rtx
operator|=
name|int_rtx
expr_stmt|;
name|replacea
operator|=
name|NULL_RTX
expr_stmt|;
name|replaceb
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr
argument_list|,
name|total_size
argument_list|,
name|replacea
argument_list|,
name|replaceb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an offset memory reference suitable for a frame store, while    converting to a valid addressing mode.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_frame_mem_offset
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|rtx
name|int_rtx
decl_stmt|,
name|offset_rtx
decl_stmt|;
name|int_rtx
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|offset_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FIXED_SCRATCH
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset_rtx
argument_list|,
name|int_rtx
argument_list|)
expr_stmt|;
block|}
else|else
name|offset_rtx
operator|=
name|int_rtx
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit function prologue as insns.  */
end_comment

begin_function
name|void
name|rs6000_emit_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|Pmode
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|rtx
name|sp_reg_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|frame_ptr_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|rtx
name|frame_reg_rtx
init|=
name|sp_reg_rtx
decl_stmt|;
name|rtx
name|cr_save_rtx
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|saving_FPRs_inline
decl_stmt|;
name|int
name|using_store_multiple
decl_stmt|;
name|HOST_WIDE_INT
name|sp_offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
name|reg_mode
operator|=
name|V2SImode
expr_stmt|;
name|reg_size
operator|=
literal|8
expr_stmt|;
block|}
name|using_store_multiple
operator|=
operator|(
name|TARGET_MULTIPLE
operator|&&
operator|!
name|TARGET_POWERPC64
operator|&&
operator|(
operator|!
name|TARGET_SPE_ABI
operator|||
name|info
operator|->
name|spe_64bit_regs_used
operator|==
literal|0
operator|)
operator|&&
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|31
operator|)
expr_stmt|;
name|saving_FPRs_inline
operator|=
operator|(
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|||
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
operator|||
name|current_function_calls_eh_return
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ra_need_lr
operator|)
expr_stmt|;
comment|/* For V.4, update stack before we do any saving and set back pointer.  */
if|if
condition|(
name|info
operator|->
name|push_p
operator|&&
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|||
name|current_function_calls_eh_return
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|total_size
operator|<
literal|32767
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
else|else
name|frame_reg_rtx
operator|=
name|frame_ptr_rtx
expr_stmt|;
name|rs6000_emit_allocate_stack
argument_list|(
name|info
operator|->
name|total_size
argument_list|,
operator|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
operator|&&
operator|(
name|info
operator|->
name|cr_save_p
operator|||
name|info
operator|->
name|lr_save_p
operator|||
name|info
operator|->
name|first_fp_reg_save
operator|<
literal|64
operator|||
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|32
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
condition|)
name|rs6000_emit_stack_tie
argument_list|()
expr_stmt|;
block|}
comment|/* Save AltiVec registers if needed.  */
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|info
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* There should be a non inline version of this, for when we 	 are saving lots of vector registers.  */
for|for
control|(
name|i
operator|=
name|info
operator|->
name|first_altivec_reg_save
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|rtx
name|areg
decl_stmt|,
name|savereg
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|info
operator|->
name|altivec_save_offset
operator|+
name|sp_offset
operator|+
literal|16
operator|*
operator|(
name|i
operator|-
name|info
operator|->
name|first_altivec_reg_save
operator|)
expr_stmt|;
name|savereg
operator|=
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|areg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|areg
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* AltiVec addressing mode is [reg+reg].  */
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|areg
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|savereg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|areg
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* VRSAVE is a bit vector representing which AltiVec registers      are used.  The OS uses this to determine which vector      registers to save on a context switch.  We need to save      VRSAVE on the stack frame, add whatever AltiVec registers we      used in this function, and do the corresponding magic in the      epilogue.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_VRSAVE
operator|&&
name|info
operator|->
name|vrsave_mask
operator|!=
literal|0
condition|)
block|{
name|rtx
name|reg
decl_stmt|,
name|mem
decl_stmt|,
name|vrsave
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* Get VRSAVE onto a GPR.  Note that ABI_V4 might be using r12 	 as frame_reg_rtx and r11 as the static chain pointer for 	 nested functions.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vrsave
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|VRSAVE_REGNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MACHO
condition|)
name|emit_insn
argument_list|(
name|gen_get_vrsave_internal
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|vrsave
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save VRSAVE.  */
name|offset
operator|=
name|info
operator|->
name|vrsave_save_offset
operator|+
name|sp_offset
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Include the registers in the mask.  */
name|emit_insn
argument_list|(
name|gen_iorsi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|info
operator|->
name|vrsave_mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|generate_set_vrsave
argument_list|(
name|reg
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we use the link register, get it into r0.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we need to save CR, put it into r12.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
operator|&&
name|frame_reg_rtx
operator|!=
name|frame_ptr_rtx
condition|)
block|{
name|cr_save_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movesi_from_cr
argument_list|(
name|cr_save_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do any required saving of fpr's.  If only one or two to save, do      it ourselves.  Otherwise, call function.  */
if|if
condition|(
name|saving_FPRs_inline
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|)
condition|)
name|emit_frame_save
argument_list|(
name|frame_reg_rtx
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|,
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|,
name|info
operator|->
name|total_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|rname
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|alloc_rname
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
operator|+
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rname
argument_list|,
literal|"%s%d%s"
argument_list|,
name|SAVE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|SAVE_FP_SUFFIX
argument_list|)
expr_stmt|;
name|alloc_rname
operator|=
name|ggc_strdup
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|alloc_rname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Save GPRs.  This is done as a PARALLEL if we are using      the store-multiple instructions.  */
if|if
condition|(
name|using_store_multiple
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|&&
operator|(
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|)
operator|)
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
init|=
name|info
operator|->
name|spe_gp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
decl_stmt|;
name|rtx
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|b
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FIXED_SCRATCH
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|b
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|V2SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|CONST_INT
condition|)
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|b
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* ??? There's no need to emit actual instructions here, but it's the      easiest way to get the frame unwind information emitted.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
comment|/* In AIX ABI we need to pretend we save r2 here.  */
if|if
condition|(
name|TARGET_AIX
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
operator|+
literal|5
operator|*
name|reg_size
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_blockage
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|regno
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|emit_frame_save
argument_list|(
name|frame_reg_rtx
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|reg_mode
argument_list|,
name|regno
argument_list|,
name|info
operator|->
name|ehrd_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
operator|(
name|int
operator|)
name|i
argument_list|,
name|info
operator|->
name|total_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save lr if we used it.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* This should not be of rs6000_sr_alias_set, because of 	 __builtin_return_address.  */
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save CR if we use any that must be preserved.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|cr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
comment|/* If r12 was used to hold the original sp, copy cr into r0 now 	 that it's free.  */
if|if
condition|(
name|REGNO
argument_list|(
name|frame_reg_rtx
argument_list|)
operator|==
literal|12
condition|)
block|{
name|cr_save_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movesi_from_cr
argument_list|(
name|cr_save_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|cr_save_rtx
argument_list|)
expr_stmt|;
comment|/* Now, there's no way that dwarf2out_frame_debug_expr is going 	 to understand '(unspec:SI [(reg:CC 68) ...] UNSPEC_MOVESI_FROM_CR)'. 	 But that's OK.  All we have to do is specify that _one_ condition 	 code register is saved in this stack slot.  The thrower's epilogue 	 will then restore all the call-saved registers. 	 We use CR2_REGNO (70) to be compatible with gcc-2.95 on Linux.  */
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|cr_save_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|CR2_REGNO
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update stack and set back pointer unless this is V.4,       for which it was done previously.  */
if|if
condition|(
name|info
operator|->
name|push_p
operator|&&
operator|!
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|||
name|current_function_calls_eh_return
operator|)
condition|)
name|rs6000_emit_allocate_stack
argument_list|(
name|info
operator|->
name|total_size
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Set frame pointer, if needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|sp_reg_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are using RS6000_PIC_OFFSET_TABLE_REGNUM, we need to set it up.  */
if|if
condition|(
operator|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|&&
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|==
literal|1
operator|&&
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|)
condition|)
block|{
comment|/* If emit_load_toc_table will use the link register, we need to save        it.  We use R12 for this purpose because emit_load_toc_table        can use register 0.  This allows us to use a plain 'blr' to return        from the procedure more often.  */
name|int
name|save_LR_around_toc_setup
init|=
operator|(
name|TARGET_ELF
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|flag_pic
operator|&&
operator|!
name|info
operator|->
name|lr_save_p
operator|&&
name|EXIT_BLOCK_PTR
operator|->
name|pred
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|save_LR_around_toc_setup
condition|)
block|{
name|rtx
name|lr
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
decl_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|frame_ptr_rtx
argument_list|,
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_emit_load_toc_table
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|lr
argument_list|,
name|frame_ptr_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|rs6000_emit_load_toc_table
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
condition|)
block|{
name|rtx
name|dest
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|picbase
init|=
name|machopic_function_base_name
argument_list|()
decl_stmt|;
name|rtx
name|src
init|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|picbase
argument_list|)
decl_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_macho_picbase
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RS6000_PIC_OFFSET_TABLE_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_stack_info
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Write .extern for any function we will call to save and restore      fp values.  */
if|if
condition|(
name|info
operator|->
name|first_fp_reg_save
operator|<
literal|64
operator|&&
operator|!
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.extern %s%d%s\n\t.extern %s%d%s\n"
argument_list|,
name|SAVE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|SAVE_FP_SUFFIX
argument_list|,
name|RESTORE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|RESTORE_FP_SUFFIX
argument_list|)
expr_stmt|;
comment|/* Write .extern for AIX common mode routines, if needed.  */
if|if
condition|(
operator|!
name|TARGET_POWER
operator|&&
operator|!
name|TARGET_POWERPC
operator|&&
operator|!
name|common_mode_defined
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.extern __mulh\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __mull\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __divss\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __divus\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __quoss\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __quous\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|common_mode_defined
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HAVE_prologue
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* A NOTE_INSN_DELETED is supposed to be at the start and end of 	 the "toplevel" insn chain.  */
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|rs6000_emit_prologue
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Expand INSN_ADDRESSES so final() doesn't crash.  */
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|addr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_rtx_list
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|file
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
name|rs6000_pic_labelno
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit function epilogue as insns.     At present, dwarf2out_frame_debug_expr doesn't understand    register restores, so we don't bother setting RTX_FRAME_RELATED_P    anywhere in the epilogue.  Most of the insns below would in any case    need special notes to explain where r11 is in relation to the stack.  */
end_comment

begin_function
name|void
name|rs6000_emit_epilogue
parameter_list|(
name|int
name|sibcall
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
decl_stmt|;
name|int
name|restoring_FPRs_inline
decl_stmt|;
name|int
name|using_load_multiple
decl_stmt|;
name|int
name|using_mfcr_multiple
decl_stmt|;
name|int
name|use_backchain_to_restore_sp
decl_stmt|;
name|int
name|sp_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|sp_reg_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|frame_reg_rtx
init|=
name|sp_reg_rtx
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|Pmode
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|int
name|i
decl_stmt|;
name|info
operator|=
name|rs6000_stack_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
name|reg_mode
operator|=
name|V2SImode
expr_stmt|;
name|reg_size
operator|=
literal|8
expr_stmt|;
block|}
name|using_load_multiple
operator|=
operator|(
name|TARGET_MULTIPLE
operator|&&
operator|!
name|TARGET_POWERPC64
operator|&&
operator|(
operator|!
name|TARGET_SPE_ABI
operator|||
name|info
operator|->
name|spe_64bit_regs_used
operator|==
literal|0
operator|)
operator|&&
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|31
operator|)
expr_stmt|;
name|restoring_FPRs_inline
operator|=
operator|(
name|sibcall
operator|||
name|current_function_calls_eh_return
operator|||
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|||
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
operator|)
expr_stmt|;
name|use_backchain_to_restore_sp
operator|=
operator|(
name|frame_pointer_needed
operator|||
name|current_function_calls_alloca
operator|||
name|info
operator|->
name|total_size
operator|>
literal|32767
operator|)
expr_stmt|;
name|using_mfcr_multiple
operator|=
operator|(
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC601
operator|||
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC603
operator|||
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC750
operator|||
name|optimize_size
operator|)
expr_stmt|;
comment|/* If we have a frame pointer, a call to alloca,  or a large stack      frame, restore the old stack pointer using the backchain.  Otherwise,      we know what size to update it with.  */
if|if
condition|(
name|use_backchain_to_restore_sp
condition|)
block|{
comment|/* Under V.4, don't reset the stack pointer until after we're done 	 loading the saved registers.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
name|frame_reg_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|frame_reg_rtx
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|sp_reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|push_p
condition|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|||
name|current_function_calls_eh_return
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
else|else
block|{
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|total_size
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|total_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore AltiVec registers if needed.  */
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|info
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|first_altivec_reg_save
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|areg
decl_stmt|,
name|mem
decl_stmt|;
name|areg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|areg
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|altivec_save_offset
operator|+
name|sp_offset
operator|+
literal|16
operator|*
operator|(
name|i
operator|-
name|info
operator|->
name|first_altivec_reg_save
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* AltiVec addressing mode is [reg+reg].  */
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|areg
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|V4SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore VRSAVE if needed.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_VRSAVE
operator|&&
name|info
operator|->
name|vrsave_mask
operator|!=
literal|0
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|,
name|reg
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|vrsave_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|generate_set_vrsave
argument_list|(
name|reg
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the old lr if we saved it.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_frame_mem_offset
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Get the old cr if we saved it.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|cr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Set LR here to try to overlap restores below.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load exception handler data registers, if needed.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
if|if
condition|(
name|TARGET_AIX
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
operator|+
literal|5
operator|*
name|reg_size
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
literal|2
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|mem
decl_stmt|;
name|regno
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|mem
operator|=
name|gen_frame_mem_offset
argument_list|(
name|reg_mode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|info
operator|->
name|ehrd_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore GPRs.  This is done as a PARALLEL if we are using      the load-multiple instructions.  */
if|if
condition|(
name|using_load_multiple
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|&&
operator|(
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|)
operator|)
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* Restore 64-bit quantities for SPE.  */
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
init|=
name|info
operator|->
name|spe_gp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
decl_stmt|;
name|rtx
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|b
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FIXED_SCRATCH
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|b
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|V2SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Restore fpr's if we need to do it without calling a function.  */
if|if
condition|(
name|restoring_FPRs_inline
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* If we saved cr, restore it here.  Just those that were used.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|r12_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|using_mfcr_multiple
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|using_mfcr_multiple
operator|&&
name|count
operator|>
literal|1
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
block|{
name|rtvec
name|r
init|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|r12_rtx
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
literal|1
operator|<<
operator|(
literal|7
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|ndx
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
operator|+
name|i
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|CCmode
argument_list|,
name|r
argument_list|,
name|UNSPEC_MOVESI_TO_CR
argument_list|)
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|!=
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi_to_cr_one
argument_list|(
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
operator|+
name|i
argument_list|)
argument_list|,
name|r12_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is V.4, unwind the stack pointer after all of the loads      have been done.  We need to emit a block here so that sched      doesn't decide to move the sp change before the register restores      (which may not have any obvious dependency on the stack).  This      doesn't hurt performance, because there is no scheduling that can      be done after this point.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|||
name|current_function_calls_eh_return
condition|)
block|{
if|if
condition|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
condition|)
name|rs6000_emit_stack_tie
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_backchain_to_restore_sp
condition|)
block|{
name|emit_move_insn
argument_list|(
name|sp_reg_rtx
argument_list|,
name|frame_reg_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp_offset
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|rtx
name|sa
init|=
name|EH_RETURN_STACKADJ_RTX
decl_stmt|;
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|sa
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sibcall
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|restoring_FPRs_inline
condition|)
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|3
operator|+
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have to restore more than two FP registers, branch to the 	 restore function.  It will return to our caller.  */
if|if
condition|(
operator|!
name|restoring_FPRs_inline
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|rname
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|alloc_rname
decl_stmt|;
name|sprintf
argument_list|(
name|rname
argument_list|,
literal|"%s%d%s"
argument_list|,
name|RESTORE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|RESTORE_FP_SUFFIX
argument_list|)
expr_stmt|;
name|alloc_rname
operator|=
name|ggc_strdup
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|alloc_rname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|rs6000_sr_alias_set
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|3
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_epilogue
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write anything except 	 the trace table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
comment|/* This is slightly ugly, but at least we don't have two 	     copies of the epilogue-emitting code.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* A NOTE_INSN_DELETED is supposed to be at the start 	     and end of the "toplevel" insn chain.  */
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|rs6000_emit_epilogue
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Expand INSN_ADDRESSES so final() doesn't crash.  */
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|addr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_rtx_list
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|file
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
if|#
directive|if
name|TARGET_MACHO
name|macho_branch_islands
argument_list|()
expr_stmt|;
comment|/* Mach-O doesn't support labels at the end of objects, so if      it looks like we might want one, insert a NOP.  */
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|insn
operator|&&
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED_LABEL
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
operator|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
operator|)
condition|)
name|fputs
argument_list|(
literal|"\tnop\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Output a traceback table here.  See /usr/include/sys/debug.h for info      on its format.       We don't output a traceback table if -finhibit-size-directive was      used.  The documentation for -finhibit-size-directive reads      ``don't output a @code{.size} assembler directive, or anything      else that would cause trouble if the function is split in the      middle, and the two halves are placed at locations far apart in      memory.''  The traceback table has this property, since it      includes the offset from the start of the function to the      traceback table itself.       System V.4 Powerpc's (and the embedded ABI derived from it) use a      different traceback table.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
operator|!
name|flag_inhibit_size_directive
operator|&&
name|rs6000_traceback
operator|!=
name|traceback_none
condition|)
block|{
specifier|const
name|char
modifier|*
name|fname
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|language_string
init|=
name|lang_hooks
operator|.
name|name
decl_stmt|;
name|int
name|fixed_parms
init|=
literal|0
decl_stmt|,
name|float_parms
init|=
literal|0
decl_stmt|,
name|parm_info
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|optional_tbtab
decl_stmt|;
if|if
condition|(
name|rs6000_traceback
operator|==
name|traceback_full
condition|)
name|optional_tbtab
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rs6000_traceback
operator|==
name|traceback_part
condition|)
name|optional_tbtab
operator|=
literal|0
expr_stmt|;
else|else
name|optional_tbtab
operator|=
operator|!
name|optimize_size
operator|&&
operator|!
name|TARGET_ELF
expr_stmt|;
if|if
condition|(
name|optional_tbtab
condition|)
block|{
name|fname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|fname
operator|==
literal|'.'
condition|)
comment|/* V.4 encodes . in the name */
name|fname
operator|++
expr_stmt|;
comment|/* Need label immediately before tbtab, so we can compute 	     its offset from the function start.  */
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LT"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* The .tbtab pseudo-op can only be used for the first eight 	 expressions, since it can't handle the possibly variable 	 length fields that follow.  However, if you omit the optional 	 fields, the assembler outputs zeros for all optional fields 	 anyways, giving each variable length field is minimum length 	 (as defined in sys/debug.h).  Thus we can not use the .tbtab 	 pseudo-op at all.  */
comment|/* An all-zero word flags the start of the tbtab, for debuggers 	 that have to find it by searching forward from the entry 	 point or from the current pc.  */
name|fputs
argument_list|(
literal|"\t.long 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Tbtab format type.  Use format type 0.  */
name|fputs
argument_list|(
literal|"\t.byte 0,"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Language type.  Unfortunately, there does not seem to be any 	 official way to discover the language being compiled, so we 	 use language_string. 	 C is 0.  Fortran is 1.  Pascal is 2.  Ada is 3.  C++ is 9. 	 Java is 13.  Objective-C is 14.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C"
argument_list|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Pascal"
argument_list|)
condition|)
name|i
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
condition|)
name|i
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
condition|)
name|i
operator|=
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Java"
argument_list|)
condition|)
name|i
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Objective-C"
argument_list|)
condition|)
name|i
operator|=
literal|14
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 8 single bit fields: global linkage (not set for C extern linkage, 	 apparently a PL/I convention?), out-of-line epilogue/prologue, offset 	 from start of procedure stored in tbtab, internal function, function 	 has controlled storage, function has no toc, function uses fp, 	 function logs/aborts fp operations.  */
comment|/* Assume that fp operations are used if any fp reg must be saved.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
name|optional_tbtab
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
operator|)
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 6 bitfields: function is interrupt handler, name present in 	 proc table, function calls alloca, on condition directives 	 (controls stack walks, 3 bits), saves condition reg, saves 	 link reg.  */
comment|/* The `function calls alloca' bit seems to be set whenever reg 31 is 	 set up as a frame pointer, even when there is no alloca call.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
operator|(
name|optional_tbtab
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|optional_tbtab
operator|&
name|frame_pointer_needed
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|info
operator|->
name|cr_save_p
operator|<<
literal|1
operator|)
operator||
operator|(
name|info
operator|->
name|lr_save_p
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 3 bitfields: saves backchain, fixup code, number of fpr saved 	 (6 bits).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
name|info
operator|->
name|push_p
operator|<<
literal|7
operator|)
operator||
operator|(
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
operator|)
argument_list|)
expr_stmt|;
comment|/* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
literal|32
operator|-
name|first_reg_to_save
argument_list|()
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optional_tbtab
condition|)
block|{
comment|/* Compute the parameter info from the function decl argument 	     list.  */
name|tree
name|decl
decl_stmt|;
name|int
name|next_parm_info_bit
init|=
literal|31
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|rtx
name|parameter
init|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|parameter
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|parameter
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|int
name|bits
decl_stmt|;
name|float_parms
operator|++
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|bits
operator|=
literal|0x2
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|TFmode
condition|)
name|bits
operator|=
literal|0x3
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If only one bit will fit, don't or in this entry.  */
if|if
condition|(
name|next_parm_info_bit
operator|>
literal|0
condition|)
name|parm_info
operator||=
operator|(
name|bits
operator|<<
operator|(
name|next_parm_info_bit
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|next_parm_info_bit
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fixed_parms
operator|+=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|next_parm_info_bit
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Number of fixed point parameters.  */
comment|/* This is actually the number of words of fixed point parameters; thus 	 an 8 byte struct counts as 2; and thus the maximum value is 8.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|fixed_parms
argument_list|)
expr_stmt|;
comment|/* 2 bitfields: number of floating point parameters (7 bits), parameters 	 all on stack.  */
comment|/* This is actually the number of fp registers that hold parameters; 	 and thus the maximum value is 13.  */
comment|/* Set parameters on stack bit if parameters are not in their original 	 registers, regardless of whether they are on the stack?  Xlc 	 seems to set the bit when not optimizing.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
operator|(
name|float_parms
operator|<<
literal|1
operator|)
operator||
operator|(
operator|!
name|optimize
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optional_tbtab
condition|)
return|return;
comment|/* Optional fields follow.  Some are variable length.  */
comment|/* Parameter types, left adjusted bit fields: 0 fixed, 10 single float, 	 11 double float.  */
comment|/* There is an entry for each parameter in a register, in the order that 	 they occur in the parameter list.  Any intervening arguments on the 	 stack are ignored.  If the list overflows a long (max possible length 	 34 bits) then completely leave off all elements that don't fit.  */
comment|/* Only emit this long if there was at least one parameter.  */
if|if
condition|(
name|fixed_parms
operator|||
name|float_parms
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long %d\n"
argument_list|,
name|parm_info
argument_list|)
expr_stmt|;
comment|/* Offset from start of code to tb table.  */
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LT"
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_AIX
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|#
directive|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
literal|"-."
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_AIX
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|#
directive|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Interrupt handler mask.  */
comment|/* Omit this long, since we never set the interrupt handler bit 	 above.  */
comment|/* Number of CTL (controlled storage) anchors.  */
comment|/* Omit this long, since the has_ctl bit is never set above.  */
comment|/* Displacement into stack of each CTL anchor.  */
comment|/* Omit this list of longs, because there are no CTL anchors.  */
comment|/* Length of function name.  */
if|if
condition|(
operator|*
name|fname
operator|==
literal|'*'
condition|)
operator|++
name|fname
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.short %d\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Function name.  */
name|assemble_string
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register for alloca automatic storage; this is always reg 31. 	 Only emit this if the alloca bit was set above.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fputs
argument_list|(
literal|"\t.byte 31\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.align 2\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement that outputs the assembler code for a thunk    function, used to implement C++ virtual function calls with    multiple inheritance.  The thunk acts as a wrapper around a virtual    function, adjusting the implicit object parameter before handing    control off to the real function.     First, emit code to add the integer DELTA to the location that    contains the incoming first argument.  Assume that this argument    contains a pointer, and is the one used to pass the `this' pointer    in C++.  This is the incoming argument *before* the function    prologue, e.g. `%o0' on a sparc.  The addition must preserve the    values of all other incoming arguments.     After the addition, emit code to jump to FUNCTION, which is a    `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does    not touch the return address.  Hence returning from FUNCTION will    return to whoever called the current `thunk'.     The effect must be as if FUNCTION had been called directly with the    adjusted first argument.  This macro is responsible for emitting    all of the code for a thunk function; output_function_prologue()    and output_function_epilogue() are not invoked.     The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already    been extracted from it.)  It might possibly be useful on some    targets, but probably not.     If you do not define this macro, the target-independent code in the    C++ frontend will generate a less efficient heavyweight thunk that    calls FUNCTION instead of jumping to it.  The generic approach does    not support varargs.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk_fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|this
decl_stmt|,
name|insn
decl_stmt|,
name|funexp
decl_stmt|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|epilogue_completed
operator|=
literal|1
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
comment|/* Mark the end of the (empty) prologue.  */
name|emit_note
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|)
expr_stmt|;
comment|/* Find the "this" pointer.  If the function returns a structure,      the structure return pointer is in r3.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|)
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Apply the constant offset, if required.  */
if|if
condition|(
name|delta
condition|)
block|{
name|rtx
name|delta_rtx
init|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|delta_rtx
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Apply the offset from the vtable, if required.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
name|rtx
name|vcall_offset_rtx
init|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
decl_stmt|;
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|vcall_offset
operator|)
operator|+
literal|0x8000
operator|>=
literal|0x10000
condition|)
block|{
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|vcall_offset_rtx
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|vcall_offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|loc
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|vcall_offset_rtx
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|loc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|tmp
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate a tail call to the target function.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funexp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
name|funexp
operator|=
name|machopic_indirect_call_target
argument_list|(
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* gen_sibcall expects reload to convert scratch pseudo to LR so we must      generate sibcall RTL explicitly to avoid constraint abort.  */
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|gen_rtx_CALL
argument_list|(
name|VOIDmode
argument_list|,
name|funexp
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Run just enough of rest_of_compilation to get the insns emitted.      There's not really enough bulk here to make other passes such as      instruction scheduling worth while.  Note that use_thunk calls      assemble_start_function and assemble_end_function.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|insn_locators_initialize
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|epilogue_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A quick summary of the various types of 'constant-pool tables'    under PowerPC:     Target	Flags		Name		One table per	    AIX		(none)		AIX TOC		object file    AIX		-mfull-toc	AIX TOC		object file    AIX		-mminimal-toc	AIX minimal TOC	translation unit    SVR4/EABI	(none)		SVR4 SDATA	object file    SVR4/EABI	-fpic		SVR4 pic	object file    SVR4/EABI	-fPIC		SVR4 PIC	translation unit    SVR4/EABI	-mrelocatable	EABI TOC	function    SVR4/EABI	-maix		AIX TOC		object file    SVR4/EABI	-maix -mminimal-toc  				AIX minimal TOC	translation unit     Name			Reg.	Set by	entries	      contains: 					made by	 addrs?	fp?	sum?     AIX TOC		2	crt0	as	 Y	option	option    AIX minimal TOC	30	prolog	gcc	 Y	Y	option    SVR4 SDATA		13	crt0	gcc	 N	Y	N    SVR4 pic		30	prolog	ld	 Y	not yet	N    SVR4 PIC		30	prolog	gcc	 Y	option	option    EABI TOC		30	prolog	gcc	 Y	option	option  */
end_comment

begin_comment
comment|/* Hash functions for the hash table.  */
end_comment

begin_function
specifier|static
name|unsigned
name|rs6000_hash_constant
parameter_list|(
name|rtx
name|k
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|unsigned
name|result
init|=
operator|(
name|code
operator|<<
literal|3
operator|)
operator|^
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|flen
decl_stmt|,
name|fidx
decl_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|fidx
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
return|return
name|result
operator|*
literal|1231
operator|+
operator|(
name|unsigned
operator|)
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|real_hash
argument_list|(
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|k
argument_list|)
argument_list|)
operator|*
name|result
return|;
name|flen
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|fidx
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
init|;
name|fidx
operator|<
name|flen
condition|;
name|fidx
operator|++
control|)
switch|switch
condition|(
name|format
index|[
name|fidx
index|]
condition|)
block|{
case|case
literal|'s'
case|:
block|{
name|unsigned
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|result
operator|*
literal|613
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|str
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
name|result
operator|=
name|result
operator|*
literal|1231
operator|+
name|rs6000_hash_constant
argument_list|(
name|XEXP
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|XINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|XWINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|XWINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
operator|>>
name|CHAR_BIT
operator|*
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|toc_hash_function
parameter_list|(
specifier|const
name|void
modifier|*
name|hash_entry
parameter_list|)
block|{
specifier|const
name|struct
name|toc_hash_struct
modifier|*
name|thc
init|=
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|hash_entry
decl_stmt|;
return|return
name|rs6000_hash_constant
argument_list|(
name|thc
operator|->
name|key
argument_list|)
operator|^
name|thc
operator|->
name|key_mode
return|;
block|}
end_function

begin_comment
comment|/* Compare H1 and H2 for equivalence.  */
end_comment

begin_function
specifier|static
name|int
name|toc_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|h1
parameter_list|,
specifier|const
name|void
modifier|*
name|h2
parameter_list|)
block|{
name|rtx
name|r1
init|=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h1
operator|)
operator|->
name|key
decl_stmt|;
name|rtx
name|r2
init|=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h2
operator|)
operator|->
name|key
decl_stmt|;
if|if
condition|(
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h1
operator|)
operator|->
name|key_mode
operator|!=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h2
operator|)
operator|->
name|key_mode
condition|)
return|return
literal|0
return|;
return|return
name|rtx_equal_p
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These are the names given by the C++ front-end to vtables, and    vtable-like objects.  Ideally, this logic should not be here;    instead, there should be some programmatic way of inquiring as    to whether or not an object is a vtable.  */
end_comment

begin_define
define|#
directive|define
name|VTABLE_NAME_P
parameter_list|(
name|NAME
parameter_list|)
define|\
value|(strncmp ("_vt.", name, strlen("_vt.")) == 0		\   || strncmp ("_ZTV", name, strlen ("_ZTV")) == 0	\   || strncmp ("_ZTT", name, strlen ("_ZTT")) == 0	\   || strncmp ("_ZTI", name, strlen ("_ZTI")) == 0	\   || strncmp ("_ZTC", name, strlen ("_ZTC")) == 0)
end_define

begin_function
name|void
name|rs6000_output_symbol_ref
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
comment|/* Currently C++ toc references to vtables can be emitted before it      is decided whether the vtable is public or private.  If this is      the case, then the linker will eventually complain that there is      a reference to an unknown section.  Thus, for vtables only,       we emit the TOC reference to reference the symbol and not the      section.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|VTABLE_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a TOC entry.  We derive the entry name from what is being    written.  */
end_comment

begin_function
name|void
name|output_toc
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|labelno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|rtx
name|base
init|=
name|x
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TARGET_NO_TOC
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* When the linker won't eliminate them, don't output duplicate      TOC entries (this happens on AIX if there is any kind of TOC,      and on SVR4 under -fPIC or -mrelocatable).  Don't do this for      CODE_LABELs.  */
if|if
condition|(
name|TARGET_TOC
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LABEL_REF
condition|)
block|{
name|struct
name|toc_hash_struct
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|found
decl_stmt|;
comment|/* Create toc_hash_table.  This can't be done at OVERRIDE_OPTIONS          time because GGC is not initialized at that point.  */
if|if
condition|(
name|toc_hash_table
operator|==
name|NULL
condition|)
name|toc_hash_table
operator|=
name|htab_create_ggc
argument_list|(
literal|1021
argument_list|,
name|toc_hash_function
argument_list|,
name|toc_hash_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|key
operator|=
name|x
expr_stmt|;
name|h
operator|->
name|key_mode
operator|=
name|mode
expr_stmt|;
name|h
operator|->
name|labelno
operator|=
name|labelno
expr_stmt|;
name|found
operator|=
name|htab_find_slot
argument_list|(
name|toc_hash_table
argument_list|,
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|found
operator|==
name|NULL
condition|)
operator|*
name|found
operator|=
name|h
expr_stmt|;
else|else
comment|/* This is indeed a duplicate.   	       Set this label equal to that label.  */
block|{
name|fputs
argument_list|(
literal|"\t.set "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
operator|(
operator|*
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|*
operator|)
name|found
operator|)
operator|->
name|labelno
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we're going to put a double constant in the TOC, make sure it's      aligned properly when strict alignment is on.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|STRICT_ALIGNMENT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|64
operator|&&
operator|!
operator|(
name|TARGET_NO_FP_IN_TOC
operator|&&
operator|!
name|TARGET_MINIMAL_TOC
operator|)
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* Handle FP constants specially.  Note that if we have a minimal      TOC, things we put here aren't actually in the TOC, so we can allow      FP constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|TFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|k
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FT_%lx_%lx_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|2
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|3
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx,0x%lx%08lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|2
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|3
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FT_%lx_%lx_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|2
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|3
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx,0x%lx,0x%lx,0x%lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|2
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|3
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|k
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FD_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FD_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx,0x%lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FS_%lx[TC],"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx00000000\n"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FS_%lx[TC],"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx\n"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
block|{
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|high
operator|=
operator|(
name|low
operator|&
literal|0x80000000
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
block|}
else|#
directive|else
block|{
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
name|high
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TOC entries are always Pmode-sized, but since this 	 is a bigendian machine then if we're putting smaller 	 integer constants in the TOC we have to pad them. 	 (This is still a win over putting the constants in 	 a separate constant pool, because then we'd have 	 to have both a TOC entry _and_ the actual constant.)  	 For a 32-bit target, CONST_INT values are loaded and shifted 	 entirely within `low' and can be stored in one TOC entry.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|POINTER_SIZE
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* It would be easy to make this work, but it doesn't now.  */
if|if
condition|(
name|POINTER_SIZE
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|lshift_double
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|POINTER_SIZE
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|POINTER_SIZE
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|low
operator||=
name|high
operator|<<
literal|32
expr_stmt|;
name|low
operator|<<=
name|POINTER_SIZE
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|high
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|low
operator|>>
literal|32
expr_stmt|;
name|low
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc ID_%lx_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx\n"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|POINTER_SIZE
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc ID_%lx_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx,0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc IS_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|name
operator|=
name|XSTR
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|real_name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|TARGET_32BIT
condition|?
literal|"\t.long "
else|:
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc %s"
argument_list|,
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".N%d"
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".P%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"[TC],"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Currently C++ toc references to vtables can be emitted before it      is decided whether the vtable is public or private.  If this is      the case, then the linker will eventually complain that there is      a TOC reference to an unknown section.  Thus, for vtables only,      we emit the TOC reference to reference the symbol and not the      section.  */
if|if
condition|(
name|VTABLE_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an assembler pseudo-op to write an ASCII string of N characters    starting at P to FILE.     On the RS/6000, we have to do this using the .byte operation and    write out special characters outside the quoted string.    Also, the assembler is broken; very long strings are truncated,    so we must artificially break them up early.  */
end_comment

begin_function
name|void
name|output_ascii
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|for_string
init|=
literal|"\t.byte \""
decl_stmt|;
specifier|const
name|char
modifier|*
name|for_decimal
init|=
literal|"\t.byte "
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_close
init|=
name|NULL
decl_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
if|if
condition|(
name|for_string
condition|)
name|fputs
argument_list|(
name|for_string
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Write two quotes to get one.  */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|++
name|count_string
expr_stmt|;
block|}
name|for_string
operator|=
name|NULL
expr_stmt|;
name|for_decimal
operator|=
literal|"\"\n\t.byte "
expr_stmt|;
name|to_close
operator|=
literal|"\"\n"
expr_stmt|;
operator|++
name|count_string
expr_stmt|;
if|if
condition|(
name|count_string
operator|>=
literal|512
condition|)
block|{
name|fputs
argument_list|(
name|to_close
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|for_string
operator|=
literal|"\t.byte \""
expr_stmt|;
name|for_decimal
operator|=
literal|"\t.byte "
expr_stmt|;
name|to_close
operator|=
name|NULL
expr_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|for_decimal
condition|)
name|fputs
argument_list|(
name|for_decimal
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|for_string
operator|=
literal|"\n\t.byte \""
expr_stmt|;
name|for_decimal
operator|=
literal|", "
expr_stmt|;
name|to_close
operator|=
literal|"\n"
expr_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now close the string if we have written one.  Then end the line.  */
if|if
condition|(
name|to_close
condition|)
name|fputs
argument_list|(
name|to_close
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a unique section name for FILENAME for a section type    represented by SECTION_DESC.  Output goes into BUF.     SECTION_DESC can be any string, as long as it is different for each    possible section type.     We name the section in the same manner as xlc.  The name begins with an    underscore followed by the filename (after stripping any leading directory    names) with the last period replaced by the string SECTION_DESC.  If    FILENAME does not contain a period, SECTION_DESC is appended to the end of    the name.  */
end_comment

begin_function
name|void
name|rs6000_gen_section_name
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|section_desc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|after_last_slash
decl_stmt|,
modifier|*
name|last_period
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|after_last_slash
operator|=
name|filename
expr_stmt|;
for|for
control|(
name|q
operator|=
name|filename
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'/'
condition|)
name|after_last_slash
operator|=
name|q
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
name|last_period
operator|=
name|q
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|after_last_slash
argument_list|)
operator|+
name|strlen
argument_list|(
name|section_desc
argument_list|)
operator|+
literal|2
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|q
operator|=
name|after_last_slash
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|==
name|last_period
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|section_desc
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|section_desc
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
block|}
if|if
condition|(
name|last_period
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|section_desc
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit profile function.  */
end_comment

begin_function
name|void
name|output_profile_hook
parameter_list|(
name|int
name|labelno
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_PROFILE_KERNEL
condition|)
return|return;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
define|#
directive|define
name|NO_PROFILE_COUNTERS
value|0
endif|#
directive|endif
if|if
condition|(
name|NO_PROFILE_COUNTERS
condition|)
name|emit_library_call
argument_list|(
name|init_one_libfunc
argument_list|(
name|RS6000_MCOUNT
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|label_name
decl_stmt|;
name|rtx
name|fun
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|label_name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fun
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_name
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|init_one_libfunc
argument_list|(
name|RS6000_MCOUNT
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|fun
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
condition|)
block|{
specifier|const
name|char
modifier|*
name|mcount_name
init|=
name|RS6000_MCOUNT
decl_stmt|;
name|int
name|caller_addr_regno
init|=
name|LINK_REGISTER_REGNUM
decl_stmt|;
comment|/* Be conservative and always set this, at least for now.  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* For PIC code, set up a stub and collect the caller's address 	 from r0, which is where the prologue puts it.  */
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
block|{
name|mcount_name
operator|=
name|machopic_stub_name
argument_list|(
name|mcount_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_uses_pic_offset_table
condition|)
name|caller_addr_regno
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|mcount_name
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|caller_addr_regno
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write function profiler code.  */
end_comment

begin_function
name|void
name|output_function_profiler
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|labelno
parameter_list|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|save_lr
init|=
literal|8
decl_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_V4
case|:
name|save_lr
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_32BIT
condition|)
block|{
name|warning
argument_list|(
literal|"no profiling of 64-bit code for this ABI"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|fputs
argument_list|(
literal|"\tbl _GLOBAL_OFFSET_TABLE_@local-4\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,%d(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|save_lr
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{l|lwz} %s,"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"@got(%s)\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|>
literal|1
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,%d(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|save_lr
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Now, we need to get the address of the label.  */
name|fputs
argument_list|(
literal|"\tbl 1f\n\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-.\n1:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{l|lwz} %s,0(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cax|add} %s,%s,%s\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{liu|lis} %s,"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@ha\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,%d(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|save_lr
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cal|la} %s,"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"@l(%s)\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* ABI_V4 saves the static chain reg with ASM_OUTPUT_REG_PUSH.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbl %s%s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|,
name|flag_pic
condition|?
literal|"@plt"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABI_AIX
case|:
case|case
name|ABI_DARWIN
case|:
if|if
condition|(
operator|!
name|TARGET_PROFILE_KERNEL
condition|)
block|{
comment|/* Don't do anything, done in output_profile_hook ().  */
block|}
else|else
block|{
if|if
condition|(
name|TARGET_32BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstd %s,16(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_needs_context
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstd %s,24(%s)\n"
argument_list|,
name|reg_names
index|[
name|STATIC_CHAIN_REGNUM
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbl %s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld %s,24(%s)\n"
argument_list|,
name|reg_names
index|[
name|STATIC_CHAIN_REGNUM
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbl %s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|rs6000_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Power4 load update and store update instructions are cracked into a    load or store and an integer insn which are executed in the same cycle.    Branches have their own dispatch slot which does not count against the    GCC issue rate, but it changes the program flow so there are no other    instructions to issue in this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_variable_issue
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|more
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|more
return|;
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
if|if
condition|(
name|is_microcoded_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|is_cracked_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|more
operator|>
literal|2
condition|?
name|more
operator|-
literal|2
else|:
literal|0
return|;
block|}
return|return
name|more
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
if|if
condition|(
operator|!
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Data dependency; DEP_INSN writes a register that INSN reads 	 some cycles later.  */
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_JMPREG
case|:
comment|/* Tell the first scheduling pass about the latency between 	     a mtctr and bctr (and mtlr and br/blr).  The first 	     scheduling pass will not know about this latency since 	     the mtctr instruction, which has the latency associated 	     to it, will be generated by reload.  */
return|return
name|TARGET_POWER
condition|?
literal|5
else|:
literal|4
return|;
case|case
name|TYPE_BRANCH
case|:
comment|/* Leave some extra cycles between a compare and its 	     dependent branch, to inhibit expensive mispredicts.  */
if|if
condition|(
operator|(
name|rs6000_cpu_attr
operator|==
name|CPU_PPC603
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC604
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC604E
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC620
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC630
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC750
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC7400
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC7450
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_POWER4
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_POWER5
operator|)
operator|&&
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|&&
operator|(
name|INSN_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_CMP
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_DELAYED_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_IMUL_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LMUL_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_FPCOMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_CR_LOGICAL
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_DELAYED_CR
operator|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
default|default:
break|break;
block|}
comment|/* Fall out to return default cost.  */
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* The function returns a true if INSN is microcoded.    Return false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|is_microcoded_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
name|enum
name|attr_type
name|type
init|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_LOAD_EXT_U
operator|||
name|type
operator|==
name|TYPE_LOAD_EXT_UX
operator|||
name|type
operator|==
name|TYPE_LOAD_UX
operator|||
name|type
operator|==
name|TYPE_STORE_UX
operator|||
name|type
operator|==
name|TYPE_MFCR
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The function returns a nonzero value if INSN can be scheduled only    as the first insn in a dispatch group ("dispatch-slot restricted").    In this case, the returned value indicates how many dispatch slots    the insn occupies (at the beginning of the group).    Return 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|is_dispatch_slot_restricted
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|attr_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|rs6000_sched_groups
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|insn
operator|||
name|insn
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_MFCR
case|:
case|case
name|TYPE_MFCRF
case|:
case|case
name|TYPE_MTCR
case|:
case|case
name|TYPE_DELAYED_CR
case|:
case|case
name|TYPE_CR_LOGICAL
case|:
case|case
name|TYPE_MTJMPR
case|:
case|case
name|TYPE_MFJMPR
case|:
return|return
literal|1
return|;
case|case
name|TYPE_IDIV
case|:
case|case
name|TYPE_LDIV
case|:
return|return
literal|2
return|;
default|default:
if|if
condition|(
name|rs6000_cpu
operator|==
name|PROCESSOR_POWER5
operator|&&
name|is_cracked_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* The function returns true if INSN is cracked into 2 instructions    by the processor (and therefore occupies 2 issue slots).  */
end_comment

begin_function
specifier|static
name|bool
name|is_cracked_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
name|enum
name|attr_type
name|type
init|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_LOAD_U
operator|||
name|type
operator|==
name|TYPE_STORE_U
operator|||
name|type
operator|==
name|TYPE_FPLOAD_U
operator|||
name|type
operator|==
name|TYPE_FPSTORE_U
operator|||
name|type
operator|==
name|TYPE_FPLOAD_UX
operator|||
name|type
operator|==
name|TYPE_FPSTORE_UX
operator|||
name|type
operator|==
name|TYPE_LOAD_EXT
operator|||
name|type
operator|==
name|TYPE_DELAYED_CR
operator|||
name|type
operator|==
name|TYPE_COMPARE
operator|||
name|type
operator|==
name|TYPE_DELAYED_COMPARE
operator|||
name|type
operator|==
name|TYPE_IMUL_COMPARE
operator|||
name|type
operator|==
name|TYPE_LMUL_COMPARE
operator|||
name|type
operator|==
name|TYPE_IDIV
operator|||
name|type
operator|==
name|TYPE_LDIV
operator|||
name|type
operator|==
name|TYPE_INSERT_WORD
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The function returns true if INSN can be issued only from    the branch slot.  */
end_comment

begin_function
specifier|static
name|bool
name|is_branch_slot_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
name|enum
name|attr_type
name|type
init|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_BRANCH
operator|||
name|type
operator|==
name|TYPE_JMPREG
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A C statement (sans semicolon) to update the integer scheduling    priority INSN_PRIORITY (INSN). Increase the priority to execute the    INSN earlier, reduce the priority to execute INSN later.  Do not    define this macro if you do not need to adjust the scheduling    priorities of insns.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_adjust_priority
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
comment|/* On machines (like the 750) which have asymmetric integer units,      where one integer unit can do multiply and divides and the other      can't, reduce the priority of multiply/divide so it is scheduled      before other integer operations.  */
if|#
directive|if
literal|0
block|if (! INSN_P (insn))     return priority;    if (GET_CODE (PATTERN (insn)) == USE)     return priority;    switch (rs6000_cpu_attr) {   case CPU_PPC750:     switch (get_attr_type (insn))       {       default: 	break;        case TYPE_IMUL:       case TYPE_IDIV: 	fprintf (stderr, "priority was %#x (%d) before adjustment\n", 		 priority, priority); 	if (priority>= 0&& priority< 0x01000000) 	  priority>>= 3; 	break;       }   }
endif|#
directive|endif
if|if
condition|(
name|is_dispatch_slot_restricted
argument_list|(
name|insn
argument_list|)
operator|&&
name|reload_completed
operator|&&
name|current_sched_info
operator|->
name|sched_max_insns_priority
operator|&&
name|rs6000_sched_restricted_insns_priority
condition|)
block|{
comment|/* Prioritize insns that can be dispatched only in the first dispatch slot.  */
if|if
condition|(
name|rs6000_sched_restricted_insns_priority
operator|==
literal|1
condition|)
comment|/* Attach highest priority to insn. This means that in  	   haifa-sched.c:ready_sort(), dispatch-slot restriction considerations  	   precede 'priority' (critical path) considerations.  */
return|return
name|current_sched_info
operator|->
name|sched_max_insns_priority
return|;
elseif|else
if|if
condition|(
name|rs6000_sched_restricted_insns_priority
operator|==
literal|2
condition|)
comment|/* Increase priority of insn by a minimal amount. This means that in  	   haifa-sched.c:ready_sort(), only 'priority' (critical path) considerations 	   precede dispatch-slot restriction considerations.  */
return|return
operator|(
name|priority
operator|+
literal|1
operator|)
return|;
block|}
return|return
name|priority
return|;
block|}
end_function

begin_comment
comment|/* Return how many instructions the machine can issue per cycle.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Use issue rate of 1 for first scheduling pass to decrease degradation.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|rs6000_cpu_attr
condition|)
block|{
case|case
name|CPU_RIOS1
case|:
comment|/* ? */
case|case
name|CPU_RS64A
case|:
case|case
name|CPU_PPC601
case|:
comment|/* ? */
case|case
name|CPU_PPC7450
case|:
return|return
literal|3
return|;
case|case
name|CPU_PPC440
case|:
case|case
name|CPU_PPC603
case|:
case|case
name|CPU_PPC750
case|:
case|case
name|CPU_PPC7400
case|:
case|case
name|CPU_PPC8540
case|:
return|return
literal|2
return|;
case|case
name|CPU_RIOS2
case|:
case|case
name|CPU_PPC604
case|:
case|case
name|CPU_PPC604E
case|:
case|case
name|CPU_PPC620
case|:
case|case
name|CPU_PPC630
case|:
return|return
literal|4
return|;
case|case
name|CPU_POWER4
case|:
case|case
name|CPU_POWER5
case|:
return|return
literal|5
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return how many instructions to look ahead for better insn    scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_use_sched_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|rs6000_cpu_attr
operator|==
name|CPU_PPC8540
condition|)
return|return
literal|4
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine is PAT refers to memory.  */
end_comment

begin_function
specifier|static
name|bool
name|is_mem_ref
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|true
return|;
comment|/* Recursively process the pattern.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
operator|!
name|ret
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|ret
operator||=
name|is_mem_ref
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|ret
operator||=
name|is_mem_ref
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Determine if PAT is a PATTERN of a load insn.  */
end_comment

begin_function
specifier|static
name|bool
name|is_load_insn1
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pat
operator|||
name|pat
operator|==
name|NULL_RTX
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
return|return
name|is_mem_ref
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_load_insn1
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine if INSN loads from memory.  */
end_comment

begin_function
specifier|static
name|bool
name|is_load_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
name|false
return|;
return|return
name|is_load_insn1
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if PAT is a PATTERN of a store insn.  */
end_comment

begin_function
specifier|static
name|bool
name|is_store_insn1
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pat
operator|||
name|pat
operator|==
name|NULL_RTX
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
return|return
name|is_mem_ref
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_store_insn1
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine if INSN stores to memory.  */
end_comment

begin_function
specifier|static
name|bool
name|is_store_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|is_store_insn1
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns whether the dependence between INSN and NEXT is considered    costly by the given target.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_is_costly_dependence
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|next
parameter_list|,
name|rtx
name|link
parameter_list|,
name|int
name|cost
parameter_list|,
name|int
name|distance
parameter_list|)
block|{
comment|/* If the flag is not enbled - no dependence is considered costly;      allow all dependent insns in the same group.       This is the most aggressive option.  */
if|if
condition|(
name|rs6000_sched_costly_dep
operator|==
name|no_dep_costly
condition|)
return|return
name|false
return|;
comment|/* If the flag is set to 1 - a dependence is always considered costly;       do not allow dependent instructions in the same group.      This is the most conservative option.  */
if|if
condition|(
name|rs6000_sched_costly_dep
operator|==
name|all_deps_costly
condition|)
return|return
name|true
return|;
if|if
condition|(
name|rs6000_sched_costly_dep
operator|==
name|store_to_load_dep_costly
operator|&&
name|is_load_insn
argument_list|(
name|next
argument_list|)
operator|&&
name|is_store_insn
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* Prevent load after store in the same group.  */
return|return
name|true
return|;
if|if
condition|(
name|rs6000_sched_costly_dep
operator|==
name|true_store_to_load_dep_costly
operator|&&
name|is_load_insn
argument_list|(
name|next
argument_list|)
operator|&&
name|is_store_insn
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|link
operator|||
operator|(
name|int
operator|)
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* Prevent load after store in the same group if it is a true dependence.  */
return|return
name|true
return|;
comment|/* The flag is set to X; dependences with latency>= X are considered costly,       and will not be scheduled in the same group.  */
if|if
condition|(
name|rs6000_sched_costly_dep
operator|<=
name|max_dep_latency
operator|&&
operator|(
operator|(
name|cost
operator|-
name|distance
operator|)
operator|>=
operator|(
name|int
operator|)
name|rs6000_sched_costly_dep
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the next insn after INSN that is found before TAIL is reached,     skipping any "non-active" insns - insns that will not actually occupy    an issue slot.  Return NULL_RTX if such an insn is not found.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_next_active_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|next_insn
decl_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
name|insn
operator|==
name|tail
condition|)
return|return
name|NULL_RTX
return|;
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_insn
operator|&&
name|next_insn
operator|!=
name|tail
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|)
block|{
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|next_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|next_insn
operator|||
name|next_insn
operator|==
name|tail
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|next_insn
return|;
block|}
end_function

begin_comment
comment|/* Return whether the presence of INSN causes a dispatch group termination    of group WHICH_GROUP.     If WHICH_GROUP == current_group, this function will return true if INSN    causes the termination of the current group (i.e, the dispatch group to    which INSN belongs). This means that INSN will be the last insn in the    group it belongs to.     If WHICH_GROUP == previous_group, this function will return true if INSN    causes the termination of the previous group (i.e, the dispatch group that    precedes the group to which INSN belongs).  This means that INSN will be    the first insn in the group it belongs to).  */
end_comment

begin_function
specifier|static
name|bool
name|insn_terminates_group_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|group_termination
name|which_group
parameter_list|)
block|{
name|enum
name|attr_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
name|false
return|;
name|type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_microcoded_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|which_group
operator|==
name|current_group
condition|)
block|{
if|if
condition|(
name|is_branch_slot_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|which_group
operator|==
name|previous_group
condition|)
block|{
if|if
condition|(
name|is_dispatch_slot_restricted
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if it is recommended to keep NEXT_INSN "far" (in a separate    dispatch group) from the insns in GROUP_INSNS.  Return false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|is_costly_group
parameter_list|(
name|rtx
modifier|*
name|group_insns
parameter_list|,
name|rtx
name|next_insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|int
name|issue_rate
init|=
name|rs6000_issue_rate
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|group_insns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
continue|continue;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|next_insn
condition|)
block|{
name|cost
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs6000_is_costly_dependence
argument_list|(
name|insn
argument_list|,
name|next_insn
argument_list|,
name|link
argument_list|,
name|cost
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Utility of the function redefine_groups.     Check if it is too costly to schedule NEXT_INSN together with GROUP_INSNS    in the same dispatch group.  If so, insert nops before NEXT_INSN, in order    to keep it "far" (in a separate group) from GROUP_INSNS, following    one of the following schemes, depending on the value of the flag    -minsert_sched_nops = X:    (1) X == sched_finish_regroup_exact: insert exactly as many nops as needed        in order to force NEXT_INSN into a separate group.    (2) X< sched_finish_regroup_exact: insert exactly X nops.      GROUP_END, CAN_ISSUE_MORE and GROUP_COUNT record the state after nop     insertion (has a group just ended, how many vacant issue slots remain in the    last group, and how many dispatch groups were encountered so far).  */
end_comment

begin_function
specifier|static
name|int
name|force_new_group
parameter_list|(
name|int
name|sched_verbose
parameter_list|,
name|FILE
modifier|*
name|dump
parameter_list|,
name|rtx
modifier|*
name|group_insns
parameter_list|,
name|rtx
name|next_insn
parameter_list|,
name|bool
modifier|*
name|group_end
parameter_list|,
name|int
name|can_issue_more
parameter_list|,
name|int
modifier|*
name|group_count
parameter_list|)
block|{
name|rtx
name|nop
decl_stmt|;
name|bool
name|force
decl_stmt|;
name|int
name|issue_rate
init|=
name|rs6000_issue_rate
argument_list|()
decl_stmt|;
name|bool
name|end
init|=
operator|*
name|group_end
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|next_insn
operator|==
name|NULL_RTX
condition|)
return|return
name|can_issue_more
return|;
if|if
condition|(
name|rs6000_sched_insert_nops
operator|>
name|sched_finish_regroup_exact
condition|)
return|return
name|can_issue_more
return|;
name|force
operator|=
name|is_costly_group
argument_list|(
name|group_insns
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
return|return
name|can_issue_more
return|;
if|if
condition|(
name|sched_verbose
operator|>
literal|6
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"force: group count = %d, can_issue_more = %d\n"
argument_list|,
operator|*
name|group_count
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs6000_sched_insert_nops
operator|==
name|sched_finish_regroup_exact
condition|)
block|{
if|if
condition|(
operator|*
name|group_end
condition|)
name|can_issue_more
operator|=
literal|0
expr_stmt|;
comment|/* Since only a branch can be issued in the last issue_slot, it is 	 sufficient to insert 'can_issue_more - 1' nops if next_insn is not 	 a branch. If next_insn is a branch, we insert 'can_issue_more' nops; 	 in this case the last nop will start a new group and the branch will be 	 forced to the new group.  */
if|if
condition|(
name|can_issue_more
operator|&&
operator|!
name|is_branch_slot_insn
argument_list|(
name|next_insn
argument_list|)
condition|)
name|can_issue_more
operator|--
expr_stmt|;
while|while
condition|(
name|can_issue_more
operator|>
literal|0
condition|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|nop
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
name|can_issue_more
operator|--
expr_stmt|;
block|}
operator|*
name|group_end
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|rs6000_sched_insert_nops
operator|<
name|sched_finish_regroup_exact
condition|)
block|{
name|int
name|n_nops
init|=
name|rs6000_sched_insert_nops
decl_stmt|;
comment|/* Nops can't be issued from the branch slot, so the effective           issue_rate for nops is 'issue_rate - 1'.  */
if|if
condition|(
name|can_issue_more
operator|==
literal|0
condition|)
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|can_issue_more
operator|--
expr_stmt|;
if|if
condition|(
name|can_issue_more
operator|==
literal|0
condition|)
block|{
name|can_issue_more
operator|=
name|issue_rate
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|group_count
operator|)
operator|++
expr_stmt|;
name|end
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|group_insns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|n_nops
operator|>
literal|0
condition|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|nop
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_issue_more
operator|==
name|issue_rate
operator|-
literal|1
condition|)
comment|/* new group begins */
name|end
operator|=
name|false
expr_stmt|;
name|can_issue_more
operator|--
expr_stmt|;
if|if
condition|(
name|can_issue_more
operator|==
literal|0
condition|)
block|{
name|can_issue_more
operator|=
name|issue_rate
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|group_count
operator|)
operator|++
expr_stmt|;
name|end
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|group_insns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|n_nops
operator|--
expr_stmt|;
block|}
comment|/* Scale back relative to 'issue_rate' (instead of 'issue_rate - 1').  */
name|can_issue_more
operator|++
expr_stmt|;
operator|*
name|group_end
operator|=
comment|/* Is next_insn going to start a new group?  */
operator|(
name|end
operator|||
operator|(
name|can_issue_more
operator|==
literal|1
operator|&&
operator|!
name|is_branch_slot_insn
argument_list|(
name|next_insn
argument_list|)
operator|)
operator|||
operator|(
name|can_issue_more
operator|<=
literal|2
operator|&&
name|is_cracked_insn
argument_list|(
name|next_insn
argument_list|)
operator|)
operator|||
operator|(
name|can_issue_more
operator|<
name|issue_rate
operator|&&
name|insn_terminates_group_p
argument_list|(
name|next_insn
argument_list|,
name|previous_group
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|group_end
operator|&&
name|end
condition|)
operator|(
operator|*
name|group_count
operator|)
operator|--
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>
literal|6
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"done force: group count = %d, can_issue_more = %d\n"
argument_list|,
operator|*
name|group_count
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
return|return
name|can_issue_more
return|;
block|}
return|return
name|can_issue_more
return|;
block|}
end_function

begin_comment
comment|/* This function tries to synch the dispatch groups that the compiler "sees"    with the dispatch groups that the processor dispatcher is expected to     form in practice.  It tries to achieve this synchronization by forcing the    estimated processor grouping on the compiler (as opposed to the function    'pad_goups' which tries to force the scheduler's grouping on the processor).     The function scans the insn sequence between PREV_HEAD_INSN and TAIL and    examines the (estimated) dispatch groups that will be formed by the processor    dispatcher.  It marks these group boundaries to reflect the estimated    processor grouping, overriding the grouping that the scheduler had marked.    Depending on the value of the flag '-minsert-sched-nops' this function can    force certain insns into separate groups or force a certain distance between    them by inserting nops, for example, if there exists a "costly dependence"    between the insns.     The function estimates the group boundaries that the processor will form as    folllows:  It keeps track of how many vacant issue slots are available after    each insn.  A subsequent insn will start a new group if one of the following    4 cases applies:    - no more vacant issue slots remain in the current dispatch group.    - only the last issue slot, which is the branch slot, is vacant, but the next      insn is not a branch.    - only the last 2 or less issue slots, including the branch slot, are vacant,      which means that a cracked insn (which occupies two issue slots) can't be      issued in this group.    - less than 'issue_rate' slots are vacant, and the next insn always needs to       start a new group.  */
end_comment

begin_function
specifier|static
name|int
name|redefine_groups
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
name|prev_head_insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next_insn
decl_stmt|;
name|int
name|issue_rate
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|group_end
decl_stmt|;
name|int
name|group_count
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|group_insns
decl_stmt|;
comment|/* Initialize.  */
name|issue_rate
operator|=
name|rs6000_issue_rate
argument_list|()
expr_stmt|;
name|group_insns
operator|=
name|alloca
argument_list|(
name|issue_rate
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|group_insns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|slot
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|get_next_active_insn
argument_list|(
name|prev_head_insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|group_end
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|slot
operator|=
operator|(
name|issue_rate
operator|-
name|can_issue_more
operator|)
expr_stmt|;
name|group_insns
index|[
name|slot
index|]
operator|=
name|insn
expr_stmt|;
name|can_issue_more
operator|=
name|rs6000_variable_issue
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_terminates_group_p
argument_list|(
name|insn
argument_list|,
name|current_group
argument_list|)
condition|)
name|can_issue_more
operator|=
literal|0
expr_stmt|;
name|next_insn
operator|=
name|get_next_active_insn
argument_list|(
name|insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_insn
operator|==
name|NULL_RTX
condition|)
return|return
name|group_count
operator|+
literal|1
return|;
name|group_end
operator|=
comment|/* Is next_insn going to start a new group?  */
operator|(
name|can_issue_more
operator|==
literal|0
operator|||
operator|(
name|can_issue_more
operator|==
literal|1
operator|&&
operator|!
name|is_branch_slot_insn
argument_list|(
name|next_insn
argument_list|)
operator|)
operator|||
operator|(
name|can_issue_more
operator|<=
literal|2
operator|&&
name|is_cracked_insn
argument_list|(
name|next_insn
argument_list|)
operator|)
operator|||
operator|(
name|can_issue_more
operator|<
name|issue_rate
operator|&&
name|insn_terminates_group_p
argument_list|(
name|next_insn
argument_list|,
name|previous_group
argument_list|)
operator|)
operator|)
expr_stmt|;
name|can_issue_more
operator|=
name|force_new_group
argument_list|(
name|sched_verbose
argument_list|,
name|dump
argument_list|,
name|group_insns
argument_list|,
name|next_insn
argument_list|,
operator|&
name|group_end
argument_list|,
name|can_issue_more
argument_list|,
operator|&
name|group_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_end
condition|)
block|{
name|group_count
operator|++
expr_stmt|;
name|can_issue_more
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|group_insns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|TImode
operator|&&
name|can_issue_more
condition|)
name|PUT_MODE
argument_list|(
name|next_insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|can_issue_more
operator|&&
name|GET_MODE
argument_list|(
name|next_insn
argument_list|)
operator|!=
name|TImode
condition|)
name|PUT_MODE
argument_list|(
name|next_insn
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next_insn
expr_stmt|;
if|if
condition|(
name|can_issue_more
operator|==
literal|0
condition|)
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
block|}
comment|/* while */
return|return
name|group_count
return|;
block|}
end_function

begin_comment
comment|/* Scan the insn sequence between PREV_HEAD_INSN and TAIL and examine the    dispatch group boundaries that the scheduler had marked.  Pad with nops    any dispatch groups which have vacant issue slots, in order to force the    scheduler's grouping on the processor dispatcher.  The function    returns the number of dispatch groups found.  */
end_comment

begin_function
specifier|static
name|int
name|pad_groups
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
name|prev_head_insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next_insn
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
name|int
name|issue_rate
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
name|int
name|group_end
decl_stmt|;
name|int
name|group_count
init|=
literal|0
decl_stmt|;
comment|/* Initialize issue_rate.  */
name|issue_rate
operator|=
name|rs6000_issue_rate
argument_list|()
expr_stmt|;
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|insn
operator|=
name|get_next_active_insn
argument_list|(
name|prev_head_insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|next_insn
operator|=
name|get_next_active_insn
argument_list|(
name|insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|can_issue_more
operator|=
name|rs6000_variable_issue
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
name|group_end
operator|=
operator|(
name|next_insn
operator|==
name|NULL_RTX
operator|||
name|GET_MODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|TImode
operator|)
expr_stmt|;
if|if
condition|(
name|next_insn
operator|==
name|NULL_RTX
condition|)
break|break;
if|if
condition|(
name|group_end
condition|)
block|{
comment|/* If the scheduler had marked group termination at this location              (between insn and next_indn), and neither insn nor next_insn will              force group termination, pad the group with nops to force group              termination.  */
if|if
condition|(
name|can_issue_more
operator|&&
operator|(
name|rs6000_sched_insert_nops
operator|==
name|sched_finish_pad_groups
operator|)
operator|&&
operator|!
name|insn_terminates_group_p
argument_list|(
name|insn
argument_list|,
name|current_group
argument_list|)
operator|&&
operator|!
name|insn_terminates_group_p
argument_list|(
name|next_insn
argument_list|,
name|previous_group
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_branch_slot_insn
argument_list|(
name|next_insn
argument_list|)
condition|)
name|can_issue_more
operator|--
expr_stmt|;
while|while
condition|(
name|can_issue_more
condition|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|nop
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
name|can_issue_more
operator|--
expr_stmt|;
block|}
block|}
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|group_count
operator|++
expr_stmt|;
block|}
name|insn
operator|=
name|next_insn
expr_stmt|;
name|next_insn
operator|=
name|get_next_active_insn
argument_list|(
name|insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
return|return
name|group_count
return|;
block|}
end_function

begin_comment
comment|/* The following function is called at the end of scheduling BB.    After reload, it inserts nops at insn group bundling.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_sched_finish
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|)
block|{
name|int
name|n_groups
decl_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"=== Finishing schedule.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|&&
name|rs6000_sched_groups
condition|)
block|{
if|if
condition|(
name|rs6000_sched_insert_nops
operator|==
name|sched_finish_none
condition|)
return|return;
if|if
condition|(
name|rs6000_sched_insert_nops
operator|==
name|sched_finish_pad_groups
condition|)
name|n_groups
operator|=
name|pad_groups
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|current_sched_info
operator|->
name|prev_head
argument_list|,
name|current_sched_info
operator|->
name|next_tail
argument_list|)
expr_stmt|;
else|else
name|n_groups
operator|=
name|redefine_groups
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|current_sched_info
operator|->
name|prev_head
argument_list|,
name|current_sched_info
operator|->
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"ngroups = %d\n"
argument_list|,
name|n_groups
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump
argument_list|,
name|current_sched_info
operator|->
name|prev_head
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"Done finish_sched\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Length in units of the trampoline for entering a nested function.  */
end_comment

begin_function
name|int
name|rs6000_trampoline_size
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
name|ret
operator|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|12
else|:
literal|24
expr_stmt|;
break|break;
case|case
name|ABI_DARWIN
case|:
case|case
name|ABI_V4
case|:
name|ret
operator|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|40
else|:
literal|48
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|rs6000_initialize_trampoline
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|)
block|{
name|enum
name|machine_mode
name|pmode
init|=
name|Pmode
decl_stmt|;
name|int
name|regsize
init|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|rtx
name|ctx_reg
init|=
name|force_reg
argument_list|(
name|pmode
argument_list|,
name|cxt
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Macros to shorten the code expansions below.  */
define|#
directive|define
name|MEM_DEREF
parameter_list|(
name|addr
parameter_list|)
value|gen_rtx_MEM (pmode, memory_address (pmode, addr))
define|#
directive|define
name|MEM_PLUS
parameter_list|(
name|addr
parameter_list|,
name|offset
parameter_list|)
define|\
value|gen_rtx_MEM (pmode, memory_address (pmode, plus_constant (addr, offset)))
comment|/* Under AIX, just build the 3 word function descriptor */
case|case
name|ABI_AIX
case|:
block|{
name|rtx
name|fn_reg
init|=
name|gen_reg_rtx
argument_list|(
name|pmode
argument_list|)
decl_stmt|;
name|rtx
name|toc_reg
init|=
name|gen_reg_rtx
argument_list|(
name|pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|fn_reg
argument_list|,
name|MEM_DEREF
argument_list|(
name|fnaddr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|toc_reg
argument_list|,
name|MEM_PLUS
argument_list|(
name|fnaddr
argument_list|,
name|regsize
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_DEREF
argument_list|(
name|addr
argument_list|)
argument_list|,
name|fn_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_PLUS
argument_list|(
name|addr
argument_list|,
name|regsize
argument_list|)
argument_list|,
name|toc_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_PLUS
argument_list|(
name|addr
argument_list|,
literal|2
operator|*
name|regsize
argument_list|)
argument_list|,
name|ctx_reg
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Under V.4/eabi/darwin, __trampoline_setup does the real work.  */
case|case
name|ABI_DARWIN
case|:
case|case
name|ABI_V4
case|:
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|SImode
argument_list|,
literal|"__trampoline_setup"
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|,
name|addr
argument_list|,
name|pmode
argument_list|,
name|GEN_INT
argument_list|(
name|rs6000_trampoline_size
argument_list|()
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|fnaddr
argument_list|,
name|pmode
argument_list|,
name|ctx_reg
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|rs6000_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"altivec"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|rs6000_handle_altivec_attribute
block|}
block|,
block|{
literal|"longcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|rs6000_handle_longcall_attribute
block|}
block|,
block|{
literal|"shortcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|rs6000_handle_longcall_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the "altivec" attribute.  The attribute may have    arguments as follows:         __attribute__((altivec(vector__)))        __attribute__((altivec(pixel__)))       (always followed by 'unsigned short')        __attribute__((altivec(bool__)))        (always followed by 'unsigned')    and may appear more than once (e.g., 'vector bool char') in a   given declaration.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_handle_altivec_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|,
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsigned_p
decl_stmt|;
name|char
name|altivec_type
init|=
operator|(
operator|(
name|args
operator|&&
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|?
operator|*
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
else|:
literal|'?'
operator|)
decl_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs6000_warn_altivec_long
operator|&&
operator|(
name|type
operator|==
name|long_unsigned_type_node
operator|||
name|type
operator|==
name|long_integer_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"use of 'long' in AltiVec types is deprecated; use 'int'"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|altivec_type
condition|)
block|{
case|case
literal|'v'
case|:
name|unsigned_p
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SImode
case|:
name|result
operator|=
operator|(
name|unsigned_p
condition|?
name|unsigned_V4SI_type_node
else|:
name|V4SI_type_node
operator|)
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|result
operator|=
operator|(
name|unsigned_p
condition|?
name|unsigned_V8HI_type_node
else|:
name|V8HI_type_node
operator|)
expr_stmt|;
break|break;
case|case
name|QImode
case|:
name|result
operator|=
operator|(
name|unsigned_p
condition|?
name|unsigned_V16QI_type_node
else|:
name|V16QI_type_node
operator|)
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
name|result
operator|=
name|V4SF_type_node
expr_stmt|;
break|break;
comment|/* If the user says 'vector int bool', we may be handed the 'bool' 	       attribute _before_ the 'vector' attribute, and so select the proper 	       type in the 'b' case below.  */
case|case
name|V4SImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V16QImode
case|:
name|result
operator|=
name|type
expr_stmt|;
default|default:
break|break;
block|}
break|break;
case|case
literal|'b'
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SImode
case|:
case|case
name|V4SImode
case|:
name|result
operator|=
name|bool_V4SI_type_node
expr_stmt|;
break|break;
case|case
name|HImode
case|:
case|case
name|V8HImode
case|:
name|result
operator|=
name|bool_V8HI_type_node
expr_stmt|;
break|break;
case|case
name|QImode
case|:
case|case
name|V16QImode
case|:
name|result
operator|=
name|bool_V16QI_type_node
expr_stmt|;
default|default:
break|break;
block|}
break|break;
case|case
literal|'p'
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V8HImode
case|:
name|result
operator|=
name|pixel_V8HI_type_node
expr_stmt|;
default|default:
break|break;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|result
operator|&&
name|result
operator|!=
name|type
operator|&&
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
name|result
operator|=
name|build_qualified_type
argument_list|(
name|result
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
comment|/* No need to hang on to the attribute.  */
if|if
condition|(
operator|!
name|result
condition|)
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|node
operator|=
name|reconstruct_complex_type
argument_list|(
operator|*
name|node
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* AltiVec defines four built-in scalar types that serve as vector    elements; we must teach the compiler how to mangle them.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_mangle_fundamental_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|bool_char_type_node
condition|)
return|return
literal|"U6__boolc"
return|;
if|if
condition|(
name|type
operator|==
name|bool_short_type_node
condition|)
return|return
literal|"U6__bools"
return|;
if|if
condition|(
name|type
operator|==
name|pixel_type_node
condition|)
return|return
literal|"u7__pixel"
return|;
if|if
condition|(
name|type
operator|==
name|bool_int_type_node
condition|)
return|return
literal|"U6__booli"
return|;
comment|/* For all other types, use normal C++ mangling.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Handle a "longcall" or "shortcall" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_handle_longcall_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set longcall attributes on all functions declared when    rs6000_default_long_calls is true.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_set_default_type_attributes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|rs6000_default_long_calls
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"longcall"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a reference suitable for calling a function with the    longcall attribute.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|rs6000_longcall_ref
parameter_list|(
name|rtx
name|call_ref
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|call_name
decl_stmt|;
name|tree
name|node
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_ref
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|call_ref
return|;
comment|/* System V adds '.' to the internal name, so skip them.  */
name|call_name
operator|=
name|XSTR
argument_list|(
name|call_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|call_name
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
operator|*
name|call_name
operator|==
literal|'.'
condition|)
name|call_name
operator|++
expr_stmt|;
name|node
operator|=
name|get_identifier
argument_list|(
name|call_name
argument_list|)
expr_stmt|;
name|call_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|call_ref
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|USING_ELFOS_H
end_ifdef

begin_comment
comment|/* A C statement or statements to switch to the appropriate section    for output of RTX in mode MODE.  You can assume that RTX is some    kind of constant in RTL.  The argument MODE is redundant except in    the case of a `const_int' rtx.  Select the section by calling    `text_section' or one of the alternatives for other sections.     Do not define this macro if you put all constants in the read-only    data section.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
if|if
condition|(
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
name|toc_section
argument_list|()
expr_stmt|;
else|else
name|default_elf_select_rtx_section
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A C statement or statements to switch to the appropriate    section for output of DECL.  DECL is either a `VAR_DECL' node    or a constant of some sort.  RELOC indicates whether forming    the initial value of DECL requires link-time relocations.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_select_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
comment|/* Pretend that we're always building for a shared library when      ABI_AIX, because otherwise we end up with dynamic relocations      in read-only sections.  This happens for function pointers,      references to vtables in typeinfo, and probably other cases.  */
name|default_elf_select_section_1
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|align
argument_list|,
name|flag_pic
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A C statement to build up a unique section name, expressed as a    STRING_CST node, and assign it to DECL_SECTION_NAME (decl).    RELOC indicates whether the initial value of EXP requires    link-time relocations.  If you do not define this macro, GCC will use    the symbol name prefixed by `.' as the section name.  Note - this    macro can now be called for uninitialized data items as well as    initialized data and functions.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
comment|/* As above, pretend that we're always building for a shared library      when ABI_AIX, to avoid dynamic relocations in read-only sections.  */
name|default_unique_section_1
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|flag_pic
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For a SYMBOL_REF, set generic flags and then perform some    target-specific processing.     When the AIX ABI is requested on a non-AIX system, replace the    function name with the real name (with a leading .) rather than the    function descriptor name.  This saves a lot of overriding code to    read the prefixes.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TARGET_AIX
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
name|rtx
name|sym_ref
init|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|rs6000_elf_in_small_data_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|rs6000_sdata
operator|==
name|SDATA_NONE
condition|)
return|return
name|false
return|;
comment|/* We want to merge strings, so we never consider them small data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|false
return|;
comment|/* Functions are never in the small data area.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
comment|/* Thread-local vars can't go in the small data area.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sdata2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sbss2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".PPC.EMB.sdata0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|size
operator|<=
name|g_switch_value
comment|/* If it's not public, and we're not going to reference it there, 	     there's no need to put it in the small data section.  */
operator|&&
operator|(
name|rs6000_sdata
operator|!=
name|SDATA_DATA
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USING_ELFOS_H */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.     r0 is special and we must not select it as an address    register by this routine since our caller will try to    increment the returned register via an "la" instruction.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|find_addr_reg
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rs6000_fatal_bad_address
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|fatal_insn
argument_list|(
literal|"bad address"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_endif
unit|int symbolic_operand (rtx op) {   switch (GET_CODE (op))     {     case SYMBOL_REF:     case LABEL_REF:       return 1;     case CONST:       op = XEXP (op, 0);       return (GET_CODE (op) == SYMBOL_REF || 	      (GET_CODE (XEXP (op, 0)) == SYMBOL_REF 	       || GET_CODE (XEXP (op, 0)) == LABEL_REF)&& GET_CODE (XEXP (op, 1)) == CONST_INT);     default:       return 0;     } }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_decl_stmt
specifier|static
name|tree
name|branch_island_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember to generate a branch island for far calls to the given    function.  */
end_comment

begin_function
specifier|static
name|void
name|add_compiler_branch_island
parameter_list|(
name|tree
name|label_name
parameter_list|,
name|tree
name|function_name
parameter_list|,
name|int
name|line_number
parameter_list|)
block|{
name|tree
name|branch_island
init|=
name|build_tree_list
argument_list|(
name|function_name
argument_list|,
name|label_name
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|branch_island
argument_list|)
operator|=
name|build_int_2
argument_list|(
name|line_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|branch_island
argument_list|)
operator|=
name|branch_island_list
expr_stmt|;
name|branch_island_list
operator|=
name|branch_island
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BRANCH_ISLAND_LABEL_NAME
parameter_list|(
name|BRANCH_ISLAND
parameter_list|)
value|TREE_VALUE (BRANCH_ISLAND)
end_define

begin_define
define|#
directive|define
name|BRANCH_ISLAND_FUNCTION_NAME
parameter_list|(
name|BRANCH_ISLAND
parameter_list|)
value|TREE_PURPOSE (BRANCH_ISLAND)
end_define

begin_define
define|#
directive|define
name|BRANCH_ISLAND_LINE_NUMBER
parameter_list|(
name|BRANCH_ISLAND
parameter_list|)
define|\
value|TREE_INT_CST_LOW (TREE_TYPE (BRANCH_ISLAND))
end_define

begin_comment
comment|/* Generate far-jump branch islands for everything on the    branch_island_list.  Invoked immediately after the last instruction    of the epilogue has been emitted; the branch-islands must be    appended to, and contiguous with, the function body.  Mach-O stubs    are generated in machopic_output_stub().  */
end_comment

begin_function
specifier|static
name|void
name|macho_branch_islands
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|tmp_buf
index|[
literal|512
index|]
decl_stmt|;
name|tree
name|branch_island
decl_stmt|;
for|for
control|(
name|branch_island
operator|=
name|branch_island_list
init|;
name|branch_island
condition|;
name|branch_island
operator|=
name|TREE_CHAIN
argument_list|(
name|branch_island
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|label
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|BRANCH_ISLAND_LABEL_NAME
argument_list|(
name|branch_island
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|darwin_strip_name_encoding
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|BRANCH_ISLAND_FUNCTION_NAME
argument_list|(
name|branch_island
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|name_buf
index|[
literal|512
index|]
decl_stmt|;
comment|/* Cheap copy of the details from the Darwin ASM_OUTPUT_LABELREF().  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|strcpy
argument_list|(
name|name_buf
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|name_buf
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|name_buf
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tmp_buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.stabd 68,0,"
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|"\n"
argument_list|,
name|BRANCH_ISLAND_LINE_NUMBER
argument_list|(
name|branch_island
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
if|if
condition|(
name|flag_pic
condition|)
block|{
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|":\n\tmflr r0\n\tbcl 20,31,"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"_pic\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"_pic:\n\tmflr r11\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"\taddis r11,r11,ha16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"_pic)\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"\tmtlr r0\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"\taddi r12,r11,lo16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"_pic)\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"\tmtctr r12\n\tbctr\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|":\nlis r12,hi16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|")\n\tori r12,r12,lo16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|")\n\tmtctr r12\n\tbctr"
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|tmp_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.stabd 68,0,"
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|"\n"
argument_list|,
name|BRANCH_ISLAND_LINE_NUMBER
argument_list|(
name|branch_island
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
block|}
name|branch_island_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NO_PREVIOUS_DEF checks in the link list whether the function name is    already there or not.  */
end_comment

begin_function
specifier|static
name|int
name|no_previous_def
parameter_list|(
name|tree
name|function_name
parameter_list|)
block|{
name|tree
name|branch_island
decl_stmt|;
for|for
control|(
name|branch_island
operator|=
name|branch_island_list
init|;
name|branch_island
condition|;
name|branch_island
operator|=
name|TREE_CHAIN
argument_list|(
name|branch_island
argument_list|)
control|)
if|if
condition|(
name|function_name
operator|==
name|BRANCH_ISLAND_FUNCTION_NAME
argument_list|(
name|branch_island
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* GET_PREV_LABEL gets the label name from the previous definition of    the function.  */
end_comment

begin_function
specifier|static
name|tree
name|get_prev_label
parameter_list|(
name|tree
name|function_name
parameter_list|)
block|{
name|tree
name|branch_island
decl_stmt|;
for|for
control|(
name|branch_island
operator|=
name|branch_island_list
init|;
name|branch_island
condition|;
name|branch_island
operator|=
name|TREE_CHAIN
argument_list|(
name|branch_island
argument_list|)
control|)
if|if
condition|(
name|function_name
operator|==
name|BRANCH_ISLAND_FUNCTION_NAME
argument_list|(
name|branch_island
argument_list|)
condition|)
return|return
name|BRANCH_ISLAND_LABEL_NAME
argument_list|(
name|branch_island
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* INSN is either a function call or a millicode call.  It may have an    unconditional jump in its delay slot.       CALL_DEST is the routine we are calling.  */
end_comment

begin_function
name|char
modifier|*
name|output_call
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|dest_operand_number
parameter_list|,
name|int
name|cookie_operand_number
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|dest_operand_number
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|INTVAL
argument_list|(
name|operands
index|[
name|cookie_operand_number
index|]
argument_list|)
operator|&
name|CALL_LONG
operator|)
condition|)
block|{
name|tree
name|labelname
decl_stmt|;
name|tree
name|funname
init|=
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|operands
index|[
name|dest_operand_number
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|no_previous_def
argument_list|(
name|funname
argument_list|)
condition|)
block|{
name|int
name|line_number
init|=
literal|0
decl_stmt|;
name|rtx
name|label_rtx
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|char
modifier|*
name|label_buf
decl_stmt|,
name|temp_buf
index|[
literal|256
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|temp_buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|label_buf
operator|=
name|temp_buf
index|[
literal|0
index|]
operator|==
literal|'*'
condition|?
name|temp_buf
operator|+
literal|1
else|:
name|temp_buf
expr_stmt|;
name|labelname
operator|=
name|get_identifier
argument_list|(
name|label_buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
condition|)
name|line_number
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_compiler_branch_island
argument_list|(
name|labelname
argument_list|,
name|funname
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
block|}
else|else
name|labelname
operator|=
name|get_prev_label
argument_list|(
name|funname
argument_list|)
expr_stmt|;
comment|/* "jbsr foo, L42" is Mach-O for "Link as 'bl foo' if a 'bl' 	 instruction will reach 'foo', otherwise link as 'bl L42'". 	 "L42" should be a 'branch island', that will do a far jump to 	 'foo'.  Branch islands are generated in 	 macho_branch_islands().  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"jbsr %%z%d,%.246s"
argument_list|,
name|dest_operand_number
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|labelname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bl %%z%d"
argument_list|,
name|dest_operand_number
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_MACHO */
end_comment

begin_comment
comment|/* Generate PIC and indirect symbol stubs.  */
end_comment

begin_function
name|void
name|machopic_output_stub
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|symb
parameter_list|,
specifier|const
name|char
modifier|*
name|stub
parameter_list|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|symbol_name
decl_stmt|,
modifier|*
name|lazy_ptr_name
decl_stmt|;
name|char
modifier|*
name|local_label_0
decl_stmt|;
specifier|static
name|int
name|label
init|=
literal|0
decl_stmt|;
comment|/* Lose our funky encoding stuff so it doesn't contaminate the stub.  */
name|symb
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_SYMBOL_NAME_FOR_SYMBOL
argument_list|(
name|symbol_name
argument_list|,
name|symb
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|lazy_ptr_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_LAZY_PTR_NAME_FOR_SYMBOL
argument_list|(
name|lazy_ptr_name
argument_list|,
name|symb
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
name|machopic_picsymbol_stub1_section
argument_list|()
expr_stmt|;
else|else
name|machopic_symbol_stub1_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align 2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|label
operator|++
expr_stmt|;
name|local_label_0
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
literal|"\"L0000000000$spb\""
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|local_label_0
argument_list|,
literal|"\"L%011d$spb\""
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr r0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbcl 20,31,%s\n"
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n\tmflr r11\n"
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddis r11,r11,ha16(%s-%s)\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtlr r0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlwzu r12,lo16(%s-%s)(r11)\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtctr r12\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbctr\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlis r11,ha16(%s)\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlwzu r12,lo16(%s)(r11)\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtctr r12\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbctr\n"
argument_list|)
expr_stmt|;
block|}
name|machopic_lazy_symbol_ptr_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long dyld_stub_binding_helper\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already    position-independent, we return ORIG.  Newly generated    position-independent addresses go into a reg.  This is REG if non    zero, otherwise we allocate register(s) as necessary.  */
end_comment

begin_define
define|#
directive|define
name|SMALL_INT
parameter_list|(
name|X
parameter_list|)
value|((unsigned) (INTVAL(X) + 0x8000)< 0x10000)
end_define

begin_function
name|rtx
name|rs6000_machopic_legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
operator|&&
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Use a different reg for the intermediate value, as 	     it will be marked UNCHANGING.  */
name|rtx
name|reg_temp
init|=
name|no_new_pseudos
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|base
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg_temp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|mem
init|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
decl_stmt|;
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|mem
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
return|;
block|}
block|}
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/* Fall back on generic machopic code.  */
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|orig
argument_list|,
name|mode
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is just a placeholder to make linking work without having to    add this to the generic Darwin EXTRA_SECTIONS.  If -mcall-aix is    ever needed for Darwin (not too likely!) this would have to get a    real definition.  */
end_comment

begin_function
name|void
name|toc_section
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_MACHO */
end_comment

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_function
specifier|static
name|unsigned
name|int
name|rs6000_elf_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
return|return
name|default_section_type_flags_1
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|,
name|flag_pic
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_AIX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Record an element in the table of global constructors.  SYMBOL is    a SYMBOL_REF of the function to be called; PRIORITY is a number    between 0 and MAX_INIT_PRIORITY.     This differs from default_named_section_asm_out_constructor in    that we have special handling for -mrelocatable.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".ctors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".ctors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper                   order; constructors are run from right to left, and the                   linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.long ("
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")@fixup\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_elf_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".dtors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".dtors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper                   order; constructors are run from right to left, and the                   linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|named_section_flags
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.long ("
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")@fixup\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rs6000_elf_declare_function_name
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.section\t\".opd\",\"aw\"\n\t.align 3\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",.TOC.@tocbase,0\n\t.previous\n\t.size\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",24\n\t.type\t."
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",@function\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.globl\t."
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|ASM_DECLARE_RESULT
argument_list|(
name|file
argument_list|,
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TARGET_RELOCATABLE
operator|&&
operator|(
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|||
name|current_function_profile
operator|)
operator|&&
name|uses_TOC
argument_list|()
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|file
argument_list|,
literal|"LCL"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCTOC"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCF"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_TYPE_DIRECTIVE
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
name|ASM_DECLARE_RESULT
argument_list|(
name|file
argument_list|,
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
specifier|const
name|char
modifier|*
name|desc_name
decl_stmt|,
modifier|*
name|orig_name
decl_stmt|;
name|orig_name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|desc_name
operator|=
name|orig_name
expr_stmt|;
while|while
condition|(
operator|*
name|desc_name
operator|==
literal|'.'
condition|)
name|desc_name
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.globl %s\n"
argument_list|,
name|desc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|MINIMAL_TOC_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|desc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long %s\n"
argument_list|,
name|orig_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.long _GLOBAL_OFFSET_TABLE_\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
name|fputs
argument_list|(
literal|"\t.long 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.previous\n"
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_elf_end_indicate_exec_stack
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_32BIT
condition|)
name|file_end_indicate_exec_stack
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET_XCOFF
end_if

begin_function
specifier|static
name|void
name|rs6000_xcoff_asm_globalize_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fputs
argument_list|(
name|GLOBAL_ASM_OP
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_xcoff_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|smclass
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|suffix
index|[
literal|3
index|]
init|=
block|{
literal|"PR"
block|,
literal|"RO"
block|,
literal|"RW"
block|}
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
name|smclass
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
name|smclass
operator|=
literal|2
expr_stmt|;
else|else
name|smclass
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.csect %s%s[%s],%u\n"
argument_list|,
operator|(
name|flags
operator|&
name|SECTION_CODE
operator|)
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|name
argument_list|,
name|suffix
index|[
name|smclass
index|]
argument_list|,
name|flags
operator|&
name|SECTION_ENTSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_xcoff_select_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|decl_readonly_section_1
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|read_only_data_section
argument_list|()
expr_stmt|;
else|else
name|read_only_private_data_section
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|private_data_section
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_xcoff_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Use select_section for private and uninitialized data.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
operator|(
name|flag_zero_initialized_in_bss
operator|&&
name|initializer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select section for constant in constant pool.     On RS/6000, all constants are in the private read-only data area.    However, if this is being placed in the TOC it must be output as a    toc entry.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
name|toc_section
argument_list|()
expr_stmt|;
else|else
name|read_only_private_data_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove any trailing [DS] or the like from the symbol name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_xcoff_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'*'
condition|)
name|name
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
return|return
name|ggc_alloc_string
argument_list|(
name|name
argument_list|,
name|len
operator|-
literal|4
argument_list|)
return|;
else|else
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Section attributes.  AIX is always PIC.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rs6000_xcoff_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
name|default_section_type_flags_1
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Align to at least UNIT size.  */
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
name|align
operator|=
name|MIN_UNITS_PER_WORD
expr_stmt|;
else|else
comment|/* Increase alignment of large objects if not already stricter.  */
name|align
operator|=
name|MAX
argument_list|(
operator|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|>
name|MIN_UNITS_PER_WORD
condition|?
name|UNITS_PER_FP_WORD
else|:
name|MIN_UNITS_PER_WORD
argument_list|)
expr_stmt|;
return|return
name|flags
operator||
operator|(
name|exact_log2
argument_list|(
name|align
argument_list|)
operator|&
name|SECTION_ENTSIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output at beginning of assembler file.     Initialize the section names for the RS/6000 at this point.     Specify filename, including full path, to assembler.     We want to go into the TOC section so at least one .toc will be emitted.    Also, in order to output proper .bs/.es pairs, we need at least one static    [RW] section emitted.     Finally, declare mcount when profiling to make the assembler happy.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|rs6000_gen_section_name
argument_list|(
operator|&
name|xcoff_bss_section_name
argument_list|,
name|main_input_filename
argument_list|,
literal|".bss_"
argument_list|)
expr_stmt|;
name|rs6000_gen_section_name
argument_list|(
operator|&
name|xcoff_private_data_section_name
argument_list|,
name|main_input_filename
argument_list|,
literal|".rw_"
argument_list|)
expr_stmt|;
name|rs6000_gen_section_name
argument_list|(
operator|&
name|xcoff_read_only_section_name
argument_list|,
name|main_input_filename
argument_list|,
literal|".ro_"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.file\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|toc_section
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|private_data_section
argument_list|()
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
if|if
condition|(
name|profile_flag
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.extern %s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|)
expr_stmt|;
name|rs6000_file_start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output at end of assembler file.    On the RS/6000, referencing data should automatically pull in text.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|text_section
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"_section_.text:\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|data_section
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|TARGET_32BIT
condition|?
literal|"\t.long _section_.text\n"
else|:
literal|"\t.llong _section_.text\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_XCOFF */
end_comment

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_comment
comment|/* Cross-module name binding.  Darwin does not support overriding    functions at dynamic-link time.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_binds_local_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|default_binds_local_p_1
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* On the RS/6000, if it is valid in the insn, it is free. 	 So this always returns 0.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|HIGH
case|:
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS
case|:
operator|*
name|total
operator|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
operator|)
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
operator|*
name|total
operator|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffff
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|optimize_size
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|rs6000_cpu
condition|)
block|{
case|case
name|PROCESSOR_RIOS1
case|:
case|case
name|PROCESSOR_PPC405
case|:
operator|*
name|total
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
else|:
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|-
literal|256
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|255
operator|)
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC440
case|:
operator|*
name|total
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_RS64A
case|:
operator|*
name|total
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|DImode
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
else|:
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|-
literal|256
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|255
operator|)
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_RIOS2
case|:
case|case
name|PROCESSOR_MPCCORE
case|:
case|case
name|PROCESSOR_PPC604e
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC601
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC603
case|:
case|case
name|PROCESSOR_PPC7400
case|:
case|case
name|PROCESSOR_PPC750
case|:
operator|*
name|total
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
else|:
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|-
literal|256
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|255
operator|)
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC7450
case|:
operator|*
name|total
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC403
case|:
case|case
name|PROCESSOR_PPC604
case|:
case|case
name|PROCESSOR_PPC8540
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC620
case|:
case|case
name|PROCESSOR_PPC630
case|:
operator|*
name|total
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|DImode
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
else|:
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|-
literal|256
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|255
operator|)
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_POWER4
case|:
case|case
name|PROCESSOR_POWER5
case|:
operator|*
name|total
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|?
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|DImode
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|DIV
case|:
case|case
name|MOD
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* FALLTHRU */
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
switch|switch
condition|(
name|rs6000_cpu
condition|)
block|{
case|case
name|PROCESSOR_RIOS1
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_RIOS2
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|13
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_RS64A
case|:
operator|*
name|total
operator|=
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|DImode
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|65
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|67
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_MPCCORE
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC403
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|33
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC405
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC440
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC601
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC603
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC604
case|:
case|case
name|PROCESSOR_PPC604e
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC620
case|:
case|case
name|PROCESSOR_PPC630
case|:
operator|*
name|total
operator|=
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|DImode
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|21
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC750
case|:
case|case
name|PROCESSOR_PPC8540
case|:
case|case
name|PROCESSOR_PPC7400
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_PPC7450
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PROCESSOR_POWER4
case|:
case|case
name|PROCESSOR_POWER5
case|:
operator|*
name|total
operator|=
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|DImode
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
else|:
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|FFS
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|MEM
case|:
comment|/* MEM should be slightly more expensive than (plus (reg) (const)).  */
operator|*
name|total
operator|=
literal|5
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* A C expression returning the cost of moving data from a register of class    CLASS1 to one of CLASS2.  */
end_comment

begin_function
name|int
name|rs6000_register_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|from
parameter_list|,
name|enum
name|reg_class
name|to
parameter_list|)
block|{
comment|/*  Moves from/to GENERAL_REGS.  */
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|to
argument_list|,
name|GENERAL_REGS
argument_list|)
operator|||
name|reg_classes_intersect_p
argument_list|(
name|from
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|reg_classes_intersect_p
argument_list|(
name|to
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
name|from
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|FLOAT_REGS
operator|||
name|from
operator|==
name|ALTIVEC_REGS
condition|)
return|return
operator|(
name|rs6000_memory_move_cost
argument_list|(
name|mode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
operator|+
name|rs6000_memory_move_cost
argument_list|(
name|mode
argument_list|,
name|GENERAL_REGS
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* It's more expensive to move CR_REGS than CR0_REGS because of the shift....  */
elseif|else
if|if
condition|(
name|from
operator|==
name|CR_REGS
condition|)
return|return
literal|4
return|;
else|else
comment|/* A move will cost one instruction per GPR moved.  */
return|return
literal|2
operator|*
name|HARD_REGNO_NREGS
argument_list|(
literal|0
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Moving between two similar registers is just one instruction.  */
elseif|else
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|mode
operator|==
name|TFmode
condition|?
literal|4
else|:
literal|2
return|;
comment|/* Everything else has to go through GENERAL_REGS.  */
else|else
return|return
operator|(
name|rs6000_register_move_cost
argument_list|(
name|mode
argument_list|,
name|GENERAL_REGS
argument_list|,
name|to
argument_list|)
operator|+
name|rs6000_register_move_cost
argument_list|(
name|mode
argument_list|,
name|from
argument_list|,
name|GENERAL_REGS
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A C expressions returning the cost of moving data of MODE from a register to    or from memory.  */
end_comment

begin_function
name|int
name|rs6000_memory_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|,
name|int
name|in
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
return|return
literal|4
operator|*
name|HARD_REGNO_NREGS
argument_list|(
literal|0
argument_list|,
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|class
argument_list|,
name|FLOAT_REGS
argument_list|)
condition|)
return|return
literal|4
operator|*
name|HARD_REGNO_NREGS
argument_list|(
literal|32
argument_list|,
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|class
argument_list|,
name|ALTIVEC_REGS
argument_list|)
condition|)
return|return
literal|4
operator|*
name|HARD_REGNO_NREGS
argument_list|(
name|FIRST_ALTIVEC_REGNO
argument_list|,
name|mode
argument_list|)
return|;
else|else
return|return
literal|4
operator|+
name|rs6000_register_move_cost
argument_list|(
name|mode
argument_list|,
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an RTX representing where to find the function value of a    function returning MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_complex_function_value
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|enum
name|machine_mode
name|inner
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inner_bytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
name|regno
operator|=
name|FP_ARG_RETURN
expr_stmt|;
else|else
block|{
name|regno
operator|=
name|GP_ARG_RETURN
expr_stmt|;
comment|/* 32-bit is OK since it'll go in r3/r4.  */
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|inner_bytes
operator|>=
literal|4
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
if|if
condition|(
name|inner_bytes
operator|>=
literal|8
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
name|r1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|inner
argument_list|,
name|gen_rtx_REG
argument_list|(
name|inner
argument_list|,
name|regno
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|r2
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|inner
argument_list|,
name|gen_rtx_REG
argument_list|(
name|inner
argument_list|,
name|regno
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|inner_bytes
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a function.    VALTYPE is the data type of the value (as a tree).    If the precise function being called is known, FUNC is its FUNCTION_DECL;    otherwise, FUNC is 0.     On the SPE, both FPs and vectors are returned in r3.     On RS/6000 an integer value is in r3 and a floating-point value is in    fp1, unless -msoft-float.  */
end_comment

begin_function
name|rtx
name|rs6000_function_value
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
name|func
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
operator|&&
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|DImode
condition|)
block|{
comment|/* Long long return value need be split in -mpowerpc64, 32bit ABI.  */
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|DImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|valtype
argument_list|)
operator|<
name|BITS_PER_WORD
operator|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|valtype
argument_list|)
condition|)
name|mode
operator|=
name|TARGET_32BIT
condition|?
name|SImode
else|:
name|DImode
expr_stmt|;
else|else
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
name|regno
operator|=
name|FP_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
condition|)
return|return
name|rs6000_complex_function_value
argument_list|(
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_ABI
condition|)
name|regno
operator|=
name|ALTIVEC_ARG_RETURN
expr_stmt|;
else|else
name|regno
operator|=
name|GP_ARG_RETURN
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a library function    assuming the value has mode MODE.  */
end_comment

begin_function
name|rtx
name|rs6000_libcall_value
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
name|regno
operator|=
name|FP_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_ABI
condition|)
name|regno
operator|=
name|ALTIVEC_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
condition|)
return|return
name|rs6000_complex_function_value
argument_list|(
name|mode
argument_list|)
return|;
else|else
name|regno
operator|=
name|GP_ARG_RETURN
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define the offset between two registers, FROM to be eliminated and its    replacement TO, at the start of a routine.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|rs6000_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|offset
operator|=
name|info
operator|->
name|push_p
condition|?
literal|0
else|:
operator|-
name|info
operator|->
name|total_size
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|FRAME_POINTER_REGNUM
condition|)
name|offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|offset
operator|=
name|info
operator|->
name|push_p
condition|?
name|info
operator|->
name|total_size
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE is of type __ev64_opaque__.  */
end_comment

begin_function
specifier|static
name|bool
name|is_ev64_opaque_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
operator|(
name|TARGET_SPE
operator|&&
operator|(
name|type
operator|==
name|opaque_V2SI_type_node
operator|||
name|type
operator|==
name|opaque_V2SF_type_node
operator|||
name|type
operator|==
name|opaque_p_V2SI_type_node
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|rs6000_dwarf_register_span
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|unsigned
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_SPE
operator|||
operator|!
name|SPE_VECTOR_MODE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* The duality of the SPE register size wreaks all kinds of havoc.      This is a way of distinguishing r0 in 32-bits from r0 in      64-bits.  */
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|BYTES_BIG_ENDIAN
condition|?
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
operator|+
literal|1200
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
argument_list|)
else|:
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
operator|+
literal|1200
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Map internal gcc register numbers to DWARF2 register numbers.  */
end_comment

begin_function
name|unsigned
name|int
name|rs6000_dbx_register_number
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<=
literal|63
operator|||
name|write_symbols
operator|!=
name|DWARF2_DEBUG
condition|)
return|return
name|regno
return|;
if|if
condition|(
name|regno
operator|==
name|MQ_REGNO
condition|)
return|return
literal|100
return|;
if|if
condition|(
name|regno
operator|==
name|LINK_REGISTER_REGNUM
condition|)
return|return
literal|108
return|;
if|if
condition|(
name|regno
operator|==
name|COUNT_REGISTER_REGNUM
condition|)
return|return
literal|109
return|;
if|if
condition|(
name|CR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|regno
operator|-
name|CR0_REGNO
operator|+
literal|86
return|;
if|if
condition|(
name|regno
operator|==
name|XER_REGNO
condition|)
return|return
literal|101
return|;
if|if
condition|(
name|ALTIVEC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|regno
operator|-
name|FIRST_ALTIVEC_REGNO
operator|+
literal|1124
return|;
if|if
condition|(
name|regno
operator|==
name|VRSAVE_REGNO
condition|)
return|return
literal|356
return|;
if|if
condition|(
name|regno
operator|==
name|VSCR_REGNO
condition|)
return|return
literal|67
return|;
if|if
condition|(
name|regno
operator|==
name|SPE_ACC_REGNO
condition|)
return|return
literal|99
return|;
if|if
condition|(
name|regno
operator|==
name|SPEFSCR_REGNO
condition|)
return|return
literal|612
return|;
comment|/* SPE high reg number.  We get these values of regno from      rs6000_dwarf_register_span.  */
if|if
condition|(
name|regno
operator|>=
literal|1200
operator|&&
name|regno
operator|<
literal|1232
condition|)
return|return
name|regno
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-rs6000.h"
end_include

end_unit

