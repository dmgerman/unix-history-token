begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IBM RS/6000.    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tm-constrs.h"
end_include

begin_if
if|#
directive|if
name|TARGET_XCOFF
end_if

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* get declarations of xcoff_*_section_name */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* for N_SLINE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_NO_PROTOTYPE
end_ifndef

begin_define
define|#
directive|define
name|TARGET_NO_PROTOTYPE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_comment
comment|/* Structure used to define the rs6000 stack */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rs6000_stack
block|{
name|int
name|first_gp_reg_save
decl_stmt|;
comment|/* first callee saved GP register used */
name|int
name|first_fp_reg_save
decl_stmt|;
comment|/* first callee saved FP register used */
name|int
name|first_altivec_reg_save
decl_stmt|;
comment|/* first callee saved AltiVec register used */
name|int
name|lr_save_p
decl_stmt|;
comment|/* true if the link reg needs to be saved */
name|int
name|cr_save_p
decl_stmt|;
comment|/* true if the CR reg needs to be saved */
name|unsigned
name|int
name|vrsave_mask
decl_stmt|;
comment|/* mask of vec registers to save */
name|int
name|push_p
decl_stmt|;
comment|/* true if we need to allocate stack space */
name|int
name|calls_p
decl_stmt|;
comment|/* true if the function makes any calls */
name|int
name|world_save_p
decl_stmt|;
comment|/* true if we're saving *everything*: 				   r13-r31, cr, f14-f31, vrsave, v20-v31  */
name|enum
name|rs6000_abi
name|abi
decl_stmt|;
comment|/* which ABI to use */
name|int
name|gp_save_offset
decl_stmt|;
comment|/* offset to save GP regs from initial SP */
name|int
name|fp_save_offset
decl_stmt|;
comment|/* offset to save FP regs from initial SP */
name|int
name|altivec_save_offset
decl_stmt|;
comment|/* offset to save AltiVec regs from initial SP */
name|int
name|lr_save_offset
decl_stmt|;
comment|/* offset to save LR from initial SP */
name|int
name|cr_save_offset
decl_stmt|;
comment|/* offset to save CR from initial SP */
name|int
name|vrsave_save_offset
decl_stmt|;
comment|/* offset to save VRSAVE from initial SP */
name|int
name|spe_gp_save_offset
decl_stmt|;
comment|/* offset to save spe 64-bit gprs  */
name|int
name|varargs_save_offset
decl_stmt|;
comment|/* offset to save the varargs registers */
name|int
name|ehrd_offset
decl_stmt|;
comment|/* offset to EH return data */
name|int
name|reg_size
decl_stmt|;
comment|/* register size (4 or 8) */
name|HOST_WIDE_INT
name|vars_size
decl_stmt|;
comment|/* variable save area size */
name|int
name|parm_size
decl_stmt|;
comment|/* outgoing parameter size */
name|int
name|save_size
decl_stmt|;
comment|/* save area size */
name|int
name|fixed_size
decl_stmt|;
comment|/* fixed size of stack frame */
name|int
name|gp_size
decl_stmt|;
comment|/* size of saved GP registers */
name|int
name|fp_size
decl_stmt|;
comment|/* size of saved FP registers */
name|int
name|altivec_size
decl_stmt|;
comment|/* size of saved AltiVec registers */
name|int
name|cr_size
decl_stmt|;
comment|/* size to hold CR if not in save_size */
name|int
name|vrsave_size
decl_stmt|;
comment|/* size to hold VRSAVE if not in save_size */
name|int
name|altivec_padding_size
decl_stmt|;
comment|/* size of altivec alignment padding if 				   not in save_size */
name|int
name|spe_gp_size
decl_stmt|;
comment|/* size of 64-bit GPR save size for SPE */
name|int
name|spe_padding_size
decl_stmt|;
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
comment|/* total bytes allocated for stack */
name|int
name|spe_64bit_regs_used
decl_stmt|;
block|}
name|rs6000_stack_t
typedef|;
end_typedef

begin_comment
comment|/* A C structure for machine-specific, per-function data.    This is added to the cfun structure.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|machine_function
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Flags if __builtin_return_address (n) with n>= 1 was used.  */
name|int
name|ra_needs_full_frame
block|;
comment|/* Some local-dynamic symbol.  */
specifier|const
name|char
modifier|*
name|some_ld_name
block|;
comment|/* Whether the instruction chain has been scanned already.  */
name|int
name|insn_chain_scanned_p
block|;
comment|/* Flags if __builtin_return_address (0) was used.  */
name|int
name|ra_need_lr
block|;
comment|/* Offset from virtual_stack_vars_rtx to the start of the ABI_V4      varargs save area.  */
name|HOST_WIDE_INT
name|varargs_save_offset
block|; }
end_typedef

begin_expr_stmt
name|machine_function
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Target cpu type */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|rs6000_cpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rs6000_cpu_select
name|rs6000_select
index|[
literal|3
index|]
init|=
block|{
comment|/* switch		name,			tune	arch */
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"--with-cpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mcpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mtune="
block|,
literal|1
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Always emit branch hint bits.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|bool
name|rs6000_always_hint
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Schedule instructions for group formation.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|bool
name|rs6000_sched_groups
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Support for -msched-costly-dep option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_sched_costly_dep_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|rs6000_dependence_cost
name|rs6000_sched_costly_dep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support for -minsert-sched-nops option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_sched_insert_nops_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|rs6000_nop_insertion
name|rs6000_sched_insert_nops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support targetm.vectorize.builtin_mask_for_load.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|altivec_builtin_mask_for_load
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Size of long double.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_long_double_type_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IEEE quad extended precision long double. */
end_comment

begin_decl_stmt
name|int
name|rs6000_ieeequad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether -mabi=altivec has appeared.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_altivec_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want SPE ABI extensions.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_spe_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if floating point operations are done in the GPRs.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_float_gprs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want Darwin's struct-by-value-in-regs ABI.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_darwin64_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero once AIX common-mode calls have been defined.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|common_mode_defined
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|rs6000_compare_op0
decl_stmt|,
name|rs6000_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_compare_fp_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label number of label created for -mrelocatable, to call to so we can    get the address of the GOT section */
end_comment

begin_decl_stmt
name|int
name|rs6000_pic_labelno
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USING_ELFOS_H
end_ifdef

begin_comment
comment|/* Which abi to adhere to */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_abi_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Semantics of the small data area */
end_comment

begin_decl_stmt
name|enum
name|rs6000_sdata_type
name|rs6000_sdata
init|=
name|SDATA_DATA
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which small data model to use */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_sdata_name
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter for labels which are to be placed in .fixup.  */
end_comment

begin_decl_stmt
name|int
name|fixuplabelno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bit size of immediate TLS offsets and string from which it is decoded.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_tls_size
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_tls_size_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ABI enumeration available for subtarget to use.  */
end_comment

begin_decl_stmt
name|enum
name|rs6000_abi
name|rs6000_current_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to use variant of AIX ABI for PowerPC64 Linux.  */
end_comment

begin_decl_stmt
name|int
name|dot_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug flags */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_debug_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_debug_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug stack applications */
end_comment

begin_decl_stmt
name|int
name|rs6000_debug_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug argument handling */
end_comment

begin_comment
comment|/* Value is TRUE if register/mode pair is acceptable.  */
end_comment

begin_decl_stmt
name|bool
name|rs6000_hard_regno_mode_ok_p
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Built in types.  */
end_comment

begin_decl_stmt
name|tree
name|rs6000_builtin_types
index|[
name|RS6000_BTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|rs6000_builtin_decls
index|[
name|RS6000_BUILTIN_COUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rs6000_traceback_name
decl_stmt|;
end_decl_stmt

begin_enum
specifier|static
enum|enum
block|{
name|traceback_default
init|=
literal|0
block|,
name|traceback_none
block|,
name|traceback_part
block|,
name|traceback_full
block|}
name|rs6000_traceback
enum|;
end_enum

begin_comment
comment|/* Flag to say the TOC is initialized */
end_comment

begin_decl_stmt
name|int
name|toc_initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|toc_label_name
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|read_only_data_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|private_data_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|read_only_private_data_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|sdata2_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|toc_section
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Control alignment for fields within structures.  */
end_comment

begin_comment
comment|/* String from -malign-XXXXX.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_alignment_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True for any options that were explicitly set.  */
end_comment

begin_struct
struct|struct
block|{
name|bool
name|aix_struct_ret
decl_stmt|;
comment|/* True if -maix-struct-ret was used.  */
name|bool
name|alignment
decl_stmt|;
comment|/* True if -malign- was used.  */
name|bool
name|abi
decl_stmt|;
comment|/* True if -mabi=spe/nospe was used.  */
name|bool
name|spe
decl_stmt|;
comment|/* True if -mspe= was used.  */
name|bool
name|float_gprs
decl_stmt|;
comment|/* True if -mfloat-gprs= was used.  */
name|bool
name|isel
decl_stmt|;
comment|/* True if -misel was used. */
name|bool
name|long_double
decl_stmt|;
comment|/* True if -mlong-double- was used.  */
name|bool
name|ieee
decl_stmt|;
comment|/* True if -mabi=ieee/ibmlongdouble used.  */
block|}
name|rs6000_explicit_options
struct|;
end_struct

begin_struct
struct|struct
name|builtin_description
block|{
comment|/* mask is not const because we're going to alter it below.  This      nonsense will go away when we rewrite the -march infrastructure      to give us more target flag bits.  */
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|rs6000_builtins
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Target cpu costs.  */
end_comment

begin_struct
struct|struct
name|processor_costs
block|{
specifier|const
name|int
name|mulsi
decl_stmt|;
comment|/* cost of SImode multiplication.  */
specifier|const
name|int
name|mulsi_const
decl_stmt|;
comment|/* cost of SImode multiplication by constant.  */
specifier|const
name|int
name|mulsi_const9
decl_stmt|;
comment|/* cost of SImode mult by short constant.  */
specifier|const
name|int
name|muldi
decl_stmt|;
comment|/* cost of DImode multiplication.  */
specifier|const
name|int
name|divsi
decl_stmt|;
comment|/* cost of SImode division.  */
specifier|const
name|int
name|divdi
decl_stmt|;
comment|/* cost of DImode division.  */
specifier|const
name|int
name|fp
decl_stmt|;
comment|/* cost of simple SFmode and DFmode insns.  */
specifier|const
name|int
name|dmul
decl_stmt|;
comment|/* cost of DFmode multiplication (and fmadd).  */
specifier|const
name|int
name|sdiv
decl_stmt|;
comment|/* cost of SFmode division (fdivs).  */
specifier|const
name|int
name|ddiv
decl_stmt|;
comment|/* cost of DFmode division (fdiv).  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|processor_costs
modifier|*
name|rs6000_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor costs (relative to an add) */
end_comment

begin_comment
comment|/* Instruction size costs on 32bit processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|size32_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction size costs on 64bit processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|size64_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on RIOS1 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|rios1_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on RIOS2 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|rios2_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|13
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|13
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on RS64A processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|rs64a_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|65
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|67
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|31
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|31
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on MPCCORE processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|mpccore_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC403 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc403_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|33
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|33
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC405 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc405_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC440 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc440_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|33
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC601 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc601_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|31
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC603 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc603_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|33
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC604 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc604_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC604e processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc604e_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC620 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc620_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|21
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC630 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc630_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|21
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|21
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC750 and PPC7400 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc750_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|31
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC7450 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc7450_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|21
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on PPC8540 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ppc8540_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|29
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|29
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Instruction costs on POWER4 and POWER5 processors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|power4_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* mulsi */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* mulsi_const9 */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* muldi */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* divsi */
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
block|,
comment|/* divdi */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fp */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* dmul */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* sdiv */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* ddiv */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|bool
name|rs6000_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_invalid_within_doloop
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_generate_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_maybe_dead
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_emit_stack_tie
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_frame_related
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_synthesize_frame_save
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|spe_func_has_64bit_regs_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_frame_save
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_frame_mem_offset
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_emit_allocate_stack
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|rs6000_hash_constant
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|toc_hash_function
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|toc_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|constant_pool_expr_1
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|constant_pool_expr_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|legitimate_small_data_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|legitimate_indexed_address_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|legitimate_lo_sum_address_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|rs6000_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_assemble_integer
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|no_global_regs_above
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
end_ifdef

begin_function_decl
specifier|static
name|void
name|rs6000_assemble_visibility
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|rs6000_ra_ever_killed
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rs6000_handle_longcall_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rs6000_handle_altivec_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_ms_bitfield_layout_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rs6000_handle_struct_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_eliminate_indexed_memrefs
parameter_list|(
name|rtx
name|operands
index|[
literal|2
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_mangle_fundamental_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|attribute_spec
name|rs6000_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rs6000_set_default_type_attributes
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_emit_set_long_const
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_return_in_memory
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_function_decl
specifier|static
name|int
name|rs6000_elf_reloc_rw_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_elf_asm_out_constructor
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_elf_asm_out_destructor
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|rs6000_elf_end_indicate_exec_stack
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rs6000_elf_asm_init_sections
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|section
modifier|*
name|rs6000_elf_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|rs6000_elf_encode_section_info
argument_list|(
name|tree
argument_list|,
name|rtx
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|rs6000_use_blocks_for_constant_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TARGET_XCOFF
end_if

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_asm_output_anchor
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_asm_globalize_label
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_asm_init_sections
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_xcoff_reloc_rw_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|section
modifier|*
name|rs6000_xcoff_select_section
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_unique_section
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|section
modifier|*
name|rs6000_xcoff_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_xcoff_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|rs6000_xcoff_section_type_flags
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_xcoff_file_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|rs6000_variable_issue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_microcoded_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_dispatch_slot_restricted
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_cracked_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_branch_slot_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_adjust_priority
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_is_costly_dependence
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_next_active_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|insn_terminates_group_p
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|group_termination
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_costly_group
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|force_new_group
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|redefine_groups
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pad_groups
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_sched_finish
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_use_sched_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rs6000_builtin_mask_for_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|def_builtin
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_vector_alignment_reachable
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_expand_ternop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|altivec_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_common_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_init_libfuncs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_mask_for_builtins
parameter_list|(
name|struct
name|builtin_description
modifier|*
parameter_list|,
name|int
parameter_list|,
name|enum
name|rs6000_builtins
parameter_list|,
name|enum
name|rs6000_builtins
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_opaque_vector_type
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spe_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_expand_stv_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_expand_predicate_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spe_expand_evsel_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_emit_int_cmove
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rs6000_stack_t
modifier|*
name|rs6000_stack_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_stack_info
parameter_list|(
name|rs6000_stack_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_ld_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_st_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_dst_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_abs_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_predicate_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_lv_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_stv_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_vec_init_builtin
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_vec_set_builtin
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|altivec_expand_vec_ext_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_element_number
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_handle_option
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_parse_tls_size_option
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_parse_yes_no_option
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|first_altivec_reg_to_save
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|compute_vrsave_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_save_world_info
parameter_list|(
name|rs6000_stack_t
modifier|*
name|info_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|is_altivec_return_reg
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|generate_set_vrsave
parameter_list|(
name|rtx
parameter_list|,
name|rs6000_stack_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|easy_vector_constant
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_is_opaque_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_dwarf_register_span
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_legitimize_tls_address
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|tls_model
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|rs6000_output_dwarf_dtprel
argument_list|(
name|FILE
operator|*
argument_list|,
name|int
argument_list|,
name|rtx
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|rs6000_tls_get_addr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_got_sym
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_tls_symbol_ref_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_complex_function_value
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_spe_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_darwin64_record_arg_advance_flush
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_darwin64_record_arg_advance_recurse
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_darwin64_record_arg_flush
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
index|[]
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_darwin64_record_arg_recurse
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
index|[]
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_darwin64_record_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_mixed_function_arg
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_move_block_from_reg
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|nregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rs6000_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|invalid_arg_for_unprototyped_fn
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_function_decl
specifier|static
name|void
name|macho_branch_islands
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|no_previous_def
parameter_list|(
name|tree
name|function_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_prev_label
parameter_list|(
name|tree
name|function_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_darwin_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|tree
name|rs6000_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rs6000_gimplify_va_arg
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_must_pass_in_stack
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_scalar_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|rs6000_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_vec_cmp_insn
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rs6000_emit_vector_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_vsel_insn
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rs6000_emit_vector_select
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rs6000_stack_protect_fail
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|int
name|INSN_NOT_AVAILABLE
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|enum
name|machine_mode
name|rs6000_eh_return_filter_mode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hash table stuff for keeping track of TOC entries.  */
end_comment

begin_decl_stmt
name|struct
name|toc_hash_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* `key' will satisfy CONSTANT_P; in fact, it will satisfy      ASM_OUTPUT_SPECIAL_POOL_ENTRY_P.  */
name|rtx
name|key
decl_stmt|;
name|enum
name|machine_mode
name|key_mode
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct toc_hash_struct))
argument_list|)
name|htab_t
name|toc_hash_table
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Default register names.  */
end_comment

begin_decl_stmt
name|char
name|rs6000_reg_names
index|[]
index|[
literal|8
index|]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"mq"
block|,
literal|"lr"
block|,
literal|"ctr"
block|,
literal|"ap"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"xer"
block|,
comment|/* AltiVec registers.  */
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"17"
block|,
literal|"18"
block|,
literal|"19"
block|,
literal|"20"
block|,
literal|"21"
block|,
literal|"22"
block|,
literal|"23"
block|,
literal|"24"
block|,
literal|"25"
block|,
literal|"26"
block|,
literal|"27"
block|,
literal|"28"
block|,
literal|"29"
block|,
literal|"30"
block|,
literal|"31"
block|,
literal|"vrsave"
block|,
literal|"vscr"
block|,
comment|/* SPE registers.  */
literal|"spe_acc"
block|,
literal|"spefscr"
block|,
comment|/* Soft frame pointer.  */
literal|"sfp"
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_REGNAMES
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|alt_reg_names
index|[]
index|[
literal|8
index|]
init|=
block|{
literal|"%r0"
block|,
literal|"%r1"
block|,
literal|"%r2"
block|,
literal|"%r3"
block|,
literal|"%r4"
block|,
literal|"%r5"
block|,
literal|"%r6"
block|,
literal|"%r7"
block|,
literal|"%r8"
block|,
literal|"%r9"
block|,
literal|"%r10"
block|,
literal|"%r11"
block|,
literal|"%r12"
block|,
literal|"%r13"
block|,
literal|"%r14"
block|,
literal|"%r15"
block|,
literal|"%r16"
block|,
literal|"%r17"
block|,
literal|"%r18"
block|,
literal|"%r19"
block|,
literal|"%r20"
block|,
literal|"%r21"
block|,
literal|"%r22"
block|,
literal|"%r23"
block|,
literal|"%r24"
block|,
literal|"%r25"
block|,
literal|"%r26"
block|,
literal|"%r27"
block|,
literal|"%r28"
block|,
literal|"%r29"
block|,
literal|"%r30"
block|,
literal|"%r31"
block|,
literal|"%f0"
block|,
literal|"%f1"
block|,
literal|"%f2"
block|,
literal|"%f3"
block|,
literal|"%f4"
block|,
literal|"%f5"
block|,
literal|"%f6"
block|,
literal|"%f7"
block|,
literal|"%f8"
block|,
literal|"%f9"
block|,
literal|"%f10"
block|,
literal|"%f11"
block|,
literal|"%f12"
block|,
literal|"%f13"
block|,
literal|"%f14"
block|,
literal|"%f15"
block|,
literal|"%f16"
block|,
literal|"%f17"
block|,
literal|"%f18"
block|,
literal|"%f19"
block|,
literal|"%f20"
block|,
literal|"%f21"
block|,
literal|"%f22"
block|,
literal|"%f23"
block|,
literal|"%f24"
block|,
literal|"%f25"
block|,
literal|"%f26"
block|,
literal|"%f27"
block|,
literal|"%f28"
block|,
literal|"%f29"
block|,
literal|"%f30"
block|,
literal|"%f31"
block|,
literal|"mq"
block|,
literal|"lr"
block|,
literal|"ctr"
block|,
literal|"ap"
block|,
literal|"%cr0"
block|,
literal|"%cr1"
block|,
literal|"%cr2"
block|,
literal|"%cr3"
block|,
literal|"%cr4"
block|,
literal|"%cr5"
block|,
literal|"%cr6"
block|,
literal|"%cr7"
block|,
literal|"xer"
block|,
comment|/* AltiVec registers.  */
literal|"%v0"
block|,
literal|"%v1"
block|,
literal|"%v2"
block|,
literal|"%v3"
block|,
literal|"%v4"
block|,
literal|"%v5"
block|,
literal|"%v6"
block|,
literal|"%v7"
block|,
literal|"%v8"
block|,
literal|"%v9"
block|,
literal|"%v10"
block|,
literal|"%v11"
block|,
literal|"%v12"
block|,
literal|"%v13"
block|,
literal|"%v14"
block|,
literal|"%v15"
block|,
literal|"%v16"
block|,
literal|"%v17"
block|,
literal|"%v18"
block|,
literal|"%v19"
block|,
literal|"%v20"
block|,
literal|"%v21"
block|,
literal|"%v22"
block|,
literal|"%v23"
block|,
literal|"%v24"
block|,
literal|"%v25"
block|,
literal|"%v26"
block|,
literal|"%v27"
block|,
literal|"%v28"
block|,
literal|"%v29"
block|,
literal|"%v30"
block|,
literal|"%v31"
block|,
literal|"vrsave"
block|,
literal|"vscr"
block|,
comment|/* SPE registers.  */
literal|"spe_acc"
block|,
literal|"spefscr"
block|,
comment|/* Soft frame pointer.  */
literal|"sfp"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MASK_STRICT_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|MASK_STRICT_ALIGN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_PROFILE_KERNEL
end_ifndef

begin_define
define|#
directive|define
name|TARGET_PROFILE_KERNEL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The VRSAVE bitmask puts bit %v0 as the most significant bit.  */
end_comment

begin_define
define|#
directive|define
name|ALTIVEC_REG_BIT
parameter_list|(
name|REGNO
parameter_list|)
value|(0x80000000>> ((REGNO) - FIRST_ALTIVEC_REGNO))
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|rs6000_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
value|rs6000_set_default_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|DOUBLE_INT_ASM_OP
end_define

begin_comment
comment|/* Default unaligned ops are only provided for ELF.  Find the ops needed    for non-ELF systems.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
end_ifndef

begin_if
if|#
directive|if
name|TARGET_XCOFF
end_if

begin_comment
comment|/* For XCOFF.  rs6000_assemble_integer will handle unaligned DIs on    64-bit targets.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.vbyte\t2,"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.vbyte\t4,"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\t.vbyte\t8,"
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* For Darwin.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.short\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.long\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\t.quad\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\t.quad\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This hook deals with fixups for relocatable code and DI-mode objects    in 64-bit code.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|rs6000_assemble_integer
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ASSEMBLE_VISIBILITY
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ASSEMBLE_VISIBILITY
value|rs6000_assemble_visibility
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|HAVE_AS_TLS
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|rs6000_tls_referenced_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|rs6000_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|rs6000_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|rs6000_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|rs6000_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|rs6000_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_PRIORITY
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_PRIORITY
value|rs6000_adjust_priority
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_IS_COSTLY_DEPENDENCE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_IS_COSTLY_DEPENDENCE
value|rs6000_is_costly_dependence
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FINISH
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FINISH
value|rs6000_sched_finish
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
value|rs6000_use_sched_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD
value|rs6000_builtin_mask_for_load
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_ALIGNMENT_REACHABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_ALIGNMENT_REACHABLE
value|rs6000_vector_alignment_reachable
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|rs6000_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|rs6000_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
end_undef

begin_define
define|#
directive|define
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
value|rs6000_mangle_fundamental_type
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_LIBFUNCS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_LIBFUNCS
value|rs6000_init_libfuncs
end_define

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_undef
undef|#
directive|undef
name|TARGET_BINDS_LOCAL_P
end_undef

begin_define
define|#
directive|define
name|TARGET_BINDS_LOCAL_P
value|darwin_binds_local_p
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_MS_BITFIELD_LAYOUT_P
end_undef

begin_define
define|#
directive|define
name|TARGET_MS_BITFIELD_LAYOUT_P
value|rs6000_ms_bitfield_layout_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|rs6000_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|rs6000_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INVALID_WITHIN_DOLOOP
end_undef

begin_define
define|#
directive|define
name|TARGET_INVALID_WITHIN_DOLOOP
value|rs6000_invalid_within_doloop
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|rs6000_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|hook_int_rtx_0
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_OPAQUE_P
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_OPAQUE_P
value|rs6000_is_opaque_type
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DWARF_REGISTER_SPAN
end_undef

begin_define
define|#
directive|define
name|TARGET_DWARF_REGISTER_SPAN
value|rs6000_dwarf_register_span
end_define

begin_comment
comment|/* On rs6000, function arguments are promoted, as are function return    values.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_ARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_ARGS
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_RETURN
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_RETURN
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MEMORY
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MEMORY
value|rs6000_return_in_memory
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SETUP_INCOMING_VARARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SETUP_INCOMING_VARARGS
value|setup_incoming_varargs
end_define

begin_comment
comment|/* Always strict argument naming on rs6000.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_STRICT_ARGUMENT_NAMING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRICT_ARGUMENT_NAMING
value|hook_bool_CUMULATIVE_ARGS_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PRETEND_OUTGOING_VARARGS_NAMED
end_undef

begin_define
define|#
directive|define
name|TARGET_PRETEND_OUTGOING_VARARGS_NAMED
value|hook_bool_CUMULATIVE_ARGS_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SPLIT_COMPLEX_ARG
end_undef

begin_define
define|#
directive|define
name|TARGET_SPLIT_COMPLEX_ARG
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MUST_PASS_IN_STACK
end_undef

begin_define
define|#
directive|define
name|TARGET_MUST_PASS_IN_STACK
value|rs6000_must_pass_in_stack
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PASS_BY_REFERENCE
end_undef

begin_define
define|#
directive|define
name|TARGET_PASS_BY_REFERENCE
value|rs6000_pass_by_reference
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ARG_PARTIAL_BYTES
end_undef

begin_define
define|#
directive|define
name|TARGET_ARG_PARTIAL_BYTES
value|rs6000_arg_partial_bytes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BUILD_BUILTIN_VA_LIST
end_undef

begin_define
define|#
directive|define
name|TARGET_BUILD_BUILTIN_VA_LIST
value|rs6000_build_builtin_va_list
end_define

begin_undef
undef|#
directive|undef
name|TARGET_GIMPLIFY_VA_ARG_EXPR
end_undef

begin_define
define|#
directive|define
name|TARGET_GIMPLIFY_VA_ARG_EXPR
value|rs6000_gimplify_va_arg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EH_RETURN_FILTER_MODE
end_undef

begin_define
define|#
directive|define
name|TARGET_EH_RETURN_FILTER_MODE
value|rs6000_eh_return_filter_mode
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCALAR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_SCALAR_MODE_SUPPORTED_P
value|rs6000_scalar_mode_supported_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_MODE_SUPPORTED_P
value|rs6000_vector_mode_supported_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN
end_undef

begin_define
define|#
directive|define
name|TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN
value|invalid_arg_for_unprototyped_fn
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HANDLE_OPTION
end_undef

begin_define
define|#
directive|define
name|TARGET_HANDLE_OPTION
value|rs6000_handle_option
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DEFAULT_TARGET_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_DEFAULT_TARGET_FLAGS
define|\
value|(TARGET_DEFAULT)
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STACK_PROTECT_FAIL
end_undef

begin_define
define|#
directive|define
name|TARGET_STACK_PROTECT_FAIL
value|rs6000_stack_protect_fail
end_define

begin_comment
comment|/* MPC604EUM 3.5.2 Weak Consistency between Multiple Processors    The PowerPC architecture requires only weak consistency among    processors--that is, memory accesses between processors need not be    sequentially consistent and memory accesses among processors can occur    in any order. The ability to order memory accesses weakly provides    opportunities for more efficient use of the system bus. Unless a    dependency exists, the 604e allows read operations to precede store    operations.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_RELAXED_ORDERING
end_undef

begin_define
define|#
directive|define
name|TARGET_RELAXED_ORDERING
value|true
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
value|rs6000_output_dwarf_dtprel
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use a 32-bit anchor range.  This leads to sequences like:  	addis	tmp,anchor,high 	add	dest,tmp,low     where tmp itself acts as an anchor, and can be shared between    accesses to the same 64k page.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_MIN_ANCHOR_OFFSET
end_undef

begin_define
define|#
directive|define
name|TARGET_MIN_ANCHOR_OFFSET
value|-0x7fffffff - 1
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MAX_ANCHOR_OFFSET
end_undef

begin_define
define|#
directive|define
name|TARGET_MAX_ANCHOR_OFFSET
value|0x7fffffff
end_define

begin_undef
undef|#
directive|undef
name|TARGET_USE_BLOCKS_FOR_CONSTANT_P
end_undef

begin_define
define|#
directive|define
name|TARGET_USE_BLOCKS_FOR_CONSTANT_P
value|rs6000_use_blocks_for_constant_p
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Value is 1 if hard register REGNO can hold a value of machine-mode    MODE.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_hard_regno_mode_ok
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* The GPRs can hold any mode, but values bigger than one register      cannot go past R31.  */
if|if
condition|(
name|INT_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|INT_REGNO_P
argument_list|(
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
return|;
comment|/* The float registers can only hold floating modes and DImode.      This also excludes decimal float modes.  */
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|FP_REGNO_P
argument_list|(
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|UNITS_PER_FP_WORD
operator|)
return|;
comment|/* The CR register can only hold CC modes.  */
if|if
condition|(
name|CR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
return|;
if|if
condition|(
name|XER_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|mode
operator|==
name|PSImode
return|;
comment|/* AltiVec only in AldyVec registers.  */
if|if
condition|(
name|ALTIVEC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
return|;
comment|/* ...but GPRs can hold SIMD data on the SPE in one register.  */
if|if
condition|(
name|SPE_SIMD_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|TARGET_SPE
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We cannot put TImode anywhere except general register and it must be      able to fit within the register set.  */
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Initialize rs6000_hard_regno_mode_ok_p table.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_init_hard_regno_mode_ok
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|m
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|r
control|)
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|NUM_MACHINE_MODES
condition|;
operator|++
name|m
control|)
if|if
condition|(
name|rs6000_hard_regno_mode_ok
argument_list|(
name|r
argument_list|,
name|m
argument_list|)
condition|)
name|rs6000_hard_regno_mode_ok_p
index|[
name|m
index|]
index|[
name|r
index|]
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If not otherwise specified by a target, make 'long double' equivalent to    'double'.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RS6000_DEFAULT_LONG_DOUBLE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|RS6000_DEFAULT_LONG_DOUBLE_SIZE
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Override command line options.  Mostly we process the processor    type and sometimes adjust other TARGET_ options.  */
end_comment

begin_function
name|void
name|rs6000_override_options
parameter_list|(
specifier|const
name|char
modifier|*
name|default_cpu
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|rs6000_cpu_select
modifier|*
name|ptr
decl_stmt|;
name|int
name|set_masks
decl_stmt|;
comment|/* Simplifications for entries below.  */
enum|enum
block|{
name|POWERPC_BASE_MASK
init|=
name|MASK_POWERPC
operator||
name|MASK_NEW_MNEMONICS
block|,
name|POWERPC_7400_MASK
init|=
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_ALTIVEC
block|}
enum|;
comment|/* This table occasionally claims that a processor does not support      a particular feature even though it does, but the feature is slower      than the alternative.  Thus, it shouldn't be relied on as a      complete description of the processor's support.       Please keep this list in order, and don't forget to update the      documentation in invoke.texi when adding a new processor or      flag.  */
specifier|static
struct|struct
name|ptt
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Canonical processor name.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
comment|/* Processor type enum value.  */
specifier|const
name|int
name|target_enable
decl_stmt|;
comment|/* Target flags to enable.  */
block|}
decl|const
name|processor_target_table
index|[]
init|=
block|{
block|{
literal|"401"
block|,
name|PROCESSOR_PPC403
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"403"
block|,
name|PROCESSOR_PPC403
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_STRICT_ALIGN
block|}
block|,
block|{
literal|"405"
block|,
name|PROCESSOR_PPC405
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_MULHW
operator||
name|MASK_DLMZB
block|}
block|,
block|{
literal|"405fp"
block|,
name|PROCESSOR_PPC405
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_MULHW
operator||
name|MASK_DLMZB
block|}
block|,
block|{
literal|"440"
block|,
name|PROCESSOR_PPC440
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
operator||
name|MASK_MULHW
operator||
name|MASK_DLMZB
block|}
block|,
block|{
literal|"440fp"
block|,
name|PROCESSOR_PPC440
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_MULHW
operator||
name|MASK_DLMZB
block|}
block|,
block|{
literal|"505"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
block|}
block|,
block|{
literal|"601"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|POWERPC_BASE_MASK
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"602"
block|,
name|PROCESSOR_PPC603
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"603"
block|,
name|PROCESSOR_PPC603
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"603e"
block|,
name|PROCESSOR_PPC603
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"604"
block|,
name|PROCESSOR_PPC604
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"604e"
block|,
name|PROCESSOR_PPC604e
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"620"
block|,
name|PROCESSOR_PPC620
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"630"
block|,
name|PROCESSOR_PPC630
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"740"
block|,
name|PROCESSOR_PPC750
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"7400"
block|,
name|PROCESSOR_PPC7400
block|,
name|POWERPC_7400_MASK
block|}
block|,
block|{
literal|"7450"
block|,
name|PROCESSOR_PPC7450
block|,
name|POWERPC_7400_MASK
block|}
block|,
block|{
literal|"750"
block|,
name|PROCESSOR_PPC750
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"801"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"821"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"823"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"8540"
block|,
name|PROCESSOR_PPC8540
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_STRICT_ALIGN
block|}
block|,
comment|/* 8548 has a dummy entry for now.  */
block|{
literal|"8548"
block|,
name|PROCESSOR_PPC8540
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_STRICT_ALIGN
block|}
block|,
block|{
literal|"860"
block|,
name|PROCESSOR_MPCCORE
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"970"
block|,
name|PROCESSOR_POWER4
block|,
name|POWERPC_7400_MASK
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"common"
block|,
name|PROCESSOR_COMMON
block|,
name|MASK_NEW_MNEMONICS
block|}
block|,
block|{
literal|"ec603e"
block|,
name|PROCESSOR_PPC603
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_SOFT_FLOAT
block|}
block|,
block|{
literal|"G3"
block|,
name|PROCESSOR_PPC750
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
block|}
block|,
block|{
literal|"G4"
block|,
name|PROCESSOR_PPC7450
block|,
name|POWERPC_7400_MASK
block|}
block|,
block|{
literal|"G5"
block|,
name|PROCESSOR_POWER4
block|,
name|POWERPC_7400_MASK
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"power"
block|,
name|PROCESSOR_POWER
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"power2"
block|,
name|PROCESSOR_POWER
block|,
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"power3"
block|,
name|PROCESSOR_PPC630
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"power4"
block|,
name|PROCESSOR_POWER4
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"power5"
block|,
name|PROCESSOR_POWER5
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_POWERPC64
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POPCNTB
block|}
block|,
block|{
literal|"power5+"
block|,
name|PROCESSOR_POWER5
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_POWERPC64
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POPCNTB
operator||
name|MASK_FPRND
block|}
block|,
block|{
literal|"power6"
block|,
name|PROCESSOR_POWER5
block|,
name|POWERPC_7400_MASK
operator||
name|MASK_POWERPC64
operator||
name|MASK_MFCRF
operator||
name|MASK_POPCNTB
operator||
name|MASK_FPRND
block|}
block|,
block|{
literal|"powerpc"
block|,
name|PROCESSOR_POWERPC
block|,
name|POWERPC_BASE_MASK
block|}
block|,
block|{
literal|"powerpc64"
block|,
name|PROCESSOR_POWERPC64
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"rios"
block|,
name|PROCESSOR_RIOS1
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rios1"
block|,
name|PROCESSOR_RIOS1
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rios2"
block|,
name|PROCESSOR_RIOS2
block|,
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rsc"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rsc1"
block|,
name|PROCESSOR_PPC601
block|,
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|}
block|,
block|{
literal|"rs64"
block|,
name|PROCESSOR_RS64A
block|,
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
block|}
block|}
struct|;
specifier|const
name|size_t
name|ptt_size
init|=
name|ARRAY_SIZE
argument_list|(
name|processor_target_table
argument_list|)
decl_stmt|;
comment|/* Some OSs don't support saving the high part of 64-bit registers on      context switch.  Other OSs don't support saving Altivec registers.      On those OSs, we don't touch the MASK_POWERPC64 or MASK_ALTIVEC      settings; if the user wants either, the user must explicitly specify      them and we won't interfere with the user's specification.  */
enum|enum
block|{
name|POWER_MASKS
init|=
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
block|,
name|POWERPC_MASKS
init|=
operator|(
name|POWERPC_BASE_MASK
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_STRICT_ALIGN
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
operator||
name|MASK_ALTIVEC
operator||
name|MASK_MFCRF
operator||
name|MASK_POPCNTB
operator||
name|MASK_FPRND
operator||
name|MASK_MULHW
operator||
name|MASK_DLMZB
operator|)
block|}
enum|;
name|rs6000_init_hard_regno_mode_ok
argument_list|()
expr_stmt|;
name|set_masks
operator|=
name|POWER_MASKS
operator||
name|POWERPC_MASKS
operator||
name|MASK_SOFT_FLOAT
expr_stmt|;
ifdef|#
directive|ifdef
name|OS_MISSING_POWERPC64
if|if
condition|(
name|OS_MISSING_POWERPC64
condition|)
name|set_masks
operator|&=
operator|~
name|MASK_POWERPC64
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OS_MISSING_ALTIVEC
if|if
condition|(
name|OS_MISSING_ALTIVEC
condition|)
name|set_masks
operator|&=
operator|~
name|MASK_ALTIVEC
expr_stmt|;
endif|#
directive|endif
comment|/* Don't override by the processor default if given explicitly.  */
name|set_masks
operator|&=
operator|~
name|target_flags_explicit
expr_stmt|;
comment|/* Identify the processor type.  */
name|rs6000_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|default_cpu
expr_stmt|;
name|rs6000_cpu
operator|=
name|TARGET_POWERPC64
condition|?
name|PROCESSOR_DEFAULT64
else|:
name|PROCESSOR_DEFAULT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rs6000_select
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
operator|&
name|rs6000_select
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptt_size
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|string
argument_list|,
name|processor_target_table
index|[
name|j
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|set_tune_p
condition|)
name|rs6000_cpu
operator|=
name|processor_target_table
index|[
name|j
index|]
operator|.
name|processor
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|set_arch_p
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|set_masks
expr_stmt|;
name|target_flags
operator||=
operator|(
name|processor_target_table
index|[
name|j
index|]
operator|.
name|target_enable
operator|&
name|set_masks
operator|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|ptt_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_E500
condition|)
name|rs6000_isel
operator|=
literal|1
expr_stmt|;
comment|/* If we are optimizing big endian systems for space, use the load/store      multiple and string instructions.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|optimize_size
condition|)
name|target_flags
operator||=
operator|~
name|target_flags_explicit
operator|&
operator|(
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator|)
expr_stmt|;
comment|/* Don't allow -mmultiple or -mstring on little endian systems      unless the cpu is a 750, because the hardware doesn't support the      instructions used in little endian mode, and causes an alignment      trap.  The 750 does not cause an alignment trap (except when the      target is unaligned).  */
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|rs6000_cpu
operator|!=
name|PROCESSOR_PPC750
condition|)
block|{
if|if
condition|(
name|TARGET_MULTIPLE
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_MULTIPLE
expr_stmt|;
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_MULTIPLE
operator|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-mmultiple is not supported on little endian systems"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_STRING
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_STRING
expr_stmt|;
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_STRING
operator|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-mstring is not supported on little endian systems"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set debug flags */
if|if
condition|(
name|rs6000_debug_name
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"all"
argument_list|)
condition|)
name|rs6000_debug_stack
operator|=
name|rs6000_debug_arg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"stack"
argument_list|)
condition|)
name|rs6000_debug_stack
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_debug_name
argument_list|,
literal|"arg"
argument_list|)
condition|)
name|rs6000_debug_arg
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown -mdebug-%s switch"
argument_list|,
name|rs6000_debug_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rs6000_traceback_name
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|rs6000_traceback_name
argument_list|,
literal|"full"
argument_list|,
literal|4
argument_list|)
condition|)
name|rs6000_traceback
operator|=
name|traceback_full
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|rs6000_traceback_name
argument_list|,
literal|"part"
argument_list|,
literal|4
argument_list|)
condition|)
name|rs6000_traceback
operator|=
name|traceback_part
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|rs6000_traceback_name
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
condition|)
name|rs6000_traceback
operator|=
name|traceback_none
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown -mtraceback arg %qs; expecting %<full%>, %<partial%> or %<none%>"
argument_list|,
name|rs6000_traceback_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rs6000_explicit_options
operator|.
name|long_double
condition|)
name|rs6000_long_double_type_size
operator|=
name|RS6000_DEFAULT_LONG_DOUBLE_SIZE
expr_stmt|;
ifndef|#
directive|ifndef
name|POWERPC_LINUX
if|if
condition|(
operator|!
name|rs6000_explicit_options
operator|.
name|ieee
condition|)
name|rs6000_ieeequad
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Set Altivec ABI as default for powerpc64 linux.  */
if|if
condition|(
name|TARGET_ELF
operator|&&
name|TARGET_64BIT
condition|)
block|{
name|rs6000_altivec_abi
operator|=
literal|1
expr_stmt|;
name|TARGET_ALTIVEC_VRSAVE
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set the Darwin64 ABI as default for 64-bit Darwin.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|TARGET_64BIT
condition|)
block|{
name|rs6000_darwin64_abi
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
name|darwin_one_byte_bool
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Default to natural alignment, for better performance.  */
name|rs6000_alignment_flags
operator|=
name|MASK_ALIGN_NATURAL
expr_stmt|;
block|}
comment|/* Place FP constants in the constant pool instead of TOC      if section anchors enabled.  */
if|if
condition|(
name|flag_section_anchors
condition|)
name|TARGET_NO_FP_IN_TOC
operator|=
literal|1
expr_stmt|;
comment|/* Handle -mtls-size option.  */
name|rs6000_parse_tls_size_option
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SUBTARGET_OVERRIDE_OPTIONS
name|SUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUBSUBTARGET_OVERRIDE_OPTIONS
name|SUBSUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUB3TARGET_OVERRIDE_OPTIONS
name|SUB3TARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TARGET_E500
condition|)
block|{
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
name|error
argument_list|(
literal|"AltiVec and E500 instructions cannot coexist"
argument_list|)
expr_stmt|;
comment|/* The e500 does not have string instructions, and we set 	 MASK_STRING above when optimizing for size.  */
if|if
condition|(
operator|(
name|target_flags
operator|&
name|MASK_STRING
operator|)
operator|!=
literal|0
condition|)
name|target_flags
operator|=
name|target_flags
operator|&
operator|~
name|MASK_STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs6000_select
index|[
literal|1
index|]
operator|.
name|string
operator|!=
name|NULL
condition|)
block|{
comment|/* For the powerpc-eabispe configuration, we set all these by 	 default, so let's unset them if we manually set another 	 CPU that is not the E500.  */
if|if
condition|(
operator|!
name|rs6000_explicit_options
operator|.
name|abi
condition|)
name|rs6000_spe_abi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rs6000_explicit_options
operator|.
name|spe
condition|)
name|rs6000_spe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rs6000_explicit_options
operator|.
name|float_gprs
condition|)
name|rs6000_float_gprs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rs6000_explicit_options
operator|.
name|isel
condition|)
name|rs6000_isel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rs6000_explicit_options
operator|.
name|long_double
condition|)
name|rs6000_long_double_type_size
operator|=
name|RS6000_DEFAULT_LONG_DOUBLE_SIZE
expr_stmt|;
block|}
name|rs6000_always_hint
operator|=
operator|(
name|rs6000_cpu
operator|!=
name|PROCESSOR_POWER4
operator|&&
name|rs6000_cpu
operator|!=
name|PROCESSOR_POWER5
operator|)
expr_stmt|;
name|rs6000_sched_groups
operator|=
operator|(
name|rs6000_cpu
operator|==
name|PROCESSOR_POWER4
operator|||
name|rs6000_cpu
operator|==
name|PROCESSOR_POWER5
operator|)
expr_stmt|;
name|rs6000_sched_restricted_insns_priority
operator|=
operator|(
name|rs6000_sched_groups
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Handle -msched-costly-dep option.  */
name|rs6000_sched_costly_dep
operator|=
operator|(
name|rs6000_sched_groups
condition|?
name|store_to_load_dep_costly
else|:
name|no_dep_costly
operator|)
expr_stmt|;
if|if
condition|(
name|rs6000_sched_costly_dep_str
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|,
literal|"no"
argument_list|)
condition|)
name|rs6000_sched_costly_dep
operator|=
name|no_dep_costly
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|,
literal|"all"
argument_list|)
condition|)
name|rs6000_sched_costly_dep
operator|=
name|all_deps_costly
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|,
literal|"true_store_to_load"
argument_list|)
condition|)
name|rs6000_sched_costly_dep
operator|=
name|true_store_to_load_dep_costly
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|,
literal|"store_to_load"
argument_list|)
condition|)
name|rs6000_sched_costly_dep
operator|=
name|store_to_load_dep_costly
expr_stmt|;
else|else
name|rs6000_sched_costly_dep
operator|=
name|atoi
argument_list|(
name|rs6000_sched_costly_dep_str
argument_list|)
expr_stmt|;
block|}
comment|/* Handle -minsert-sched-nops option.  */
name|rs6000_sched_insert_nops
operator|=
operator|(
name|rs6000_sched_groups
condition|?
name|sched_finish_regroup_exact
else|:
name|sched_finish_none
operator|)
expr_stmt|;
if|if
condition|(
name|rs6000_sched_insert_nops_str
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_insert_nops_str
argument_list|,
literal|"no"
argument_list|)
condition|)
name|rs6000_sched_insert_nops
operator|=
name|sched_finish_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_insert_nops_str
argument_list|,
literal|"pad"
argument_list|)
condition|)
name|rs6000_sched_insert_nops
operator|=
name|sched_finish_pad_groups
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs6000_sched_insert_nops_str
argument_list|,
literal|"regroup_exact"
argument_list|)
condition|)
name|rs6000_sched_insert_nops
operator|=
name|sched_finish_regroup_exact
expr_stmt|;
else|else
name|rs6000_sched_insert_nops
operator|=
name|atoi
argument_list|(
name|rs6000_sched_insert_nops_str
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_REGNAMES
comment|/* If the user desires alternate register names, copy in the      alternate names now.  */
if|if
condition|(
name|TARGET_REGNAMES
condition|)
name|memcpy
argument_list|(
name|rs6000_reg_names
argument_list|,
name|alt_reg_names
argument_list|,
sizeof|sizeof
argument_list|(
name|rs6000_reg_names
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set aix_struct_return last, after the ABI is determined.      If -maix-struct-return or -msvr4-struct-return was explicitly      used, don't override with the ABI default.  */
if|if
condition|(
operator|!
name|rs6000_explicit_options
operator|.
name|aix_struct_ret
condition|)
name|aix_struct_return
operator|=
operator|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
operator|||
name|DRAFT_V4_STRUCT_RET
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_LONG_DOUBLE_128
operator|&&
operator|!
name|TARGET_IEEEQUAD
condition|)
name|REAL_MODE_FORMAT
argument_list|(
name|TFmode
argument_list|)
operator|=
operator|&
name|ibm_extended_format
expr_stmt|;
if|if
condition|(
name|TARGET_TOC
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|toc_label_name
argument_list|,
literal|"LCTOC"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We can only guarantee the availability of DI pseudo-ops when      assembling for 64-bit targets.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|aligned_op
operator|.
name|di
operator|=
name|NULL
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
operator|.
name|di
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set branch target alignment, if not optimizing for size.  */
if|if
condition|(
operator|!
name|optimize_size
condition|)
block|{
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
if|if
condition|(
name|align_functions
operator|<=
literal|0
condition|)
name|align_functions
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|<=
literal|0
condition|)
name|align_jumps
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|align_loops
operator|<=
literal|0
condition|)
name|align_loops
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|align_jumps_max_skip
operator|<=
literal|0
condition|)
name|align_jumps_max_skip
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|align_loops_max_skip
operator|<=
literal|0
condition|)
name|align_loops_max_skip
operator|=
literal|15
expr_stmt|;
block|}
comment|/* Arrange to save and restore machine status around nested functions.  */
name|init_machine_status
operator|=
name|rs6000_init_machine_status
expr_stmt|;
comment|/* We should always be splitting complex arguments, but we can't break      Linux and Darwin ABIs at the moment.  For now, only AIX is fixed.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
condition|)
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize rs6000_cost with the appropriate target costs.  */
if|if
condition|(
name|optimize_size
condition|)
name|rs6000_cost
operator|=
name|TARGET_POWERPC64
condition|?
operator|&
name|size64_cost
else|:
operator|&
name|size32_cost
expr_stmt|;
else|else
switch|switch
condition|(
name|rs6000_cpu
condition|)
block|{
case|case
name|PROCESSOR_RIOS1
case|:
name|rs6000_cost
operator|=
operator|&
name|rios1_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_RIOS2
case|:
name|rs6000_cost
operator|=
operator|&
name|rios2_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_RS64A
case|:
name|rs6000_cost
operator|=
operator|&
name|rs64a_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_MPCCORE
case|:
name|rs6000_cost
operator|=
operator|&
name|mpccore_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC403
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc403_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC405
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc405_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC440
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc440_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC601
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc601_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC603
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc603_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC604
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc604_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC604e
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc604e_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC620
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc620_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC630
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc630_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC750
case|:
case|case
name|PROCESSOR_PPC7400
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc750_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC7450
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc7450_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PPC8540
case|:
name|rs6000_cost
operator|=
operator|&
name|ppc8540_cost
expr_stmt|;
break|break;
case|case
name|PROCESSOR_POWER4
case|:
case|case
name|PROCESSOR_POWER5
case|:
name|rs6000_cost
operator|=
operator|&
name|power4_cost
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement targetm.vectorize.builtin_mask_for_load.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_builtin_mask_for_load
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
return|return
name|altivec_builtin_mask_for_load
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true iff, data reference of TYPE can reach vector alignment (16)    after applying N number of iterations.  This routine does not determine    how may iterations are required to reach desired alignment.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_vector_alignment_reachable
parameter_list|(
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|is_packed
parameter_list|)
block|{
if|if
condition|(
name|is_packed
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TARGET_32BIT
condition|)
block|{
if|if
condition|(
name|rs6000_alignment_flags
operator|==
name|MASK_ALIGN_NATURAL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|rs6000_alignment_flags
operator|==
name|MASK_ALIGN_POWER
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MACHO
condition|)
return|return
name|false
return|;
comment|/* Assuming that all other types are naturally aligned. CHECKME!  */
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Handle generic options of the form -mfoo=yes/no.    NAME is the option name.    VALUE is the option value.    FLAG is the pointer to the flag where to store a 1 or 0, depending on    whether the option value is 'yes' or 'no' respectively.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_parse_yes_no_option
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|flag
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"yes"
argument_list|)
condition|)
operator|*
name|flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"no"
argument_list|)
condition|)
operator|*
name|flag
operator|=
literal|0
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown -m%s= option specified: '%s'"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Validate and record the size specified with the -mtls-size option.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_parse_tls_size_option
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|rs6000_tls_size_string
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rs6000_tls_size_string
argument_list|,
literal|"16"
argument_list|)
operator|==
literal|0
condition|)
name|rs6000_tls_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rs6000_tls_size_string
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
name|rs6000_tls_size
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rs6000_tls_size_string
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
name|rs6000_tls_size
operator|=
literal|64
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value %qs for -mtls-size switch"
argument_list|,
name|rs6000_tls_size_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|optimization_options
parameter_list|(
name|int
name|level
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
condition|)
comment|/* The Darwin libraries never set errno, so we might as well        avoid calling them when that's the only reason we would.  */
name|flag_errno_math
operator|=
literal|0
expr_stmt|;
comment|/* Double growth factor to counter reduced min jump length.  */
name|set_param_value
argument_list|(
literal|"max-grow-copy-bb-insns"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Enable section anchors by default.      Skip section anchors for Objective C and Objective C++      until front-ends fixed.  */
if|if
condition|(
operator|!
name|TARGET_MACHO
operator|&&
name|lang_hooks
operator|.
name|name
index|[
literal|4
index|]
operator|!=
literal|'O'
condition|)
name|flag_section_anchors
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_HANDLE_OPTION.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_handle_option
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPT_mno_power
case|:
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator|)
expr_stmt|;
name|target_flags_explicit
operator||=
operator|(
name|MASK_POWER
operator||
name|MASK_POWER2
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator|)
expr_stmt|;
break|break;
case|case
name|OPT_mno_powerpc
case|:
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_POWERPC
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
operator|)
expr_stmt|;
name|target_flags_explicit
operator||=
operator|(
name|MASK_POWERPC
operator||
name|MASK_PPC_GPOPT
operator||
name|MASK_PPC_GFXOPT
operator||
name|MASK_POWERPC64
operator|)
expr_stmt|;
break|break;
case|case
name|OPT_mfull_toc
case|:
name|target_flags
operator|&=
operator|~
name|MASK_MINIMAL_TOC
expr_stmt|;
name|TARGET_NO_FP_IN_TOC
operator|=
literal|0
expr_stmt|;
name|TARGET_NO_SUM_IN_TOC
operator|=
literal|0
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_MINIMAL_TOC
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_USES_SYSV4_OPT
comment|/* Note, V.4 no longer uses a normal TOC, so make -mfull-toc, be 	 just the same as -mminimal-toc.  */
name|target_flags
operator||=
name|MASK_MINIMAL_TOC
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_MINIMAL_TOC
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|TARGET_USES_SYSV4_OPT
case|case
name|OPT_mtoc
case|:
comment|/* Make -mtoc behave like -mminimal-toc.  */
name|target_flags
operator||=
name|MASK_MINIMAL_TOC
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_MINIMAL_TOC
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_USES_AIX64_OPT
case|case
name|OPT_maix64
case|:
else|#
directive|else
case|case
name|OPT_m64
case|:
endif|#
directive|endif
name|target_flags
operator||=
name|MASK_POWERPC64
operator||
name|MASK_POWERPC
expr_stmt|;
name|target_flags
operator||=
operator|~
name|target_flags_explicit
operator|&
name|MASK_PPC_GFXOPT
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_POWERPC64
operator||
name|MASK_POWERPC
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TARGET_USES_AIX64_OPT
case|case
name|OPT_maix32
case|:
else|#
directive|else
case|case
name|OPT_m32
case|:
endif|#
directive|endif
name|target_flags
operator|&=
operator|~
name|MASK_POWERPC64
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_POWERPC64
expr_stmt|;
break|break;
case|case
name|OPT_minsert_sched_nops_
case|:
name|rs6000_sched_insert_nops_str
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_mminimal_toc
case|:
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
name|TARGET_NO_FP_IN_TOC
operator|=
literal|0
expr_stmt|;
name|TARGET_NO_SUM_IN_TOC
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|OPT_mpower
case|:
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
name|target_flags
operator||=
operator|(
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator|)
expr_stmt|;
name|target_flags_explicit
operator||=
operator|(
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_mpower2
case|:
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
name|target_flags
operator||=
operator|(
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator|)
expr_stmt|;
name|target_flags_explicit
operator||=
operator|(
name|MASK_POWER
operator||
name|MASK_MULTIPLE
operator||
name|MASK_STRING
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_mpowerpc_gpopt
case|:
case|case
name|OPT_mpowerpc_gfxopt
case|:
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
name|target_flags
operator||=
name|MASK_POWERPC
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_POWERPC
expr_stmt|;
block|}
break|break;
case|case
name|OPT_maix_struct_return
case|:
case|case
name|OPT_msvr4_struct_return
case|:
name|rs6000_explicit_options
operator|.
name|aix_struct_ret
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_mvrsave_
case|:
name|rs6000_parse_yes_no_option
argument_list|(
literal|"vrsave"
argument_list|,
name|arg
argument_list|,
operator|&
operator|(
name|TARGET_ALTIVEC_VRSAVE
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_misel_
case|:
name|rs6000_explicit_options
operator|.
name|isel
operator|=
name|true
expr_stmt|;
name|rs6000_parse_yes_no_option
argument_list|(
literal|"isel"
argument_list|,
name|arg
argument_list|,
operator|&
operator|(
name|rs6000_isel
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_mspe_
case|:
name|rs6000_explicit_options
operator|.
name|spe
operator|=
name|true
expr_stmt|;
name|rs6000_parse_yes_no_option
argument_list|(
literal|"spe"
argument_list|,
name|arg
argument_list|,
operator|&
operator|(
name|rs6000_spe
operator|)
argument_list|)
expr_stmt|;
comment|/* No SPE means 64-bit long doubles, even if an E500.  */
if|if
condition|(
operator|!
name|rs6000_spe
condition|)
name|rs6000_long_double_type_size
operator|=
literal|64
expr_stmt|;
break|break;
case|case
name|OPT_mdebug_
case|:
name|rs6000_debug_name
operator|=
name|arg
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TARGET_USES_SYSV4_OPT
case|case
name|OPT_mcall_
case|:
name|rs6000_abi_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_msdata_
case|:
name|rs6000_sdata_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_mtls_size_
case|:
name|rs6000_tls_size_string
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_mrelocatable
case|:
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
name|target_flags
operator||=
name|MASK_MINIMAL_TOC
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_MINIMAL_TOC
expr_stmt|;
name|TARGET_NO_FP_IN_TOC
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OPT_mrelocatable_lib
case|:
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
name|target_flags
operator||=
name|MASK_RELOCATABLE
operator||
name|MASK_MINIMAL_TOC
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_RELOCATABLE
operator||
name|MASK_MINIMAL_TOC
expr_stmt|;
name|TARGET_NO_FP_IN_TOC
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|target_flags
operator|&=
operator|~
name|MASK_RELOCATABLE
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_RELOCATABLE
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|OPT_mabi_
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"altivec"
argument_list|)
condition|)
block|{
name|rs6000_explicit_options
operator|.
name|abi
operator|=
name|true
expr_stmt|;
name|rs6000_altivec_abi
operator|=
literal|1
expr_stmt|;
name|rs6000_spe_abi
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-altivec"
argument_list|)
condition|)
block|{
comment|/* ??? Don't set rs6000_explicit_options.abi here, to allow 	     the default for rs6000_spe_abi to be chosen later.  */
name|rs6000_altivec_abi
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"spe"
argument_list|)
condition|)
block|{
name|rs6000_explicit_options
operator|.
name|abi
operator|=
name|true
expr_stmt|;
name|rs6000_spe_abi
operator|=
literal|1
expr_stmt|;
name|rs6000_altivec_abi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_SPE_ABI
condition|)
name|error
argument_list|(
literal|"not configured for ABI: '%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no-spe"
argument_list|)
condition|)
block|{
name|rs6000_explicit_options
operator|.
name|abi
operator|=
name|true
expr_stmt|;
name|rs6000_spe_abi
operator|=
literal|0
expr_stmt|;
block|}
comment|/* These are here for testing during development only, do not 	 document in the manual please.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"d64"
argument_list|)
condition|)
block|{
name|rs6000_darwin64_abi
operator|=
literal|1
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"Using darwin64 ABI"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"d32"
argument_list|)
condition|)
block|{
name|rs6000_darwin64_abi
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"Using old darwin ABI"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ibmlongdouble"
argument_list|)
condition|)
block|{
name|rs6000_explicit_options
operator|.
name|ieee
operator|=
name|true
expr_stmt|;
name|rs6000_ieeequad
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"Using IBM extended precision long double"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ieeelongdouble"
argument_list|)
condition|)
block|{
name|rs6000_explicit_options
operator|.
name|ieee
operator|=
name|true
expr_stmt|;
name|rs6000_ieeequad
operator|=
literal|1
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"Using IEEE extended precision long double"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"unknown ABI specified: '%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
name|OPT_mcpu_
case|:
name|rs6000_select
index|[
literal|1
index|]
operator|.
name|string
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_mtune_
case|:
name|rs6000_select
index|[
literal|2
index|]
operator|.
name|string
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_mtraceback_
case|:
name|rs6000_traceback_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_mfloat_gprs_
case|:
name|rs6000_explicit_options
operator|.
name|float_gprs
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"yes"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"single"
argument_list|)
condition|)
name|rs6000_float_gprs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"double"
argument_list|)
condition|)
name|rs6000_float_gprs
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"no"
argument_list|)
condition|)
name|rs6000_float_gprs
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid option for -mfloat-gprs: '%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
name|OPT_mlong_double_
case|:
name|rs6000_explicit_options
operator|.
name|long_double
operator|=
name|true
expr_stmt|;
name|rs6000_long_double_type_size
operator|=
name|RS6000_DEFAULT_LONG_DOUBLE_SIZE
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|64
operator|&&
name|value
operator|!=
literal|128
condition|)
block|{
name|error
argument_list|(
literal|"Unknown switch -mlong-double-%s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rs6000_long_double_type_size
operator|=
name|RS6000_DEFAULT_LONG_DOUBLE_SIZE
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
name|rs6000_long_double_type_size
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_msched_costly_dep_
case|:
name|rs6000_sched_costly_dep_str
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_malign_
case|:
name|rs6000_explicit_options
operator|.
name|alignment
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"power"
argument_list|)
condition|)
block|{
comment|/* On 64-bit Darwin, power alignment is ABI-incompatible with 	     some C library functions, so warn about it. The flag may be 	     useful for performance studies from time to time though, so 	     don't disable it entirely.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|TARGET_64BIT
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-malign-power is not supported for 64-bit Darwin;"
literal|" it is incompatible with the installed C and C++ libraries"
argument_list|)
expr_stmt|;
name|rs6000_alignment_flags
operator|=
name|MASK_ALIGN_POWER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"natural"
argument_list|)
condition|)
name|rs6000_alignment_flags
operator|=
name|MASK_ALIGN_NATURAL
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"unknown -malign-XXXXX option specified: '%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do anything needed at the start of the asm file.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|buffer
decl_stmt|;
name|struct
name|rs6000_cpu_select
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|default_cpu
init|=
name|TARGET_CPU_DEFAULT
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
name|asm_out_file
decl_stmt|;
name|default_file_start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_BI_ARCH
if|if
condition|(
operator|(
name|TARGET_DEFAULT
operator|^
name|target_flags
operator|)
operator|&
name|MASK_64BIT
condition|)
name|default_cpu
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_verbose_asm
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\n%s rs6000/powerpc options:"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|rs6000_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|default_cpu
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rs6000_select
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
operator|&
name|rs6000_select
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s %s%s"
argument_list|,
name|start
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
name|ptr
operator|->
name|string
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PPC405_ERRATUM77
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s PPC405CR_ERRATUM77"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USING_ELFOS_H
switch|switch
condition|(
name|rs6000_sdata
condition|)
block|{
case|case
name|SDATA_NONE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=none"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_DATA
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=data"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_SYSV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=sysv"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SDATA_EABI
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -msdata=eabi"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rs6000_sdata
operator|&&
name|g_switch_value
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s -G "
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|start
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
name|start
operator|=
literal|""
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|start
operator|==
literal|'\0'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|||
operator|(
name|TARGET_ELF
operator|&&
name|flag_pic
operator|==
literal|2
operator|)
condition|)
block|{
name|switch_to_section
argument_list|(
name|toc_section
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if this function is known to have a null epilogue.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|reload_completed
condition|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|first_gp_reg_save
operator|==
literal|32
operator|&&
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|&&
name|info
operator|->
name|first_altivec_reg_save
operator|==
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
operator|&&
operator|!
name|info
operator|->
name|lr_save_p
operator|&&
operator|!
name|info
operator|->
name|cr_save_p
operator|&&
name|info
operator|->
name|vrsave_mask
operator|==
literal|0
operator|&&
operator|!
name|info
operator|->
name|push_p
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the number of instructions it takes to form a constant in an    integer register.  */
end_comment

begin_function
name|int
name|num_insns_constant_wide
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
comment|/* signed constant loadable with {cal|addi} */
if|if
condition|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|value
operator|+
literal|0x8000
argument_list|)
operator|<
literal|0x10000
condition|)
return|return
literal|1
return|;
comment|/* constant loadable with {cau|addis} */
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|&&
operator|(
name|value
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|value
operator|>>
literal|31
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
elseif|else
if|if
condition|(
name|TARGET_POWERPC64
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|value
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
name|value
operator|>>
literal|31
decl_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
operator|||
name|high
operator|==
operator|-
literal|1
condition|)
return|return
literal|2
return|;
name|high
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
else|else
return|return
literal|2
return|;
block|}
end_function

begin_function
name|int
name|num_insns_constant
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>>
literal|31
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>>
literal|31
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|2
return|;
else|else
endif|#
directive|endif
return|return
name|num_insns_constant_wide
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
name|long
name|l
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|num_insns_constant_wide
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
argument_list|)
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|DImode
condition|)
block|{
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|high
operator|=
name|l
index|[
name|WORDS_BIG_ENDIAN
operator|==
literal|0
index|]
expr_stmt|;
name|low
operator|=
name|l
index|[
name|WORDS_BIG_ENDIAN
operator|!=
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_32BIT
condition|)
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|)
return|;
else|else
block|{
if|if
condition|(
operator|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|>=
literal|0
operator|)
operator|||
operator|(
name|high
operator|==
operator|-
literal|1
operator|&&
name|low
operator|<
literal|0
operator|)
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
return|;
elseif|else
if|if
condition|(
name|mask64_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|low
operator|==
literal|0
condition|)
return|return
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
name|num_insns_constant_wide
argument_list|(
name|high
argument_list|)
operator|+
name|num_insns_constant_wide
argument_list|(
name|low
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Interpret element ELT of the CONST_VECTOR OP as an integer value.    If the mode of OP is MODE_VECTOR_INT, this simply returns the    corresponding element of the vector, but for V4SFmode and V2SFmode,    the corresponding "float" is interpreted as an SImode integer.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|const_vector_elt_as_int
parameter_list|(
name|rtx
name|op
parameter_list|,
name|unsigned
name|int
name|elt
parameter_list|)
block|{
name|rtx
name|tmp
init|=
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
name|elt
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|V4SFmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|V2SFmode
condition|)
name|tmp
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|INTVAL
argument_list|(
name|tmp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP can be synthesized with a particular vspltisb, vspltish    or vspltisw instruction.  OP is a CONST_VECTOR.  Which instruction is used    depends on STEP and COPIES, one of which will be 1.  If COPIES> 1,    all items are set to the same value and contain COPIES replicas of the    vsplt's operand; if STEP> 1, one in STEP elements is set to the vsplt's    operand and the others are set to the value of the operand's msb.  */
end_comment

begin_function
specifier|static
name|bool
name|vspltis_constant
parameter_list|(
name|rtx
name|op
parameter_list|,
name|unsigned
name|step
parameter_list|,
name|unsigned
name|copies
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|nunits
init|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|bitsize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|inner
argument_list|)
decl_stmt|;
name|unsigned
name|mask
init|=
name|GET_MODE_MASK
argument_list|(
name|inner
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|val
init|=
name|const_vector_elt_as_int
argument_list|(
name|op
argument_list|,
name|nunits
operator|-
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|splat_val
init|=
name|val
decl_stmt|;
name|HOST_WIDE_INT
name|msb_val
init|=
name|val
operator|>
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
decl_stmt|;
comment|/* Construct the value to be splatted, if possible.  If not, return 0.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|copies
condition|;
name|i
operator|*=
literal|2
control|)
block|{
name|HOST_WIDE_INT
name|small_val
decl_stmt|;
name|bitsize
operator|/=
literal|2
expr_stmt|;
name|small_val
operator|=
name|splat_val
operator|>>
name|bitsize
expr_stmt|;
name|mask
operator|>>=
name|bitsize
expr_stmt|;
if|if
condition|(
name|splat_val
operator|!=
operator|(
operator|(
name|small_val
operator|<<
name|bitsize
operator|)
operator||
operator|(
name|small_val
operator|&
name|mask
operator|)
operator|)
condition|)
return|return
name|false
return|;
name|splat_val
operator|=
name|small_val
expr_stmt|;
block|}
comment|/* Check if SPLAT_VAL can really be the operand of a vspltis[bhw].  */
if|if
condition|(
name|EASY_VECTOR_15
argument_list|(
name|splat_val
argument_list|)
condition|)
empty_stmt|;
comment|/* Also check if we can splat, and then add the result to itself.  Do so if      the value is positive, of if the splat instruction is using OP's mode;      for splat_val< 0, the splat and the add should use the same mode.  */
elseif|else
if|if
condition|(
name|EASY_VECTOR_15_ADD_SELF
argument_list|(
name|splat_val
argument_list|)
operator|&&
operator|(
name|splat_val
operator|>=
literal|0
operator|||
operator|(
name|step
operator|==
literal|1
operator|&&
name|copies
operator|==
literal|1
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
name|false
return|;
comment|/* Check if VAL is present in every STEP-th element, and the      other elements are filled with its most significant bit.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nunits
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|HOST_WIDE_INT
name|desired_val
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
operator|(
name|step
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|desired_val
operator|=
name|val
expr_stmt|;
else|else
name|desired_val
operator|=
name|msb_val
expr_stmt|;
if|if
condition|(
name|desired_val
operator|!=
name|const_vector_elt_as_int
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is of the given MODE and can be synthesized    with a vspltisb, vspltish or vspltisw.  */
end_comment

begin_function
name|bool
name|easy_altivec_constant
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|unsigned
name|step
decl_stmt|,
name|copies
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Start with a vspltisw.  */
name|step
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|/
literal|4
expr_stmt|;
name|copies
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vspltis_constant
argument_list|(
name|op
argument_list|,
name|step
argument_list|,
name|copies
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Then try with a vspltish.  */
if|if
condition|(
name|step
operator|==
literal|1
condition|)
name|copies
operator|<<=
literal|1
expr_stmt|;
else|else
name|step
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|vspltis_constant
argument_list|(
name|op
argument_list|,
name|step
argument_list|,
name|copies
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* And finally a vspltisb.  */
if|if
condition|(
name|step
operator|==
literal|1
condition|)
name|copies
operator|<<=
literal|1
expr_stmt|;
else|else
name|step
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|vspltis_constant
argument_list|(
name|op
argument_list|,
name|step
argument_list|,
name|copies
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Generate a VEC_DUPLICATE representing a vspltis[bhw] instruction whose    result is OP.  Abort if it is not possible.  */
end_comment

begin_function
name|rtx
name|gen_easy_altivec_constant
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|nunits
init|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|last
init|=
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
name|nunits
operator|-
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|step
init|=
name|nunits
operator|/
literal|4
decl_stmt|;
name|unsigned
name|copies
init|=
literal|1
decl_stmt|;
comment|/* Start with a vspltisw.  */
if|if
condition|(
name|vspltis_constant
argument_list|(
name|op
argument_list|,
name|step
argument_list|,
name|copies
argument_list|)
condition|)
return|return
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|V4SImode
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|last
argument_list|)
argument_list|)
return|;
comment|/* Then try with a vspltish.  */
if|if
condition|(
name|step
operator|==
literal|1
condition|)
name|copies
operator|<<=
literal|1
expr_stmt|;
else|else
name|step
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|vspltis_constant
argument_list|(
name|op
argument_list|,
name|step
argument_list|,
name|copies
argument_list|)
condition|)
return|return
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|V8HImode
argument_list|,
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
name|last
argument_list|)
argument_list|)
return|;
comment|/* And finally a vspltisb.  */
if|if
condition|(
name|step
operator|==
literal|1
condition|)
name|copies
operator|<<=
literal|1
expr_stmt|;
else|else
name|step
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|vspltis_constant
argument_list|(
name|op
argument_list|,
name|step
argument_list|,
name|copies
argument_list|)
condition|)
return|return
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|V16QImode
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|last
argument_list|)
argument_list|)
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|output_vec_const_move
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|cst
decl_stmt|,
name|cst2
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|vec
decl_stmt|;
name|dest
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|vec
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
block|{
name|rtx
name|splat_vec
decl_stmt|;
if|if
condition|(
name|zero_constant
argument_list|(
name|vec
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|"vxor %0,%0,%0"
return|;
name|splat_vec
operator|=
name|gen_easy_altivec_constant
argument_list|(
name|vec
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|splat_vec
argument_list|)
operator|==
name|VEC_DUPLICATE
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|splat_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EASY_VECTOR_15
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
return|return
literal|"#"
return|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|splat_vec
argument_list|)
condition|)
block|{
case|case
name|V4SImode
case|:
return|return
literal|"vspltisw %0,%1"
return|;
case|case
name|V8HImode
case|:
return|return
literal|"vspltish %0,%1"
return|;
case|case
name|V16QImode
case|:
return|return
literal|"vspltisb %0,%1"
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|TARGET_SPE
argument_list|)
expr_stmt|;
comment|/* Vector constant 0 is handled as a splitter of V2SI, and in the      pattern of V1DI, V4HI, and V2SF.       FIXME: We should probably return # and add post reload      splitters for these, but this way is so easy ;-).  */
name|cst
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cst2
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cst
operator|==
name|cst2
condition|)
return|return
literal|"li %0,%1\n\tevmergelo %0,%0,%0"
return|;
else|else
return|return
literal|"li %0,%1\n\tevmergelo %0,%0,%0\n\tli %0,%2"
return|;
block|}
end_function

begin_comment
comment|/* Initialize vector TARGET to VALS.  */
end_comment

begin_function
name|void
name|rs6000_expand_vector_init
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|vals
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|n_elts
init|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|n_var
init|=
literal|0
decl_stmt|,
name|one_var
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|all_same
init|=
name|true
decl_stmt|,
name|all_const_zero
init|=
name|true
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
operator|++
name|n_var
operator|,
name|one_var
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|!=
name|CONST0_RTX
argument_list|(
name|inner_mode
argument_list|)
condition|)
name|all_const_zero
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|all_same
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|n_var
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|V4SFmode
operator|&&
name|all_const_zero
condition|)
block|{
comment|/* Zero register.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_XOR
argument_list|(
name|mode
argument_list|,
name|target
argument_list|,
name|target
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mode
operator|!=
name|V4SFmode
operator|&&
name|easy_vector_constant
argument_list|(
name|vals
argument_list|,
name|mode
argument_list|)
condition|)
block|{
comment|/* Splat immediate.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|vals
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|all_same
condition|)
empty_stmt|;
comment|/* Splat vector element.  */
else|else
block|{
comment|/* Load from constant pool.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|XVEC
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Store value to stack temp.  Load vector element.  Splat.  */
if|if
condition|(
name|all_same
condition|)
block|{
name|mem
operator|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address_nv
argument_list|(
name|mem
argument_list|,
name|inner_mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_LVE
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|mem
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_VEC_SELECT
argument_list|(
name|inner_mode
argument_list|,
name|target
argument_list|,
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* One field is non-constant.  Load constant then overwrite      varying field.  */
if|if
condition|(
name|n_var
operator|==
literal|1
condition|)
block|{
name|rtx
name|copy
init|=
name|copy_rtx
argument_list|(
name|vals
argument_list|)
decl_stmt|;
comment|/* Load constant part of vector, substitute neighboring value for 	 varying element.  */
name|XVECEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|one_var
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
operator|(
name|one_var
operator|+
literal|1
operator|)
operator|%
name|n_elts
argument_list|)
expr_stmt|;
name|rs6000_expand_vector_init
argument_list|(
name|target
argument_list|,
name|copy
argument_list|)
expr_stmt|;
comment|/* Insert variable.  */
name|rs6000_expand_vector_set
argument_list|(
name|target
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|one_var
argument_list|)
argument_list|,
name|one_var
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Construct the vector in memory one field at a time      and load the whole vector.  */
name|mem
operator|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
name|i
operator|++
control|)
name|emit_move_insn
argument_list|(
name|adjust_address_nv
argument_list|(
name|mem
argument_list|,
name|inner_mode
argument_list|,
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set field ELT of TARGET to VAL.  */
end_comment

begin_function
name|void
name|rs6000_expand_vector_set
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|val
parameter_list|,
name|int
name|elt
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|mask
decl_stmt|,
name|mem
decl_stmt|,
name|x
decl_stmt|;
name|int
name|width
init|=
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Load single variable value.  */
name|mem
operator|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address_nv
argument_list|(
name|mem
argument_list|,
name|inner_mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_LVE
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Linear sequence.  */
name|mask
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|V16QImode
argument_list|,
name|rtvec_alloc
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
name|XVECEXP
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Set permute mask to insert element into target.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
operator|++
name|i
control|)
name|XVECEXP
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|,
name|elt
operator|*
name|width
operator|+
name|i
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|i
operator|+
literal|0x10
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_CONST_VECTOR
argument_list|(
name|V16QImode
argument_list|,
name|XVEC
argument_list|(
name|mask
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|3
argument_list|,
name|target
argument_list|,
name|reg
argument_list|,
name|force_reg
argument_list|(
name|V16QImode
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_VPERM
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract field ELT from VEC into TARGET.  */
end_comment

begin_function
name|void
name|rs6000_expand_vector_extract
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|vec
parameter_list|,
name|int
name|elt
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|vec
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|x
decl_stmt|;
comment|/* Allocate mode-sized buffer.  */
name|mem
operator|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add offset to field within buffer matching vector element.  */
name|mem
operator|=
name|adjust_address_nv
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|elt
operator|*
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store single field into mode-sized buffer.  */
name|x
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_STVE
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|vec
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|adjust_address_nv
argument_list|(
name|mem
argument_list|,
name|inner_mode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generates shifts and masks for a pair of rldicl or rldicr insns to    implement ANDing by the mask IN.  */
end_comment

begin_function
name|void
name|build_mask64_2_operands
parameter_list|(
name|rtx
name|in
parameter_list|,
name|rtx
modifier|*
name|out
parameter_list|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|unsigned
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|1
condition|)
block|{
comment|/* Assume c initially something like 0x00fff000000fffff.  The idea 	 is to rotate the word so that the middle ^^^^^^ group of zeros 	 is at the MS end and can be cleared with an rldicl mask.  We then 	 rotate back and clear off the MS    ^^ group of zeros with a 	 second rldicl.  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0xff000ffffff00000 */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* lsb == 0x0000000000100000 */
name|m1
operator|=
operator|-
name|lsb
expr_stmt|;
comment|/*  m1 == 0xfffffffffff00000 */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0x00fff000000fffff */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/*   c == 0x00fff00000000000 */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* lsb == 0x0000100000000000 */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0xff000fffffffffff */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/*   c == 0xff00000000000000 */
name|shift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|lsb
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|shift
operator|++
expr_stmt|;
comment|/* shift == 44 on exit from loop */
name|m1
operator|<<=
literal|64
operator|-
name|shift
expr_stmt|;
comment|/*  m1 == 0xffffff0000000000 */
name|m1
operator|=
operator|~
name|m1
expr_stmt|;
comment|/*  m1 == 0x000000ffffffffff */
name|m2
operator|=
operator|~
name|c
expr_stmt|;
comment|/*  m2 == 0x00ffffffffffffff */
block|}
else|else
block|{
comment|/* Assume c initially something like 0xff000f0000000000.  The idea 	 is to rotate the word so that the     ^^^  middle group of zeros 	 is at the LS end and can be cleared with an rldicr mask.  We then 	 rotate back and clear off the LS group of ^^^^^^^^^^ zeros with 	 a second rldicr.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* lsb == 0x0000010000000000 */
name|m2
operator|=
operator|-
name|lsb
expr_stmt|;
comment|/*  m2 == 0xffffff0000000000 */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0x00fff0ffffffffff */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/*   c == 0x00fff00000000000 */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* lsb == 0x0000100000000000 */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/*   c == 0xff000fffffffffff */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/*   c == 0xff00000000000000 */
name|shift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|lsb
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|shift
operator|++
expr_stmt|;
comment|/* shift == 44 on exit from loop */
name|m1
operator|=
operator|~
name|c
expr_stmt|;
comment|/*  m1 == 0x00ffffffffffffff */
name|m1
operator|>>=
name|shift
expr_stmt|;
comment|/*  m1 == 0x0000000000000fff */
name|m1
operator|=
operator|~
name|m1
expr_stmt|;
comment|/*  m1 == 0xfffffffffffff000 */
block|}
comment|/* Note that when we only have two 0->1 and 1->0 transitions, one of the      masks will be all 1's.  We are guaranteed more than one transition.  */
name|out
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
literal|64
operator|-
name|shift
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|shift
argument_list|)
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|GEN_INT
argument_list|(
name|m2
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|in
expr_stmt|;
operator|(
name|void
operator|)
name|out
expr_stmt|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return TRUE if OP is an invalid SUBREG operation on the e500.  */
end_comment

begin_function
name|bool
name|invalid_e500_subreg
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|TARGET_E500_DOUBLE
condition|)
block|{
comment|/* Reject (subreg:SI (reg:DF)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|DFmode
condition|)
return|return
name|true
return|;
comment|/* Reject (subreg:DF (reg:DI)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|mode
operator|==
name|DFmode
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
name|TARGET_SPE
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Darwin, AIX increases natural record alignment to doubleword if the first    field is an FP double while the FP fields remain word aligned.  */
end_comment

begin_function
name|unsigned
name|int
name|rs6000_special_round_type_align
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|int
name|computed
parameter_list|,
name|unsigned
name|int
name|specified
parameter_list|)
block|{
name|unsigned
name|int
name|align
init|=
name|MAX
argument_list|(
name|computed
argument_list|,
name|specified
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Skip all non field decls */
while|while
condition|(
name|field
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|!=
name|NULL
operator|&&
name|field
operator|!=
name|type
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Return 1 for an operand in small memory on V.4/eabi.  */
end_comment

begin_function
name|int
name|small_data_operand
parameter_list|(
name|rtx
name|op
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|TARGET_ELF
name|rtx
name|sym_ref
decl_stmt|;
if|if
condition|(
name|rs6000_sdata
operator|==
name|SDATA_NONE
operator|||
name|rs6000_sdata
operator|==
name|SDATA_DATA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|sym_ref
operator|=
name|op
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
else|else
block|{
name|rtx
name|sum
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|summand
decl_stmt|;
comment|/* We have to be careful here, because it is the referenced address 	 that must be 32k from _SDA_BASE_, not just the symbol.  */
name|summand
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|summand
operator|<
literal|0
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|summand
operator|>
name|g_switch_value
condition|)
return|return
literal|0
return|;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|SYMBOL_REF_SMALL_P
argument_list|(
name|sym_ref
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return true if either operand is a general purpose register.  */
end_comment

begin_function
name|bool
name|gpr_or_gpr_p
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
return|return
operator|(
operator|(
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|INT_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|INT_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address.  */
end_comment

begin_function
specifier|static
name|int
name|constant_pool_expr_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
modifier|*
name|have_sym
parameter_list|,
name|int
modifier|*
name|have_toc
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|RS6000_SYMBOL_REF_TLS_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|op
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
operator|*
name|have_sym
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|toc_label_name
argument_list|)
condition|)
block|{
operator|*
name|have_toc
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
operator|(
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
operator|&&
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
operator|)
return|;
case|case
name|CONST
case|:
return|return
name|constant_pool_expr_1
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|have_sym
argument_list|,
name|have_toc
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|constant_pool_expr_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|have_sym
init|=
literal|0
decl_stmt|;
name|int
name|have_toc
init|=
literal|0
decl_stmt|;
return|return
name|constant_pool_expr_1
argument_list|(
name|op
argument_list|,
operator|&
name|have_sym
argument_list|,
operator|&
name|have_toc
argument_list|)
operator|&&
name|have_sym
return|;
block|}
end_function

begin_function
name|bool
name|toc_relative_expr_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|have_sym
init|=
literal|0
decl_stmt|;
name|int
name|have_toc
init|=
literal|0
decl_stmt|;
return|return
name|constant_pool_expr_1
argument_list|(
name|op
argument_list|,
operator|&
name|have_sym
argument_list|,
operator|&
name|have_toc
argument_list|)
operator|&&
name|have_toc
return|;
block|}
end_function

begin_function
name|bool
name|legitimate_constant_pool_address_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
operator|(
name|TARGET_TOC
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|TARGET_MINIMAL_TOC
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TOC_REGISTER
operator|)
operator|&&
name|constant_pool_expr_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|legitimate_small_data_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
return|return
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|!
name|flag_pic
operator|&&
operator|!
name|TARGET_TOC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|)
operator|&&
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SPE offset addressing is limited to 5-bits worth of double words.  */
end_comment

begin_define
define|#
directive|define
name|SPE_CONST_OFFSET_OK
parameter_list|(
name|x
parameter_list|)
value|(((x)& ~0xf8) == 0)
end_define

begin_function
name|bool
name|rs6000_legitimate_offset_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|extra
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|legitimate_constant_pool_address_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|false
return|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
comment|/* AltiVec vector modes.  Only reg+reg addressing is valid and 	 constant offset zero should not occur due to canonicalization. 	 Allow any offset when not strict before reload.  */
return|return
operator|!
name|strict
return|;
case|case
name|V4HImode
case|:
case|case
name|V2SImode
case|:
case|case
name|V1DImode
case|:
case|case
name|V2SFmode
case|:
comment|/* SPE vector modes.  */
return|return
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
return|;
case|case
name|DFmode
case|:
if|if
condition|(
name|TARGET_E500_DOUBLE
condition|)
return|return
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
return|;
case|case
name|DImode
case|:
comment|/* On e500v2, we may have:  	   (subreg:DF (mem:DI (plus (reg) (const_int))) 0).           Which gets addressed with evldd instructions.  */
if|if
condition|(
name|TARGET_E500_DOUBLE
condition|)
return|return
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|||
operator|!
name|TARGET_POWERPC64
condition|)
name|extra
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|&
literal|3
condition|)
return|return
name|false
return|;
break|break;
case|case
name|TFmode
case|:
case|case
name|TImode
case|:
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|||
operator|!
name|TARGET_POWERPC64
condition|)
name|extra
operator|=
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|&
literal|3
condition|)
return|return
name|false
return|;
else|else
name|extra
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|offset
operator|+=
literal|0x8000
expr_stmt|;
return|return
operator|(
name|offset
operator|<
literal|0x10000
operator|)
operator|&&
operator|(
name|offset
operator|+
name|extra
operator|<
literal|0x10000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|legitimate_indexed_address_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Recognize the rtl generated by reload which we know will later be      replaced with proper base and index regs.  */
if|if
condition|(
operator|!
name|strict
operator|&&
name|reload_in_progress
operator|&&
operator|(
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|)
operator|&&
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|true
return|;
return|return
operator|(
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|op1
argument_list|)
operator|&&
operator|(
operator|(
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|,
name|strict
argument_list|)
operator|&&
name|INT_REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|,
name|strict
argument_list|)
operator|)
operator|||
operator|(
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|,
name|strict
argument_list|)
operator|&&
name|INT_REG_OK_FOR_INDEX_P
argument_list|(
name|op0
argument_list|,
name|strict
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|inline
name|bool
name|legitimate_indirect_address_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|x
argument_list|,
name|strict
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|macho_lo_sum_memory_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_MACHO
operator|||
operator|!
name|flag_pic
operator|||
name|mode
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|false
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LO_SUM
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|legitimate_lo_sum_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LO_SUM
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|INT_REG_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Restrict addressing for DI because of our SUBREG hackery.  */
if|if
condition|(
name|TARGET_E500_DOUBLE
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DImode
operator|)
condition|)
return|return
name|false
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|||
name|TARGET_MACHO
condition|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_DARWIN
operator|&&
name|flag_pic
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TARGET_TOC
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|64
operator|||
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|32
operator|&&
operator|!
name|TARGET_POWERPC64
operator|&&
operator|!
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|mode
operator|==
name|DFmode
operator|)
operator|)
condition|)
return|return
name|false
return|;
return|return
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This is used from only one place: `memory_address' in explow.c.     OLDX is the address as it was before break_out_memory_refs was    called.  In some cases it is useful to look at this to decide what    needs to be done.     MODE is passed so that this function can use GO_IF_LEGITIMATE_ADDRESS.     It is always safe for this function to do nothing.  It exists to    recognize opportunities to optimize the output.     On RS/6000, first check for the sum of a register with a constant    integer that is out of range.  If so, generate code to add the    constant with the low-order 16 bits masked to the register and force    this result into another register (this can be done with `cau').    Then generate an address of REG+(CONST&0xffff), allowing for the    possibility of bit 16 being a one.     Then check for the sum of a register and something not constant, try to    load the other things into a register and return the sum.  */
end_comment

begin_function
name|rtx
name|rs6000_legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|enum
name|tls_model
name|model
init|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|model
operator|!=
literal|0
condition|)
return|return
name|rs6000_legitimize_tls_address
argument_list|(
name|x
argument_list|,
name|model
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
condition|)
block|{
name|HOST_WIDE_INT
name|high_int
decl_stmt|,
name|low_int
decl_stmt|;
name|rtx
name|sum
decl_stmt|;
name|low_int
operator|=
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|high_int
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|low_int
expr_stmt|;
name|sum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high_int
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum
argument_list|,
name|GEN_INT
argument_list|(
name|low_int
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|)
operator|||
name|TARGET_POWERPC64
operator|||
operator|(
operator|(
operator|(
name|mode
operator|!=
name|DImode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
operator|||
name|TARGET_E500_DOUBLE
operator|)
operator|&&
name|mode
operator|!=
name|TFmode
operator|)
operator|)
operator|&&
operator|(
name|TARGET_POWERPC64
operator|||
name|mode
operator|!=
name|DImode
operator|)
operator|&&
name|mode
operator|!=
name|TImode
condition|)
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|reg
decl_stmt|;
comment|/* Make sure both operands are registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
name|reg
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
name|TARGET_E500_DOUBLE
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DImode
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
name|NULL_RTX
return|;
comment|/* We accept [reg + reg] and [reg + OFFSET].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|!
name|SPE_CONST_OFFSET_OK
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|)
condition|)
name|op2
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ELF
operator|&&
name|TARGET_32BIT
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
operator|||
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|)
operator|&&
name|mode
operator|==
name|DFmode
operator|)
operator|)
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|reg
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|x
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MACHO
operator|&&
name|TARGET_32BIT
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
if|#
directive|if
name|TARGET_MACHO
operator|&&
operator|!
name|MACHO_DYNAMIC_NO_PIC_P
endif|#
directive|endif
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|)
operator|||
name|mode
operator|!=
name|DFmode
operator|)
operator|&&
name|mode
operator|!=
name|DImode
operator|&&
name|mode
operator|!=
name|TImode
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|reg
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|x
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_TOC
operator|&&
name|constant_pool_expr_p
argument_list|(
name|x
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
return|return
name|create_TOC_reference
argument_list|(
name|x
argument_list|)
return|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|fputs
argument_list|(
literal|"\t.long\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@dtprel+0x8000"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for the tls_get_addr function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|rs6000_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|rs6000_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs6000_tls_symbol
condition|)
name|rs6000_tls_symbol
operator|=
name|init_one_libfunc
argument_list|(
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
return|return
name|rs6000_tls_symbol
return|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for TLS GOT references.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|rs6000_got_symbol
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|rs6000_got_sym
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs6000_got_symbol
condition|)
block|{
name|rs6000_got_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|rs6000_got_symbol
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|rs6000_got_symbol
argument_list|)
operator||=
name|SYMBOL_FLAG_EXTERNAL
expr_stmt|;
block|}
return|return
name|rs6000_got_symbol
return|;
block|}
end_function

begin_comment
comment|/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute    this (thread-local) address.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_legitimize_tls_address
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|enum
name|tls_model
name|model
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|insn
decl_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_LOCAL_EXEC
operator|&&
name|rs6000_tls_size
operator|==
literal|16
condition|)
block|{
name|rtx
name|tlsreg
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|tlsreg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_tls_tprel_64
argument_list|(
name|dest
argument_list|,
name|tlsreg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tlsreg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_tls_tprel_32
argument_list|(
name|dest
argument_list|,
name|tlsreg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_LOCAL_EXEC
operator|&&
name|rs6000_tls_size
operator|==
literal|32
condition|)
block|{
name|rtx
name|tlsreg
decl_stmt|,
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|tlsreg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_tls_tprel_ha_64
argument_list|(
name|tmp
argument_list|,
name|tlsreg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tlsreg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_tls_tprel_ha_32
argument_list|(
name|tmp
argument_list|,
name|tlsreg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_tprel_lo_64
argument_list|(
name|dest
argument_list|,
name|tmp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_tprel_lo_32
argument_list|(
name|dest
argument_list|,
name|tmp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|r3
decl_stmt|,
name|got
decl_stmt|,
name|tga
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|eqv
decl_stmt|;
comment|/* We currently use relocations like @got@tlsgd for tls, which 	 means the linker will handle allocation of tls entries, placing 	 them in the .got section.  So use a pointer to the .got section, 	 not one to secondary TOC sections used by 64-bit -mminimal-toc, 	 or to secondary GOT sections used by 32-bit -fPIC.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|got
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
name|got
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RS6000_PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|gsym
init|=
name|rs6000_got_sym
argument_list|()
decl_stmt|;
name|got
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|0
condition|)
name|rs6000_emit_move
argument_list|(
name|got
argument_list|,
name|gsym
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|tempLR
decl_stmt|,
name|tmp3
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
name|tempLR
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|first
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1b
argument_list|(
name|tempLR
argument_list|,
name|gsym
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp1
argument_list|,
name|tempLR
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp2
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|tmp3
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|emit_move_insn
argument_list|(
name|got
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|gsym
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LIBCALL
argument_list|,
name|last
argument_list|,
name|REG_NOTES
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_RETVAL
argument_list|,
name|first
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_GLOBAL_DYNAMIC
condition|)
block|{
name|r3
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_gd_64
argument_list|(
name|r3
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_gd_32
argument_list|(
name|r3
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|tga
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|rs6000_tls_get_addr
argument_list|()
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_call_value
argument_list|(
name|r3
argument_list|,
name|tga
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|r3
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|,
name|r3
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|model
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|r3
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_ld_64
argument_list|(
name|r3
argument_list|,
name|got
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_ld_32
argument_list|(
name|r3
argument_list|,
name|got
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|tga
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|rs6000_tls_get_addr
argument_list|()
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_call_value
argument_list|(
name|r3
argument_list|,
name|tga
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|r3
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLD
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|tmp1
argument_list|,
name|r3
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs6000_tls_size
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_dtprel_64
argument_list|(
name|dest
argument_list|,
name|tmp1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_dtprel_32
argument_list|(
name|dest
argument_list|,
name|tmp1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs6000_tls_size
operator|==
literal|32
condition|)
block|{
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_dtprel_ha_64
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_dtprel_ha_32
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_dtprel_lo_64
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_dtprel_lo_32
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_got_dtprel_64
argument_list|(
name|tmp2
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_got_dtprel_32
argument_list|(
name|tmp2
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp2
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* IE, or 64 bit offset LE.  */
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_got_tprel_64
argument_list|(
name|tmp2
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_got_tprel_32
argument_list|(
name|tmp2
argument_list|,
name|got
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_tls_tls_64
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_tls_tls_32
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X contains a thread-local symbol.  */
end_comment

begin_function
name|bool
name|rs6000_tls_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAVE_TLS
condition|)
return|return
name|false
return|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|rs6000_tls_symbol_ref_1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if *X is a thread-local symbol.  This is the same as    rs6000_tls_symbol_ref except for the type of the unused argument.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_tls_symbol_ref_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|RS6000_SYMBOL_REF_TLS_P
argument_list|(
operator|*
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The convention appears to be to define this wherever it is used.    With legitimize_reload_address now defined here, REG_MODE_OK_FOR_BASE_P    is now used here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REG_MODE_OK_FOR_BASE_P
end_ifndef

begin_define
define|#
directive|define
name|REG_MODE_OK_FOR_BASE_P
parameter_list|(
name|REGNO
parameter_list|,
name|MODE
parameter_list|)
value|REG_OK_FOR_BASE_P (REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to    replace the input X, or the original X if no replacement is called for.    The output parameter *WIN is 1 if the calling macro should goto WIN,    0 if it should not.     For RS/6000, we wish to handle large displacements off a base    register by splitting the addend across an addiu/addis and the mem insn.    This cuts number of extra insns needed from 3 to 1.     On Darwin, we use this to generate code for floating point constants.    A movsf_low is generated so we wind up with 2 instructions rather than 3.    The Darwin code is inside #if TARGET_MACHO because only then is    machopic_function_base_name() defined.  */
end_comment

begin_function
name|rtx
name|rs6000_legitimize_reload_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|opnum
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|ind_levels
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|win
parameter_list|)
block|{
comment|/* We must recognize output that we have already generated ourselves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* Result of previous invocation of this function on Darwin 	 floating point constant.  */
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
endif|#
directive|endif
comment|/* Force ld/std non-word aligned offset into base register by wrapping      in offset 0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|32
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|UNITS_PER_WORD
operator|&&
name|TARGET_POWERPC64
condition|)
block|{
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
operator|(
name|TARGET_E500_DOUBLE
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DImode
operator|)
operator|)
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
init|=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
operator|(
name|val
operator|-
name|low
operator|)
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
decl_stmt|;
comment|/* Check for 32-bit overflow.  */
if|if
condition|(
name|high
operator|+
name|low
operator|!=
name|val
condition|)
block|{
operator|*
name|win
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* Reload the high part into a base reg; leave the low part 	 in the mem directly.  */
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|high
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
if|#
directive|if
name|TARGET_MACHO
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
operator|(
name|flag_pic
operator|||
name|MACHO_DYNAMIC_NO_PIC_P
operator|)
else|#
directive|else
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|!
name|flag_pic
endif|#
directive|endif
comment|/* Don't do this for TFmode, since the result isn't offsettable. 	 The same goes for DImode without 64-bit gprs and DFmode 	 without fprs.  */
operator|&&
name|mode
operator|!=
name|TFmode
operator|&&
operator|(
name|mode
operator|!=
name|DImode
operator|||
name|TARGET_POWERPC64
operator|)
operator|&&
operator|(
name|mode
operator|!=
name|DFmode
operator|||
name|TARGET_POWERPC64
operator|||
operator|(
name|TARGET_FPRS
operator|&&
name|TARGET_HARD_FLOAT
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|flag_pic
condition|)
block|{
name|rtx
name|offset
init|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|machopic_function_base_sym
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|x
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* Reload an offset address wrapped by an AND that represents the      masking of the lower bits.  Strip the outer AND and let reload      convert the offset address into an indirect address.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|16
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|if
condition|(
name|TARGET_TOC
operator|&&
name|constant_pool_expr_p
argument_list|(
name|x
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|x
operator|=
name|create_TOC_reference
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|*
name|win
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
operator|*
name|win
operator|=
literal|0
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression    that is a valid memory address for an instruction.    The MODE argument is the machine mode for the MEM expression    that wants to use this address.     On the RS/6000, there are four valid address: a SYMBOL_REF that    refers to a constant pool entry of an address (or the sum of it    plus a constant), a short (16-bit signed) constant plus a register,    the sum of two registers, or a register indirect, possibly with an    auto-increment.  For DFmode and DImode with a constant plus register,    we must ensure that both words are addressable or PowerPC64 with offset    word aligned.     For modes spanning multiple registers (DFmode in 32-bit GPRs,    32-bit DImode, TImode, TFmode), indexed addressing cannot be used because    adjacent memory cells are accessed by adding word-sized offsets    during assembly output.  */
end_comment

begin_function
name|int
name|rs6000_legitimate_address
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|reg_ok_strict
parameter_list|)
block|{
comment|/* If this is an unaligned stvx/ldvx type address, discard the outer AND.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|16
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|RS6000_SYMBOL_REF_TLS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|legitimate_indirect_address_p
argument_list|(
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_DEC
operator|)
operator|&&
operator|!
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|mode
operator|!=
name|TFmode
comment|/* Restrict addressing for DI because of our SUBREG hackery.  */
operator|&&
operator|!
operator|(
name|TARGET_E500_DOUBLE
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DImode
operator|)
operator|)
operator|&&
name|TARGET_UPDATE
operator|&&
name|legitimate_indirect_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|legitimate_small_data_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|legitimate_constant_pool_address_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If not REG_OK_STRICT (before reload) let pass any stack offset.  */
if|if
condition|(
operator|!
name|reg_ok_strict
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|rs6000_legitimate_offset_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mode
operator|!=
name|TImode
operator|&&
name|mode
operator|!=
name|TFmode
operator|&&
operator|(
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|)
operator|||
name|TARGET_POWERPC64
operator|||
operator|(
operator|(
name|mode
operator|!=
name|DFmode
operator|||
name|TARGET_E500_DOUBLE
operator|)
operator|&&
name|mode
operator|!=
name|TFmode
operator|)
operator|)
operator|&&
operator|(
name|TARGET_POWERPC64
operator|||
name|mode
operator|!=
name|DImode
operator|)
operator|&&
name|legitimate_indexed_address_p
argument_list|(
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|legitimate_lo_sum_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|reg_ok_strict
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Go to LABEL if ADDR (a legitimate address expression)    has an effect that depends on the machine mode it is used for.     On the RS/6000 this is true of all integral offsets (since AltiVec    modes don't allow them) or is a pre-increment or decrement.     ??? Except that due to conceptual problems in offsettable_address_p    we can't really report the problems of integral offsets.  So leave    this assuming that the adjustable offset must be valid for the    sub-words of a TFmode operand, which is what we had before.  */
end_comment

begin_function
name|bool
name|rs6000_mode_dependent_address
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|val
operator|+
literal|12
operator|+
literal|0x8000
operator|>=
literal|0x10000
return|;
block|}
break|break;
case|case
name|LO_SUM
case|:
return|return
name|true
return|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
return|return
name|TARGET_UPDATE
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* More elaborate version of recog's offsettable_memref_p predicate    that works around the ??? note of rs6000_mode_dependent_address.    In particular it accepts       (mem:DI (plus:SI (reg/f:SI 31 31) (const_int 32760 [0x7ff8])))     in 32-bit mode, that the recog predicate rejects.  */
end_comment

begin_function
name|bool
name|rs6000_offsettable_memref_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* First mimic offsettable_memref_p.  */
if|if
condition|(
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* offsettable_address_p invokes rs6000_mode_dependent_address, but      the latter predicate knows nothing about the mode of the memory      reference and, therefore, assumes that it is the largest supported      mode (TFmode).  As a consequence, legitimate offsettable memory      references are rejected.  rs6000_legitimate_offset_address_p contains      the correct logic for the PLUS case of rs6000_mode_dependent_address.  */
return|return
name|rs6000_legitimate_offset_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return number of consecutive hard regs needed starting at reg REGNO    to hold something of mode MODE.    This is ordinarily the length in words of a value of mode MODE    but can be less for certain modes in special long registers.     For the SPE, GPRs are 64 bits but only 32 bits are visible in    scalar instructions.  The upper 32 bits are only available to the    SIMD instructions.     POWER and PowerPC GPRs hold 32 bits worth;    PowerPC64 GPRs and FPRs point register holds 64 bits worth.  */
end_comment

begin_function
name|int
name|rs6000_hard_regno_nregs
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_FP_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_FP_WORD
return|;
if|if
condition|(
name|SPE_SIMD_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|TARGET_SPE
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_SPE_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_SPE_WORD
return|;
if|if
condition|(
name|ALTIVEC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_ALTIVEC_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_ALTIVEC_WORD
return|;
comment|/* The value returned for SCmode in the E500 double case is 2 for      ABI compatibility; storing an SCmode value in a single register      would require function_arg and rs6000_spe_function_arg to handle      SCmode so as to pass the value correctly in a pair of      registers.  */
if|if
condition|(
name|TARGET_E500_DOUBLE
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|mode
operator|!=
name|SCmode
condition|)
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_FP_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_FP_WORD
return|;
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Change register usage conditional on target flags.  */
end_comment

begin_function
name|void
name|rs6000_conditional_register_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Set MQ register fixed (already call_used) if not POWER      architecture (RIOS1, RIOS2, RSC, and PPC601) so that it will not      be allocated.  */
if|if
condition|(
operator|!
name|TARGET_POWER
condition|)
name|fixed_regs
index|[
literal|64
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 64-bit AIX and Linux reserve GPR13 for thread-private data.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fixed_regs
index|[
literal|13
index|]
operator|=
name|call_used_regs
index|[
literal|13
index|]
operator|=
name|call_really_used_regs
index|[
literal|13
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Conditionally disable FPRs.  */
if|if
condition|(
name|TARGET_SOFT_FLOAT
operator|||
operator|!
name|TARGET_FPRS
condition|)
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_really_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The TOC register is not killed across calls in a way that is      visible to the compiler.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
name|call_really_used_regs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
operator|&&
name|flag_pic
operator|==
literal|2
condition|)
name|fixed_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
operator|&&
name|flag_pic
operator|==
literal|1
condition|)
name|fixed_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
name|call_used_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
name|call_really_used_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
condition|)
name|fixed_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
name|call_used_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
name|call_really_used_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
condition|)
name|fixed_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
name|call_used_regs
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
name|global_regs
index|[
name|VSCR_REGNO
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_SPE
condition|)
block|{
name|global_regs
index|[
name|SPEFSCR_REGNO
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
name|FIXED_SCRATCH
index|]
operator|=
name|call_used_regs
index|[
name|FIXED_SCRATCH
index|]
operator|=
name|call_really_used_regs
index|[
name|FIXED_SCRATCH
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_ALTIVEC
condition|)
block|{
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_really_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|call_really_used_regs
index|[
name|VRSAVE_REGNO
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<
name|FIRST_ALTIVEC_REGNO
operator|+
literal|20
condition|;
operator|++
name|i
control|)
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_really_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to output insns to set TARGET equal to the constant C if it can    be done in less than N insns.  Do all computations in MODE.    Returns the place where the output has been placed if it can be    done and the insns have been emitted.  If it would take more than N    insns, zero is returned and no insns and emitted.  */
end_comment

begin_function
name|rtx
name|rs6000_emit_set_const
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|source
parameter_list|,
name|int
name|n
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|,
name|insn
decl_stmt|,
name|set
decl_stmt|;
name|HOST_WIDE_INT
name|c0
decl_stmt|,
name|c1
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
case|case
name|HImode
case|:
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
case|case
name|SImode
case|:
name|result
operator|=
name|no_new_pseudos
condition|?
name|dest
else|:
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|result
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|source
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|result
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|source
argument_list|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dest
expr_stmt|;
break|break;
case|case
name|DImode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|source
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|c0
operator|=
name|INTVAL
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|-
operator|(
name|c0
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|c0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|-
operator|(
name|c0
operator|<
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|c0
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|c1
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|source
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|rs6000_emit_set_long_const
argument_list|(
name|dest
argument_list|,
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Having failed to find a 3 insn sequence in rs6000_emit_set_const,    fall back to a straight forward decomposition.  We do this to avoid    exponential run times encountered when looking for longer sequences    with rs6000_emit_set_const.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_emit_set_long_const
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|HOST_WIDE_INT
name|c1
parameter_list|,
name|HOST_WIDE_INT
name|c2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_POWERPC64
condition|)
block|{
name|rtx
name|operand1
decl_stmt|,
name|operand2
decl_stmt|;
name|operand1
operator|=
name|operand_subword_force
argument_list|(
name|dest
argument_list|,
name|WORDS_BIG_ENDIAN
operator|==
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|operand2
operator|=
name|operand_subword_force
argument_list|(
name|dest
argument_list|,
name|WORDS_BIG_ENDIAN
operator|!=
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operand1
argument_list|,
name|GEN_INT
argument_list|(
name|c1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operand2
argument_list|,
name|GEN_INT
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|ud1
decl_stmt|,
name|ud2
decl_stmt|,
name|ud3
decl_stmt|,
name|ud4
decl_stmt|;
name|ud1
operator|=
name|c1
operator|&
literal|0xffff
expr_stmt|;
name|ud2
operator|=
operator|(
name|c1
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|c2
operator|=
name|c1
operator|>>
literal|32
expr_stmt|;
endif|#
directive|endif
name|ud3
operator|=
name|c2
operator|&
literal|0xffff
expr_stmt|;
name|ud4
operator|=
operator|(
name|c2
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
name|ud3
operator|==
literal|0xffff
operator|&&
name|ud2
operator|==
literal|0xffff
operator|&&
operator|(
name|ud1
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
name|ud3
operator|==
literal|0
operator|&&
name|ud2
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud1
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud1
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud1
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
name|ud3
operator|==
literal|0xffff
operator|&&
operator|(
name|ud2
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
name|ud3
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud2
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud2
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud2
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ud4
operator|==
literal|0xffff
operator|&&
operator|(
name|ud3
operator|&
literal|0x8000
operator|)
operator|)
operator|||
operator|(
name|ud4
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ud3
operator|&
literal|0x8000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ud3
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud3
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud3
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud2
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ud4
operator|&
literal|0x8000
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|ud4
operator|<<
literal|16
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud4
operator|<<
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud3
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud2
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud2
operator|<<
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud1
operator|!=
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|ud1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Helper for the following.  Get rid of [r+r] memory refs    in cases where it won't work (TImode, TFmode).  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_eliminate_indexed_memrefs
parameter_list|(
name|rtx
name|operands
index|[
literal|2
index|]
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|legitimate_constant_pool_address_p
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|legitimate_constant_pool_address_p
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a move from SOURCE to DEST in mode MODE.  */
end_comment

begin_function
name|void
name|rs6000_emit_move
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|source
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|source
expr_stmt|;
comment|/* Sanity checks.  Check that we get CONST_DOUBLE only when we should.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* FIXME.  This should never happen.  */
comment|/* Since it seems that it does, do the safe thing and convert 	 to a CONST_INT.  */
name|operands
index|[
literal|1
index|]
operator|=
name|gen_int_mode
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Check if GCC is setting up a block move that will end up using FP      registers as temporaries.  We must make sure this is acceptable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|DImode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|DImode
argument_list|,
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|SImode
argument_list|,
operator|(
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>
literal|32
condition|?
literal|32
else|:
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
operator|||
name|SLOW_UNALIGNED_ACCESS
argument_list|(
name|SImode
argument_list|,
operator|(
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>
literal|32
condition|?
literal|32
else|:
name|MEM_ALIGN
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|)
argument_list|)
operator|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|gpc_reg_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
operator|&&
operator|!
name|TARGET_POWERPC
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regnum
operator|=
name|true_regnum
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
name|regnum
operator|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|regnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If operands[1] is a register, on POWER it may have 	 double-precision data in it, so truncate it to single 	 precision.  */
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|regnum
argument_list|)
operator|||
name|regnum
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|newreg
decl_stmt|;
name|newreg
operator|=
operator|(
name|no_new_pseudos
condition|?
name|operands
index|[
literal|1
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_aux_truncdfsf2
argument_list|(
name|newreg
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|newreg
expr_stmt|;
block|}
block|}
comment|/* Recognize the case where operand[1] is a reference to thread-local      data and load its address to a register.  */
if|if
condition|(
name|rs6000_tls_referenced_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|enum
name|tls_model
name|model
decl_stmt|;
name|rtx
name|tmp
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|addend
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|addend
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|model
operator|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|model
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|rs6000_legitimize_tls_address
argument_list|(
name|tmp
argument_list|,
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|addend
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_operand
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Handle the case where reload calls us with an invalid address.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
operator|(
operator|!
name|general_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|||
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
goto|goto
name|emit_set
goto|;
comment|/* 128-bit constant floating-point values on Darwin should really be      loaded as two parts.  */
if|if
condition|(
operator|!
name|TARGET_IEEEQUAD
operator|&&
name|TARGET_LONG_DOUBLE_128
operator|&&
name|mode
operator|==
name|TFmode
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* DImode is used, not DFmode, because simplify_gen_subreg doesn't 	 know how to get a DFmode SUBREG of a TFmode.  */
name|rs6000_emit_move
argument_list|(
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|rs6000_emit_move
argument_list|(
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME:  In the long term, this switch statement should go away      and be replaced by a sequence of tests based on things like      mode == Pmode.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HImode
case|:
case|case
name|QImode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|rs6000_eliminate_indexed_memrefs
argument_list|(
name|operands
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|DFmode
case|:
case|case
name|SFmode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|easy_fp_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V2SFmode
case|:
case|case
name|V2SImode
case|:
case|case
name|V1DImode
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|easy_vector_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|DImode
case|:
comment|/* Use default pattern for address of ELF small data */
if|if
condition|(
name|TARGET_ELF
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST
operator|)
operator|&&
name|small_data_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|flag_pic
operator|==
literal|1
operator|&&
name|got_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi_got
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|TARGET_ELF
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
operator|&&
name|TARGET_NO_TOC
operator|&&
operator|!
name|flag_pic
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|HIGH
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|rtx
name|target
init|=
operator|(
name|no_new_pseudos
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
comment|/* If this is a function address on -mcall-aixdesc, 	     convert it to the address of the descriptor.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|XSTR
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|new_ref
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
name|name
operator|++
expr_stmt|;
name|new_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|new_ref
argument_list|)
operator|=
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|new_ref
argument_list|)
operator|=
name|SYMBOL_REF_FLAGS
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SYMBOL_REF_USED
argument_list|(
name|new_ref
argument_list|)
operator|=
name|SYMBOL_REF_USED
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SYMBOL_REF_DATA
argument_list|(
name|new_ref
argument_list|)
operator|=
name|SYMBOL_REF_DATA
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|new_ref
expr_stmt|;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
condition|)
block|{
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
block|{
comment|/* Take care of any required data indirection.  */
name|operands
index|[
literal|1
index|]
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
index|[
literal|0
index|]
operator|!=
name|operands
index|[
literal|1
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_low
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|target
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is a SYMBOL_REF that refers to a constant pool entry, 	 and we have put it in the TOC, we just need to make a TOC-relative 	 reference to it.  */
if|if
condition|(
name|TARGET_TOC
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|constant_pool_expr_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|create_TOC_reference
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|!
name|easy_fp_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|num_insns_constant
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|>
literal|2
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|HIGH
operator|&&
operator|!
name|legitimate_constant_pool_address_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|toc_relative_expr_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Emit a USE operation so that the constant isn't deleted if 	     expensive optimizations are turned on because nobody 	     references it.  This should only be done for operands that 	     contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set. 	     This should not be done for operands that contain LABEL_REFs. 	     For now, we just handle the obvious case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|LABEL_REF
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* Darwin uses a special PIC legitimizer.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|MACHOPIC_INDIRECT
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
index|[
literal|0
index|]
operator|!=
name|operands
index|[
literal|1
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If we are to limit the number of things we put in the TOC and 	     this is a symbol plus a constant we can add in one insn, 	     just put the symbol in the TOC and add the constant.  Don't do 	     this if reload is in progress.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST
operator|&&
name|TARGET_NO_SUM_IN_TOC
operator|&&
operator|!
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|add_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|rtx
name|sym
init|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|other
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|sym
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|sym
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|sym
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_TOC
operator|&&
name|constant_pool_expr_p
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_const_mem
argument_list|(
name|mode
argument_list|,
name|create_TOC_reference
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|get_TOC_alias_set
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TImode
case|:
name|rs6000_eliminate_indexed_memrefs
argument_list|(
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_POWER
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|SImode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Above, we may have called force_const_mem which may have returned      an invalid address.  If we can, fix this up; otherwise, reload will      have to deal with it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|validize_mem
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_set
label|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we can use a floating-point register to pass this arg.  */
end_comment

begin_define
define|#
directive|define
name|USE_FP_FOR_ARG_P
parameter_list|(
name|CUM
parameter_list|,
name|MODE
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|(SCALAR_FLOAT_MODE_P (MODE)			\&& !DECIMAL_FLOAT_MODE_P (MODE)		\&& (CUM)->fregno<= FP_ARG_MAX_REG		\&& TARGET_HARD_FLOAT&& TARGET_FPRS)
end_define

begin_comment
comment|/* Nonzero if we can use an AltiVec register to pass this arg.  */
end_comment

begin_define
define|#
directive|define
name|USE_ALTIVEC_FOR_ARG_P
parameter_list|(
name|CUM
parameter_list|,
name|MODE
parameter_list|,
name|TYPE
parameter_list|,
name|NAMED
parameter_list|)
define|\
value|(ALTIVEC_VECTOR_MODE (MODE)				\&& (CUM)->vregno<= ALTIVEC_ARG_MAX_REG		\&& TARGET_ALTIVEC_ABI				\&& (NAMED))
end_define

begin_comment
comment|/* Return a nonzero value to say to return the function value in    memory, just as large structures are always returned.  TYPE will be    the data type of the value, and FNTYPE will be the type of the    function doing the returning, or @code{NULL} for libcalls.     The AIX ABI for the RS/6000 specifies that all structures are    returned in memory.  The Darwin ABI does the same.  The SVR4 ABI    specifies that structures<= 8 bytes are returned in r3/r4, but a    draft put them in memory, and GCC used to implement the draft    instead of the final standard.  Therefore, aix_struct_return    controls this instead of DEFAULT_ABI; V.4 targets needing backward    compatibility can change DRAFT_V4_STRUCT_RET to override the    default, and -m switches get the final word.  See    rs6000_override_options for more details.     The PPC32 SVR4 ABI uses IEEE double extended for long double, if 128-bit    long double support is enabled.  These values are returned in memory.     int_size_in_bytes returns -1 for variable size objects, which go in    memory always.  The cast to unsigned makes -1> 8.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* In the darwin64 abi, try to use registers for larger structs      if possible.  */
if|if
condition|(
name|rs6000_darwin64_abi
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
block|{
name|CUMULATIVE_ARGS
name|valcum
decl_stmt|;
name|rtx
name|valret
decl_stmt|;
name|valcum
operator|.
name|words
operator|=
literal|0
expr_stmt|;
name|valcum
operator|.
name|fregno
operator|=
name|FP_ARG_MIN_REG
expr_stmt|;
name|valcum
operator|.
name|vregno
operator|=
name|ALTIVEC_ARG_MIN_REG
expr_stmt|;
comment|/* Do a trial code generation as if this were going to be passed 	 as an argument; if any part goes in memory, we return NULL.  */
name|valret
operator|=
name|rs6000_darwin64_record_arg
argument_list|(
operator|&
name|valcum
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|valret
condition|)
return|return
name|false
return|;
comment|/* Otherwise fall through to more conventional ABI rules.  */
block|}
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|aix_struct_return
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|)
condition|)
return|return
name|true
return|;
comment|/* Allow -maltivec -mabi=no-altivec without warning.  Altivec vector      modes only exist for GCC vector types if -maltivec.  */
if|if
condition|(
name|TARGET_32BIT
operator|&&
operator|!
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Return synthetic vectors in memory.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
operator|(
name|TARGET_ALTIVEC_ABI
condition|?
literal|16
else|:
literal|8
operator|)
condition|)
block|{
specifier|static
name|bool
name|warned_for_return_big_vectors
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|warned_for_return_big_vectors
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"GCC vector returned by reference: "
literal|"non-standard ABI extension with no compatibility guarantee"
argument_list|)
expr_stmt|;
name|warned_for_return_big_vectors
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|TARGET_IEEEQUAD
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.     For incoming args we set the number of arguments in the prototype large    so we never return a PARALLEL.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|tree
name|fntype
parameter_list|,
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|incoming
parameter_list|,
name|int
name|libcall
parameter_list|,
name|int
name|n_named_args
parameter_list|)
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cumulative
decl_stmt|;
operator|*
name|cum
operator|=
name|zero_cumulative
expr_stmt|;
name|cum
operator|->
name|words
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|fregno
operator|=
name|FP_ARG_MIN_REG
expr_stmt|;
name|cum
operator|->
name|vregno
operator|=
name|ALTIVEC_ARG_MIN_REG
expr_stmt|;
name|cum
operator|->
name|prototype
operator|=
operator|(
name|fntype
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
expr_stmt|;
name|cum
operator|->
name|call_cookie
operator|=
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|libcall
operator|)
condition|?
name|CALL_LIBCALL
else|:
name|CALL_NORMAL
operator|)
expr_stmt|;
name|cum
operator|->
name|sysv_gregno
operator|=
name|GP_ARG_MIN_REG
expr_stmt|;
name|cum
operator|->
name|stdarg
operator|=
name|fntype
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
expr_stmt|;
name|cum
operator|->
name|nargs_prototype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|incoming
operator|||
name|cum
operator|->
name|prototype
condition|)
name|cum
operator|->
name|nargs_prototype
operator|=
name|n_named_args
expr_stmt|;
comment|/* Check for a longcall attribute.  */
if|if
condition|(
operator|(
operator|!
name|fntype
operator|&&
name|rs6000_default_long_calls
operator|)
operator|||
operator|(
name|fntype
operator|&&
name|lookup_attribute
argument_list|(
literal|"longcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"shortcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|)
condition|)
name|cum
operator|->
name|call_cookie
operator||=
name|CALL_LONG
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" ret code = %s,"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cum
operator|->
name|call_cookie
operator|&
name|CALL_LONG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" longcall,"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" proto = %d, nargs = %d\n"
argument_list|,
name|cum
operator|->
name|prototype
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fntype
operator|&&
operator|!
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot return value in vector register because"
literal|" altivec instructions are disabled, use -maltivec"
literal|" to enable them"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if TYPE must be passed on the stack and not in registers.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_must_pass_in_stack
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|||
name|TARGET_64BIT
condition|)
return|return
name|must_pass_in_stack_var_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
else|else
return|return
name|must_pass_in_stack_var_size_or_pad
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If defined, a C expression which determines whether, and in which    direction, to pad out an argument with extra space.  The value    should be of type `enum direction': either `upward' to pad above    the argument, `downward' to pad below, or `none' to inhibit    padding.     For the AIX ABI structs are always stored left shifted in their    argument slot.  */
end_comment

begin_function
name|enum
name|direction
name|function_arg_padding
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|AGGREGATE_PADDING_FIXED
define|#
directive|define
name|AGGREGATE_PADDING_FIXED
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AGGREGATES_PAD_UPWARD_ALWAYS
define|#
directive|define
name|AGGREGATES_PAD_UPWARD_ALWAYS
value|0
endif|#
directive|endif
if|if
condition|(
operator|!
name|AGGREGATE_PADDING_FIXED
condition|)
block|{
comment|/* GCC used to pass structures of the same size as integer types as 	 if they were in fact integers, ignoring FUNCTION_ARG_PADDING. 	 i.e. Structures of size 1 or 2 (or 4 when TARGET_64BIT) were 	 passed padded downward, except that -mstrict-align further 	 muddied the water in that multi-component structures of 2 and 4 	 bytes in size were passed padded upward.  	 The following arranges for best compatibility with previous 	 versions of gcc, but removes the -mstrict-align dependency.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
operator|||
name|size
operator|==
literal|2
operator|||
name|size
operator|==
literal|4
condition|)
return|return
name|downward
return|;
block|}
return|return
name|upward
return|;
block|}
if|if
condition|(
name|AGGREGATES_PAD_UPWARD_ALWAYS
condition|)
block|{
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|upward
return|;
block|}
comment|/* Fall back to the default.  */
return|return
name|DEFAULT_FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If defined, a C expression that gives the alignment boundary, in bits,    of an argument with the specified mode and type.  If it is not defined,    PARM_BOUNDARY is used for all arguments.     V.4 wants long longs and doubles to be double word aligned.  Just    testing the mode size is a boneheaded way to do this as it means    that other types such as complex int are also double word aligned.    However, we're stuck with this because changing the ABI might break    existing library interfaces.     Doubleword align SPE vectors.    Quadword align Altivec vectors.    Quadword align large synthetic vector types.   */
end_comment

begin_function
name|int
name|function_arg_boundary
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
operator|||
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|mode
operator|==
name|TFmode
operator|)
operator|)
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>=
literal|8
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
literal|16
operator|)
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>=
literal|16
operator|)
condition|)
return|return
literal|128
return|;
elseif|else
if|if
condition|(
name|rs6000_darwin64_abi
operator|&&
name|mode
operator|==
name|BLKmode
operator|&&
name|type
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|64
condition|)
return|return
literal|128
return|;
else|else
return|return
name|PARM_BOUNDARY
return|;
block|}
end_function

begin_comment
comment|/* For a function parm of MODE and TYPE, return the starting word in    the parameter area.  NWORDS of the parameter area are already used.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rs6000_parm_start
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|unsigned
name|int
name|nwords
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
name|unsigned
name|int
name|parm_offset
decl_stmt|;
name|align
operator|=
name|function_arg_boundary
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|/
name|PARM_BOUNDARY
operator|-
literal|1
expr_stmt|;
name|parm_offset
operator|=
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|?
literal|2
else|:
literal|6
expr_stmt|;
return|return
name|nwords
operator|+
operator|(
operator|-
operator|(
name|parm_offset
operator|+
name|nwords
operator|)
operator|&
name|align
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the size (in words) of a function argument.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|rs6000_arg_size
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_32BIT
condition|)
return|return
operator|(
name|size
operator|+
literal|3
operator|)
operator|>>
literal|2
return|;
else|else
return|return
operator|(
name|size
operator|+
literal|7
operator|)
operator|>>
literal|3
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use this to flush pending int fields.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_darwin64_record_arg_advance_flush
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|HOST_WIDE_INT
name|bitpos
parameter_list|)
block|{
name|unsigned
name|int
name|startbit
decl_stmt|,
name|endbit
decl_stmt|;
name|int
name|intregs
decl_stmt|,
name|intoffset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
return|return;
name|intoffset
operator|=
name|cum
operator|->
name|intoffset
expr_stmt|;
name|cum
operator|->
name|intoffset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|intoffset
operator|%
name|BITS_PER_WORD
operator|!=
literal|0
condition|)
block|{
name|mode
operator|=
name|mode_for_size
argument_list|(
name|BITS_PER_WORD
operator|-
name|intoffset
operator|%
name|BITS_PER_WORD
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* We couldn't find an appropriate mode, which happens, 	     e.g., in packed structs when there are 3 bytes to load. 	     Back intoffset back to the beginning of the word in this 	     case.  */
name|intoffset
operator|=
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
block|}
block|}
name|startbit
operator|=
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|endbit
operator|=
operator|(
name|bitpos
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|intregs
operator|=
operator|(
name|endbit
operator|-
name|startbit
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|intregs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The darwin64 ABI calls for us to recurse down through structs,    looking for elements passed in registers.  Unfortunately, we have    to track int register count here also because of misalignments    in powerpc alignment mode.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_darwin64_record_arg_advance_recurse
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|tree
name|type
parameter_list|,
name|HOST_WIDE_INT
name|startbitpos
parameter_list|)
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|HOST_WIDE_INT
name|bitpos
init|=
name|startbitpos
decl_stmt|;
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|ftype
operator|==
name|error_mark_node
condition|)
continue|continue;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|f
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|bitpos
operator|+=
name|int_bit_position
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* ??? FIXME: else assume zero offset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|rs6000_darwin64_record_arg_advance_recurse
argument_list|(
name|cum
argument_list|,
name|ftype
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|USE_FP_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|ftype
argument_list|)
condition|)
block|{
name|rs6000_darwin64_record_arg_advance_flush
argument_list|(
name|cum
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
name|cum
operator|->
name|fregno
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|rs6000_darwin64_record_arg_advance_flush
argument_list|(
name|cum
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
name|cum
operator|->
name|vregno
operator|++
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cum
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
name|cum
operator|->
name|intoffset
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    (TYPE is null for libcalls where that information may not be available.)     Note that for args passed by reference, function_arg will be called    with MODE and TYPE set to that of the pointer to the arg, not the arg    itself.  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
comment|/* Only tick off an argument if we're not recursing.  */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|cum
operator|->
name|nargs_prototype
operator|--
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
operator|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|==
literal|16
operator|)
operator|)
condition|)
block|{
name|bool
name|stack
init|=
name|false
decl_stmt|;
if|if
condition|(
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
condition|)
block|{
name|cum
operator|->
name|vregno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC
condition|)
name|error
argument_list|(
literal|"cannot pass argument in vector register because"
literal|" altivec instructions are disabled, use -maltivec"
literal|" to enable them"
argument_list|)
expr_stmt|;
comment|/* PowerPC64 Linux and AIX allocate GPRs for a vector argument 	     even if it is going to be passed in a vector register. 	     Darwin does the same for variable-argument functions.  */
if|if
condition|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|TARGET_64BIT
operator|)
operator|||
operator|(
name|cum
operator|->
name|stdarg
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_V4
operator|)
condition|)
name|stack
operator|=
name|true
expr_stmt|;
block|}
else|else
name|stack
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|stack
condition|)
block|{
name|int
name|align
decl_stmt|;
comment|/* Vector parameters must be 16-byte aligned.  This places 	     them at 2 mod 4 in terms of words in 32-bit mode, since 	     the parameter save area starts at offset 24 from the 	     stack.  In 64-bit mode, they just have to start on an 	     even word, since the parameter save area is 16-byte 	     aligned.  Space for GPRs is reserved even if the argument 	     will be passed in memory.  */
if|if
condition|(
name|TARGET_32BIT
condition|)
name|align
operator|=
operator|(
literal|2
operator|-
name|cum
operator|->
name|words
operator|)
operator|&
literal|3
expr_stmt|;
else|else
name|align
operator|=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|align
operator|+
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, align=%d, "
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nargs = %4d, proto = %d, mode = %4s\n"
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|,
name|cum
operator|->
name|prototype
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|TARGET_SPE
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|cum
operator|->
name|stdarg
operator|&&
name|cum
operator|->
name|sysv_gregno
operator|<=
name|GP_ARG_MAX_REG
condition|)
name|cum
operator|->
name|sysv_gregno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|rs6000_darwin64_abi
operator|&&
name|mode
operator|==
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* Variable sized types have size == -1 and are 	 treated as if consisting entirely of ints. 	 Pad to 16 byte boundary if needed.  */
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
literal|2
operator|*
name|BITS_PER_WORD
operator|&&
operator|(
name|cum
operator|->
name|words
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
name|cum
operator|->
name|words
operator|++
expr_stmt|;
comment|/* For varargs, we can just go up by the size of the struct. */
if|if
condition|(
operator|!
name|named
condition|)
name|cum
operator|->
name|words
operator|+=
operator|(
name|size
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
else|else
block|{
comment|/* It is tempting to say int register count just goes up by 	     sizeof(type)/8, but this is wrong in a case such as 	     { int; double; int; } [powerpc alignment].  We have to 	     grovel through the fields for these too.  */
name|cum
operator|->
name|intoffset
operator|=
literal|0
expr_stmt|;
name|rs6000_darwin64_record_arg_advance_recurse
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rs6000_darwin64_record_arg_advance_flush
argument_list|(
name|cum
argument_list|,
name|size
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
operator|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
operator|||
operator|(
name|mode
operator|==
name|TFmode
operator|&&
operator|!
name|TARGET_IEEEQUAD
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fregno
operator|+
operator|(
name|mode
operator|==
name|TFmode
condition|?
literal|1
else|:
literal|0
operator|)
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
name|cum
operator|->
name|fregno
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
else|else
block|{
name|cum
operator|->
name|fregno
operator|=
name|FP_ARG_V4_MAX_REG
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|TFmode
condition|)
name|cum
operator|->
name|words
operator|+=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|gregno
init|=
name|cum
operator|->
name|sysv_gregno
decl_stmt|;
comment|/* Long long and SPE vectors are put in (r3,r4), (r5,r6), 	     (r7,r8) or (r9,r10).  As does any other 2 word item such 	     as complex int due to a historical mistake.  */
if|if
condition|(
name|n_words
operator|==
literal|2
condition|)
name|gregno
operator|+=
operator|(
literal|1
operator|-
name|gregno
operator|)
operator|&
literal|1
expr_stmt|;
comment|/* Multi-reg args are not split between registers and stack.  */
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|>
name|GP_ARG_MAX_REG
condition|)
block|{
comment|/* Long long and SPE vectors are aligned on the stack. 		 So are other 2 word items such as complex int due to 		 a historical mistake.  */
if|if
condition|(
name|n_words
operator|==
literal|2
condition|)
name|cum
operator|->
name|words
operator|+=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|n_words
expr_stmt|;
block|}
comment|/* Note: continuing to accumulate gregno past when we've started 	     spilling to the stack indicates the fact that we've started 	     spilling to the stack to expand_builtin_saveregs.  */
name|cum
operator|->
name|sysv_gregno
operator|=
name|gregno
operator|+
name|n_words
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, fregno = %2d, "
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gregno = %2d, nargs = %4d, proto = %d, "
argument_list|,
name|cum
operator|->
name|sysv_gregno
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|,
name|cum
operator|->
name|prototype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mode = %4s, named = %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|start_words
init|=
name|cum
operator|->
name|words
decl_stmt|;
name|int
name|align_words
init|=
name|rs6000_parm_start
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|start_words
argument_list|)
decl_stmt|;
name|cum
operator|->
name|words
operator|=
name|align_words
operator|+
name|n_words
expr_stmt|;
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
name|cum
operator|->
name|fregno
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv: words = %2d, fregno = %2d, "
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nargs = %4d, proto = %d, mode = %4s, "
argument_list|,
name|cum
operator|->
name|nargs_prototype
argument_list|,
name|cum
operator|->
name|prototype
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"named = %d, align = %d, depth = %d\n"
argument_list|,
name|named
argument_list|,
name|align_words
operator|-
name|start_words
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|rtx
name|spe_build_register_parallel
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|gregno
parameter_list|)
block|{
name|rtx
name|r1
decl_stmt|,
name|r3
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DFmode
case|:
name|r1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|gregno
argument_list|)
expr_stmt|;
name|r1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r1
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|r1
argument_list|)
argument_list|)
return|;
case|case
name|DCmode
case|:
name|r1
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|gregno
argument_list|)
expr_stmt|;
name|r1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r1
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|r3
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|gregno
operator|+
literal|2
argument_list|)
expr_stmt|;
name|r3
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r3
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|r1
argument_list|,
name|r3
argument_list|)
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine where to put a SIMD argument on the SPE.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_spe_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|gregno
init|=
name|cum
operator|->
name|sysv_gregno
decl_stmt|;
comment|/* On E500 v2, double arithmetic is done on the full 64-bit GPR, but      are passed and returned in a pair of GPRs for ABI compatibility.  */
if|if
condition|(
name|TARGET_E500_DOUBLE
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DCmode
operator|)
condition|)
block|{
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Doubles go in an odd/even register pair (r5/r6, etc).  */
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
name|gregno
operator|+=
operator|(
literal|1
operator|-
name|gregno
operator|)
operator|&
literal|1
expr_stmt|;
comment|/* Multi-reg args are not split between registers and stack.  */
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|>
name|GP_ARG_MAX_REG
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|spe_build_register_parallel
argument_list|(
name|mode
argument_list|,
name|gregno
argument_list|)
return|;
block|}
if|if
condition|(
name|cum
operator|->
name|stdarg
condition|)
block|{
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* SPE vectors are put in odd registers.  */
if|if
condition|(
name|n_words
operator|==
literal|2
operator|&&
operator|(
name|gregno
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|gregno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|<=
name|GP_ARG_MAX_REG
condition|)
block|{
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|enum
name|machine_mode
name|m
init|=
name|SImode
decl_stmt|;
name|r1
operator|=
name|gen_rtx_REG
argument_list|(
name|m
argument_list|,
name|gregno
argument_list|)
expr_stmt|;
name|r1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|m
argument_list|,
name|r1
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|r2
operator|=
name|gen_rtx_REG
argument_list|(
name|m
argument_list|,
name|gregno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|r2
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|m
argument_list|,
name|r2
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
else|else
block|{
if|if
condition|(
name|gregno
operator|<=
name|GP_ARG_MAX_REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|gregno
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of rs6000_darwin64_record_arg.  Assign the bits of the    structure between cum->intoffset and bitpos to integer registers.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_darwin64_record_arg_flush
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|HOST_WIDE_INT
name|bitpos
parameter_list|,
name|rtx
name|rvec
index|[]
parameter_list|,
name|int
modifier|*
name|k
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|startbit
decl_stmt|,
name|endbit
decl_stmt|;
name|int
name|this_regno
decl_stmt|,
name|intregs
decl_stmt|,
name|intoffset
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
return|return;
name|intoffset
operator|=
name|cum
operator|->
name|intoffset
expr_stmt|;
name|cum
operator|->
name|intoffset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If this is the trailing part of a word, try to only load that      much into the register.  Otherwise load the whole register.  Note      that in the latter case we may pick up unwanted bits.  It's not a      problem at the moment but may wish to revisit.  */
if|if
condition|(
name|intoffset
operator|%
name|BITS_PER_WORD
operator|!=
literal|0
condition|)
block|{
name|mode
operator|=
name|mode_for_size
argument_list|(
name|BITS_PER_WORD
operator|-
name|intoffset
operator|%
name|BITS_PER_WORD
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* We couldn't find an appropriate mode, which happens, 	     e.g., in packed structs when there are 3 bytes to load. 	     Back intoffset back to the beginning of the word in this 	     case.  */
name|intoffset
operator|=
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|mode
operator|=
name|word_mode
expr_stmt|;
block|}
block|}
else|else
name|mode
operator|=
name|word_mode
expr_stmt|;
name|startbit
operator|=
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|endbit
operator|=
operator|(
name|bitpos
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|intregs
operator|=
operator|(
name|endbit
operator|-
name|startbit
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_regno
operator|=
name|cum
operator|->
name|words
operator|+
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|intregs
operator|>
literal|0
operator|&&
name|intregs
operator|>
name|GP_ARG_NUM_REG
operator|-
name|this_regno
condition|)
name|cum
operator|->
name|use_stack
operator|=
literal|1
expr_stmt|;
name|intregs
operator|=
name|MIN
argument_list|(
name|intregs
argument_list|,
name|GP_ARG_NUM_REG
operator|-
name|this_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|intregs
operator|<=
literal|0
condition|)
return|return;
name|intoffset
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
do|do
block|{
name|regno
operator|=
name|GP_ARG_MIN_REG
operator|+
name|this_regno
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|rvec
index|[
operator|(
operator|*
name|k
operator|)
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|intoffset
argument_list|)
argument_list|)
expr_stmt|;
name|this_regno
operator|+=
literal|1
expr_stmt|;
name|intoffset
operator|=
operator|(
name|intoffset
operator||
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|=
name|word_mode
expr_stmt|;
name|intregs
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|intregs
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Recursive workhorse for the following.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_darwin64_record_arg_recurse
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|tree
name|type
parameter_list|,
name|HOST_WIDE_INT
name|startbitpos
parameter_list|,
name|rtx
name|rvec
index|[]
parameter_list|,
name|int
modifier|*
name|k
parameter_list|)
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|HOST_WIDE_INT
name|bitpos
init|=
name|startbitpos
decl_stmt|;
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|ftype
operator|==
name|error_mark_node
condition|)
continue|continue;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|f
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|bitpos
operator|+=
name|int_bit_position
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* ??? FIXME: else assume zero offset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|rs6000_darwin64_record_arg_recurse
argument_list|(
name|cum
argument_list|,
name|ftype
argument_list|,
name|bitpos
argument_list|,
name|rvec
argument_list|,
name|k
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cum
operator|->
name|named
operator|&&
name|USE_FP_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|ftype
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|switch (mode) 	      { 	      case SCmode: mode = SFmode; break; 	      case DCmode: mode = DFmode; break; 	      case TCmode: mode = TFmode; break; 	      default: break; 	      }
endif|#
directive|endif
name|rs6000_darwin64_record_arg_flush
argument_list|(
name|cum
argument_list|,
name|bitpos
argument_list|,
name|rvec
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|rvec
index|[
operator|(
operator|*
name|k
operator|)
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|fregno
operator|++
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
name|cum
operator|->
name|fregno
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cum
operator|->
name|named
operator|&&
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|ftype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|rs6000_darwin64_record_arg_flush
argument_list|(
name|cum
argument_list|,
name|bitpos
argument_list|,
name|rvec
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|rvec
index|[
operator|(
operator|*
name|k
operator|)
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|vregno
operator|++
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cum
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
name|cum
operator|->
name|intoffset
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For the darwin64 ABI, we want to construct a PARALLEL consisting of    the register(s) to be used for each field and subfield of a struct    being passed by value, along with the offset of where the    register's value may be found in the block.  FP fields go in FP    register, vector fields go in vector registers, and everything    else goes in int registers, packed as in memory.     This code is also used for function return values.  RETVAL indicates    whether this is the case.     Much of this is taken from the SPARC V9 port, which has a similar    calling convention.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_darwin64_record_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|orig_cum
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|,
name|bool
name|retval
parameter_list|)
block|{
name|rtx
name|rvec
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|int
name|k
init|=
literal|1
decl_stmt|,
name|kbase
init|=
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|typesize
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* This is a copy; modifications are not visible to our caller.  */
name|CUMULATIVE_ARGS
name|copy_cum
init|=
operator|*
name|orig_cum
decl_stmt|;
name|CUMULATIVE_ARGS
modifier|*
name|cum
init|=
operator|&
name|copy_cum
decl_stmt|;
comment|/* Pad to 16 byte boundary if needed.  */
if|if
condition|(
operator|!
name|retval
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
literal|2
operator|*
name|BITS_PER_WORD
operator|&&
operator|(
name|cum
operator|->
name|words
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
name|cum
operator|->
name|words
operator|++
expr_stmt|;
name|cum
operator|->
name|intoffset
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|use_stack
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|named
operator|=
name|named
expr_stmt|;
comment|/* Put entries into rvec[] for individual FP and vector fields, and      for the chunks of memory that go in int regs.  Note we start at      element 1; 0 is reserved for an indication of using memory, and      may or may not be filled in below. */
name|rs6000_darwin64_record_arg_recurse
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|rvec
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
name|rs6000_darwin64_record_arg_flush
argument_list|(
name|cum
argument_list|,
name|typesize
operator|*
name|BITS_PER_UNIT
argument_list|,
name|rvec
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
comment|/* If any part of the struct went on the stack put all of it there.      This hack is because the generic code for      FUNCTION_ARG_PARTIAL_NREGS cannot handle cases where the register      parts of the struct are not at the beginning.  */
if|if
condition|(
name|cum
operator|->
name|use_stack
condition|)
block|{
if|if
condition|(
name|retval
condition|)
return|return
name|NULL_RTX
return|;
comment|/* doesn't go in registers at all */
name|kbase
operator|=
literal|0
expr_stmt|;
name|rvec
index|[
literal|0
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>
literal|1
operator|||
name|cum
operator|->
name|use_stack
condition|)
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|k
operator|-
name|kbase
argument_list|,
operator|&
name|rvec
index|[
name|kbase
index|]
argument_list|)
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Determine where to place an argument in 64-bit mode with 32-bit ABI.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_mixed_function_arg
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|align_words
parameter_list|)
block|{
name|int
name|n_units
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|rtx
name|rvec
index|[
name|GP_ARG_NUM_REG
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|align_words
operator|>=
name|GP_ARG_NUM_REG
condition|)
return|return
name|NULL_RTX
return|;
name|n_units
operator|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Optimize the simple case where the arg fits in one gpr, except in      the case of BLKmode due to assign_parms assuming that registers are      BITS_PER_WORD wide.  */
if|if
condition|(
name|n_units
operator|==
literal|0
operator|||
operator|(
name|n_units
operator|==
literal|1
operator|&&
name|mode
operator|!=
name|BLKmode
operator|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
return|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|align_words
operator|+
name|n_units
operator|>
name|GP_ARG_NUM_REG
condition|)
comment|/* Not all of the arg fits in gprs.  Say that it goes in memory too,        using a magic NULL_RTX component.        This is not strictly correct.  Only some of the arg belongs in        memory, not all of it.  However, the normal scheme using        function_arg_partial_nregs can result in unusual subregs, eg.        (subreg:SI (reg:DF) 4), which are not handled well.  The code to        store the whole arg to memory is often more efficient than code        to store pieces, and we know that space is available in the right        place for the whole arg.  */
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|rtx
name|r
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
decl_stmt|;
name|rtx
name|off
init|=
name|GEN_INT
argument_list|(
name|i
operator|++
operator|*
literal|4
argument_list|)
decl_stmt|;
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|align_words
operator|<
name|GP_ARG_NUM_REG
operator|&&
operator|--
name|n_units
operator|!=
literal|0
condition|)
do|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|k
argument_list|,
name|rvec
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.  It is     not modified in this routine.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).     On RS/6000 the first eight words of non-FP are normally in registers    and the rest are pushed.  Under AIX, the first 13 FP args are in registers.    Under V.4, the first 8 FP args are in registers.     If this is floating-point and no prototype is specified, we use    both an FP and integer register (or possibly FP reg and stack).  Library    functions (when CALL_LIBCALL is set) always have the proper types for args,    so we can pass the FP value just in one register.  emit_library_function    doesn't support PARALLEL anyway.     Note that for args passed by reference, function_arg will be called    with MODE and TYPE set to that of the pointer to the arg, not the arg    itself.  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|enum
name|rs6000_abi
name|abi
init|=
name|DEFAULT_ABI
decl_stmt|;
comment|/* Return a marker to indicate whether CR1 needs to set or clear the      bit that V.4 uses to say fp args were passed in registers.      Assume that we don't need the marker for software floating point,      or compiler generated library calls.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|abi
operator|==
name|ABI_V4
operator|&&
operator|(
name|cum
operator|->
name|call_cookie
operator|&
name|CALL_LIBCALL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cum
operator|->
name|stdarg
operator|||
operator|(
name|cum
operator|->
name|nargs_prototype
operator|<
literal|0
operator|&&
operator|(
name|cum
operator|->
name|prototype
operator|||
name|TARGET_NO_PROTOTYPE
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* For the SPE, we need to crxor CR6 always.  */
if|if
condition|(
name|TARGET_SPE_ABI
condition|)
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|call_cookie
operator||
name|CALL_V4_SET_FP_ARGS
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|call_cookie
operator||
operator|(
operator|(
name|cum
operator|->
name|fregno
operator|==
name|FP_ARG_MIN_REG
operator|)
condition|?
name|CALL_V4_SET_FP_ARGS
else|:
name|CALL_V4_CLEAR_FP_ARGS
operator|)
argument_list|)
return|;
block|}
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|call_cookie
argument_list|)
return|;
block|}
if|if
condition|(
name|rs6000_darwin64_abi
operator|&&
name|mode
operator|==
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|rtx
name|rslt
init|=
name|rs6000_darwin64_record_arg
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|rslt
operator|!=
name|NULL_RTX
condition|)
return|return
name|rslt
return|;
comment|/* Else fall through to usual handling.  */
block|}
if|if
condition|(
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
condition|)
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|cum
operator|->
name|prototype
condition|)
block|{
comment|/* Vector parameters get passed in vector register 	   and also in GPRs or memory, in absence of prototype.  */
name|int
name|align_words
decl_stmt|;
name|rtx
name|slot
decl_stmt|;
name|align_words
operator|=
operator|(
name|cum
operator|->
name|words
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|align_words
operator|>=
name|GP_ARG_NUM_REG
condition|)
block|{
name|slot
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|vregno
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|vregno
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
operator|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|==
literal|16
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|named
operator|||
name|abi
operator|==
name|ABI_V4
condition|)
return|return
name|NULL_RTX
return|;
else|else
block|{
comment|/* Vector parameters to varargs functions under AIX or Darwin 	     get passed in memory and possibly also in GPRs.  */
name|int
name|align
decl_stmt|,
name|align_words
decl_stmt|,
name|n_words
decl_stmt|;
name|enum
name|machine_mode
name|part_mode
decl_stmt|;
comment|/* Vector parameters must be 16-byte aligned.  This places them at 	     2 mod 4 in terms of words in 32-bit mode, since the parameter 	     save area starts at offset 24 from the stack.  In 64-bit mode, 	     they just have to start on an even word, since the parameter 	     save area is 16-byte aligned.  */
if|if
condition|(
name|TARGET_32BIT
condition|)
name|align
operator|=
operator|(
literal|2
operator|-
name|cum
operator|->
name|words
operator|)
operator|&
literal|3
expr_stmt|;
else|else
name|align
operator|=
name|cum
operator|->
name|words
operator|&
literal|1
expr_stmt|;
name|align_words
operator|=
name|cum
operator|->
name|words
operator|+
name|align
expr_stmt|;
comment|/* Out of registers?  Memory, then.  */
if|if
condition|(
name|align_words
operator|>=
name|GP_ARG_NUM_REG
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
condition|)
return|return
name|rs6000_mixed_function_arg
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|align_words
argument_list|)
return|;
comment|/* The vector value goes in GPRs.  Only the part of the 	     value in GPRs is reported here.  */
name|part_mode
operator|=
name|mode
expr_stmt|;
name|n_words
operator|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_words
operator|+
name|n_words
operator|>
name|GP_ARG_NUM_REG
condition|)
comment|/* Fortunately, there are only two possibilities, the value 	       is either wholly in GPRs or half in GPRs and half not.  */
name|part_mode
operator|=
name|DImode
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|part_mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|TARGET_SPE
operator|&&
operator|(
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
name|TARGET_E500_DOUBLE
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DCmode
operator|)
operator|)
operator|)
condition|)
return|return
name|rs6000_spe_function_arg
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
return|;
elseif|else
if|if
condition|(
name|abi
operator|==
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
operator|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
operator|||
operator|(
name|mode
operator|==
name|TFmode
operator|&&
operator|!
name|TARGET_IEEEQUAD
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fregno
operator|+
operator|(
name|mode
operator|==
name|TFmode
condition|?
literal|1
else|:
literal|0
operator|)
operator|<=
name|FP_ARG_V4_MAX_REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
else|else
block|{
name|int
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|gregno
init|=
name|cum
operator|->
name|sysv_gregno
decl_stmt|;
comment|/* Long long and SPE vectors are put in (r3,r4), (r5,r6), 	     (r7,r8) or (r9,r10).  As does any other 2 word item such 	     as complex int due to a historical mistake.  */
if|if
condition|(
name|n_words
operator|==
literal|2
condition|)
name|gregno
operator|+=
operator|(
literal|1
operator|-
name|gregno
operator|)
operator|&
literal|1
expr_stmt|;
comment|/* Multi-reg args are not split between registers and stack.  */
if|if
condition|(
name|gregno
operator|+
name|n_words
operator|-
literal|1
operator|>
name|GP_ARG_MAX_REG
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
condition|)
return|return
name|rs6000_mixed_function_arg
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|gregno
operator|-
name|GP_ARG_MIN_REG
argument_list|)
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|gregno
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|int
name|align_words
init|=
name|rs6000_parm_start
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|cum
operator|->
name|words
argument_list|)
decl_stmt|;
if|if
condition|(
name|USE_FP_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|rtx
name|rvec
index|[
name|GP_ARG_NUM_REG
operator|+
literal|1
index|]
decl_stmt|;
name|rtx
name|r
decl_stmt|;
name|int
name|k
decl_stmt|;
name|bool
name|needs_psave
decl_stmt|;
name|enum
name|machine_mode
name|fmode
init|=
name|mode
decl_stmt|;
name|unsigned
name|long
name|n_fpreg
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|fregno
operator|+
name|n_fpreg
operator|>
name|FP_ARG_MAX_REG
operator|+
literal|1
condition|)
block|{
comment|/* Currently, we only ever need one reg here because complex 		 doubles are split.  */
name|gcc_assert
argument_list|(
name|cum
operator|->
name|fregno
operator|==
name|FP_ARG_MAX_REG
operator|&&
name|fmode
operator|==
name|TFmode
argument_list|)
expr_stmt|;
comment|/* Long double split over regs and memory.  */
name|fmode
operator|=
name|DFmode
expr_stmt|;
block|}
comment|/* Do we also need to pass this arg in the parameter save 	     area?  */
name|needs_psave
operator|=
operator|(
name|type
operator|&&
operator|(
name|cum
operator|->
name|nargs_prototype
operator|<=
literal|0
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|TARGET_XL_COMPAT
operator|&&
name|align_words
operator|>=
name|GP_ARG_NUM_REG
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_psave
operator|&&
name|mode
operator|==
name|fmode
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|fmode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
return|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needs_psave
condition|)
block|{
comment|/* Describe the part that goes in gprs or the stack. 		 This piece must come first, before the fprs.  */
if|if
condition|(
name|align_words
operator|<
name|GP_ARG_NUM_REG
condition|)
block|{
name|unsigned
name|long
name|n_words
init|=
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|align_words
operator|+
name|n_words
operator|>
name|GP_ARG_NUM_REG
operator|||
operator|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
operator|)
condition|)
block|{
comment|/* If this is partially on the stack, then we only 			 include the portion actually in registers here.  */
name|enum
name|machine_mode
name|rmode
init|=
name|TARGET_32BIT
condition|?
name|SImode
else|:
name|DImode
decl_stmt|;
name|rtx
name|off
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|align_words
operator|+
name|n_words
operator|>
name|GP_ARG_NUM_REG
condition|)
comment|/* Not all of the arg fits in gprs.  Say that it 			   goes in memory too, using a magic NULL_RTX 			   component.  Also see comment in 			   rs6000_mixed_function_arg for why the normal 			   function_arg_partial_nregs scheme doesn't work 			   in this case. */
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
do|do
block|{
name|r
operator|=
name|gen_rtx_REG
argument_list|(
name|rmode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
expr_stmt|;
name|off
operator|=
name|GEN_INT
argument_list|(
name|i
operator|++
operator|*
name|GET_MODE_SIZE
argument_list|(
name|rmode
argument_list|)
argument_list|)
expr_stmt|;
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|align_words
operator|<
name|GP_ARG_NUM_REG
operator|&&
operator|--
name|n_words
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* The whole arg fits in gprs.  */
name|r
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
expr_stmt|;
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* It's entirely in memory.  */
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Describe where this piece goes in the fprs.  */
name|r
operator|=
name|gen_rtx_REG
argument_list|(
name|fmode
argument_list|,
name|cum
operator|->
name|fregno
argument_list|)
expr_stmt|;
name|rvec
index|[
name|k
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|k
argument_list|,
name|rvec
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|align_words
operator|<
name|GP_ARG_NUM_REG
condition|)
block|{
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
condition|)
return|return
name|rs6000_mixed_function_arg
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|align_words
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|mode
operator|=
name|Pmode
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_MIN_REG
operator|+
name|align_words
argument_list|)
return|;
block|}
else|else
return|return
name|NULL_RTX
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For an arg passed partly in registers and partly in memory, this is    the number of bytes passed in registers.  For args passed entirely in    registers or entirely in memory, zero.  When an arg is described by a    PARALLEL, perhaps using more than one register type, this function    returns the number of bytes used by the first element of the PARALLEL.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|align_words
decl_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|USE_ALTIVEC_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|)
operator|&&
name|cum
operator|->
name|nargs_prototype
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* In this complicated case we just disable the partial_nregs code.  */
if|if
condition|(
name|rs6000_darwin64_abi
operator|&&
name|mode
operator|==
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|0
return|;
name|align_words
operator|=
name|rs6000_parm_start
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|cum
operator|->
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_FP_FOR_ARG_P
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
comment|/* If we are passing this arg in the fixed parameter save area 	 (gprs or memory) as well as fprs, then this function should 	 return the number of partial bytes passed in the parameter 	 save area rather than partial bytes passed in fprs.  */
if|if
condition|(
name|type
operator|&&
operator|(
name|cum
operator|->
name|nargs_prototype
operator|<=
literal|0
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|TARGET_XL_COMPAT
operator|&&
name|align_words
operator|>=
name|GP_ARG_NUM_REG
operator|)
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|cum
operator|->
name|fregno
operator|+
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|>
name|FP_ARG_MAX_REG
operator|+
literal|1
condition|)
name|ret
operator|=
operator|(
name|FP_ARG_MAX_REG
operator|+
literal|1
operator|-
name|cum
operator|->
name|fregno
operator|)
operator|*
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|cum
operator|->
name|nargs_prototype
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|align_words
operator|<
name|GP_ARG_NUM_REG
operator|&&
name|GP_ARG_NUM_REG
operator|<
name|align_words
operator|+
name|rs6000_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
name|ret
operator|=
operator|(
name|GP_ARG_NUM_REG
operator|-
name|align_words
operator|)
operator|*
operator|(
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rs6000_arg_partial_bytes: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C expression that indicates when an argument must be passed by    reference.  If nonzero for an argument, a copy of that argument is    made in memory and a pointer to the argument is passed instead of    the argument itself.  The pointer is passed in whatever way is    appropriate for passing a pointer to that type.     Under V.4, aggregates and long double are passed by reference.     As an extension to all 32-bit ABIs, AltiVec vectors are passed by    reference unless the AltiVec vector extension ABI is in force.     As an extension to all ABIs, variable sized types are passed by    reference.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|TARGET_IEEEQUAD
operator|&&
name|mode
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference: V4 long double\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|type
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference: V4 aggregate\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference: variable size\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Allow -maltivec -mabi=no-altivec without warning.  Altivec vector      modes only exist for GCC vector types if -maltivec.  */
if|if
condition|(
name|TARGET_32BIT
operator|&&
operator|!
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference: AltiVec\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Pass synthetic vectors in memory.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
operator|(
name|TARGET_ALTIVEC_ABI
condition|?
literal|16
else|:
literal|8
operator|)
condition|)
block|{
specifier|static
name|bool
name|warned_for_pass_big_vectors
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference: synthetic vector\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|warned_for_pass_big_vectors
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"GCC vector passed by reference: "
literal|"non-standard ABI extension with no compatibility guarantee"
argument_list|)
expr_stmt|;
name|warned_for_pass_big_vectors
operator|=
name|true
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_move_block_from_reg
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|nregs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|TARGET_32BIT
condition|?
name|SImode
else|:
name|DImode
decl_stmt|;
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|reg_mode
argument_list|,
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|reg_mode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_completed
condition|)
block|{
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|reg_mode
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|tem
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|tem
operator|=
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|x
argument_list|,
name|BLKmode
argument_list|,
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|reg_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|replace_equiv_address
argument_list|(
name|tem
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform any needed actions needed for a function that is receiving a    variable number of arguments.     CUM is as above.     MODE and TYPE are the mode and type of the current parameter.     PRETEND_SIZE is a variable that should be set to the amount of stack    that must be pushed by the prolog to pretend that our caller pushed    it.     Normally, this macro will push all remaining incoming registers on the    stack and set PRETEND_SIZE to the length of the registers pushed.  */
end_comment

begin_function
specifier|static
name|void
name|setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|pretend_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|no_rtl
parameter_list|)
block|{
name|CUMULATIVE_ARGS
name|next_cum
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|rtx
name|save_area
init|=
name|NULL_RTX
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|first_reg_offset
decl_stmt|,
name|set
decl_stmt|;
comment|/* Skip the last named argument.  */
name|next_cum
operator|=
operator|*
name|cum
expr_stmt|;
name|function_arg_advance
argument_list|(
operator|&
name|next_cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
name|first_reg_offset
operator|=
name|next_cum
operator|.
name|sysv_gregno
operator|-
name|GP_ARG_MIN_REG
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
condition|)
block|{
name|int
name|gpr_reg_num
init|=
literal|0
decl_stmt|,
name|gpr_size
init|=
literal|0
decl_stmt|,
name|fpr_size
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Try to optimize the size of the varargs save area. 	     The ABI requires that ap.reg_save_area is doubleword 	     aligned, but we don't need to allocate space for all 	     the bytes, only those to which we actually will save 	     anything.  */
if|if
condition|(
name|cfun
operator|->
name|va_list_gpr_size
operator|&&
name|first_reg_offset
operator|<
name|GP_ARG_NUM_REG
condition|)
name|gpr_reg_num
operator|=
name|GP_ARG_NUM_REG
operator|-
name|first_reg_offset
expr_stmt|;
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|next_cum
operator|.
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
operator|&&
name|cfun
operator|->
name|va_list_fpr_size
condition|)
block|{
if|if
condition|(
name|gpr_reg_num
condition|)
name|fpr_size
operator|=
operator|(
name|next_cum
operator|.
name|fregno
operator|-
name|FP_ARG_MIN_REG
operator|)
operator|*
name|UNITS_PER_FP_WORD
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|va_list_fpr_size
operator|<
name|FP_ARG_V4_MAX_REG
operator|+
literal|1
operator|-
name|next_cum
operator|.
name|fregno
condition|)
name|fpr_size
operator|+=
name|cfun
operator|->
name|va_list_fpr_size
operator|*
name|UNITS_PER_FP_WORD
expr_stmt|;
else|else
name|fpr_size
operator|+=
operator|(
name|FP_ARG_V4_MAX_REG
operator|+
literal|1
operator|-
name|next_cum
operator|.
name|fregno
operator|)
operator|*
name|UNITS_PER_FP_WORD
expr_stmt|;
block|}
if|if
condition|(
name|gpr_reg_num
condition|)
block|{
name|offset
operator|=
operator|-
operator|(
operator|(
name|first_reg_offset
operator|*
name|reg_size
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|fpr_size
operator|&&
name|gpr_reg_num
operator|>
name|cfun
operator|->
name|va_list_gpr_size
condition|)
block|{
name|gpr_reg_num
operator|=
name|cfun
operator|->
name|va_list_gpr_size
expr_stmt|;
if|if
condition|(
name|reg_size
operator|==
literal|4
operator|&&
operator|(
name|first_reg_offset
operator|&
literal|1
operator|)
condition|)
name|gpr_reg_num
operator|++
expr_stmt|;
block|}
name|gpr_size
operator|=
operator|(
name|gpr_reg_num
operator|*
name|reg_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fpr_size
condition|)
name|offset
operator|=
operator|-
call|(
name|int
call|)
argument_list|(
name|next_cum
operator|.
name|fregno
operator|-
name|FP_ARG_MIN_REG
argument_list|)
operator|*
name|UNITS_PER_FP_WORD
operator|-
call|(
name|int
call|)
argument_list|(
name|GP_ARG_NUM_REG
operator|*
name|reg_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpr_size
operator|+
name|fpr_size
condition|)
block|{
name|rtx
name|reg_save_area
init|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|gpr_size
operator|+
name|fpr_size
argument_list|,
literal|64
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|reg_save_area
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
name|reg_save_area
operator|=
name|XEXP
argument_list|(
name|reg_save_area
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg_save_area
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|gcc_assert
argument_list|(
name|XEXP
argument_list|(
name|reg_save_area
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg_save_area
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|reg_save_area
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
name|reg_save_area
operator|==
name|virtual_stack_vars_rtx
argument_list|)
expr_stmt|;
block|}
name|cfun
operator|->
name|machine
operator|->
name|varargs_save_offset
operator|=
name|offset
expr_stmt|;
name|save_area
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|first_reg_offset
operator|=
name|next_cum
operator|.
name|words
expr_stmt|;
name|save_area
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|must_pass_in_stack
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
name|first_reg_offset
operator|+=
name|rs6000_arg_size
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
operator|&&
name|first_reg_offset
operator|<
name|GP_ARG_NUM_REG
operator|&&
name|cfun
operator|->
name|va_list_gpr_size
condition|)
block|{
name|int
name|nregs
init|=
name|GP_ARG_NUM_REG
operator|-
name|first_reg_offset
decl_stmt|;
if|if
condition|(
name|va_list_gpr_counter_field
condition|)
block|{
comment|/* V4 va_list_gpr_size counts number of registers needed.  */
if|if
condition|(
name|nregs
operator|>
name|cfun
operator|->
name|va_list_gpr_size
condition|)
name|nregs
operator|=
name|cfun
operator|->
name|va_list_gpr_size
expr_stmt|;
block|}
else|else
block|{
comment|/* char * va_list instead counts number of bytes needed.  */
if|if
condition|(
name|nregs
operator|>
name|cfun
operator|->
name|va_list_gpr_size
operator|/
name|reg_size
condition|)
name|nregs
operator|=
name|cfun
operator|->
name|va_list_gpr_size
operator|/
name|reg_size
expr_stmt|;
block|}
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|first_reg_offset
operator|*
name|reg_size
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|rs6000_move_block_from_reg
argument_list|(
name|GP_ARG_MIN_REG
operator|+
name|first_reg_offset
argument_list|,
name|mem
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* Save FP registers if needed.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
operator|!
name|no_rtl
operator|&&
name|next_cum
operator|.
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
operator|&&
name|cfun
operator|->
name|va_list_fpr_size
condition|)
block|{
name|int
name|fregno
init|=
name|next_cum
operator|.
name|fregno
decl_stmt|,
name|nregs
decl_stmt|;
name|rtx
name|cr1
init|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR1_REGNO
argument_list|)
decl_stmt|;
name|rtx
name|lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|int
name|off
init|=
operator|(
name|GP_ARG_NUM_REG
operator|*
name|reg_size
operator|)
operator|+
operator|(
operator|(
name|fregno
operator|-
name|FP_ARG_MIN_REG
operator|)
operator|*
name|UNITS_PER_FP_WORD
operator|)
decl_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cr1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|nregs
operator|=
literal|0
init|;
name|fregno
operator|<=
name|FP_ARG_V4_MAX_REG
operator|&&
name|nregs
operator|<
name|cfun
operator|->
name|va_list_fpr_size
condition|;
name|fregno
operator|++
operator|,
name|off
operator|+=
name|UNITS_PER_FP_WORD
operator|,
name|nregs
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|fregno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the va_list data type.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_res
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
comment|/* For AIX, prefer 'char *' because that's what the system      header files like.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
name|record
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"gpr"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"fpr"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* Give the two bytes of padding a name, so that -Wpadded won't warn on      every user file.  */
name|f_res
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"reserved"
argument_list|)
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|va_list_gpr_counter_field
operator|=
name|f_gpr
expr_stmt|;
name|va_list_fpr_counter_field
operator|=
name|f_fpr
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_res
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_res
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_res
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement va_start.  */
end_comment

begin_function
name|void
name|rs6000_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
parameter_list|)
block|{
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_res
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
comment|/* Only SVR4 needs something special.  */
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
block|{
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_res
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_res
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|words
operator|=
name|current_function_args_info
operator|.
name|words
expr_stmt|;
name|n_gpr
operator|=
name|MIN
argument_list|(
name|current_function_args_info
operator|.
name|sysv_gregno
operator|-
name|GP_ARG_MIN_REG
argument_list|,
name|GP_ARG_NUM_REG
argument_list|)
expr_stmt|;
name|n_fpr
operator|=
name|MIN
argument_list|(
name|current_function_args_info
operator|.
name|fregno
operator|-
name|FP_ARG_MIN_REG
argument_list|,
name|FP_ARG_NUM_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: words = "
name|HOST_WIDE_INT_PRINT_DEC
literal|", n_gpr = "
name|HOST_WIDE_INT_PRINT_DEC
literal|", n_fpr = "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|words
argument_list|,
name|n_gpr
argument_list|,
name|n_fpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|va_list_gpr_size
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|n_gpr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|va_list_fpr_size
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|n_fpr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* Find the overflow area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|!=
literal|0
condition|)
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|words
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If there were no va_arg invocations, don't set up the register      save area.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|va_list_gpr_size
operator|&&
operator|!
name|cfun
operator|->
name|va_list_fpr_size
operator|&&
name|n_gpr
operator|<
name|GP_ARG_NUM_REG
operator|&&
name|n_fpr
operator|<
name|FP_ARG_V4_MAX_REG
condition|)
return|return;
comment|/* Find the register save area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|virtual_stack_vars_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|varargs_save_offset
condition|)
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|varargs_save_offset
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|tree
name|rs6000_gimplify_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_res
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|reg
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|;
name|int
name|size
decl_stmt|,
name|rsize
decl_stmt|,
name|n_reg
decl_stmt|,
name|sav_ofs
decl_stmt|,
name|sav_scale
decl_stmt|;
name|tree
name|lab_false
decl_stmt|,
name|lab_over
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|align
decl_stmt|;
name|tree
name|ptrtype
init|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|pass_by_reference
argument_list|(
name|NULL
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|t
operator|=
name|rs6000_gimplify_va_arg
argument_list|(
name|valist
argument_list|,
name|ptrtype
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
return|return
name|build_va_arg_indirect_ref
argument_list|(
name|t
argument_list|)
return|;
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|elem_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|elem_mode
init|=
name|TYPE_MODE
argument_list|(
name|elem_type
argument_list|)
decl_stmt|;
name|int
name|elem_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|elem_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|elem_size
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|tree
name|real_part
decl_stmt|,
name|imag_part
decl_stmt|;
name|tree
name|post
init|=
name|NULL_TREE
decl_stmt|;
name|real_part
operator|=
name|rs6000_gimplify_va_arg
argument_list|(
name|valist
argument_list|,
name|elem_type
argument_list|,
name|pre_p
argument_list|,
operator|&
name|post
argument_list|)
expr_stmt|;
comment|/* Copy the value into a temporary, lest the formal temporary 		 be reused out from under us.  */
name|real_part
operator|=
name|get_initialized_tmp_var
argument_list|(
name|real_part
argument_list|,
name|pre_p
argument_list|,
operator|&
name|post
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|post
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|imag_part
operator|=
name|rs6000_gimplify_va_arg
argument_list|(
name|valist
argument_list|,
name|elem_type
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|real_part
argument_list|,
name|imag_part
argument_list|)
return|;
block|}
block|}
return|return
name|std_gimplify_va_arg_expr
argument_list|(
name|valist
argument_list|,
name|type
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
return|;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_res
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_res
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rsize
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|align
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
operator|)
condition|)
block|{
comment|/* FP args go in FP registers, if present.  */
name|reg
operator|=
name|fpr
expr_stmt|;
name|n_reg
operator|=
operator|(
name|size
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|sav_ofs
operator|=
literal|8
operator|*
literal|4
expr_stmt|;
name|sav_scale
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|SFmode
condition|)
name|align
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise into GP registers.  */
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
name|rsize
expr_stmt|;
name|sav_ofs
operator|=
literal|0
expr_stmt|;
name|sav_scale
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|n_reg
operator|==
literal|2
condition|)
name|align
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Pull the value out of the saved registers....  */
name|lab_over
operator|=
name|NULL
expr_stmt|;
name|addr
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|addr
argument_list|)
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
comment|/*  AltiVec vectors never go in registers when -mabi=altivec.  */
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|align
operator|=
literal|16
expr_stmt|;
else|else
block|{
name|lab_false
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|lab_over
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
comment|/* Long long and SPE vectors are aligned in the registers. 	 As are any other 2 gpr item such as complex int due to a 	 historical mistake.  */
name|u
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|n_reg
operator|==
literal|2
operator|&&
name|reg
operator|==
name|gpr
condition|)
block|{
name|u
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|size_int
argument_list|(
name|n_reg
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build2
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|size_int
argument_list|(
literal|8
operator|-
name|n_reg
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|u
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|u
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|sav
expr_stmt|;
if|if
condition|(
name|sav_ofs
condition|)
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|size_int
argument_list|(
name|sav_ofs
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build2
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|size_int
argument_list|(
name|n_reg
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|u
argument_list|,
name|size_int
argument_list|(
name|sav_scale
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_over
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_reg
operator|==
literal|2
operator|&&
name|reg
operator|!=
name|gpr
operator|)
operator|||
name|n_reg
operator|>
literal|2
condition|)
block|{
comment|/* Ensure that we don't find any more args in regs. 	     Alignment has taken care of the n_reg == 2 gpr case.  */
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|size_int
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ... otherwise out of the overflow area.  */
comment|/* Care for on-stack alignment if needed.  */
name|t
operator|=
name|ovf
expr_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|size_int
argument_list|(
name|align
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
name|align
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimplify_expr
argument_list|(
operator|&
name|t
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|u
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|u
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|size_int
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lab_over
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_over
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|BITS_PER_UNIT
operator|*
operator|(
name|align
operator|<
literal|4
condition|?
literal|4
else|:
name|align
operator|)
operator|)
condition|)
block|{
comment|/* The value (of type complex double, for example) may not be 	 aligned in memory in the saved registers, so copy via a 	 temporary.  (This is the same code as used for SPARC.)  */
name|tree
name|tmp
init|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"va_arg_tmp"
argument_list|)
decl_stmt|;
name|tree
name|dest_addr
init|=
name|build_fold_addr_expr
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|tree
name|copy
init|=
name|build_function_call_expr
argument_list|(
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest_addr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_int
argument_list|(
name|rsize
operator|*
literal|4
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|gimplify_and_add
argument_list|(
name|copy
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|addr
operator|=
name|dest_addr
expr_stmt|;
block|}
name|addr
operator|=
name|fold_convert
argument_list|(
name|ptrtype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Builtins.  */
end_comment

begin_function
specifier|static
name|void
name|def_builtin
parameter_list|(
name|int
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|mask
operator|&
name|target_flags
condition|)
block|{
if|if
condition|(
name|rs6000_builtin_decls
index|[
name|code
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rs6000_builtin_decls
index|[
name|code
index|]
operator|=
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Simple ternary operations: VECd = foo (VECa, VECb, VECc).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_3arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmaddfp
block|,
literal|"__builtin_altivec_vmaddfp"
block|,
name|ALTIVEC_BUILTIN_VMADDFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmhaddshs
block|,
literal|"__builtin_altivec_vmhaddshs"
block|,
name|ALTIVEC_BUILTIN_VMHADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmhraddshs
block|,
literal|"__builtin_altivec_vmhraddshs"
block|,
name|ALTIVEC_BUILTIN_VMHRADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmladduhm
block|,
literal|"__builtin_altivec_vmladduhm"
block|,
name|ALTIVEC_BUILTIN_VMLADDUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumubm
block|,
literal|"__builtin_altivec_vmsumubm"
block|,
name|ALTIVEC_BUILTIN_VMSUMUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsummbm
block|,
literal|"__builtin_altivec_vmsummbm"
block|,
name|ALTIVEC_BUILTIN_VMSUMMBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumuhm
block|,
literal|"__builtin_altivec_vmsumuhm"
block|,
name|ALTIVEC_BUILTIN_VMSUMUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumshm
block|,
literal|"__builtin_altivec_vmsumshm"
block|,
name|ALTIVEC_BUILTIN_VMSUMSHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumuhs
block|,
literal|"__builtin_altivec_vmsumuhs"
block|,
name|ALTIVEC_BUILTIN_VMSUMUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmsumshs
block|,
literal|"__builtin_altivec_vmsumshs"
block|,
name|ALTIVEC_BUILTIN_VMSUMSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vnmsubfp
block|,
literal|"__builtin_altivec_vnmsubfp"
block|,
name|ALTIVEC_BUILTIN_VNMSUBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_v4sf
block|,
literal|"__builtin_altivec_vperm_4sf"
block|,
name|ALTIVEC_BUILTIN_VPERM_4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_v4si
block|,
literal|"__builtin_altivec_vperm_4si"
block|,
name|ALTIVEC_BUILTIN_VPERM_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_v8hi
block|,
literal|"__builtin_altivec_vperm_8hi"
block|,
name|ALTIVEC_BUILTIN_VPERM_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vperm_v16qi
block|,
literal|"__builtin_altivec_vperm_16qi"
block|,
name|ALTIVEC_BUILTIN_VPERM_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_v4sf
block|,
literal|"__builtin_altivec_vsel_4sf"
block|,
name|ALTIVEC_BUILTIN_VSEL_4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_v4si
block|,
literal|"__builtin_altivec_vsel_4si"
block|,
name|ALTIVEC_BUILTIN_VSEL_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_v8hi
block|,
literal|"__builtin_altivec_vsel_8hi"
block|,
name|ALTIVEC_BUILTIN_VSEL_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsel_v16qi
block|,
literal|"__builtin_altivec_vsel_16qi"
block|,
name|ALTIVEC_BUILTIN_VSEL_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_v16qi
block|,
literal|"__builtin_altivec_vsldoi_16qi"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_v8hi
block|,
literal|"__builtin_altivec_vsldoi_8hi"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_v4si
block|,
literal|"__builtin_altivec_vsldoi_4si"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsldoi_v4sf
block|,
literal|"__builtin_altivec_vsldoi_4sf"
block|,
name|ALTIVEC_BUILTIN_VSLDOI_4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_madd"
block|,
name|ALTIVEC_BUILTIN_VEC_MADD
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_madds"
block|,
name|ALTIVEC_BUILTIN_VEC_MADDS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_mladd"
block|,
name|ALTIVEC_BUILTIN_VEC_MLADD
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_mradds"
block|,
name|ALTIVEC_BUILTIN_VEC_MRADDS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_msum"
block|,
name|ALTIVEC_BUILTIN_VEC_MSUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmsumshm"
block|,
name|ALTIVEC_BUILTIN_VEC_VMSUMSHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmsumuhm"
block|,
name|ALTIVEC_BUILTIN_VEC_VMSUMUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmsummbm"
block|,
name|ALTIVEC_BUILTIN_VEC_VMSUMMBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmsumubm"
block|,
name|ALTIVEC_BUILTIN_VEC_VMSUMUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_msums"
block|,
name|ALTIVEC_BUILTIN_VEC_MSUMS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmsumshs"
block|,
name|ALTIVEC_BUILTIN_VEC_VMSUMSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmsumuhs"
block|,
name|ALTIVEC_BUILTIN_VEC_VMSUMUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_nmsub"
block|,
name|ALTIVEC_BUILTIN_VEC_NMSUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_perm"
block|,
name|ALTIVEC_BUILTIN_VEC_PERM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sel"
block|,
name|ALTIVEC_BUILTIN_VEC_SEL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DST operations: void foo (void *, const int, const char).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_dst
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dst
block|,
literal|"__builtin_altivec_dst"
block|,
name|ALTIVEC_BUILTIN_DST
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dstt
block|,
literal|"__builtin_altivec_dstt"
block|,
name|ALTIVEC_BUILTIN_DSTT
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dstst
block|,
literal|"__builtin_altivec_dstst"
block|,
name|ALTIVEC_BUILTIN_DSTST
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_dststt
block|,
literal|"__builtin_altivec_dststt"
block|,
name|ALTIVEC_BUILTIN_DSTSTT
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_dst"
block|,
name|ALTIVEC_BUILTIN_VEC_DST
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_dstt"
block|,
name|ALTIVEC_BUILTIN_VEC_DSTT
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_dstst"
block|,
name|ALTIVEC_BUILTIN_VEC_DSTST
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_dststt"
block|,
name|ALTIVEC_BUILTIN_VEC_DSTSTT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple binary operations: VECc = foo (VECa, VECb).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv16qi3
block|,
literal|"__builtin_altivec_vaddubm"
block|,
name|ALTIVEC_BUILTIN_VADDUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv8hi3
block|,
literal|"__builtin_altivec_vadduhm"
block|,
name|ALTIVEC_BUILTIN_VADDUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv4si3
block|,
literal|"__builtin_altivec_vadduwm"
block|,
name|ALTIVEC_BUILTIN_VADDUWM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_addv4sf3
block|,
literal|"__builtin_altivec_vaddfp"
block|,
name|ALTIVEC_BUILTIN_VADDFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddcuw
block|,
literal|"__builtin_altivec_vaddcuw"
block|,
name|ALTIVEC_BUILTIN_VADDCUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddubs
block|,
literal|"__builtin_altivec_vaddubs"
block|,
name|ALTIVEC_BUILTIN_VADDUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddsbs
block|,
literal|"__builtin_altivec_vaddsbs"
block|,
name|ALTIVEC_BUILTIN_VADDSBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vadduhs
block|,
literal|"__builtin_altivec_vadduhs"
block|,
name|ALTIVEC_BUILTIN_VADDUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddshs
block|,
literal|"__builtin_altivec_vaddshs"
block|,
name|ALTIVEC_BUILTIN_VADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vadduws
block|,
literal|"__builtin_altivec_vadduws"
block|,
name|ALTIVEC_BUILTIN_VADDUWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vaddsws
block|,
literal|"__builtin_altivec_vaddsws"
block|,
name|ALTIVEC_BUILTIN_VADDSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_andv4si3
block|,
literal|"__builtin_altivec_vand"
block|,
name|ALTIVEC_BUILTIN_VAND
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_andcv4si3
block|,
literal|"__builtin_altivec_vandc"
block|,
name|ALTIVEC_BUILTIN_VANDC
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgub
block|,
literal|"__builtin_altivec_vavgub"
block|,
name|ALTIVEC_BUILTIN_VAVGUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsb
block|,
literal|"__builtin_altivec_vavgsb"
block|,
name|ALTIVEC_BUILTIN_VAVGSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavguh
block|,
literal|"__builtin_altivec_vavguh"
block|,
name|ALTIVEC_BUILTIN_VAVGUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsh
block|,
literal|"__builtin_altivec_vavgsh"
block|,
name|ALTIVEC_BUILTIN_VAVGSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavguw
block|,
literal|"__builtin_altivec_vavguw"
block|,
name|ALTIVEC_BUILTIN_VAVGUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vavgsw
block|,
literal|"__builtin_altivec_vavgsw"
block|,
name|ALTIVEC_BUILTIN_VAVGSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcfux
block|,
literal|"__builtin_altivec_vcfux"
block|,
name|ALTIVEC_BUILTIN_VCFUX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcfsx
block|,
literal|"__builtin_altivec_vcfsx"
block|,
name|ALTIVEC_BUILTIN_VCFSX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpbfp
block|,
literal|"__builtin_altivec_vcmpbfp"
block|,
name|ALTIVEC_BUILTIN_VCMPBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequb
block|,
literal|"__builtin_altivec_vcmpequb"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequh
block|,
literal|"__builtin_altivec_vcmpequh"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpequw
block|,
literal|"__builtin_altivec_vcmpequw"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpeqfp
block|,
literal|"__builtin_altivec_vcmpeqfp"
block|,
name|ALTIVEC_BUILTIN_VCMPEQFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgefp
block|,
literal|"__builtin_altivec_vcmpgefp"
block|,
name|ALTIVEC_BUILTIN_VCMPGEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtub
block|,
literal|"__builtin_altivec_vcmpgtub"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsb
block|,
literal|"__builtin_altivec_vcmpgtsb"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtuh
block|,
literal|"__builtin_altivec_vcmpgtuh"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsh
block|,
literal|"__builtin_altivec_vcmpgtsh"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtuw
block|,
literal|"__builtin_altivec_vcmpgtuw"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtsw
block|,
literal|"__builtin_altivec_vcmpgtsw"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vcmpgtfp
block|,
literal|"__builtin_altivec_vcmpgtfp"
block|,
name|ALTIVEC_BUILTIN_VCMPGTFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vctsxs
block|,
literal|"__builtin_altivec_vctsxs"
block|,
name|ALTIVEC_BUILTIN_VCTSXS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vctuxs
block|,
literal|"__builtin_altivec_vctuxs"
block|,
name|ALTIVEC_BUILTIN_VCTUXS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_umaxv16qi3
block|,
literal|"__builtin_altivec_vmaxub"
block|,
name|ALTIVEC_BUILTIN_VMAXUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv16qi3
block|,
literal|"__builtin_altivec_vmaxsb"
block|,
name|ALTIVEC_BUILTIN_VMAXSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_umaxv8hi3
block|,
literal|"__builtin_altivec_vmaxuh"
block|,
name|ALTIVEC_BUILTIN_VMAXUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv8hi3
block|,
literal|"__builtin_altivec_vmaxsh"
block|,
name|ALTIVEC_BUILTIN_VMAXSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_umaxv4si3
block|,
literal|"__builtin_altivec_vmaxuw"
block|,
name|ALTIVEC_BUILTIN_VMAXUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv4si3
block|,
literal|"__builtin_altivec_vmaxsw"
block|,
name|ALTIVEC_BUILTIN_VMAXSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_smaxv4sf3
block|,
literal|"__builtin_altivec_vmaxfp"
block|,
name|ALTIVEC_BUILTIN_VMAXFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghb
block|,
literal|"__builtin_altivec_vmrghb"
block|,
name|ALTIVEC_BUILTIN_VMRGHB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghh
block|,
literal|"__builtin_altivec_vmrghh"
block|,
name|ALTIVEC_BUILTIN_VMRGHH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrghw
block|,
literal|"__builtin_altivec_vmrghw"
block|,
name|ALTIVEC_BUILTIN_VMRGHW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglb
block|,
literal|"__builtin_altivec_vmrglb"
block|,
name|ALTIVEC_BUILTIN_VMRGLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglh
block|,
literal|"__builtin_altivec_vmrglh"
block|,
name|ALTIVEC_BUILTIN_VMRGLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmrglw
block|,
literal|"__builtin_altivec_vmrglw"
block|,
name|ALTIVEC_BUILTIN_VMRGLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv16qi3
block|,
literal|"__builtin_altivec_vminub"
block|,
name|ALTIVEC_BUILTIN_VMINUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv16qi3
block|,
literal|"__builtin_altivec_vminsb"
block|,
name|ALTIVEC_BUILTIN_VMINSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv8hi3
block|,
literal|"__builtin_altivec_vminuh"
block|,
name|ALTIVEC_BUILTIN_VMINUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv8hi3
block|,
literal|"__builtin_altivec_vminsh"
block|,
name|ALTIVEC_BUILTIN_VMINSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_uminv4si3
block|,
literal|"__builtin_altivec_vminuw"
block|,
name|ALTIVEC_BUILTIN_VMINUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv4si3
block|,
literal|"__builtin_altivec_vminsw"
block|,
name|ALTIVEC_BUILTIN_VMINSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_sminv4sf3
block|,
literal|"__builtin_altivec_vminfp"
block|,
name|ALTIVEC_BUILTIN_VMINFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuleub
block|,
literal|"__builtin_altivec_vmuleub"
block|,
name|ALTIVEC_BUILTIN_VMULEUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulesb
block|,
literal|"__builtin_altivec_vmulesb"
block|,
name|ALTIVEC_BUILTIN_VMULESB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuleuh
block|,
literal|"__builtin_altivec_vmuleuh"
block|,
name|ALTIVEC_BUILTIN_VMULEUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulesh
block|,
literal|"__builtin_altivec_vmulesh"
block|,
name|ALTIVEC_BUILTIN_VMULESH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmuloub
block|,
literal|"__builtin_altivec_vmuloub"
block|,
name|ALTIVEC_BUILTIN_VMULOUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulosb
block|,
literal|"__builtin_altivec_vmulosb"
block|,
name|ALTIVEC_BUILTIN_VMULOSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulouh
block|,
literal|"__builtin_altivec_vmulouh"
block|,
name|ALTIVEC_BUILTIN_VMULOUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vmulosh
block|,
literal|"__builtin_altivec_vmulosh"
block|,
name|ALTIVEC_BUILTIN_VMULOSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_norv4si3
block|,
literal|"__builtin_altivec_vnor"
block|,
name|ALTIVEC_BUILTIN_VNOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_iorv4si3
block|,
literal|"__builtin_altivec_vor"
block|,
name|ALTIVEC_BUILTIN_VOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuhum
block|,
literal|"__builtin_altivec_vpkuhum"
block|,
name|ALTIVEC_BUILTIN_VPKUHUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuwum
block|,
literal|"__builtin_altivec_vpkuwum"
block|,
name|ALTIVEC_BUILTIN_VPKUWUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkpx
block|,
literal|"__builtin_altivec_vpkpx"
block|,
name|ALTIVEC_BUILTIN_VPKPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkshss
block|,
literal|"__builtin_altivec_vpkshss"
block|,
name|ALTIVEC_BUILTIN_VPKSHSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkswss
block|,
literal|"__builtin_altivec_vpkswss"
block|,
name|ALTIVEC_BUILTIN_VPKSWSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuhus
block|,
literal|"__builtin_altivec_vpkuhus"
block|,
name|ALTIVEC_BUILTIN_VPKUHUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkshus
block|,
literal|"__builtin_altivec_vpkshus"
block|,
name|ALTIVEC_BUILTIN_VPKSHUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkuwus
block|,
literal|"__builtin_altivec_vpkuwus"
block|,
name|ALTIVEC_BUILTIN_VPKUWUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vpkswus
block|,
literal|"__builtin_altivec_vpkswus"
block|,
name|ALTIVEC_BUILTIN_VPKSWUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlb
block|,
literal|"__builtin_altivec_vrlb"
block|,
name|ALTIVEC_BUILTIN_VRLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlh
block|,
literal|"__builtin_altivec_vrlh"
block|,
name|ALTIVEC_BUILTIN_VRLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrlw
block|,
literal|"__builtin_altivec_vrlw"
block|,
name|ALTIVEC_BUILTIN_VRLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslb
block|,
literal|"__builtin_altivec_vslb"
block|,
name|ALTIVEC_BUILTIN_VSLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslh
block|,
literal|"__builtin_altivec_vslh"
block|,
name|ALTIVEC_BUILTIN_VSLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslw
block|,
literal|"__builtin_altivec_vslw"
block|,
name|ALTIVEC_BUILTIN_VSLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsl
block|,
literal|"__builtin_altivec_vsl"
block|,
name|ALTIVEC_BUILTIN_VSL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vslo
block|,
literal|"__builtin_altivec_vslo"
block|,
name|ALTIVEC_BUILTIN_VSLO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltb
block|,
literal|"__builtin_altivec_vspltb"
block|,
name|ALTIVEC_BUILTIN_VSPLTB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsplth
block|,
literal|"__builtin_altivec_vsplth"
block|,
name|ALTIVEC_BUILTIN_VSPLTH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltw
block|,
literal|"__builtin_altivec_vspltw"
block|,
name|ALTIVEC_BUILTIN_VSPLTW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_lshrv16qi3
block|,
literal|"__builtin_altivec_vsrb"
block|,
name|ALTIVEC_BUILTIN_VSRB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_lshrv8hi3
block|,
literal|"__builtin_altivec_vsrh"
block|,
name|ALTIVEC_BUILTIN_VSRH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_lshrv4si3
block|,
literal|"__builtin_altivec_vsrw"
block|,
name|ALTIVEC_BUILTIN_VSRW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_ashrv16qi3
block|,
literal|"__builtin_altivec_vsrab"
block|,
name|ALTIVEC_BUILTIN_VSRAB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_ashrv8hi3
block|,
literal|"__builtin_altivec_vsrah"
block|,
name|ALTIVEC_BUILTIN_VSRAH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_ashrv4si3
block|,
literal|"__builtin_altivec_vsraw"
block|,
name|ALTIVEC_BUILTIN_VSRAW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsr
block|,
literal|"__builtin_altivec_vsr"
block|,
name|ALTIVEC_BUILTIN_VSR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsro
block|,
literal|"__builtin_altivec_vsro"
block|,
name|ALTIVEC_BUILTIN_VSRO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv16qi3
block|,
literal|"__builtin_altivec_vsububm"
block|,
name|ALTIVEC_BUILTIN_VSUBUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv8hi3
block|,
literal|"__builtin_altivec_vsubuhm"
block|,
name|ALTIVEC_BUILTIN_VSUBUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv4si3
block|,
literal|"__builtin_altivec_vsubuwm"
block|,
name|ALTIVEC_BUILTIN_VSUBUWM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_subv4sf3
block|,
literal|"__builtin_altivec_vsubfp"
block|,
name|ALTIVEC_BUILTIN_VSUBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubcuw
block|,
literal|"__builtin_altivec_vsubcuw"
block|,
name|ALTIVEC_BUILTIN_VSUBCUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsububs
block|,
literal|"__builtin_altivec_vsububs"
block|,
name|ALTIVEC_BUILTIN_VSUBUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubsbs
block|,
literal|"__builtin_altivec_vsubsbs"
block|,
name|ALTIVEC_BUILTIN_VSUBSBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubuhs
block|,
literal|"__builtin_altivec_vsubuhs"
block|,
name|ALTIVEC_BUILTIN_VSUBUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubshs
block|,
literal|"__builtin_altivec_vsubshs"
block|,
name|ALTIVEC_BUILTIN_VSUBSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubuws
block|,
literal|"__builtin_altivec_vsubuws"
block|,
name|ALTIVEC_BUILTIN_VSUBUWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsubsws
block|,
literal|"__builtin_altivec_vsubsws"
block|,
name|ALTIVEC_BUILTIN_VSUBSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4ubs
block|,
literal|"__builtin_altivec_vsum4ubs"
block|,
name|ALTIVEC_BUILTIN_VSUM4UBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4sbs
block|,
literal|"__builtin_altivec_vsum4sbs"
block|,
name|ALTIVEC_BUILTIN_VSUM4SBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum4shs
block|,
literal|"__builtin_altivec_vsum4shs"
block|,
name|ALTIVEC_BUILTIN_VSUM4SHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsum2sws
block|,
literal|"__builtin_altivec_vsum2sws"
block|,
name|ALTIVEC_BUILTIN_VSUM2SWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vsumsws
block|,
literal|"__builtin_altivec_vsumsws"
block|,
name|ALTIVEC_BUILTIN_VSUMSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_xorv4si3
block|,
literal|"__builtin_altivec_vxor"
block|,
name|ALTIVEC_BUILTIN_VXOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_add"
block|,
name|ALTIVEC_BUILTIN_VEC_ADD
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vaddfp"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vadduwm"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDUWM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vadduhm"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vaddubm"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_addc"
block|,
name|ALTIVEC_BUILTIN_VEC_ADDC
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_adds"
block|,
name|ALTIVEC_BUILTIN_VEC_ADDS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vaddsws"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vadduws"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDUWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vaddshs"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vadduhs"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vaddsbs"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDSBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vaddubs"
block|,
name|ALTIVEC_BUILTIN_VEC_VADDUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_and"
block|,
name|ALTIVEC_BUILTIN_VEC_AND
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_andc"
block|,
name|ALTIVEC_BUILTIN_VEC_ANDC
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_avg"
block|,
name|ALTIVEC_BUILTIN_VEC_AVG
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vavgsw"
block|,
name|ALTIVEC_BUILTIN_VEC_VAVGSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vavguw"
block|,
name|ALTIVEC_BUILTIN_VEC_VAVGUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vavgsh"
block|,
name|ALTIVEC_BUILTIN_VEC_VAVGSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vavguh"
block|,
name|ALTIVEC_BUILTIN_VEC_VAVGUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vavgsb"
block|,
name|ALTIVEC_BUILTIN_VEC_VAVGSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vavgub"
block|,
name|ALTIVEC_BUILTIN_VEC_VAVGUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_cmpb"
block|,
name|ALTIVEC_BUILTIN_VEC_CMPB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_cmpeq"
block|,
name|ALTIVEC_BUILTIN_VEC_CMPEQ
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpeqfp"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPEQFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpequw"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPEQUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpequh"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPEQUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpequb"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPEQUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_cmpge"
block|,
name|ALTIVEC_BUILTIN_VEC_CMPGE
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_cmpgt"
block|,
name|ALTIVEC_BUILTIN_VEC_CMPGT
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpgtfp"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPGTFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpgtsw"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPGTSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpgtuw"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPGTUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpgtsh"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPGTSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpgtuh"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPGTUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpgtsb"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPGTSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vcmpgtub"
block|,
name|ALTIVEC_BUILTIN_VEC_VCMPGTUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_cmple"
block|,
name|ALTIVEC_BUILTIN_VEC_CMPLE
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_cmplt"
block|,
name|ALTIVEC_BUILTIN_VEC_CMPLT
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_max"
block|,
name|ALTIVEC_BUILTIN_VEC_MAX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmaxfp"
block|,
name|ALTIVEC_BUILTIN_VEC_VMAXFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmaxsw"
block|,
name|ALTIVEC_BUILTIN_VEC_VMAXSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmaxuw"
block|,
name|ALTIVEC_BUILTIN_VEC_VMAXUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmaxsh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMAXSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmaxuh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMAXUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmaxsb"
block|,
name|ALTIVEC_BUILTIN_VEC_VMAXSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmaxub"
block|,
name|ALTIVEC_BUILTIN_VEC_VMAXUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_mergeh"
block|,
name|ALTIVEC_BUILTIN_VEC_MERGEH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmrghw"
block|,
name|ALTIVEC_BUILTIN_VEC_VMRGHW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmrghh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMRGHH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmrghb"
block|,
name|ALTIVEC_BUILTIN_VEC_VMRGHB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_mergel"
block|,
name|ALTIVEC_BUILTIN_VEC_MERGEL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmrglw"
block|,
name|ALTIVEC_BUILTIN_VEC_VMRGLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmrglh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMRGLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmrglb"
block|,
name|ALTIVEC_BUILTIN_VEC_VMRGLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_min"
block|,
name|ALTIVEC_BUILTIN_VEC_MIN
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vminfp"
block|,
name|ALTIVEC_BUILTIN_VEC_VMINFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vminsw"
block|,
name|ALTIVEC_BUILTIN_VEC_VMINSW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vminuw"
block|,
name|ALTIVEC_BUILTIN_VEC_VMINUW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vminsh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMINSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vminuh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMINUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vminsb"
block|,
name|ALTIVEC_BUILTIN_VEC_VMINSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vminub"
block|,
name|ALTIVEC_BUILTIN_VEC_VMINUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_mule"
block|,
name|ALTIVEC_BUILTIN_VEC_MULE
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmuleub"
block|,
name|ALTIVEC_BUILTIN_VEC_VMULEUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmulesb"
block|,
name|ALTIVEC_BUILTIN_VEC_VMULESB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmuleuh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMULEUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmulesh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMULESH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_mulo"
block|,
name|ALTIVEC_BUILTIN_VEC_MULO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmulosh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMULOSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmulouh"
block|,
name|ALTIVEC_BUILTIN_VEC_VMULOUH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmulosb"
block|,
name|ALTIVEC_BUILTIN_VEC_VMULOSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vmuloub"
block|,
name|ALTIVEC_BUILTIN_VEC_VMULOUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_nor"
block|,
name|ALTIVEC_BUILTIN_VEC_NOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_or"
block|,
name|ALTIVEC_BUILTIN_VEC_OR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_pack"
block|,
name|ALTIVEC_BUILTIN_VEC_PACK
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vpkuwum"
block|,
name|ALTIVEC_BUILTIN_VEC_VPKUWUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vpkuhum"
block|,
name|ALTIVEC_BUILTIN_VEC_VPKUHUM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_packpx"
block|,
name|ALTIVEC_BUILTIN_VEC_PACKPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_packs"
block|,
name|ALTIVEC_BUILTIN_VEC_PACKS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vpkswss"
block|,
name|ALTIVEC_BUILTIN_VEC_VPKSWSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vpkuwus"
block|,
name|ALTIVEC_BUILTIN_VEC_VPKUWUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vpkshss"
block|,
name|ALTIVEC_BUILTIN_VEC_VPKSHSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vpkuhus"
block|,
name|ALTIVEC_BUILTIN_VEC_VPKUHUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_packsu"
block|,
name|ALTIVEC_BUILTIN_VEC_PACKSU
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vpkswus"
block|,
name|ALTIVEC_BUILTIN_VEC_VPKSWUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vpkshus"
block|,
name|ALTIVEC_BUILTIN_VEC_VPKSHUS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_rl"
block|,
name|ALTIVEC_BUILTIN_VEC_RL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vrlw"
block|,
name|ALTIVEC_BUILTIN_VEC_VRLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vrlh"
block|,
name|ALTIVEC_BUILTIN_VEC_VRLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vrlb"
block|,
name|ALTIVEC_BUILTIN_VEC_VRLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sl"
block|,
name|ALTIVEC_BUILTIN_VEC_SL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vslw"
block|,
name|ALTIVEC_BUILTIN_VEC_VSLW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vslh"
block|,
name|ALTIVEC_BUILTIN_VEC_VSLH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vslb"
block|,
name|ALTIVEC_BUILTIN_VEC_VSLB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sll"
block|,
name|ALTIVEC_BUILTIN_VEC_SLL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_slo"
block|,
name|ALTIVEC_BUILTIN_VEC_SLO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sr"
block|,
name|ALTIVEC_BUILTIN_VEC_SR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsrw"
block|,
name|ALTIVEC_BUILTIN_VEC_VSRW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsrh"
block|,
name|ALTIVEC_BUILTIN_VEC_VSRH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsrb"
block|,
name|ALTIVEC_BUILTIN_VEC_VSRB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sra"
block|,
name|ALTIVEC_BUILTIN_VEC_SRA
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsraw"
block|,
name|ALTIVEC_BUILTIN_VEC_VSRAW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsrah"
block|,
name|ALTIVEC_BUILTIN_VEC_VSRAH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsrab"
block|,
name|ALTIVEC_BUILTIN_VEC_VSRAB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_srl"
block|,
name|ALTIVEC_BUILTIN_VEC_SRL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sro"
block|,
name|ALTIVEC_BUILTIN_VEC_SRO
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sub"
block|,
name|ALTIVEC_BUILTIN_VEC_SUB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsubfp"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsubuwm"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBUWM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsubuhm"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBUHM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsububm"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBUBM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_subc"
block|,
name|ALTIVEC_BUILTIN_VEC_SUBC
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_subs"
block|,
name|ALTIVEC_BUILTIN_VEC_SUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsubsws"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBSWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsubuws"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBUWS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsubshs"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBSHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsubuhs"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBUHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsubsbs"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBSBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsububs"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUBUBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sum4s"
block|,
name|ALTIVEC_BUILTIN_VEC_SUM4S
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsum4shs"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUM4SHS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsum4sbs"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUM4SBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vsum4ubs"
block|,
name|ALTIVEC_BUILTIN_VEC_VSUM4UBS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sum2s"
block|,
name|ALTIVEC_BUILTIN_VEC_SUM2S
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_sums"
block|,
name|ALTIVEC_BUILTIN_VEC_SUMS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_xor"
block|,
name|ALTIVEC_BUILTIN_VEC_XOR
block|}
block|,
comment|/* Place holder, leave as first spe builtin.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddw
block|,
literal|"__builtin_spe_evaddw"
block|,
name|SPE_BUILTIN_EVADDW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evand
block|,
literal|"__builtin_spe_evand"
block|,
name|SPE_BUILTIN_EVAND
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evandc
block|,
literal|"__builtin_spe_evandc"
block|,
name|SPE_BUILTIN_EVANDC
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evdivws
block|,
literal|"__builtin_spe_evdivws"
block|,
name|SPE_BUILTIN_EVDIVWS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evdivwu
block|,
literal|"__builtin_spe_evdivwu"
block|,
name|SPE_BUILTIN_EVDIVWU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_eveqv
block|,
literal|"__builtin_spe_eveqv"
block|,
name|SPE_BUILTIN_EVEQV
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsadd
block|,
literal|"__builtin_spe_evfsadd"
block|,
name|SPE_BUILTIN_EVFSADD
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsdiv
block|,
literal|"__builtin_spe_evfsdiv"
block|,
name|SPE_BUILTIN_EVFSDIV
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsmul
block|,
literal|"__builtin_spe_evfsmul"
block|,
name|SPE_BUILTIN_EVFSMUL
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfssub
block|,
literal|"__builtin_spe_evfssub"
block|,
name|SPE_BUILTIN_EVFSSUB
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmergehi
block|,
literal|"__builtin_spe_evmergehi"
block|,
name|SPE_BUILTIN_EVMERGEHI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmergehilo
block|,
literal|"__builtin_spe_evmergehilo"
block|,
name|SPE_BUILTIN_EVMERGEHILO
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmergelo
block|,
literal|"__builtin_spe_evmergelo"
block|,
name|SPE_BUILTIN_EVMERGELO
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmergelohi
block|,
literal|"__builtin_spe_evmergelohi"
block|,
name|SPE_BUILTIN_EVMERGELOHI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegsmfaa
block|,
literal|"__builtin_spe_evmhegsmfaa"
block|,
name|SPE_BUILTIN_EVMHEGSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegsmfan
block|,
literal|"__builtin_spe_evmhegsmfan"
block|,
name|SPE_BUILTIN_EVMHEGSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegsmiaa
block|,
literal|"__builtin_spe_evmhegsmiaa"
block|,
name|SPE_BUILTIN_EVMHEGSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegsmian
block|,
literal|"__builtin_spe_evmhegsmian"
block|,
name|SPE_BUILTIN_EVMHEGSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegumiaa
block|,
literal|"__builtin_spe_evmhegumiaa"
block|,
name|SPE_BUILTIN_EVMHEGUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhegumian
block|,
literal|"__builtin_spe_evmhegumian"
block|,
name|SPE_BUILTIN_EVMHEGUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmf
block|,
literal|"__builtin_spe_evmhesmf"
block|,
name|SPE_BUILTIN_EVMHESMF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmfa
block|,
literal|"__builtin_spe_evmhesmfa"
block|,
name|SPE_BUILTIN_EVMHESMFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmfaaw
block|,
literal|"__builtin_spe_evmhesmfaaw"
block|,
name|SPE_BUILTIN_EVMHESMFAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmfanw
block|,
literal|"__builtin_spe_evmhesmfanw"
block|,
name|SPE_BUILTIN_EVMHESMFANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmi
block|,
literal|"__builtin_spe_evmhesmi"
block|,
name|SPE_BUILTIN_EVMHESMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmia
block|,
literal|"__builtin_spe_evmhesmia"
block|,
name|SPE_BUILTIN_EVMHESMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmiaaw
block|,
literal|"__builtin_spe_evmhesmiaaw"
block|,
name|SPE_BUILTIN_EVMHESMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhesmianw
block|,
literal|"__builtin_spe_evmhesmianw"
block|,
name|SPE_BUILTIN_EVMHESMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessf
block|,
literal|"__builtin_spe_evmhessf"
block|,
name|SPE_BUILTIN_EVMHESSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessfa
block|,
literal|"__builtin_spe_evmhessfa"
block|,
name|SPE_BUILTIN_EVMHESSFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessfaaw
block|,
literal|"__builtin_spe_evmhessfaaw"
block|,
name|SPE_BUILTIN_EVMHESSFAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessfanw
block|,
literal|"__builtin_spe_evmhessfanw"
block|,
name|SPE_BUILTIN_EVMHESSFANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessiaaw
block|,
literal|"__builtin_spe_evmhessiaaw"
block|,
name|SPE_BUILTIN_EVMHESSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhessianw
block|,
literal|"__builtin_spe_evmhessianw"
block|,
name|SPE_BUILTIN_EVMHESSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheumi
block|,
literal|"__builtin_spe_evmheumi"
block|,
name|SPE_BUILTIN_EVMHEUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheumia
block|,
literal|"__builtin_spe_evmheumia"
block|,
name|SPE_BUILTIN_EVMHEUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheumiaaw
block|,
literal|"__builtin_spe_evmheumiaaw"
block|,
name|SPE_BUILTIN_EVMHEUMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheumianw
block|,
literal|"__builtin_spe_evmheumianw"
block|,
name|SPE_BUILTIN_EVMHEUMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheusiaaw
block|,
literal|"__builtin_spe_evmheusiaaw"
block|,
name|SPE_BUILTIN_EVMHEUSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmheusianw
block|,
literal|"__builtin_spe_evmheusianw"
block|,
name|SPE_BUILTIN_EVMHEUSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogsmfaa
block|,
literal|"__builtin_spe_evmhogsmfaa"
block|,
name|SPE_BUILTIN_EVMHOGSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogsmfan
block|,
literal|"__builtin_spe_evmhogsmfan"
block|,
name|SPE_BUILTIN_EVMHOGSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogsmiaa
block|,
literal|"__builtin_spe_evmhogsmiaa"
block|,
name|SPE_BUILTIN_EVMHOGSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogsmian
block|,
literal|"__builtin_spe_evmhogsmian"
block|,
name|SPE_BUILTIN_EVMHOGSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogumiaa
block|,
literal|"__builtin_spe_evmhogumiaa"
block|,
name|SPE_BUILTIN_EVMHOGUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhogumian
block|,
literal|"__builtin_spe_evmhogumian"
block|,
name|SPE_BUILTIN_EVMHOGUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmf
block|,
literal|"__builtin_spe_evmhosmf"
block|,
name|SPE_BUILTIN_EVMHOSMF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmfa
block|,
literal|"__builtin_spe_evmhosmfa"
block|,
name|SPE_BUILTIN_EVMHOSMFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmfaaw
block|,
literal|"__builtin_spe_evmhosmfaaw"
block|,
name|SPE_BUILTIN_EVMHOSMFAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmfanw
block|,
literal|"__builtin_spe_evmhosmfanw"
block|,
name|SPE_BUILTIN_EVMHOSMFANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmi
block|,
literal|"__builtin_spe_evmhosmi"
block|,
name|SPE_BUILTIN_EVMHOSMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmia
block|,
literal|"__builtin_spe_evmhosmia"
block|,
name|SPE_BUILTIN_EVMHOSMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmiaaw
block|,
literal|"__builtin_spe_evmhosmiaaw"
block|,
name|SPE_BUILTIN_EVMHOSMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhosmianw
block|,
literal|"__builtin_spe_evmhosmianw"
block|,
name|SPE_BUILTIN_EVMHOSMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossf
block|,
literal|"__builtin_spe_evmhossf"
block|,
name|SPE_BUILTIN_EVMHOSSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossfa
block|,
literal|"__builtin_spe_evmhossfa"
block|,
name|SPE_BUILTIN_EVMHOSSFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossfaaw
block|,
literal|"__builtin_spe_evmhossfaaw"
block|,
name|SPE_BUILTIN_EVMHOSSFAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossfanw
block|,
literal|"__builtin_spe_evmhossfanw"
block|,
name|SPE_BUILTIN_EVMHOSSFANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossiaaw
block|,
literal|"__builtin_spe_evmhossiaaw"
block|,
name|SPE_BUILTIN_EVMHOSSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhossianw
block|,
literal|"__builtin_spe_evmhossianw"
block|,
name|SPE_BUILTIN_EVMHOSSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhoumi
block|,
literal|"__builtin_spe_evmhoumi"
block|,
name|SPE_BUILTIN_EVMHOUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhoumia
block|,
literal|"__builtin_spe_evmhoumia"
block|,
name|SPE_BUILTIN_EVMHOUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhoumiaaw
block|,
literal|"__builtin_spe_evmhoumiaaw"
block|,
name|SPE_BUILTIN_EVMHOUMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhoumianw
block|,
literal|"__builtin_spe_evmhoumianw"
block|,
name|SPE_BUILTIN_EVMHOUMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhousiaaw
block|,
literal|"__builtin_spe_evmhousiaaw"
block|,
name|SPE_BUILTIN_EVMHOUSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmhousianw
block|,
literal|"__builtin_spe_evmhousianw"
block|,
name|SPE_BUILTIN_EVMHOUSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmf
block|,
literal|"__builtin_spe_evmwhsmf"
block|,
name|SPE_BUILTIN_EVMWHSMF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmfa
block|,
literal|"__builtin_spe_evmwhsmfa"
block|,
name|SPE_BUILTIN_EVMWHSMFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmi
block|,
literal|"__builtin_spe_evmwhsmi"
block|,
name|SPE_BUILTIN_EVMWHSMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmia
block|,
literal|"__builtin_spe_evmwhsmia"
block|,
name|SPE_BUILTIN_EVMWHSMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssf
block|,
literal|"__builtin_spe_evmwhssf"
block|,
name|SPE_BUILTIN_EVMWHSSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssfa
block|,
literal|"__builtin_spe_evmwhssfa"
block|,
name|SPE_BUILTIN_EVMWHSSFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhumi
block|,
literal|"__builtin_spe_evmwhumi"
block|,
name|SPE_BUILTIN_EVMWHUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhumia
block|,
literal|"__builtin_spe_evmwhumia"
block|,
name|SPE_BUILTIN_EVMWHUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlsmiaaw
block|,
literal|"__builtin_spe_evmwlsmiaaw"
block|,
name|SPE_BUILTIN_EVMWLSMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlsmianw
block|,
literal|"__builtin_spe_evmwlsmianw"
block|,
name|SPE_BUILTIN_EVMWLSMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlssiaaw
block|,
literal|"__builtin_spe_evmwlssiaaw"
block|,
name|SPE_BUILTIN_EVMWLSSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlssianw
block|,
literal|"__builtin_spe_evmwlssianw"
block|,
name|SPE_BUILTIN_EVMWLSSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlumi
block|,
literal|"__builtin_spe_evmwlumi"
block|,
name|SPE_BUILTIN_EVMWLUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlumia
block|,
literal|"__builtin_spe_evmwlumia"
block|,
name|SPE_BUILTIN_EVMWLUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlumiaaw
block|,
literal|"__builtin_spe_evmwlumiaaw"
block|,
name|SPE_BUILTIN_EVMWLUMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlumianw
block|,
literal|"__builtin_spe_evmwlumianw"
block|,
name|SPE_BUILTIN_EVMWLUMIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlusiaaw
block|,
literal|"__builtin_spe_evmwlusiaaw"
block|,
name|SPE_BUILTIN_EVMWLUSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwlusianw
block|,
literal|"__builtin_spe_evmwlusianw"
block|,
name|SPE_BUILTIN_EVMWLUSIANW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmf
block|,
literal|"__builtin_spe_evmwsmf"
block|,
name|SPE_BUILTIN_EVMWSMF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmfa
block|,
literal|"__builtin_spe_evmwsmfa"
block|,
name|SPE_BUILTIN_EVMWSMFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmfaa
block|,
literal|"__builtin_spe_evmwsmfaa"
block|,
name|SPE_BUILTIN_EVMWSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmfan
block|,
literal|"__builtin_spe_evmwsmfan"
block|,
name|SPE_BUILTIN_EVMWSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmi
block|,
literal|"__builtin_spe_evmwsmi"
block|,
name|SPE_BUILTIN_EVMWSMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmia
block|,
literal|"__builtin_spe_evmwsmia"
block|,
name|SPE_BUILTIN_EVMWSMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmiaa
block|,
literal|"__builtin_spe_evmwsmiaa"
block|,
name|SPE_BUILTIN_EVMWSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwsmian
block|,
literal|"__builtin_spe_evmwsmian"
block|,
name|SPE_BUILTIN_EVMWSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwssf
block|,
literal|"__builtin_spe_evmwssf"
block|,
name|SPE_BUILTIN_EVMWSSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwssfa
block|,
literal|"__builtin_spe_evmwssfa"
block|,
name|SPE_BUILTIN_EVMWSSFA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwssfaa
block|,
literal|"__builtin_spe_evmwssfaa"
block|,
name|SPE_BUILTIN_EVMWSSFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwssfan
block|,
literal|"__builtin_spe_evmwssfan"
block|,
name|SPE_BUILTIN_EVMWSSFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwumi
block|,
literal|"__builtin_spe_evmwumi"
block|,
name|SPE_BUILTIN_EVMWUMI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwumia
block|,
literal|"__builtin_spe_evmwumia"
block|,
name|SPE_BUILTIN_EVMWUMIA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwumiaa
block|,
literal|"__builtin_spe_evmwumiaa"
block|,
name|SPE_BUILTIN_EVMWUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwumian
block|,
literal|"__builtin_spe_evmwumian"
block|,
name|SPE_BUILTIN_EVMWUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evnand
block|,
literal|"__builtin_spe_evnand"
block|,
name|SPE_BUILTIN_EVNAND
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evnor
block|,
literal|"__builtin_spe_evnor"
block|,
name|SPE_BUILTIN_EVNOR
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evor
block|,
literal|"__builtin_spe_evor"
block|,
name|SPE_BUILTIN_EVOR
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evorc
block|,
literal|"__builtin_spe_evorc"
block|,
name|SPE_BUILTIN_EVORC
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evrlw
block|,
literal|"__builtin_spe_evrlw"
block|,
name|SPE_BUILTIN_EVRLW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evslw
block|,
literal|"__builtin_spe_evslw"
block|,
name|SPE_BUILTIN_EVSLW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsrws
block|,
literal|"__builtin_spe_evsrws"
block|,
name|SPE_BUILTIN_EVSRWS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsrwu
block|,
literal|"__builtin_spe_evsrwu"
block|,
name|SPE_BUILTIN_EVSRWU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfw
block|,
literal|"__builtin_spe_evsubfw"
block|,
name|SPE_BUILTIN_EVSUBFW
block|}
block|,
comment|/* SPE binary operations expecting a 5-bit unsigned literal.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddiw
block|,
literal|"__builtin_spe_evaddiw"
block|,
name|SPE_BUILTIN_EVADDIW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evrlwi
block|,
literal|"__builtin_spe_evrlwi"
block|,
name|SPE_BUILTIN_EVRLWI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evslwi
block|,
literal|"__builtin_spe_evslwi"
block|,
name|SPE_BUILTIN_EVSLWI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsrwis
block|,
literal|"__builtin_spe_evsrwis"
block|,
name|SPE_BUILTIN_EVSRWIS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsrwiu
block|,
literal|"__builtin_spe_evsrwiu"
block|,
name|SPE_BUILTIN_EVSRWIU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubifw
block|,
literal|"__builtin_spe_evsubifw"
block|,
name|SPE_BUILTIN_EVSUBIFW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssfaa
block|,
literal|"__builtin_spe_evmwhssfaa"
block|,
name|SPE_BUILTIN_EVMWHSSFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssmaa
block|,
literal|"__builtin_spe_evmwhssmaa"
block|,
name|SPE_BUILTIN_EVMWHSSMAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmfaa
block|,
literal|"__builtin_spe_evmwhsmfaa"
block|,
name|SPE_BUILTIN_EVMWHSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmiaa
block|,
literal|"__builtin_spe_evmwhsmiaa"
block|,
name|SPE_BUILTIN_EVMWHSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhusiaa
block|,
literal|"__builtin_spe_evmwhusiaa"
block|,
name|SPE_BUILTIN_EVMWHUSIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhumiaa
block|,
literal|"__builtin_spe_evmwhumiaa"
block|,
name|SPE_BUILTIN_EVMWHUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssfan
block|,
literal|"__builtin_spe_evmwhssfan"
block|,
name|SPE_BUILTIN_EVMWHSSFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhssian
block|,
literal|"__builtin_spe_evmwhssian"
block|,
name|SPE_BUILTIN_EVMWHSSIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmfan
block|,
literal|"__builtin_spe_evmwhsmfan"
block|,
name|SPE_BUILTIN_EVMWHSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhsmian
block|,
literal|"__builtin_spe_evmwhsmian"
block|,
name|SPE_BUILTIN_EVMWHSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhusian
block|,
literal|"__builtin_spe_evmwhusian"
block|,
name|SPE_BUILTIN_EVMWHUSIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhumian
block|,
literal|"__builtin_spe_evmwhumian"
block|,
name|SPE_BUILTIN_EVMWHUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgssfaa
block|,
literal|"__builtin_spe_evmwhgssfaa"
block|,
name|SPE_BUILTIN_EVMWHGSSFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgsmfaa
block|,
literal|"__builtin_spe_evmwhgsmfaa"
block|,
name|SPE_BUILTIN_EVMWHGSMFAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgsmiaa
block|,
literal|"__builtin_spe_evmwhgsmiaa"
block|,
name|SPE_BUILTIN_EVMWHGSMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgumiaa
block|,
literal|"__builtin_spe_evmwhgumiaa"
block|,
name|SPE_BUILTIN_EVMWHGUMIAA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgssfan
block|,
literal|"__builtin_spe_evmwhgssfan"
block|,
name|SPE_BUILTIN_EVMWHGSSFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgsmfan
block|,
literal|"__builtin_spe_evmwhgsmfan"
block|,
name|SPE_BUILTIN_EVMWHGSMFAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgsmian
block|,
literal|"__builtin_spe_evmwhgsmian"
block|,
name|SPE_BUILTIN_EVMWHGSMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmwhgumian
block|,
literal|"__builtin_spe_evmwhgumian"
block|,
name|SPE_BUILTIN_EVMWHGUMIAN
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_brinc
block|,
literal|"__builtin_spe_brinc"
block|,
name|SPE_BUILTIN_BRINC
block|}
block|,
comment|/* Place-holder.  Leave as last binary SPE builtin.  */
block|{
literal|0
block|,
name|CODE_FOR_xorv2si3
block|,
literal|"__builtin_spe_evxor"
block|,
name|SPE_BUILTIN_EVXOR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AltiVec predicates.  */
end_comment

begin_struct
struct|struct
name|builtin_description_predicates
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|rs6000_builtins
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description_predicates
name|bdesc_altivec_preds
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpbfp."
block|,
literal|"__builtin_altivec_vcmpbfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPBFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpeqfp."
block|,
literal|"__builtin_altivec_vcmpeqfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpgefp."
block|,
literal|"__builtin_altivec_vcmpgefp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGEFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4sf
block|,
literal|"*vcmpgtfp."
block|,
literal|"__builtin_altivec_vcmpgtfp_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTFP_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpequw."
block|,
literal|"__builtin_altivec_vcmpequw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpgtsw."
block|,
literal|"__builtin_altivec_vcmpgtsw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v4si
block|,
literal|"*vcmpgtuw."
block|,
literal|"__builtin_altivec_vcmpgtuw_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUW_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpgtuh."
block|,
literal|"__builtin_altivec_vcmpgtuh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpgtsh."
block|,
literal|"__builtin_altivec_vcmpgtsh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v8hi
block|,
literal|"*vcmpequh."
block|,
literal|"__builtin_altivec_vcmpequh_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUH_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpequb."
block|,
literal|"__builtin_altivec_vcmpequb_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQUB_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpgtsb."
block|,
literal|"__builtin_altivec_vcmpgtsb_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTSB_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_predicate_v16qi
block|,
literal|"*vcmpgtub."
block|,
literal|"__builtin_altivec_vcmpgtub_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGTUB_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
literal|0
block|,
name|NULL
block|,
literal|"__builtin_vec_vcmpeq_p"
block|,
name|ALTIVEC_BUILTIN_VCMPEQ_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
literal|0
block|,
name|NULL
block|,
literal|"__builtin_vec_vcmpgt_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGT_P
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
literal|0
block|,
name|NULL
block|,
literal|"__builtin_vec_vcmpge_p"
block|,
name|ALTIVEC_BUILTIN_VCMPGE_P
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SPE predicates.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_spe_predicates
index|[]
init|=
block|{
comment|/* Place-holder.  Leave as first.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpeq
block|,
literal|"__builtin_spe_evcmpeq"
block|,
name|SPE_BUILTIN_EVCMPEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpgts
block|,
literal|"__builtin_spe_evcmpgts"
block|,
name|SPE_BUILTIN_EVCMPGTS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpgtu
block|,
literal|"__builtin_spe_evcmpgtu"
block|,
name|SPE_BUILTIN_EVCMPGTU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmplts
block|,
literal|"__builtin_spe_evcmplts"
block|,
name|SPE_BUILTIN_EVCMPLTS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpltu
block|,
literal|"__builtin_spe_evcmpltu"
block|,
name|SPE_BUILTIN_EVCMPLTU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmpeq
block|,
literal|"__builtin_spe_evfscmpeq"
block|,
name|SPE_BUILTIN_EVFSCMPEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmpgt
block|,
literal|"__builtin_spe_evfscmpgt"
block|,
name|SPE_BUILTIN_EVFSCMPGT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmplt
block|,
literal|"__builtin_spe_evfscmplt"
block|,
name|SPE_BUILTIN_EVFSCMPLT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststeq
block|,
literal|"__builtin_spe_evfststeq"
block|,
name|SPE_BUILTIN_EVFSTSTEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststgt
block|,
literal|"__builtin_spe_evfststgt"
block|,
name|SPE_BUILTIN_EVFSTSTGT
block|}
block|,
comment|/* Place-holder.  Leave as last.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststlt
block|,
literal|"__builtin_spe_evfststlt"
block|,
name|SPE_BUILTIN_EVFSTSTLT
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SPE evsel predicates.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_spe_evsel
index|[]
init|=
block|{
comment|/* Place-holder.  Leave as first.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpgts
block|,
literal|"__builtin_spe_evsel_gts"
block|,
name|SPE_BUILTIN_EVSEL_CMPGTS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpgtu
block|,
literal|"__builtin_spe_evsel_gtu"
block|,
name|SPE_BUILTIN_EVSEL_CMPGTU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmplts
block|,
literal|"__builtin_spe_evsel_lts"
block|,
name|SPE_BUILTIN_EVSEL_CMPLTS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpltu
block|,
literal|"__builtin_spe_evsel_ltu"
block|,
name|SPE_BUILTIN_EVSEL_CMPLTU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcmpeq
block|,
literal|"__builtin_spe_evsel_eq"
block|,
name|SPE_BUILTIN_EVSEL_CMPEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmpgt
block|,
literal|"__builtin_spe_evsel_fsgt"
block|,
name|SPE_BUILTIN_EVSEL_FSCMPGT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmplt
block|,
literal|"__builtin_spe_evsel_fslt"
block|,
name|SPE_BUILTIN_EVSEL_FSCMPLT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscmpeq
block|,
literal|"__builtin_spe_evsel_fseq"
block|,
name|SPE_BUILTIN_EVSEL_FSCMPEQ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststgt
block|,
literal|"__builtin_spe_evsel_fststgt"
block|,
name|SPE_BUILTIN_EVSEL_FSTSTGT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststlt
block|,
literal|"__builtin_spe_evsel_fststlt"
block|,
name|SPE_BUILTIN_EVSEL_FSTSTLT
block|}
block|,
comment|/* Place-holder.  Leave as last.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evfststeq
block|,
literal|"__builtin_spe_evsel_fststeq"
block|,
name|SPE_BUILTIN_EVSEL_FSTSTEQ
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ABS* operations.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_abs
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv4si2
block|,
literal|"__builtin_altivec_abs_v4si"
block|,
name|ALTIVEC_BUILTIN_ABS_V4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv8hi2
block|,
literal|"__builtin_altivec_abs_v8hi"
block|,
name|ALTIVEC_BUILTIN_ABS_V8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv4sf2
block|,
literal|"__builtin_altivec_abs_v4sf"
block|,
name|ALTIVEC_BUILTIN_ABS_V4SF
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_absv16qi2
block|,
literal|"__builtin_altivec_abs_v16qi"
block|,
name|ALTIVEC_BUILTIN_ABS_V16QI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v4si
block|,
literal|"__builtin_altivec_abss_v4si"
block|,
name|ALTIVEC_BUILTIN_ABSS_V4SI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v8hi
block|,
literal|"__builtin_altivec_abss_v8hi"
block|,
name|ALTIVEC_BUILTIN_ABSS_V8HI
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_abss_v16qi
block|,
literal|"__builtin_altivec_abss_v16qi"
block|,
name|ALTIVEC_BUILTIN_ABSS_V16QI
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simple unary operations: VECb = foo (unsigned literal) or VECb =    foo (VECa).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vexptefp
block|,
literal|"__builtin_altivec_vexptefp"
block|,
name|ALTIVEC_BUILTIN_VEXPTEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vlogefp
block|,
literal|"__builtin_altivec_vlogefp"
block|,
name|ALTIVEC_BUILTIN_VLOGEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrefp
block|,
literal|"__builtin_altivec_vrefp"
block|,
name|ALTIVEC_BUILTIN_VREFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfim
block|,
literal|"__builtin_altivec_vrfim"
block|,
name|ALTIVEC_BUILTIN_VRFIM
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfin
block|,
literal|"__builtin_altivec_vrfin"
block|,
name|ALTIVEC_BUILTIN_VRFIN
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrfip
block|,
literal|"__builtin_altivec_vrfip"
block|,
name|ALTIVEC_BUILTIN_VRFIP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_ftruncv4sf2
block|,
literal|"__builtin_altivec_vrfiz"
block|,
name|ALTIVEC_BUILTIN_VRFIZ
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vrsqrtefp
block|,
literal|"__builtin_altivec_vrsqrtefp"
block|,
name|ALTIVEC_BUILTIN_VRSQRTEFP
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltisb
block|,
literal|"__builtin_altivec_vspltisb"
block|,
name|ALTIVEC_BUILTIN_VSPLTISB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltish
block|,
literal|"__builtin_altivec_vspltish"
block|,
name|ALTIVEC_BUILTIN_VSPLTISH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vspltisw
block|,
literal|"__builtin_altivec_vspltisw"
block|,
name|ALTIVEC_BUILTIN_VSPLTISW
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhsb
block|,
literal|"__builtin_altivec_vupkhsb"
block|,
name|ALTIVEC_BUILTIN_VUPKHSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhpx
block|,
literal|"__builtin_altivec_vupkhpx"
block|,
name|ALTIVEC_BUILTIN_VUPKHPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupkhsh
block|,
literal|"__builtin_altivec_vupkhsh"
block|,
name|ALTIVEC_BUILTIN_VUPKHSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklsb
block|,
literal|"__builtin_altivec_vupklsb"
block|,
name|ALTIVEC_BUILTIN_VUPKLSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklpx
block|,
literal|"__builtin_altivec_vupklpx"
block|,
name|ALTIVEC_BUILTIN_VUPKLPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_altivec_vupklsh
block|,
literal|"__builtin_altivec_vupklsh"
block|,
name|ALTIVEC_BUILTIN_VUPKLSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_abs"
block|,
name|ALTIVEC_BUILTIN_VEC_ABS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_abss"
block|,
name|ALTIVEC_BUILTIN_VEC_ABSS
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_ceil"
block|,
name|ALTIVEC_BUILTIN_VEC_CEIL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_expte"
block|,
name|ALTIVEC_BUILTIN_VEC_EXPTE
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_floor"
block|,
name|ALTIVEC_BUILTIN_VEC_FLOOR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_loge"
block|,
name|ALTIVEC_BUILTIN_VEC_LOGE
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_mtvscr"
block|,
name|ALTIVEC_BUILTIN_VEC_MTVSCR
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_re"
block|,
name|ALTIVEC_BUILTIN_VEC_RE
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_round"
block|,
name|ALTIVEC_BUILTIN_VEC_ROUND
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_rsqrte"
block|,
name|ALTIVEC_BUILTIN_VEC_RSQRTE
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_trunc"
block|,
name|ALTIVEC_BUILTIN_VEC_TRUNC
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_unpackh"
block|,
name|ALTIVEC_BUILTIN_VEC_UNPACKH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vupkhsh"
block|,
name|ALTIVEC_BUILTIN_VEC_VUPKHSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vupkhpx"
block|,
name|ALTIVEC_BUILTIN_VEC_VUPKHPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vupkhsb"
block|,
name|ALTIVEC_BUILTIN_VEC_VUPKHSB
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_unpackl"
block|,
name|ALTIVEC_BUILTIN_VEC_UNPACKL
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vupklpx"
block|,
name|ALTIVEC_BUILTIN_VEC_VUPKLPX
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vupklsh"
block|,
name|ALTIVEC_BUILTIN_VEC_VUPKLSH
block|}
block|,
block|{
name|MASK_ALTIVEC
block|,
name|CODE_FOR_nothing
block|,
literal|"__builtin_vec_vupklsb"
block|,
name|ALTIVEC_BUILTIN_VEC_VUPKLSB
block|}
block|,
comment|/* The SPE unary builtins must start with SPE_BUILTIN_EVABS and      end with SPE_BUILTIN_EVSUBFUSIAAW.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evabs
block|,
literal|"__builtin_spe_evabs"
block|,
name|SPE_BUILTIN_EVABS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddsmiaaw
block|,
literal|"__builtin_spe_evaddsmiaaw"
block|,
name|SPE_BUILTIN_EVADDSMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddssiaaw
block|,
literal|"__builtin_spe_evaddssiaaw"
block|,
name|SPE_BUILTIN_EVADDSSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddumiaaw
block|,
literal|"__builtin_spe_evaddumiaaw"
block|,
name|SPE_BUILTIN_EVADDUMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evaddusiaaw
block|,
literal|"__builtin_spe_evaddusiaaw"
block|,
name|SPE_BUILTIN_EVADDUSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcntlsw
block|,
literal|"__builtin_spe_evcntlsw"
block|,
name|SPE_BUILTIN_EVCNTLSW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evcntlzw
block|,
literal|"__builtin_spe_evcntlzw"
block|,
name|SPE_BUILTIN_EVCNTLZW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evextsb
block|,
literal|"__builtin_spe_evextsb"
block|,
name|SPE_BUILTIN_EVEXTSB
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evextsh
block|,
literal|"__builtin_spe_evextsh"
block|,
name|SPE_BUILTIN_EVEXTSH
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsabs
block|,
literal|"__builtin_spe_evfsabs"
block|,
name|SPE_BUILTIN_EVFSABS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscfsf
block|,
literal|"__builtin_spe_evfscfsf"
block|,
name|SPE_BUILTIN_EVFSCFSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscfsi
block|,
literal|"__builtin_spe_evfscfsi"
block|,
name|SPE_BUILTIN_EVFSCFSI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscfuf
block|,
literal|"__builtin_spe_evfscfuf"
block|,
name|SPE_BUILTIN_EVFSCFUF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfscfui
block|,
literal|"__builtin_spe_evfscfui"
block|,
name|SPE_BUILTIN_EVFSCFUI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctsf
block|,
literal|"__builtin_spe_evfsctsf"
block|,
name|SPE_BUILTIN_EVFSCTSF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctsi
block|,
literal|"__builtin_spe_evfsctsi"
block|,
name|SPE_BUILTIN_EVFSCTSI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctsiz
block|,
literal|"__builtin_spe_evfsctsiz"
block|,
name|SPE_BUILTIN_EVFSCTSIZ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctuf
block|,
literal|"__builtin_spe_evfsctuf"
block|,
name|SPE_BUILTIN_EVFSCTUF
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctui
block|,
literal|"__builtin_spe_evfsctui"
block|,
name|SPE_BUILTIN_EVFSCTUI
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsctuiz
block|,
literal|"__builtin_spe_evfsctuiz"
block|,
name|SPE_BUILTIN_EVFSCTUIZ
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsnabs
block|,
literal|"__builtin_spe_evfsnabs"
block|,
name|SPE_BUILTIN_EVFSNABS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evfsneg
block|,
literal|"__builtin_spe_evfsneg"
block|,
name|SPE_BUILTIN_EVFSNEG
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evmra
block|,
literal|"__builtin_spe_evmra"
block|,
name|SPE_BUILTIN_EVMRA
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_negv2si2
block|,
literal|"__builtin_spe_evneg"
block|,
name|SPE_BUILTIN_EVNEG
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evrndw
block|,
literal|"__builtin_spe_evrndw"
block|,
name|SPE_BUILTIN_EVRNDW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfsmiaaw
block|,
literal|"__builtin_spe_evsubfsmiaaw"
block|,
name|SPE_BUILTIN_EVSUBFSMIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfssiaaw
block|,
literal|"__builtin_spe_evsubfssiaaw"
block|,
name|SPE_BUILTIN_EVSUBFSSIAAW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfumiaaw
block|,
literal|"__builtin_spe_evsubfumiaaw"
block|,
name|SPE_BUILTIN_EVSUBFUMIAAW
block|}
block|,
comment|/* Place-holder.  Leave as last unary SPE builtin.  */
block|{
literal|0
block|,
name|CODE_FOR_spe_evsubfusiaaw
block|,
literal|"__builtin_spe_evsubfusiaaw"
block|,
name|SPE_BUILTIN_EVSUBFUSIAAW
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
name|rs6000_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
comment|/* Builtin not supported on this processor.  */
return|return
literal|0
return|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_altivec_vspltisb
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vspltish
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vspltisw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsplatfi
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsplati
condition|)
block|{
comment|/* Only allow 5-bit *signed* literals.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|>
literal|15
operator|||
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|<
operator|-
literal|16
condition|)
block|{
name|error
argument_list|(
literal|"argument 1 must be a 5-bit signed literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_abs_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch1
decl_stmt|,
name|scratch2
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
comment|/* If we have invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|scratch1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|scratch2
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|scratch1
argument_list|,
name|scratch2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|rs6000_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
comment|/* Builtin not supported on this processor.  */
return|return
literal|0
return|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_altivec_vcfux
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vcfsx
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vctsxs
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vctuxs
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vspltb
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vsplth
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vspltw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evaddiw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evldd
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evldh
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evldw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlhhesplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlhhossplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlhhousplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwhe
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwhos
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwhou
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwhsplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evlwwsplat
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evrlwi
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evslwi
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsrwis
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsubifw
operator|||
name|icode
operator|==
name|CODE_FOR_spe_evsrwiu
condition|)
block|{
comment|/* Only allow 5-bit unsigned literals.  */
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|~
literal|0x1f
condition|)
block|{
name|error
argument_list|(
literal|"argument 2 must be a 5-bit unsigned literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_predicate_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
specifier|const
name|char
modifier|*
name|opcode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch
decl_stmt|;
name|tree
name|cr6_form
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|SImode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|int
name|cr6_form_int
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cr6_form
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"argument 1 of __builtin_altivec_predicate must be a constant"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
name|cr6_form_int
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|cr6_form
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode0
operator|==
name|mode1
argument_list|)
expr_stmt|;
comment|/* If we have invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|scratch
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* The vec_any* and vec_all* predicates use the same opcodes for two      different operations, but the bits in CR6 will be different      depending on what information we want.  So we have to play tricks      with CR6 to get the right bits out.       If you think this is disgusting, look at the specs for the      AltiVec predicates.  */
switch|switch
condition|(
name|cr6_form_int
condition|)
block|{
case|case
literal|0
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_zero
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_zero_reverse
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_lt
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|emit_insn
argument_list|(
name|gen_cr6_test_for_lt_reverse
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"argument 1 of __builtin_altivec_predicate is out of range"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_lv_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|addr
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|Pmode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|Pmode
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
comment|/* Builtin not supported on this processor.  */
return|return
literal|0
return|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|tmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|tmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|spe_expand_stv_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
comment|/* Invalid arguments.  Bail before doing anything stoopid!  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode2
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode0
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode1
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|altivec_expand_stv_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|addr
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|Pmode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|Pmode
decl_stmt|;
comment|/* Invalid arguments.  Bail before doing anything stoopid!  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|tmode
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|tmode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|tmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|addr
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|rs6000_expand_ternop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
comment|/* Builtin not supported on this processor.  */
return|return
literal|0
return|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_altivec_vsldoi_v4sf
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vsldoi_v4si
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vsldoi_v8hi
operator|||
name|icode
operator|==
name|CODE_FOR_altivec_vsldoi_v16qi
condition|)
block|{
comment|/* Only allow 4-bit unsigned literals.  */
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
operator|&
operator|~
literal|0xf
condition|)
block|{
name|error
argument_list|(
literal|"argument 3 must be a 4-bit unsigned literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand the lvx builtins.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_ld_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op0
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_16qi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_v16qi
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_8hi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_v8hi
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_4si
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_v4si
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_LD_INTERNAL_4sf
case|:
name|icode
operator|=
name|CODE_FOR_altivec_lvx_v4sf
expr_stmt|;
break|break;
default|default:
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand the stvx builtins.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_st_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_16qi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_v16qi
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_8hi
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_v8hi
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_4si
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_v4si
expr_stmt|;
break|break;
case|case
name|ALTIVEC_BUILTIN_ST_INTERNAL_4sf
case|:
name|icode
operator|=
name|CODE_FOR_altivec_stvx_v4sf
expr_stmt|;
break|break;
default|default:
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand the dst builtins.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_dst_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
comment|/* Handle DST variants.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_dst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_dst
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
block|{
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
comment|/* Invalid arguments, bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
operator|&
operator|~
literal|0x3
condition|)
block|{
name|error
argument_list|(
literal|"argument to %qs must be a 2-bit unsigned literal"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Expand vec_init builtin.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_vec_init_builtin
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|tmode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|tmode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_elt
init|=
name|GET_MODE_NUNITS
argument_list|(
name|tmode
argument_list|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elt
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|tmode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elt
condition|;
operator|++
name|i
operator|,
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
control|)
block|{
name|rtx
name|x
init|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|gen_lowpart
argument_list|(
name|inner_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|arglist
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|tmode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|rs6000_expand_vector_init
argument_list|(
name|target
argument_list|,
name|gen_rtx_PARALLEL
argument_list|(
name|tmode
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Return the integer constant in ARG.  Constrain it to be in the range    of the subparts of VEC_TYPE; issue an error if not.  */
end_comment

begin_function
specifier|static
name|int
name|get_element_number
parameter_list|(
name|tree
name|vec_type
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|elt
decl_stmt|,
name|max
init|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|vec_type
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|elt
operator|=
name|tree_low_cst
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
operator|,
name|elt
operator|>
name|max
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"selector must be an integer constant in the range 0..%wi"
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|elt
return|;
block|}
end_function

begin_comment
comment|/* Expand vec_set builtin.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_vec_set_builtin
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode1
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|int
name|elt
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|mode1
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|tmode
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|tmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elt
operator|=
name|get_element_number
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|op1
operator|=
name|convert_modes
argument_list|(
name|mode1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op1
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|rs6000_expand_vector_set
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|elt
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
end_function

begin_comment
comment|/* Expand vec_ext builtin.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_vec_ext_builtin
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|int
name|elt
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|elt
operator|=
name|get_element_number
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|||
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|tmode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|rs6000_expand_vector_extract
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|elt
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand the builtin in EXP and store the result in TARGET.  Store    true in *EXPANDEDP if we found a builtin to expand.  */
end_comment

begin_function
specifier|static
name|rtx
name|altivec_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|struct
name|builtin_description_predicates
modifier|*
name|dp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|fcode
operator|>=
name|ALTIVEC_BUILTIN_OVERLOADED_FIRST
operator|&&
name|fcode
operator|<=
name|ALTIVEC_BUILTIN_OVERLOADED_LAST
condition|)
block|{
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
name|error
argument_list|(
literal|"unresolved overload for Altivec builtin %qF"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|target
operator|=
name|altivec_expand_ld_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|expandedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expandedp
condition|)
return|return
name|target
return|;
name|target
operator|=
name|altivec_expand_st_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|expandedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expandedp
condition|)
return|return
name|target
return|;
name|target
operator|=
name|altivec_expand_dst_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|expandedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expandedp
condition|)
return|return
name|target
return|;
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_STVX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEBX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvebx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEHX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvehx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVEWX
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvewx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_STVXL
case|:
return|return
name|altivec_expand_stv_builtin
argument_list|(
name|CODE_FOR_altivec_stvxl
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_MFVSCR
case|:
name|icode
operator|=
name|CODE_FOR_altivec_mfvscr
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ALTIVEC_BUILTIN_MTVSCR
case|:
name|icode
operator|=
name|CODE_FOR_altivec_mtvscr
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_DSSALL
case|:
name|emit_insn
argument_list|(
name|gen_altivec_dssall
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_DSS
case|:
name|icode
operator|=
name|CODE_FOR_altivec_dss
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
comment|/* If we got invalid arguments bail out before generating bad rtl.  */
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|&
operator|~
literal|0x3
condition|)
block|{
name|error
argument_list|(
literal|"argument to dss must be a 2-bit unsigned literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_altivec_dss
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|ALTIVEC_BUILTIN_VEC_INIT_V4SI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_INIT_V8HI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_INIT_V16QI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_INIT_V4SF
case|:
return|return
name|altivec_expand_vec_init_builtin
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_VEC_SET_V4SI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_SET_V8HI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_SET_V16QI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_SET_V4SF
case|:
return|return
name|altivec_expand_vec_set_builtin
argument_list|(
name|arglist
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_VEC_EXT_V4SI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_EXT_V8HI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_EXT_V16QI
case|:
case|case
name|ALTIVEC_BUILTIN_VEC_EXT_V4SF
case|:
return|return
name|altivec_expand_vec_ext_builtin
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
return|;
default|default:
break|break;
comment|/* Fall through.  */
block|}
comment|/* Expand abs* operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_abs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_abs
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_abs_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Expand the AltiVec predicates.  */
name|dp
operator|=
operator|(
expr|struct
name|builtin_description_predicates
operator|*
operator|)
name|bdesc_altivec_preds
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_altivec_preds
argument_list|)
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|altivec_expand_predicate_builtin
argument_list|(
name|dp
operator|->
name|icode
argument_list|,
name|dp
operator|->
name|opcode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* LV* are funky.  We initialized them differently.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ALTIVEC_BUILTIN_LVSL
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvsl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVSR
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvsr
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEBX
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvebx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEHX
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvehx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVEWX
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvewx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVXL
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvxl
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ALTIVEC_BUILTIN_LVX
case|:
return|return
name|altivec_expand_lv_builtin
argument_list|(
name|CODE_FOR_altivec_lvx
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
default|default:
break|break;
comment|/* Fall through.  */
block|}
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Binops that need to be initialized manually, but can be expanded    automagically by rs6000_expand_binop_builtin.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|builtin_description
name|bdesc_2arg_spe
index|[]
init|=
block|{
block|{
literal|0
block|,
name|CODE_FOR_spe_evlddx
block|,
literal|"__builtin_spe_evlddx"
block|,
name|SPE_BUILTIN_EVLDDX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldwx
block|,
literal|"__builtin_spe_evldwx"
block|,
name|SPE_BUILTIN_EVLDWX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldhx
block|,
literal|"__builtin_spe_evldhx"
block|,
name|SPE_BUILTIN_EVLDHX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhex
block|,
literal|"__builtin_spe_evlwhex"
block|,
name|SPE_BUILTIN_EVLWHEX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhoux
block|,
literal|"__builtin_spe_evlwhoux"
block|,
name|SPE_BUILTIN_EVLWHOUX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhosx
block|,
literal|"__builtin_spe_evlwhosx"
block|,
name|SPE_BUILTIN_EVLWHOSX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwwsplatx
block|,
literal|"__builtin_spe_evlwwsplatx"
block|,
name|SPE_BUILTIN_EVLWWSPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhsplatx
block|,
literal|"__builtin_spe_evlwhsplatx"
block|,
name|SPE_BUILTIN_EVLWHSPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhesplatx
block|,
literal|"__builtin_spe_evlhhesplatx"
block|,
name|SPE_BUILTIN_EVLHHESPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhousplatx
block|,
literal|"__builtin_spe_evlhhousplatx"
block|,
name|SPE_BUILTIN_EVLHHOUSPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhossplatx
block|,
literal|"__builtin_spe_evlhhossplatx"
block|,
name|SPE_BUILTIN_EVLHHOSSPLATX
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldd
block|,
literal|"__builtin_spe_evldd"
block|,
name|SPE_BUILTIN_EVLDD
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldw
block|,
literal|"__builtin_spe_evldw"
block|,
name|SPE_BUILTIN_EVLDW
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evldh
block|,
literal|"__builtin_spe_evldh"
block|,
name|SPE_BUILTIN_EVLDH
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhe
block|,
literal|"__builtin_spe_evlwhe"
block|,
name|SPE_BUILTIN_EVLWHE
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhou
block|,
literal|"__builtin_spe_evlwhou"
block|,
name|SPE_BUILTIN_EVLWHOU
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhos
block|,
literal|"__builtin_spe_evlwhos"
block|,
name|SPE_BUILTIN_EVLWHOS
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwwsplat
block|,
literal|"__builtin_spe_evlwwsplat"
block|,
name|SPE_BUILTIN_EVLWWSPLAT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlwhsplat
block|,
literal|"__builtin_spe_evlwhsplat"
block|,
name|SPE_BUILTIN_EVLWHSPLAT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhesplat
block|,
literal|"__builtin_spe_evlhhesplat"
block|,
name|SPE_BUILTIN_EVLHHESPLAT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhousplat
block|,
literal|"__builtin_spe_evlhhousplat"
block|,
name|SPE_BUILTIN_EVLHHOUSPLAT
block|}
block|,
block|{
literal|0
block|,
name|CODE_FOR_spe_evlhhossplat
block|,
literal|"__builtin_spe_evlhhossplat"
block|,
name|SPE_BUILTIN_EVLHHOSSPLAT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand the builtin in EXP and store the result in TARGET.  Store    true in *EXPANDEDP if we found a builtin to expand.     This expands the SPE builtins that are not simple unary and binary    operations.  */
end_comment

begin_function
specifier|static
name|rtx
name|spe_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
modifier|*
name|expandedp
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg0
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op0
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
operator|*
name|expandedp
operator|=
name|true
expr_stmt|;
comment|/* Syntax check for a 5-bit unsigned immediate.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|SPE_BUILTIN_EVSTDD
case|:
case|case
name|SPE_BUILTIN_EVSTDH
case|:
case|case
name|SPE_BUILTIN_EVSTDW
case|:
case|case
name|SPE_BUILTIN_EVSTWHE
case|:
case|case
name|SPE_BUILTIN_EVSTWHO
case|:
case|case
name|SPE_BUILTIN_EVSTWWE
case|:
case|case
name|SPE_BUILTIN_EVSTWWO
case|:
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|~
literal|0x1f
condition|)
block|{
name|error
argument_list|(
literal|"argument 2 must be a 5-bit unsigned literal"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* The evsplat*i instructions are not quite generic.  */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|SPE_BUILTIN_EVSPLATFI
case|:
return|return
name|rs6000_expand_unop_builtin
argument_list|(
name|CODE_FOR_spe_evsplatfi
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSPLATI
case|:
return|return
name|rs6000_expand_unop_builtin
argument_list|(
name|CODE_FOR_spe_evsplati
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
default|default:
break|break;
block|}
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg_spe
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg_spe
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|d
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|rs6000_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_predicates
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_predicates
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|d
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|spe_expand_predicate_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_evsel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_evsel
argument_list|)
condition|;
operator|++
name|i
operator|,
operator|++
name|d
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|spe_expand_evsel_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|SPE_BUILTIN_EVSTDDX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstddx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDHX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdhx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDWX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdwx
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWHEX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwhex
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWHOX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwhox
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWWEX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwwex
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWWOX
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwwox
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDD
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdd
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDH
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdh
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTDW
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstdw
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWHE
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwhe
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWHO
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwho
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWWE
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwwe
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_EVSTWWO
case|:
return|return
name|spe_expand_stv_builtin
argument_list|(
name|CODE_FOR_spe_evstwwo
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|SPE_BUILTIN_MFSPEFSCR
case|:
name|icode
operator|=
name|CODE_FOR_spe_mfspefscr
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|SPE_BUILTIN_MTSPEFSCR
case|:
name|icode
operator|=
name|CODE_FOR_spe_mtspefscr
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
default|default:
break|break;
block|}
operator|*
name|expandedp
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|spe_expand_predicate_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|form
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|int
name|form_int
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|form
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"argument 1 of __builtin_spe_predicate must be a constant"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
else|else
name|form_int
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode0
operator|==
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|SImode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|SImode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|CCmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|scratch
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|const0_rtx
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* There are 4 variants for each predicate: _any_, _all_, _upper_,      _lower_.  We use one compare, but look in different bits of the      CR for each variant.       There are 2 elements in each SPE simd type (upper/lower).  The CR      bits are set as follows:       BIT0  | BIT 1  | BIT 2   | BIT 3      U     |   L    | (U | L) | (U& L)       So, for an "all" relationship, BIT 3 would be set.      For an "any" relationship, BIT 2 would be set.  Etc.       Following traditional nomenclature, these bits map to:       BIT0  | BIT 1  | BIT 2   | BIT 3      LT    | GT     | EQ      | OV       Later, we will generate rtl to look in the LT/EQ/EQ/OV bits.   */
switch|switch
condition|(
name|form_int
condition|)
block|{
comment|/* All variant.  OV bit.  */
case|case
literal|0
case|:
comment|/* We need to get to the OV bit, which is the ORDERED bit.  We 	 could generate (ordered:SI (reg:CC xx) (const_int 0)), but 	 that's ugly and will make validate_condition_mode die. 	 So let's just use another pattern.  */
name|emit_insn
argument_list|(
name|gen_move_from_CR_ov_bit
argument_list|(
name|target
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
comment|/* Any variant.  EQ bit.  */
case|case
literal|1
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
comment|/* Upper variant.  LT bit.  */
case|case
literal|2
case|:
name|code
operator|=
name|LT
expr_stmt|;
break|break;
comment|/* Lower variant.  GT bit.  */
case|case
literal|3
case|:
name|code
operator|=
name|GT
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"argument 1 of __builtin_spe_predicate is out of range"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|SImode
argument_list|,
name|scratch
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* The evsel builtins look like this:       e = __builtin_spe_evsel_OP (a, b, c, d);     and work like this:       e[upper] = a[upper] *OP* b[upper] ? c[upper] : d[upper];      e[lower] = a[lower] *OP* b[lower] ? c[lower] : d[lower]; */
end_comment

begin_function
specifier|static
name|rtx
name|spe_expand_evsel_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|scratch
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg3
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|rtx
name|op3
init|=
name|expand_normal
argument_list|(
name|arg3
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|gcc_assert
argument_list|(
name|mode0
operator|==
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
operator|||
name|arg3
operator|==
name|error_mark_node
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode0
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|mode0
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode1
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op3
operator|,
name|mode1
operator|)
condition|)
name|op3
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op3
argument_list|)
expr_stmt|;
comment|/* Generate the compare.  */
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|CCmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|scratch
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|const0_rtx
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode0
operator|==
name|V2SImode
condition|)
name|emit_insn
argument_list|(
name|gen_spe_evsel
argument_list|(
name|target
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_spe_evsel_fs
argument_list|(
name|target
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|bool
name|success
decl_stmt|;
if|if
condition|(
name|fcode
operator|==
name|ALTIVEC_BUILTIN_MASK_FOR_LOAD
operator|||
name|fcode
operator|==
name|ALTIVEC_BUILTIN_MASK_FOR_STORE
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|CODE_FOR_altivec_lvsr
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|rtx
name|op
decl_stmt|,
name|addr
decl_stmt|,
name|pat
decl_stmt|;
name|gcc_assert
argument_list|(
name|TARGET_ALTIVEC
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|op
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|ALTIVEC_BUILTIN_MASK_FOR_STORE
condition|)
name|op
operator|=
name|addr
expr_stmt|;
else|else
block|{
comment|/* For the load case need to negate the address.  */
name|op
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|op
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
comment|/*pat = gen_altivec_lvsr (target, op);*/
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
block|{
name|ret
operator|=
name|altivec_expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|TARGET_SPE
condition|)
block|{
name|ret
operator|=
name|spe_expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
return|return
name|ret
return|;
block|}
name|gcc_assert
argument_list|(
name|TARGET_ALTIVEC
operator|||
name|TARGET_SPE
argument_list|)
expr_stmt|;
comment|/* Handle simple unary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_1arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|rs6000_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Handle simple binary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|rs6000_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Handle simple ternary operations.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_3arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_3arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|rs6000_expand_ternop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_opaque_vector_type
parameter_list|(
name|tree
name|node
parameter_list|,
name|int
name|nunits
parameter_list|)
block|{
name|node
operator|=
name|copy_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|node
argument_list|)
operator|=
name|node
expr_stmt|;
return|return
name|build_vector_type
argument_list|(
name|node
argument_list|,
name|nunits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|V2SI_type_node
operator|=
name|build_vector_type
argument_list|(
name|intSI_type_node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|V2SF_type_node
operator|=
name|build_vector_type
argument_list|(
name|float_type_node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|V4HI_type_node
operator|=
name|build_vector_type
argument_list|(
name|intHI_type_node
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|V4SI_type_node
operator|=
name|build_vector_type
argument_list|(
name|intSI_type_node
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|V4SF_type_node
operator|=
name|build_vector_type
argument_list|(
name|float_type_node
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|V8HI_type_node
operator|=
name|build_vector_type
argument_list|(
name|intHI_type_node
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|V16QI_type_node
operator|=
name|build_vector_type
argument_list|(
name|intQI_type_node
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|unsigned_V16QI_type_node
operator|=
name|build_vector_type
argument_list|(
name|unsigned_intQI_type_node
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|unsigned_V8HI_type_node
operator|=
name|build_vector_type
argument_list|(
name|unsigned_intHI_type_node
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|unsigned_V4SI_type_node
operator|=
name|build_vector_type
argument_list|(
name|unsigned_intSI_type_node
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|opaque_V2SF_type_node
operator|=
name|build_opaque_vector_type
argument_list|(
name|float_type_node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opaque_V2SI_type_node
operator|=
name|build_opaque_vector_type
argument_list|(
name|intSI_type_node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opaque_p_V2SI_type_node
operator|=
name|build_pointer_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|)
expr_stmt|;
name|opaque_V4SI_type_node
operator|=
name|copy_node
argument_list|(
name|V4SI_type_node
argument_list|)
expr_stmt|;
comment|/* The 'vector bool ...' types must be kept distinct from 'vector unsigned ...'      types, especially in C++ land.  Similarly, 'vector pixel' is distinct from      'vector unsigned short'.  */
name|bool_char_type_node
operator|=
name|build_distinct_type_copy
argument_list|(
name|unsigned_intQI_type_node
argument_list|)
expr_stmt|;
name|bool_short_type_node
operator|=
name|build_distinct_type_copy
argument_list|(
name|unsigned_intHI_type_node
argument_list|)
expr_stmt|;
name|bool_int_type_node
operator|=
name|build_distinct_type_copy
argument_list|(
name|unsigned_intSI_type_node
argument_list|)
expr_stmt|;
name|pixel_type_node
operator|=
name|build_distinct_type_copy
argument_list|(
name|unsigned_intHI_type_node
argument_list|)
expr_stmt|;
name|long_integer_type_internal_node
operator|=
name|long_integer_type_node
expr_stmt|;
name|long_unsigned_type_internal_node
operator|=
name|long_unsigned_type_node
expr_stmt|;
name|intQI_type_internal_node
operator|=
name|intQI_type_node
expr_stmt|;
name|uintQI_type_internal_node
operator|=
name|unsigned_intQI_type_node
expr_stmt|;
name|intHI_type_internal_node
operator|=
name|intHI_type_node
expr_stmt|;
name|uintHI_type_internal_node
operator|=
name|unsigned_intHI_type_node
expr_stmt|;
name|intSI_type_internal_node
operator|=
name|intSI_type_node
expr_stmt|;
name|uintSI_type_internal_node
operator|=
name|unsigned_intSI_type_node
expr_stmt|;
name|float_type_internal_node
operator|=
name|float_type_node
expr_stmt|;
name|void_type_internal_node
operator|=
name|void_type_node
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__bool char"
argument_list|)
argument_list|,
name|bool_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__bool short"
argument_list|)
argument_list|,
name|bool_short_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__bool int"
argument_list|)
argument_list|,
name|bool_int_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__pixel"
argument_list|)
argument_list|,
name|pixel_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|bool_V16QI_type_node
operator|=
name|build_vector_type
argument_list|(
name|bool_char_type_node
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|bool_V8HI_type_node
operator|=
name|build_vector_type
argument_list|(
name|bool_short_type_node
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bool_V4SI_type_node
operator|=
name|build_vector_type
argument_list|(
name|bool_int_type_node
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pixel_V8HI_type_node
operator|=
name|build_vector_type
argument_list|(
name|pixel_type_node
argument_list|,
literal|8
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector unsigned char"
argument_list|)
argument_list|,
name|unsigned_V16QI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector signed char"
argument_list|)
argument_list|,
name|V16QI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector __bool char"
argument_list|)
argument_list|,
name|bool_V16QI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector unsigned short"
argument_list|)
argument_list|,
name|unsigned_V8HI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector signed short"
argument_list|)
argument_list|,
name|V8HI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector __bool short"
argument_list|)
argument_list|,
name|bool_V8HI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector unsigned int"
argument_list|)
argument_list|,
name|unsigned_V4SI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector signed int"
argument_list|)
argument_list|,
name|V4SI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector __bool int"
argument_list|)
argument_list|,
name|bool_V4SI_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector float"
argument_list|)
argument_list|,
name|V4SF_type_node
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__vector __pixel"
argument_list|)
argument_list|,
name|pixel_V8HI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE
condition|)
name|spe_init_builtins
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
name|altivec_init_builtins
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC
operator|||
name|TARGET_SPE
condition|)
name|rs6000_common_init_builtins
argument_list|()
expr_stmt|;
if|#
directive|if
name|TARGET_XCOFF
comment|/* AIX libm provides clog as __clog.  */
if|if
condition|(
name|built_in_decls
index|[
name|BUILT_IN_CLOG
index|]
condition|)
name|set_user_assembler_name
argument_list|(
name|built_in_decls
index|[
name|BUILT_IN_CLOG
index|]
argument_list|,
literal|"__clog"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Search through a set of builtins and enable the mask bits.    DESC is an array of builtins.    SIZE is the total number of builtins.    START is the builtin enum at which to start.    END is the builtin enum at which to end.  */
end_comment

begin_function
specifier|static
name|void
name|enable_mask_for_builtins
parameter_list|(
name|struct
name|builtin_description
modifier|*
name|desc
parameter_list|,
name|int
name|size
parameter_list|,
name|enum
name|rs6000_builtins
name|start
parameter_list|,
name|enum
name|rs6000_builtins
name|end
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|desc
index|[
name|i
index|]
operator|.
name|code
operator|==
name|start
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|size
condition|)
return|return;
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
comment|/* Flip all the bits on.  */
name|desc
index|[
name|i
index|]
operator|.
name|mask
operator|=
name|target_flags
expr_stmt|;
if|if
condition|(
name|desc
index|[
name|i
index|]
operator|.
name|code
operator|==
name|end
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|spe_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
name|tree
name|puint_type_node
init|=
name|build_pointer_type
argument_list|(
name|unsigned_type_node
argument_list|)
decl_stmt|;
name|tree
name|pushort_type_node
init|=
name|build_pointer_type
argument_list|(
name|short_unsigned_type_node
argument_list|)
decl_stmt|;
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|v2si_ftype_4_v2si
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_4_v2sf
init|=
name|build_function_type
argument_list|(
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v2si_v2si
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v2sf_v2sf
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v2si_puint_int
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|puint_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v2si_puint_char
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|puint_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v2si_pv2si_int
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_p_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v2si_pv2si_char
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_p_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_int
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_void
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_pv2si_int
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|opaque_p_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_puint_int
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|puint_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_pushort_int
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pushort_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_signed_char
init|=
name|build_function_type
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|signed_char_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The initialization of the simple binary and unary builtins is      done in rs6000_common_init_builtins, but we have to enable the      mask bits here manually because we have run out of `target_flags'      bits.  We really need to redesign this mask business.  */
name|enable_mask_for_builtins
argument_list|(
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
argument_list|,
name|SPE_BUILTIN_EVADDW
argument_list|,
name|SPE_BUILTIN_EVXOR
argument_list|)
expr_stmt|;
name|enable_mask_for_builtins
argument_list|(
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_1arg
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
argument_list|,
name|SPE_BUILTIN_EVABS
argument_list|,
name|SPE_BUILTIN_EVSUBFUSIAAW
argument_list|)
expr_stmt|;
name|enable_mask_for_builtins
argument_list|(
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_predicates
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_predicates
argument_list|)
argument_list|,
name|SPE_BUILTIN_EVCMPEQ
argument_list|,
name|SPE_BUILTIN_EVFSTSTLT
argument_list|)
expr_stmt|;
name|enable_mask_for_builtins
argument_list|(
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_evsel
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_evsel
argument_list|)
argument_list|,
name|SPE_BUILTIN_EVSEL_CMPGTS
argument_list|,
name|SPE_BUILTIN_EVSEL_FSTSTEQ
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
call|)
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__ev64_opaque__"
argument_list|)
argument_list|,
name|opaque_V2SI_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize irregular SPE builtins.  */
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_mtspefscr"
argument_list|,
name|void_ftype_int
argument_list|,
name|SPE_BUILTIN_MTSPEFSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_mfspefscr"
argument_list|,
name|int_ftype_void
argument_list|,
name|SPE_BUILTIN_MFSPEFSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstddx"
argument_list|,
name|void_ftype_v2si_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVSTDDX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdhx"
argument_list|,
name|void_ftype_v2si_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVSTDHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdwx"
argument_list|,
name|void_ftype_v2si_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVSTDWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwhex"
argument_list|,
name|void_ftype_v2si_puint_int
argument_list|,
name|SPE_BUILTIN_EVSTWHEX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwhox"
argument_list|,
name|void_ftype_v2si_puint_int
argument_list|,
name|SPE_BUILTIN_EVSTWHOX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwwex"
argument_list|,
name|void_ftype_v2si_puint_int
argument_list|,
name|SPE_BUILTIN_EVSTWWEX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwwox"
argument_list|,
name|void_ftype_v2si_puint_int
argument_list|,
name|SPE_BUILTIN_EVSTWWOX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdd"
argument_list|,
name|void_ftype_v2si_pv2si_char
argument_list|,
name|SPE_BUILTIN_EVSTDD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdh"
argument_list|,
name|void_ftype_v2si_pv2si_char
argument_list|,
name|SPE_BUILTIN_EVSTDH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstdw"
argument_list|,
name|void_ftype_v2si_pv2si_char
argument_list|,
name|SPE_BUILTIN_EVSTDW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwhe"
argument_list|,
name|void_ftype_v2si_puint_char
argument_list|,
name|SPE_BUILTIN_EVSTWHE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwho"
argument_list|,
name|void_ftype_v2si_puint_char
argument_list|,
name|SPE_BUILTIN_EVSTWHO
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwwe"
argument_list|,
name|void_ftype_v2si_puint_char
argument_list|,
name|SPE_BUILTIN_EVSTWWE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evstwwo"
argument_list|,
name|void_ftype_v2si_puint_char
argument_list|,
name|SPE_BUILTIN_EVSTWWO
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evsplatfi"
argument_list|,
name|v2si_ftype_signed_char
argument_list|,
name|SPE_BUILTIN_EVSPLATFI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evsplati"
argument_list|,
name|v2si_ftype_signed_char
argument_list|,
name|SPE_BUILTIN_EVSPLATI
argument_list|)
expr_stmt|;
comment|/* Loads.  */
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlddx"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDDX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldwx"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldhx"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhex"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHEX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhoux"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHOUX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhosx"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHOSX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwwsplatx"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWWSPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhsplatx"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHSPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhesplatx"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHESPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhousplatx"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHOUSPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhossplatx"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHOSSPLATX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldd"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldw"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evldh"
argument_list|,
name|v2si_ftype_pv2si_int
argument_list|,
name|SPE_BUILTIN_EVLDH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhesplat"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHESPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhossplat"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHOSSPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlhhousplat"
argument_list|,
name|v2si_ftype_pushort_int
argument_list|,
name|SPE_BUILTIN_EVLHHOUSPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhe"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhos"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHOS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhou"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHOU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwhsplat"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWHSPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|target_flags
argument_list|,
literal|"__builtin_spe_evlwwsplat"
argument_list|,
name|v2si_ftype_puint_int
argument_list|,
name|SPE_BUILTIN_EVLWWSPLAT
argument_list|)
expr_stmt|;
comment|/* Predicates.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_predicates
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_predicates
argument_list|)
condition|;
operator|++
name|i
operator|,
name|d
operator|++
control|)
block|{
name|tree
name|type
decl_stmt|;
switch|switch
condition|(
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
condition|)
block|{
case|case
name|V2SImode
case|:
name|type
operator|=
name|int_ftype_int_v2si_v2si
expr_stmt|;
break|break;
case|case
name|V2SFmode
case|:
name|type
operator|=
name|int_ftype_int_v2sf_v2sf
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Evsel predicates.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_spe_evsel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_spe_evsel
argument_list|)
condition|;
operator|++
name|i
operator|,
name|d
operator|++
control|)
block|{
name|tree
name|type
decl_stmt|;
switch|switch
condition|(
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
condition|)
block|{
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_4_v2si
expr_stmt|;
break|break;
case|case
name|V2SFmode
case|:
name|type
operator|=
name|v2sf_ftype_4_v2sf
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|altivec_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|struct
name|builtin_description_predicates
modifier|*
name|dp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|ftype
decl_stmt|;
name|tree
name|pfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|float_type_node
argument_list|)
decl_stmt|;
name|tree
name|pint_type_node
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pshort_type_node
init|=
name|build_pointer_type
argument_list|(
name|short_integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|tree
name|pvoid_type_node
init|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|float_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pcint_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pcshort_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|short_integer_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pcchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pcvoid_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_opaque
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|opaque_ftype_opaque_int
init|=
name|build_function_type_list
argument_list|(
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|opaque_ftype_opaque_opaque_int
init|=
name|build_function_type_list
argument_list|(
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_opaque_opaque
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_pcfloat
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|pcfloat_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pfloat_v4sf
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pfloat_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_pcint
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|pcint_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pint_v4si
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pint_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_pcshort
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|pcshort_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pshort_v8hi
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pshort_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_pcchar
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|pcchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pchar_v16qi
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pchar_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v4si
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_void
init|=
name|build_function_type
argument_list|(
name|V8HI_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_int
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|opaque_ftype_long_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|opaque_V4SI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_long_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_long_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_long_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_opaque_long_pvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v4si_long_pvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v16qi_long_pvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v8hi_long_pvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|pvoid_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pcvoid_int_int
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pcvoid_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_4sf"
argument_list|,
name|v4sf_ftype_pcfloat
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_4sf
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_4sf"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_4sf
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_4si"
argument_list|,
name|v4si_ftype_pcint
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_4si
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_4si"
argument_list|,
name|void_ftype_pint_v4si
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_4si
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_8hi"
argument_list|,
name|v8hi_ftype_pcshort
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_8hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_8hi"
argument_list|,
name|void_ftype_pshort_v8hi
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_8hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_ld_internal_16qi"
argument_list|,
name|v16qi_ftype_pcchar
argument_list|,
name|ALTIVEC_BUILTIN_LD_INTERNAL_16qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_st_internal_16qi"
argument_list|,
name|void_ftype_pchar_v16qi
argument_list|,
name|ALTIVEC_BUILTIN_ST_INTERNAL_16qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_mtvscr"
argument_list|,
name|void_ftype_v4si
argument_list|,
name|ALTIVEC_BUILTIN_MTVSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_mfvscr"
argument_list|,
name|v8hi_ftype_void
argument_list|,
name|ALTIVEC_BUILTIN_MFVSCR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_dssall"
argument_list|,
name|void_ftype_void
argument_list|,
name|ALTIVEC_BUILTIN_DSSALL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_dss"
argument_list|,
name|void_ftype_int
argument_list|,
name|ALTIVEC_BUILTIN_DSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvsl"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVSL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvsr"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvebx"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEBX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvehx"
argument_list|,
name|v8hi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvewx"
argument_list|,
name|v4si_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVEWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvxl"
argument_list|,
name|v4si_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVXL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_lvx"
argument_list|,
name|v4si_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_LVX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvx"
argument_list|,
name|void_ftype_v4si_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvewx"
argument_list|,
name|void_ftype_v4si_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvxl"
argument_list|,
name|void_ftype_v4si_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVXL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvebx"
argument_list|,
name|void_ftype_v16qi_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEBX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_altivec_stvehx"
argument_list|,
name|void_ftype_v8hi_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_STVEHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ld"
argument_list|,
name|opaque_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_LD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_lde"
argument_list|,
name|opaque_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_LDE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ldl"
argument_list|,
name|opaque_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_LDL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_lvsl"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_LVSL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_lvsr"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_LVSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_lvebx"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_LVEBX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_lvehx"
argument_list|,
name|v8hi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_LVEHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_lvewx"
argument_list|,
name|v4si_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_LVEWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_st"
argument_list|,
name|void_ftype_opaque_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_ST
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ste"
argument_list|,
name|void_ftype_opaque_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_STE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_stl"
argument_list|,
name|void_ftype_opaque_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_STL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_stvewx"
argument_list|,
name|void_ftype_opaque_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_STVEWX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_stvebx"
argument_list|,
name|void_ftype_opaque_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_STVEBX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_stvehx"
argument_list|,
name|void_ftype_opaque_long_pvoid
argument_list|,
name|ALTIVEC_BUILTIN_VEC_STVEHX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_step"
argument_list|,
name|int_ftype_opaque
argument_list|,
name|ALTIVEC_BUILTIN_VEC_STEP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_sld"
argument_list|,
name|opaque_ftype_opaque_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_SLD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_splat"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_SPLAT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_vspltw"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_VSPLTW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_vsplth"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_VSPLTH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_vspltb"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_VSPLTB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ctf"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_CTF
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_vcfsx"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_VCFSX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_vcfux"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_VCFUX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_cts"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_CTS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ctu"
argument_list|,
name|opaque_ftype_opaque_int
argument_list|,
name|ALTIVEC_BUILTIN_VEC_CTU
argument_list|)
expr_stmt|;
comment|/* Add the DST variants.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_dst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_dst
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|void_ftype_pcvoid_int_int
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
comment|/* Initialize the predicates.  */
name|dp
operator|=
operator|(
expr|struct
name|builtin_description_predicates
operator|*
operator|)
name|bdesc_altivec_preds
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_altivec_preds
argument_list|)
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|bool
name|is_overloaded
init|=
name|dp
operator|->
name|code
operator|>=
name|ALTIVEC_BUILTIN_OVERLOADED_FIRST
operator|&&
name|dp
operator|->
name|code
operator|<=
name|ALTIVEC_BUILTIN_OVERLOADED_LAST
decl_stmt|;
if|if
condition|(
name|is_overloaded
condition|)
name|mode1
operator|=
name|VOIDmode
expr_stmt|;
else|else
name|mode1
operator|=
name|insn_data
index|[
name|dp
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode1
condition|)
block|{
case|case
name|VOIDmode
case|:
name|type
operator|=
name|int_ftype_int_opaque_opaque
expr_stmt|;
break|break;
case|case
name|V4SImode
case|:
name|type
operator|=
name|int_ftype_int_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|int_ftype_int_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|int_ftype_int_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|int_ftype_int_v4sf_v4sf
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|dp
operator|->
name|mask
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|dp
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the abs* operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_abs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_abs
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ALTIVEC
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Initialize target builtin that implements          targetm.vectorize.builtin_mask_for_load.  */
name|decl
operator|=
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
literal|"__builtin_altivec_mask_for_load"
argument_list|,
name|v16qi_ftype_long_pcvoid
argument_list|,
name|ALTIVEC_BUILTIN_MASK_FOR_LOAD
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"const"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the decl. Will be used by rs6000_builtin_mask_for_load.  */
name|altivec_builtin_mask_for_load
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Access to the vec_init patterns.  */
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_init_v4si"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_INIT_V4SI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_init_v8hi"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_INIT_V8HI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_init_v16qi"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_INIT_V16QI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|float_type_node
argument_list|,
name|float_type_node
argument_list|,
name|float_type_node
argument_list|,
name|float_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_init_v4sf"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_INIT_V4SF
argument_list|)
expr_stmt|;
comment|/* Access to the vec_set patterns.  */
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_set_v4si"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_SET_V4SI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|intHI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_set_v8hi"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_SET_V8HI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|intQI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_set_v16qi"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_SET_V16QI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|float_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_set_v4sf"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_SET_V4SF
argument_list|)
expr_stmt|;
comment|/* Access to the vec_extract patterns.  */
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ext_v4si"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_EXT_V4SI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|intHI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ext_v8hi"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_EXT_V8HI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|intQI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ext_v16qi"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_EXT_V16QI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|float_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_ALTIVEC
argument_list|,
literal|"__builtin_vec_ext_v4sf"
argument_list|,
name|ftype
argument_list|,
name|ALTIVEC_BUILTIN_VEC_EXT_V4SF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_common_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_int
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_v2si
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf_v2sf
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SF_type_node
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_int_int
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|opaque_ftype_opaque
init|=
name|build_function_type_list
argument_list|(
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SF_type_node
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SF_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2sf
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_char
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|opaque_V2SI_type_node
argument_list|,
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_int_char
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_char
init|=
name|build_function_type_list
argument_list|(
name|opaque_V2SI_type_node
argument_list|,
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int_int
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|opaque_ftype_opaque_opaque
init|=
name|build_function_type_list
argument_list|(
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4si_int
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_int
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi_int
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_int
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|opaque_ftype_opaque_opaque_opaque
init|=
name|build_function_type_list
argument_list|(
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|opaque_V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v8hi_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v16qi_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Add the simple ternary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_3arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_3arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|,
name|mode3
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|bool
name|is_overloaded
init|=
name|d
operator|->
name|code
operator|>=
name|ALTIVEC_BUILTIN_OVERLOADED_FIRST
operator|&&
name|d
operator|->
name|code
operator|<=
name|ALTIVEC_BUILTIN_OVERLOADED_LAST
decl_stmt|;
if|if
condition|(
name|is_overloaded
condition|)
block|{
name|mode0
operator|=
name|VOIDmode
expr_stmt|;
name|mode1
operator|=
name|VOIDmode
expr_stmt|;
name|mode2
operator|=
name|VOIDmode
expr_stmt|;
name|mode3
operator|=
name|VOIDmode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode3
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
block|}
comment|/* When all four are of the same mode.  */
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
operator|&&
name|mode2
operator|==
name|mode3
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|VOIDmode
case|:
name|type
operator|=
name|opaque_ftype_opaque_opaque_opaque
expr_stmt|;
break|break;
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_v16qi
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
operator|&&
name|mode3
operator|==
name|V16QImode
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si_v16qi
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_v16qi
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_v16qi
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v16qi_v4si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v8hi_v4si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|V4SFmode
operator|&&
name|mode3
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_v4si
expr_stmt|;
comment|/* vchar, vchar, vchar, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi_int
expr_stmt|;
comment|/* vshort, vshort, vshort, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi_int
expr_stmt|;
comment|/* vint, vint, vint, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4si_v4si_int
expr_stmt|;
comment|/* vfloat, vfloat, vfloat, 4 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|mode0
operator|&&
name|mode2
operator|==
name|mode0
operator|&&
name|mode3
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf_int
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the simple binary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_2arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|bool
name|is_overloaded
init|=
name|d
operator|->
name|code
operator|>=
name|ALTIVEC_BUILTIN_OVERLOADED_FIRST
operator|&&
name|d
operator|->
name|code
operator|<=
name|ALTIVEC_BUILTIN_OVERLOADED_LAST
decl_stmt|;
if|if
condition|(
name|is_overloaded
condition|)
block|{
name|mode0
operator|=
name|VOIDmode
expr_stmt|;
name|mode1
operator|=
name|VOIDmode
expr_stmt|;
name|mode2
operator|=
name|VOIDmode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
block|}
comment|/* When all three operands are of the same mode.  */
if|if
condition|(
name|mode0
operator|==
name|mode1
operator|&&
name|mode1
operator|==
name|mode2
condition|)
block|{
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|VOIDmode
case|:
name|type
operator|=
name|opaque_ftype_opaque_opaque
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_v2si_v2si
expr_stmt|;
break|break;
case|case
name|V2SFmode
case|:
name|type
operator|=
name|v2sf_ftype_v2sf_v2sf
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|type
operator|=
name|int_ftype_int_int
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* A few other combos we really don't want to do manually.  */
comment|/* vint, vfloat, vfloat.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|V4SFmode
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_v4sf
expr_stmt|;
comment|/* vshort, vchar, vchar.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v16qi_v16qi
expr_stmt|;
comment|/* vint, vshort, vshort.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v8hi
expr_stmt|;
comment|/* vshort, vint, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v8hi_ftype_v4si_v4si
expr_stmt|;
comment|/* vchar, vshort, vshort.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v16qi_ftype_v8hi_v8hi
expr_stmt|;
comment|/* vint, vchar, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v4si
expr_stmt|;
comment|/* vint, vchar, vchar.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v4si_ftype_v16qi_v16qi
expr_stmt|;
comment|/* vint, vshort, vint.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|V4SImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi_v4si
expr_stmt|;
comment|/* vint, vint, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4si_int
expr_stmt|;
comment|/* vshort, vshort, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V8HImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v8hi_int
expr_stmt|;
comment|/* vchar, vchar, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|V16QImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_v16qi_int
expr_stmt|;
comment|/* vfloat, vint, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4sf_ftype_v4si_int
expr_stmt|;
comment|/* vint, vfloat, 5 bit literal.  */
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V4SFmode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|SImode
operator|&&
name|mode2
operator|==
name|SImode
condition|)
name|type
operator|=
name|v2si_ftype_int_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|V2SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v2si_ftype_v2si_char
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|SImode
operator|&&
name|mode2
operator|==
name|QImode
condition|)
name|type
operator|=
name|v2si_ftype_int_char
expr_stmt|;
else|else
block|{
comment|/* int, x, x.  */
name|gcc_assert
argument_list|(
name|mode0
operator|==
name|SImode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode1
condition|)
block|{
case|case
name|V4SImode
case|:
name|type
operator|=
name|int_ftype_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|int_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
name|type
operator|=
name|int_ftype_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|int_ftype_v8hi_v8hi
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the simple unary operators.  */
name|d
operator|=
operator|(
expr|struct
name|builtin_description
operator|*
operator|)
name|bdesc_1arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|bool
name|is_overloaded
init|=
name|d
operator|->
name|code
operator|>=
name|ALTIVEC_BUILTIN_OVERLOADED_FIRST
operator|&&
name|d
operator|->
name|code
operator|<=
name|ALTIVEC_BUILTIN_OVERLOADED_LAST
decl_stmt|;
if|if
condition|(
name|is_overloaded
condition|)
block|{
name|mode0
operator|=
name|VOIDmode
expr_stmt|;
name|mode1
operator|=
name|VOIDmode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
name|mode0
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
block|}
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v4si_ftype_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v8hi_ftype_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V16QImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v16qi_ftype_int
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|VOIDmode
operator|&&
name|mode1
operator|==
name|VOIDmode
condition|)
name|type
operator|=
name|opaque_ftype_opaque
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SFmode
operator|&&
name|mode1
operator|==
name|V4SFmode
condition|)
name|type
operator|=
name|v4sf_ftype_v4sf
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V8HImode
operator|&&
name|mode1
operator|==
name|V16QImode
condition|)
name|type
operator|=
name|v8hi_ftype_v16qi
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V4SImode
operator|&&
name|mode1
operator|==
name|V8HImode
condition|)
name|type
operator|=
name|v4si_ftype_v8hi
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|V2SImode
condition|)
name|type
operator|=
name|v2si_ftype_v2si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SFmode
operator|&&
name|mode1
operator|==
name|V2SFmode
condition|)
name|type
operator|=
name|v2sf_ftype_v2sf
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SFmode
operator|&&
name|mode1
operator|==
name|V2SImode
condition|)
name|type
operator|=
name|v2sf_ftype_v2si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|V2SFmode
condition|)
name|type
operator|=
name|v2si_ftype_v2sf
expr_stmt|;
elseif|else
if|if
condition|(
name|mode0
operator|==
name|V2SImode
operator|&&
name|mode1
operator|==
name|QImode
condition|)
name|type
operator|=
name|v2si_ftype_char
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|!=
name|ABI_V4
operator|&&
name|TARGET_XCOFF
operator|&&
operator|!
name|TARGET_POWER2
operator|&&
operator|!
name|TARGET_POWERPC
condition|)
block|{
comment|/* AIX library routines for float->int conversion.  */
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|DFmode
argument_list|,
literal|"__itrunc"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|DFmode
argument_list|,
literal|"__uitrunc"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_qitrunc"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_quitrunc"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_IEEEQUAD
condition|)
comment|/* AIX/Darwin/64-bit Linux quad floating point routines.  */
if|if
condition|(
operator|!
name|TARGET_XL_COMPAT
condition|)
block|{
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qadd"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qsub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qmul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qdiv"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SOFT_FLOAT
condition|)
block|{
name|set_optab_libfunc
argument_list|(
name|neg_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qneg"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qeq"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qne"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qgt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qge"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qlt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qle"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|unord_optab
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qunord"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|SFmode
argument_list|,
literal|"__gcc_stoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|DFmode
argument_list|,
literal|"__gcc_dtoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|SFmode
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qtos"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|DFmode
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qtod"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qtoi"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"__gcc_qtou"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"__gcc_itoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"__gcc_utoq"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_xlqadd"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_xlqsub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_xlqmul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_xlqdiv"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 32-bit SVR4 quad floating point routines.  */
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_add"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_sub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|neg_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_neg"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_mul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_div"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_PPC_GPOPT
operator|||
name|TARGET_POWER2
condition|)
name|set_optab_libfunc
argument_list|(
name|sqrt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_sqrt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_feq"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_fne"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_fgt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_fge"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_flt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_q_fle"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|SFmode
argument_list|,
literal|"_q_stoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|DFmode
argument_list|,
literal|"_q_dtoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|SFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_q_qtos"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|DFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_q_qtod"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_q_qtoi"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_q_qtou"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"_q_itoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"_q_utoq"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a block clear operation, and return 1 if successful.  Return 0    if we should let the compiler generate normal code.     operands[0] is the destination    operands[1] is the length    operands[3] is the alignment */
end_comment

begin_function
name|int
name|expand_block_clear
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|orig_dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|bool
name|constp
init|=
operator|(
name|GET_CODE
argument_list|(
name|bytes_rtx
argument_list|)
operator|==
name|CONST_INT
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|align
decl_stmt|;
name|HOST_WIDE_INT
name|bytes
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|clear_bytes
decl_stmt|;
name|int
name|clear_step
decl_stmt|;
comment|/* If this is not a fixed size move, just call memcpy */
if|if
condition|(
operator|!
name|constp
condition|)
return|return
literal|0
return|;
comment|/* This must be a fixed size alignment  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Anything to clear? */
name|bytes
operator|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Use the builtin memset after a point, to avoid huge code bloat.      When optimize_size, avoid any significant code bloat; calling      memset is about 4 instructions, so allow for one instruction to      load zero and three to do clearing.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|align
operator|>=
literal|128
condition|)
name|clear_step
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_POWERPC64
operator|&&
name|align
operator|>=
literal|32
condition|)
name|clear_step
operator|=
literal|8
expr_stmt|;
else|else
name|clear_step
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|optimize_size
operator|&&
name|bytes
operator|>
literal|3
operator|*
name|clear_step
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|bytes
operator|>
literal|8
operator|*
name|clear_step
condition|)
return|return
literal|0
return|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|bytes
operator|>
literal|0
condition|;
name|offset
operator|+=
name|clear_bytes
operator|,
name|bytes
operator|-=
name|clear_bytes
control|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|BLKmode
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|16
operator|&&
name|TARGET_ALTIVEC
operator|&&
name|align
operator|>=
literal|128
condition|)
block|{
name|clear_bytes
operator|=
literal|16
expr_stmt|;
name|mode
operator|=
name|V4SImode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|8
operator|&&
name|TARGET_POWERPC64
comment|/* 64-bit loads and stores require word-aligned 	     displacements.  */
operator|&&
operator|(
name|align
operator|>=
literal|64
operator|||
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|&&
name|align
operator|>=
literal|32
operator|)
operator|)
condition|)
block|{
name|clear_bytes
operator|=
literal|8
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|4
operator|&&
operator|(
name|align
operator|>=
literal|32
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
comment|/* move 4 bytes */
name|clear_bytes
operator|=
literal|4
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|2
operator|&&
operator|(
name|align
operator|>=
literal|16
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
comment|/* move 2 bytes */
name|clear_bytes
operator|=
literal|2
expr_stmt|;
name|mode
operator|=
name|HImode
expr_stmt|;
block|}
else|else
comment|/* move 1 byte at a time */
block|{
name|clear_bytes
operator|=
literal|1
expr_stmt|;
name|mode
operator|=
name|QImode
expr_stmt|;
block|}
name|dest
operator|=
name|adjust_address
argument_list|(
name|orig_dest
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a block move operation, and return 1 if successful.  Return 0    if we should let the compiler generate normal code.     operands[0] is the destination    operands[1] is the source    operands[2] is the length    operands[3] is the alignment */
end_comment

begin_define
define|#
directive|define
name|MAX_MOVE_REG
value|4
end_define

begin_function
name|int
name|expand_block_move
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|orig_dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|orig_src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|bytes_rtx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|align_rtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|constp
init|=
operator|(
name|GET_CODE
argument_list|(
name|bytes_rtx
argument_list|)
operator|==
name|CONST_INT
operator|)
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|move_bytes
decl_stmt|;
name|rtx
name|stores
index|[
name|MAX_MOVE_REG
index|]
decl_stmt|;
name|int
name|num_reg
init|=
literal|0
decl_stmt|;
comment|/* If this is not a fixed size move, just call memcpy */
if|if
condition|(
operator|!
name|constp
condition|)
return|return
literal|0
return|;
comment|/* This must be a fixed size alignment */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Anything to move? */
name|bytes
operator|=
name|INTVAL
argument_list|(
name|bytes_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* store_one_arg depends on expand_block_move to handle at least the size of      reg_parm_stack_space.  */
if|if
condition|(
name|bytes
operator|>
operator|(
name|TARGET_POWERPC64
condition|?
literal|64
else|:
literal|32
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|bytes
operator|>
literal|0
condition|;
name|offset
operator|+=
name|move_bytes
operator|,
name|bytes
operator|-=
name|move_bytes
control|)
block|{
union|union
block|{
name|rtx
function_decl|(
modifier|*
name|movmemsi
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|mov
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
block|}
name|gen_func
union|;
name|enum
name|machine_mode
name|mode
init|=
name|BLKmode
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
comment|/* Altivec first, since it will be faster than a string move 	 when it applies, and usually not significantly larger.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|bytes
operator|>=
literal|16
operator|&&
name|align
operator|>=
literal|128
condition|)
block|{
name|move_bytes
operator|=
literal|16
expr_stmt|;
name|mode
operator|=
name|V4SImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movv4si
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|24
comment|/* move up to 32 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|9
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|10
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|11
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|12
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|32
operator|)
condition|?
literal|32
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movmemsi
operator|=
name|gen_movmemsi_8reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|16
comment|/* move up to 24 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|9
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|10
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|24
operator|)
condition|?
literal|24
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movmemsi
operator|=
name|gen_movmemsi_6reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|8
comment|/* move up to 16 bytes at a time */
operator|&&
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|6
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|7
index|]
operator|&&
operator|!
name|fixed_regs
index|[
literal|8
index|]
condition|)
block|{
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|16
operator|)
condition|?
literal|16
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movmemsi
operator|=
name|gen_movmemsi_4reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|8
operator|&&
name|TARGET_POWERPC64
comment|/* 64-bit loads and stores require word-aligned 		  displacements.  */
operator|&&
operator|(
name|align
operator|>=
literal|64
operator|||
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|&&
name|align
operator|>=
literal|32
operator|)
operator|)
condition|)
block|{
name|move_bytes
operator|=
literal|8
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movdi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|4
operator|&&
operator|!
name|TARGET_POWERPC64
condition|)
block|{
comment|/* move up to 8 bytes at a time */
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|8
operator|)
condition|?
literal|8
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movmemsi
operator|=
name|gen_movmemsi_2reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|4
operator|&&
operator|(
name|align
operator|>=
literal|32
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
comment|/* move 4 bytes */
name|move_bytes
operator|=
literal|4
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movsi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
literal|2
operator|&&
operator|(
name|align
operator|>=
literal|16
operator|||
operator|!
name|STRICT_ALIGNMENT
operator|)
condition|)
block|{
comment|/* move 2 bytes */
name|move_bytes
operator|=
literal|2
expr_stmt|;
name|mode
operator|=
name|HImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movhi
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_STRING
operator|&&
name|bytes
operator|>
literal|1
condition|)
block|{
comment|/* move up to 4 bytes at a time */
name|move_bytes
operator|=
operator|(
name|bytes
operator|>
literal|4
operator|)
condition|?
literal|4
else|:
name|bytes
expr_stmt|;
name|gen_func
operator|.
name|movmemsi
operator|=
name|gen_movmemsi_1reg
expr_stmt|;
block|}
else|else
comment|/* move 1 byte at a time */
block|{
name|move_bytes
operator|=
literal|1
expr_stmt|;
name|mode
operator|=
name|QImode
expr_stmt|;
name|gen_func
operator|.
name|mov
operator|=
name|gen_movqi
expr_stmt|;
block|}
name|src
operator|=
name|adjust_address
argument_list|(
name|orig_src
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dest
operator|=
name|adjust_address
argument_list|(
name|orig_dest
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|rtx
name|tmp_reg
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_func
operator|.
name|mov
call|)
argument_list|(
name|tmp_reg
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|stores
index|[
name|num_reg
operator|++
index|]
operator|=
call|(
modifier|*
name|gen_func
operator|.
name|mov
call|)
argument_list|(
name|dest
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
name|num_reg
operator|>=
name|MAX_MOVE_REG
operator|||
name|bytes
operator|==
name|move_bytes
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_reg
condition|;
name|i
operator|++
control|)
name|emit_insn
argument_list|(
name|stores
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|num_reg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* Move the address into scratch registers.  The movmemsi 	     patterns require zero offset.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src_reg
init|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|src
operator|=
name|replace_equiv_address
argument_list|(
name|src
argument_list|,
name|src_reg
argument_list|)
expr_stmt|;
block|}
name|set_mem_size
argument_list|(
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|dest_reg
init|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|dest
operator|=
name|replace_equiv_address
argument_list|(
name|dest
argument_list|,
name|dest_reg
argument_list|)
expr_stmt|;
block|}
name|set_mem_size
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_func
operator|.
name|movmemsi
call|)
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|move_bytes
operator|&
literal|31
argument_list|)
argument_list|,
name|align_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a string to perform a load_multiple operation.    operands[0] is the vector.    operands[1] is the source address.    operands[2] is the first destination register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|rs6000_output_load_multiple
parameter_list|(
name|rtx
name|operands
index|[
literal|3
index|]
parameter_list|)
block|{
comment|/* We have to handle the case where the pseudo used to contain the address      is assigned to one of the output registers.  */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|words
init|=
name|XVECLEN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|"{l|lwz} %2,0(%1)"
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
name|i
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|words
operator|-
literal|1
condition|)
block|{
name|xop
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
literal|4
operator|*
operator|(
name|words
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xop
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xop
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"{lsi|lswi} %2,%1,%0\n\t{l|lwz} %1,%0(%1)"
argument_list|,
name|xop
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|xop
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
literal|4
operator|*
operator|(
name|words
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xop
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xop
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"{cal %1,4(%1)|addi %1,%1,4}\n\t{lsi|lswi} %2,%1,%0\n\t{l|lwz} %1,-4(%1)"
argument_list|,
name|xop
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|words
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
name|i
condition|)
block|{
name|xop
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|j
operator|*
literal|4
argument_list|)
expr_stmt|;
name|xop
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xop
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
name|j
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"{l|lwz} %2,%0(%1)"
argument_list|,
name|xop
argument_list|)
expr_stmt|;
block|}
name|xop
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|xop
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"{l|lwz} %1,%0(%1)"
argument_list|,
name|xop
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
return|return
literal|"{lsi|lswi} %2,%1,%N0"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A validation routine: say whether CODE, a condition code, and MODE    match.  The other alternatives either don't make sense or should    never be generated.  */
end_comment

begin_function
name|void
name|validate_condition_mode
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMPARE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_COMPARE
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
argument_list|)
expr_stmt|;
comment|/* These don't make sense.  */
name|gcc_assert
argument_list|(
operator|(
name|code
operator|!=
name|GT
operator|&&
name|code
operator|!=
name|LT
operator|&&
name|code
operator|!=
name|GE
operator|&&
name|code
operator|!=
name|LE
operator|)
operator|||
name|mode
operator|!=
name|CCUNSmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|code
operator|!=
name|GTU
operator|&&
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LEU
operator|)
operator|||
name|mode
operator|==
name|CCUNSmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode
operator|==
name|CCFPmode
operator|||
operator|(
name|code
operator|!=
name|ORDERED
operator|&&
name|code
operator|!=
name|UNORDERED
operator|&&
name|code
operator|!=
name|UNEQ
operator|&&
name|code
operator|!=
name|LTGT
operator|&&
name|code
operator|!=
name|UNGT
operator|&&
name|code
operator|!=
name|UNLT
operator|&&
name|code
operator|!=
name|UNGE
operator|&&
name|code
operator|!=
name|UNLE
operator|)
argument_list|)
expr_stmt|;
comment|/* These should never be generated except for      flag_finite_math_only.  */
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|CCFPmode
operator|||
name|flag_finite_math_only
operator|||
operator|(
name|code
operator|!=
name|LE
operator|&&
name|code
operator|!=
name|GE
operator|&&
name|code
operator|!=
name|UNEQ
operator|&&
name|code
operator|!=
name|LTGT
operator|&&
name|code
operator|!=
name|UNGT
operator|&&
name|code
operator|!=
name|UNLT
operator|)
argument_list|)
expr_stmt|;
comment|/* These are invalid; the information is not there.  */
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|CCEQmode
operator|||
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if ANDOP is a mask that has no bits on that are not in the    mask required to convert the result of a rotate insn into a shift    left insn of SHIFTOP bits.  Both are known to be SImode CONST_INT.  */
end_comment

begin_function
name|int
name|includes_lshift_p
parameter_list|(
name|rtx
name|shiftop
parameter_list|,
name|rtx
name|andop
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
decl_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTVAL
argument_list|(
name|andop
argument_list|)
operator|&
literal|0xffffffff
operator|&
operator|~
name|shift_mask
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar, but for right shift.  */
end_comment

begin_function
name|int
name|includes_rshift_p
parameter_list|(
name|rtx
name|shiftop
parameter_list|,
name|rtx
name|andop
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
decl_stmt|;
name|shift_mask
operator|>>=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTVAL
argument_list|(
name|andop
argument_list|)
operator|&
literal|0xffffffff
operator|&
operator|~
name|shift_mask
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ANDOP is a mask suitable for use with an rldic insn    to perform a left shift.  It must have exactly SHIFTOP least    significant 0's, then one or more 1's, then zero or more 0's.  */
end_comment

begin_function
name|int
name|includes_rldic_lshift_p
parameter_list|(
name|rtx
name|shiftop
parameter_list|,
name|rtx
name|andop
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask
decl_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
operator|~
literal|0
condition|)
return|return
literal|0
return|;
name|shift_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
comment|/* Find the least significant one bit.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* It must coincide with the LSB of the shift mask.  */
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask
condition|)
return|return
literal|0
return|;
comment|/* Invert to look for the next transition (if any).  */
name|c
operator|=
operator|~
name|c
expr_stmt|;
comment|/* Remove the low group of ones (originally low group of zeros).  */
name|c
operator|&=
operator|-
name|lsb
expr_stmt|;
comment|/* Again find the lsb, and check we have all 1's above.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
return|return
name|c
operator|==
operator|-
name|lsb
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|DImode
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|,
name|lsb
decl_stmt|;
name|HOST_WIDE_INT
name|shift_mask_low
decl_stmt|,
name|shift_mask_high
decl_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|low
operator|==
operator|~
literal|0
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
operator|~
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|&&
name|low
operator|==
literal|0
condition|)
block|{
name|shift_mask_high
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|>
literal|32
condition|)
name|shift_mask_high
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|-
literal|32
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask_high
operator|||
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
name|high
operator|=
operator|~
name|high
expr_stmt|;
name|high
operator|&=
operator|-
name|lsb
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
name|shift_mask_low
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask_low
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
if|if
condition|(
operator|-
name|lsb
operator|!=
name|shift_mask_low
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
name|high
operator|=
operator|~
name|high
expr_stmt|;
name|low
operator|=
operator|~
name|low
expr_stmt|;
name|low
operator|&=
operator|-
name|lsb
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|&&
name|low
operator|==
literal|0
condition|)
block|{
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
return|return
name|low
operator|==
operator|-
name|lsb
operator|&&
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
operator|||
name|high
operator|==
operator|~
literal|0
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ANDOP is a mask suitable for use with an rldicr insn    to perform a left shift.  It must have SHIFTOP or more least    significant 0's, with the remainder of the word 1's.  */
end_comment

begin_function
name|int
name|includes_rldicr_lshift_p
parameter_list|(
name|rtx
name|shiftop
parameter_list|,
name|rtx
name|andop
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|c
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask
decl_stmt|;
name|shift_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|c
operator|=
name|INTVAL
argument_list|(
name|andop
argument_list|)
expr_stmt|;
comment|/* Find the least significant one bit.  */
name|lsb
operator|=
name|c
operator|&
operator|-
name|c
expr_stmt|;
comment|/* It must be covered by the shift mask. 	 This test also rejects c == 0.  */
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check we have all 1's above the transition, and reject all 1's.  */
return|return
name|c
operator|==
operator|-
name|lsb
operator|&&
name|lsb
operator|!=
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|andop
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|andop
argument_list|)
operator|==
name|DImode
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|lsb
decl_stmt|,
name|shift_mask_low
decl_stmt|;
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
condition|)
block|{
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|shift_mask_high
decl_stmt|;
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|andop
argument_list|)
expr_stmt|;
if|if
condition|(
name|low
operator|==
literal|0
condition|)
block|{
name|shift_mask_high
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|>
literal|32
condition|)
name|shift_mask_high
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|-
literal|32
expr_stmt|;
name|lsb
operator|=
name|high
operator|&
operator|-
name|high
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask_high
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|high
operator|==
operator|-
name|lsb
return|;
block|}
if|if
condition|(
name|high
operator|!=
operator|~
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|shift_mask_low
operator|=
operator|~
literal|0
expr_stmt|;
name|shift_mask_low
operator|<<=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|low
operator|&
operator|-
name|low
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|&
name|shift_mask_low
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|low
operator|==
operator|-
name|lsb
operator|&&
name|lsb
operator|!=
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if operands will generate a valid arguments to rlwimi instruction for insert with right shift in 64-bit mode.  The mask may not start on the first bit or stop on the last bit because wrap-around effects of instruction do not correspond to semantics of RTL insn.  */
end_comment

begin_function
name|int
name|insvdi_rshift_rlwimi_p
parameter_list|(
name|rtx
name|sizeop
parameter_list|,
name|rtx
name|startop
parameter_list|,
name|rtx
name|shiftop
parameter_list|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|startop
argument_list|)
operator|>
literal|32
operator|&&
name|INTVAL
argument_list|(
name|startop
argument_list|)
operator|<
literal|64
operator|&&
name|INTVAL
argument_list|(
name|sizeop
argument_list|)
operator|>
literal|1
operator|&&
name|INTVAL
argument_list|(
name|sizeop
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|startop
argument_list|)
operator|<
literal|64
operator|&&
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|sizeop
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|<
literal|32
operator|&&
operator|(
literal|64
operator|-
operator|(
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|&
literal|63
operator|)
operator|)
operator|>=
name|INTVAL
argument_list|(
name|sizeop
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if REGNO (reg1) == REGNO (reg2) - 1 making them candidates    for lfq and stfq insns iff the registers are hard registers.   */
end_comment

begin_function
name|int
name|registers_ok_for_quad_peep
parameter_list|(
name|rtx
name|reg1
parameter_list|,
name|rtx
name|reg2
parameter_list|)
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* We might have been passed non floating point registers.  */
if|if
condition|(
operator|!
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
argument_list|)
operator|||
operator|!
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg2
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if addr1 and addr2 are suitable for lfq or stfq insn.    addr1 and addr2 must be in consecutive memory locations    (addr2 == addr1 + 8).  */
end_comment

begin_function
name|int
name|mems_ok_for_quad_peep
parameter_list|(
name|rtx
name|mem1
parameter_list|,
name|rtx
name|mem2
parameter_list|)
block|{
name|rtx
name|addr1
decl_stmt|,
name|addr2
decl_stmt|;
name|unsigned
name|int
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
name|int
name|offset1
decl_stmt|,
name|offset2
decl_stmt|;
comment|/* The mems cannot be volatile.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|mem1
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|mem2
argument_list|)
condition|)
return|return
literal|0
return|;
name|addr1
operator|=
name|XEXP
argument_list|(
name|mem1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|XEXP
argument_list|(
name|mem2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Extract an offset (if used) from the first addr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* If not a REG, return zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset must be constant!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
comment|/* This was a simple (mem (reg)) expression.  Offset is 0.  */
name|offset1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* And now for the second addr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* If not a REG, return zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg2
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset must be constant. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset2
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg2
operator|=
name|REGNO
argument_list|(
name|addr2
argument_list|)
expr_stmt|;
comment|/* This was a simple (mem (reg)) expression.  Offset is 0.  */
name|offset2
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Both of these must have the same base register.  */
if|if
condition|(
name|reg1
operator|!=
name|reg2
condition|)
return|return
literal|0
return|;
comment|/* The offset for the second addr must be 8 more than the first addr.  */
if|if
condition|(
name|offset2
operator|!=
name|offset1
operator|+
literal|8
condition|)
return|return
literal|0
return|;
comment|/* All the tests passed.  addr1 and addr2 are valid for lfq or stfq      instructions.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the register class of a scratch register needed to copy IN into    or out of a register in CLASS in MODE.  If it can be done directly,    NO_REGS is returned.  */
end_comment

begin_function
name|enum
name|reg_class
name|rs6000_secondary_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
if|#
directive|if
name|TARGET_MACHO
operator|&&
name|MACHOPIC_INDIRECT
endif|#
directive|endif
operator|)
condition|)
block|{
comment|/* We cannot copy a symbolic operand directly into anything 	 other than BASE_REGS for TARGET_ELF.  So indicate that a 	 register from BASE_REGS is needed as an intermediate 	 register.  	 On Darwin, pic addresses require a load from memory, which 	 needs a base register.  */
if|if
condition|(
name|class
operator|!=
name|BASE_REGS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|HIGH
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|CONST
operator|)
condition|)
return|return
name|BASE_REGS
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|regno
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We can place anything into GENERAL_REGS and can put GENERAL_REGS      into anything.  */
if|if
condition|(
name|class
operator|==
name|GENERAL_REGS
operator|||
name|class
operator|==
name|BASE_REGS
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|INT_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Constants, memory, and FP registers can go into FP registers.  */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|&&
operator|(
name|class
operator|==
name|FLOAT_REGS
operator|||
name|class
operator|==
name|NON_SPECIAL_REGS
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Memory, and AltiVec registers can go into AltiVec registers.  */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|ALTIVEC_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|&&
name|class
operator|==
name|ALTIVEC_REGS
condition|)
return|return
name|NO_REGS
return|;
comment|/* We can copy among the CR registers.  */
if|if
condition|(
operator|(
name|class
operator|==
name|CR_REGS
operator|||
name|class
operator|==
name|CR0_REGS
operator|)
operator|&&
name|regno
operator|>=
literal|0
operator|&&
name|CR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Otherwise, we need GENERAL_REGS.  */
return|return
name|GENERAL_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison operation, return the bit number in CCR to test.  We    know this is a valid comparison.     SCC_P is 1 if this is for an scc.  That means that %D will have been    used instead of %C, so the bits will be in different places.     Return -1 if OP isn't a valid comparison for some reason.  */
end_comment

begin_function
name|int
name|ccr_bit
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|scc_p
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
name|int
name|cc_regnum
decl_stmt|;
name|int
name|base_bit
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|cc_regnum
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|base_bit
operator|=
literal|4
operator|*
operator|(
name|cc_regnum
operator|-
name|CR0_REGNO
operator|)
expr_stmt|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|cc_mode
argument_list|)
expr_stmt|;
comment|/* When generating a sCOND operation, only positive conditions are      allowed.  */
name|gcc_assert
argument_list|(
operator|!
name|scc_p
operator|||
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
operator|+
literal|2
return|;
case|case
name|EQ
case|:
return|return
name|base_bit
operator|+
literal|2
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNLE
case|:
return|return
name|base_bit
operator|+
literal|1
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNGE
case|:
return|return
name|base_bit
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
return|return
name|base_bit
operator|+
literal|3
return|;
case|case
name|GE
case|:
case|case
name|GEU
case|:
comment|/* If scc, we will have done a cror to put the bit in the 	 unordered position.  So test that bit.  For integer, this is ! LT 	 unless this is an scc insn.  */
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
return|;
case|case
name|LE
case|:
case|case
name|LEU
case|:
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
operator|+
literal|1
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the GOT register.  */
end_comment

begin_function
name|rtx
name|rs6000_got_register
parameter_list|(
name|rtx
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* The second flow pass currently (June 1999) can't update      regs_ever_live without disturbing other parts of the compiler, so      update it here to make the prolog/epilogue code happy.  */
if|if
condition|(
name|no_new_pseudos
operator|&&
operator|!
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|pic_offset_table_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to init struct machine_function.    This will be called, via a pointer variable,    from push_function_context.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|rs6000_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These macros test for integers and extract the low-order bits.  */
end_comment

begin_define
define|#
directive|define
name|INT_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)	\&& GET_MODE (X) == VOIDmode)
end_define

begin_define
define|#
directive|define
name|INT_LOWPART
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))
end_define

begin_function
name|int
name|extract_MB
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|INT_LOWPART
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* If the high bit is zero, the value is the first 1 bit we find      from the left.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
name|val
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
operator|++
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* If the high bit is set and the low bit is not, or the mask is all      1's, the value is zero.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0xffffffff
condition|)
return|return
literal|0
return|;
comment|/* Otherwise we have a wrap-around mask.  Look for the first 0 bit      from the right.  */
name|i
operator|=
literal|31
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|extract_ME
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|INT_LOWPART
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* If the low bit is zero, the value is the first 1 bit we find from      the right.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
name|val
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|i
operator|=
literal|30
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
operator|--
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* If the low bit is set and the high bit is not, or the mask is all      1's, the value is 31.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|||
operator|(
name|val
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0xffffffff
condition|)
return|return
literal|31
return|;
comment|/* Otherwise we have a wrap-around mask.  Look for the first 0 bit      from the left.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
operator|++
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in some tls_ld pattern.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|rs6000_get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for rs6000_get_some_local_dynamic_name.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|str
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out a function code label.  */
end_comment

begin_function
name|void
name|rs6000_output_function_entry
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
if|if
condition|(
name|DOT_SYMBOLS
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"L."
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
case|case
name|ABI_DARWIN
case|:
break|break;
block|}
block|}
if|if
condition|(
name|TARGET_AIX
condition|)
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_define
define|#
directive|define
name|SMALL_DATA_RELOC
value|((rs6000_sdata == SDATA_EABI) ? "sda21" : "sdarel")
end_define

begin_define
define|#
directive|define
name|SMALL_DATA_REG
value|((rs6000_sdata == SDATA_EABI) ? 0 : 13)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SMALL_DATA_RELOC
value|"sda21"
end_define

begin_define
define|#
directive|define
name|SMALL_DATA_REG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|uval
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Write out an instruction after the call which may be replaced 	 with glue code by the loader.  This depends on the AIX version.  */
name|asm_fprintf
argument_list|(
name|file
argument_list|,
name|RS6000_CALL_GLUE
argument_list|)
expr_stmt|;
return|return;
comment|/* %a is output_address.  */
case|case
literal|'A'
case|:
comment|/* If X is a constant integer whose low-order 5 bits are zero, 	 write 'l'.  Otherwise, write 'r'.  This is a kludge to fix a bug 	 in the AIX assembler where "sri" with a zero shift count 	 writes a trash instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|31
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'r'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'b'
case|:
comment|/* If constant, low-order 16 bits of constant, unsigned. 	 Otherwise, write normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
comment|/* If the low-order bit is zero, write 'r'; otherwise, write 'l' 	 for 64-bit mask direction.  */
name|putc
argument_list|(
operator|(
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
literal|'r'
else|:
literal|'l'
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise 	 output_operand.  */
case|case
literal|'c'
case|:
comment|/* X is a CR register.  Print the number of the GT bit of the CR.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
comment|/* Like 'J' but get to the GT bit only.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
comment|/* Bit 1 is GT bit.  */
name|i
operator|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Add one for shift count in rlinm for scc.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'E'
case|:
comment|/* X is a CR register.  Print the number of the EQ bit of the CR */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'f'
case|:
comment|/* X is a CR register.  Print the shift count needed to move it 	 to the high-order four bits.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%f value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* Similar, but print the count for the rotate in the opposite 	 direction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%F value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|32
operator|-
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'G'
case|:
comment|/* X is a constant integer.  If it is negative, print "m", 	 otherwise print "z".  This is to make an aze or ame insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%G value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
condition|)
name|putc
argument_list|(
literal|'z'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'m'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'h'
case|:
comment|/* If constant, output low-order five bits.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|31
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* If constant, output low-order six bits.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|63
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
comment|/* Print `i' if this is a constant, else nothing.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|putc
argument_list|(
literal|'i'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'j'
case|:
comment|/* Write the bit number in CCR for jump.  */
name|i
operator|=
name|ccr_bit
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%j code"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
comment|/* Similar, but add one for shift count in rlinm for scc and pass 	 scc flag to `ccr_bit'.  */
name|i
operator|=
name|ccr_bit
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%J code"
argument_list|)
expr_stmt|;
else|else
comment|/* If we want bit 31, write a shift count of zero, not 32.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|==
literal|31
condition|?
literal|0
else|:
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'k'
case|:
comment|/* X must be a constant.  Write the 1's complement of the 	 constant.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%k value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|~
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'K'
case|:
comment|/* X must be a symbolic constant on ELF.  Write an 	 expression suitable for an 'addi' that adds in the low 16 	 bits of the MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
block|{
name|print_operand_address
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%K value"
argument_list|)
expr_stmt|;
name|print_operand_address
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* For GNU as, there must be a non-alphanumeric character 	     between 'l' and the number.  The '-' is added by 	     print_operand() already.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fputs
argument_list|(
literal|"+"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_operand
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* %l is output_asm_label.  */
case|case
literal|'L'
case|:
comment|/* Write second word of DImode or DFmode reference.  Works on register 	 or non-indexed memory only.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Handle possible auto-increment.  Since it is pre-increment and 	     we have already done it, we can just use an offset of word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'m'
case|:
comment|/* MB value for a mask operand.  */
if|if
condition|(
operator|!
name|mask_operand
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|extract_MB
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
comment|/* ME value for a mask operand.  */
if|if
condition|(
operator|!
name|mask_operand
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|extract_ME
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* %n outputs the negative of its operand.  */
case|case
literal|'N'
case|:
comment|/* Write the number of elements in the vector times 4.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
comment|/* Similar, but subtract 1 first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%O value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'p'
case|:
comment|/* X is a CONST_INT that is a power of two.  Output the logarithm.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
operator|||
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%p value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
comment|/* The operand must be an indirect memory reference.  The result 	 is the register name.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|32
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'q'
case|:
comment|/* This outputs the logical code corresponding to a boolean 	 expression.  The expression may have one or both operands 	 negated (if one, only the first one).  For condition register 	 logical operations, it will also treat the negated 	 CR codes as NOTs, but not handle NOTs of them.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|t
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tbl
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|"and"
block|,
literal|"andc"
block|,
literal|"nor"
block|}
block|,
block|{
literal|"or"
block|,
literal|"orc"
block|,
literal|"nand"
block|}
block|,
block|{
literal|"xor"
block|,
literal|"eqv"
block|,
literal|"xor"
block|}
block|}
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|AND
condition|)
name|t
operator|=
name|tbl
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|IOR
condition|)
name|t
operator|=
name|tbl
index|[
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|XOR
condition|)
name|t
operator|=
name|tbl
index|[
literal|2
index|]
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%q value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOT
condition|)
name|s
operator|=
name|t
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
name|s
operator|=
name|t
index|[
literal|2
index|]
expr_stmt|;
else|else
name|s
operator|=
name|t
index|[
literal|1
index|]
expr_stmt|;
block|}
name|fputs
argument_list|(
name|s
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'Q'
case|:
if|if
condition|(
name|TARGET_MFCRF
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
else|else
return|return;
case|case
literal|'R'
case|:
comment|/* X is a CR register.  Print the mask for `mtcrf'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|128
operator|>>
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
comment|/* Low 5 bits of 32 - value */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
literal|32
operator|-
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|)
operator|&
literal|31
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* PowerPC64 mask position.  All 0's is excluded. 	 CONST_INT 32-bit mask is considered sign-extended so any 	 transition must occur within the CONST_INT, not on the boundary.  */
if|if
condition|(
operator|!
name|mask64_operand
argument_list|(
name|x
argument_list|,
name|DImode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%S value"
argument_list|)
expr_stmt|;
name|uval
operator|=
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|uval
operator|&
literal|1
condition|)
comment|/* Clear Left */
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|64
name|uval
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|64
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|64
expr_stmt|;
block|}
else|else
comment|/* Clear Right */
block|{
name|uval
operator|=
operator|~
name|uval
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|64
name|uval
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|64
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|63
expr_stmt|;
block|}
while|while
condition|(
name|uval
operator|!=
literal|0
condition|)
operator|--
name|i
operator|,
name|uval
operator|>>=
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
name|i
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'t'
case|:
comment|/* Like 'J' but get to the OVERFLOW/UNORDERED bit.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|CCmode
argument_list|)
expr_stmt|;
comment|/* Bit 3 is OV bit.  */
name|i
operator|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|3
expr_stmt|;
comment|/* If we want bit 31, write a shift count of zero, not 32.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|==
literal|31
condition|?
literal|0
else|:
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* Print the symbolic name of a branch target register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|LINK_REGISTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|COUNT_REGISTER_REGNUM
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%T value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|LINK_REGISTER_REGNUM
condition|)
name|fputs
argument_list|(
name|TARGET_NEW_MNEMONICS
condition|?
literal|"lr"
else|:
literal|"r"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"ctr"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'u'
case|:
comment|/* High-order 16 bits of constant for use in unsigned operand.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%u value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'v'
case|:
comment|/* High-order 16 bits of constant for use in signed operand.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%v value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'U'
case|:
comment|/* Print `u' if this has an auto-increment or auto-decrement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|)
condition|)
name|putc
argument_list|(
literal|'u'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'V'
case|:
comment|/* Print the trap code for this operand.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 4 */
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 24 */
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 16 */
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 20 */
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 8 */
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 12 */
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"llt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 2 */
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"lle"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 6 */
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"lgt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 1 */
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"lge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 5 */
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
comment|/* If constant, low-order 16 bits of constant, signed.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
comment|/* MB value for a PowerPC64 rldic operand.  */
name|val
operator|=
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|?
name|INTVAL
argument_list|(
name|x
argument_list|)
else|:
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|<
literal|0
condition|)
break|break;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
comment|/* zero-extend high-part was all 0's */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|i
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
operator|--
name|i
expr_stmt|;
else|else
for|for
control|(
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|<
literal|0
condition|)
break|break;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'X'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|legitimate_indexed_address_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|putc
argument_list|(
literal|'x'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Y'
case|:
comment|/* Like 'L', for third word of TImode  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'z'
case|:
comment|/* X is a SYMBOL_REF.  Write out the name preceded by a 	 period and without any trailing data in brackets.  Used for function 	 names.  If we are configured for System V (or the embedded ABI) on 	 the PowerPC, do not emit the period, since those systems do not use 	 TOCs and the like.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
comment|/* Mark the decl as referenced so that cgraph will output the 	 function.  */
if|if
condition|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
condition|)
name|mark_decl_referenced
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For macho, check to see if we need a stub.  */
if|if
condition|(
name|TARGET_MACHO
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|MACHOPIC_INDIRECT
operator|&&
name|machopic_classify_symbol
argument_list|(
name|x
argument_list|)
operator|==
name|MACHOPIC_UNDEFINED_FUNCTION
condition|)
name|name
operator|=
name|machopic_indirection_name
argument_list|(
name|x
argument_list|,
comment|/*stub_p=*/
name|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DOT_SYMBOLS
condition|)
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rs6000_output_function_entry
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Z'
case|:
comment|/* Like 'L', for last word of TImode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
literal|12
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* Print AltiVec or SPE memory operand.  */
case|case
literal|'y'
case|:
block|{
name|rtx
name|tmp
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ugly hack because %y is overloaded.  */
if|if
condition|(
name|TARGET_E500
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|8
condition|)
block|{
comment|/* Handle [reg].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Handle [reg+UIMM].  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|x
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|x
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%s)"
argument_list|,
name|x
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  Must be [reg+reg].  */
block|}
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|16
condition|)
name|tmp
operator|=
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|tmp
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PLUS
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* We need to handle PRE_INC and PRE_DEC here, since we need to 	     know the width from the mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%s)"
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%s)"
argument_list|,
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'&'
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|rs6000_get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the address of an operand.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_data_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@%s(%s)"
argument_list|,
name|SMALL_DATA_RELOC
argument_list|,
name|reg_names
index|[
name|SMALL_DATA_REG
index|]
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
operator|!
name|TARGET_TOC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
literal|"(%s)"
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_ELF
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@l(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET_MACHO
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lo16("
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|legitimate_constant_pool_address_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_AIX
operator|&&
operator|(
operator|!
name|TARGET_ELF
operator|||
operator|!
name|TARGET_MINIMAL_TOC
operator|)
condition|)
block|{
name|rtx
name|contains_minus
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|minus
decl_stmt|,
name|symref
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Find the (minus (sym) (toc)) buried in X, and temporarily 	     turn it into (sym) for output_addr_const.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MINUS
condition|)
name|contains_minus
operator|=
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|minus
operator|=
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symref
operator|=
name|XEXP
argument_list|(
name|minus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
operator|=
name|symref
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
condition|)
block|{
name|char
modifier|*
name|newname
decl_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"@toc"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newname
argument_list|,
literal|"@toc"
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
operator|=
name|newname
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
condition|)
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|XEXP
argument_list|(
name|contains_minus
argument_list|,
literal|0
argument_list|)
operator|=
name|minus
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Target hook for assembling integer objects.  The PowerPC version has    to handle fixup entries for relocatable code if RELOCATABLE_NEEDS_FIXUP    is defined.  It also needs to handle DI-mode objects on 64-bit    targets.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RELOCATABLE_NEEDS_FIXUP
comment|/* Special handling for SI values.  */
if|if
condition|(
name|RELOCATABLE_NEEDS_FIXUP
operator|&&
name|size
operator|==
literal|4
operator|&&
name|aligned_p
condition|)
block|{
specifier|static
name|int
name|recurse
init|=
literal|0
decl_stmt|;
comment|/* For -mrelocatable, we mark all addresses that need to be fixed up 	 in the .fixup section.  */
if|if
condition|(
name|TARGET_RELOCATABLE
operator|&&
name|in_section
operator|!=
name|toc_section
operator|&&
name|in_section
operator|!=
name|text_section
operator|&&
operator|!
name|unlikely_text_section_p
argument_list|(
name|in_section
argument_list|)
operator|&&
operator|!
name|recurse
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|recurse
operator|=
literal|1
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCP"
argument_list|,
name|fixuplabelno
argument_list|)
expr_stmt|;
name|fixuplabelno
operator|++
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t("
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|")@fixup\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t\".fixup\",\"aw\"\n"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n\t.previous\n"
argument_list|)
expr_stmt|;
name|recurse
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Remove initial .'s to turn a -mcall-aixdesc function 	 address into the address of the descriptor, not the function 	 itself.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
name|name
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.long\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
endif|#
directive|endif
comment|/* RELOCATABLE_NEEDS_FIXUP */
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAS_HIDDEN
end_ifdef

begin_comment
comment|/* Emit an assembler directive to set symbol visibility for DECL to    VISIBILITY_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_assemble_visibility
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|vis
parameter_list|)
block|{
comment|/* Functions need to have their entry point symbol visibility set as      well as their descriptor symbol visibility.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|DOT_SYMBOLS
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|visibility_types
index|[]
init|=
block|{
name|NULL
block|,
literal|"internal"
block|,
literal|"hidden"
block|,
literal|"protected"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|;
name|name
operator|=
operator|(
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|type
operator|=
name|visibility_types
index|[
name|vis
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.%s\t%s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.%s\t.%s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|default_assemble_visibility
argument_list|(
name|decl
argument_list|,
name|vis
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|enum
name|rtx_code
name|rs6000_reverse_condition
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
comment|/* Reversal of FP compares takes care -- an ordered compare      becomes an unordered compare and vice versa.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|&&
operator|(
operator|!
name|flag_finite_math_only
operator|||
name|code
operator|==
name|UNLT
operator|||
name|code
operator|==
name|UNLE
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNGE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|)
condition|)
return|return
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
return|;
else|else
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a compare for CODE.  Return a brand-new rtx that    represents the result of the compare.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_generate_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|machine_mode
name|comp_mode
decl_stmt|;
name|rtx
name|compare_result
decl_stmt|;
if|if
condition|(
name|rs6000_compare_fp_p
condition|)
name|comp_mode
operator|=
name|CCFPmode
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
condition|)
name|comp_mode
operator|=
name|CCUNSmode
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|rs6000_compare_op1
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|rs6000_compare_op0
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|rs6000_compare_op1
argument_list|)
condition|)
comment|/* These are unsigned values, perhaps there will be a later        ordering compare that can be shared with this one.        Unfortunately we cannot detect the signedness of the operands        for non-subregs.  */
name|comp_mode
operator|=
name|CCUNSmode
expr_stmt|;
else|else
name|comp_mode
operator|=
name|CCmode
expr_stmt|;
comment|/* First, the compare.  */
name|compare_result
operator|=
name|gen_reg_rtx
argument_list|(
name|comp_mode
argument_list|)
expr_stmt|;
comment|/* E500 FP compare instructions on the GPRs.  Yuck!  */
if|if
condition|(
operator|(
name|TARGET_E500
operator|&&
operator|!
name|TARGET_FPRS
operator|&&
name|TARGET_HARD_FLOAT
operator|)
operator|&&
name|rs6000_compare_fp_p
condition|)
block|{
name|rtx
name|cmp
decl_stmt|,
name|or_result
decl_stmt|,
name|compare_result2
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
comment|/* The E500 FP compare instructions toggle the GT bit (CR bit 1) only. 	 This explains the following mess.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
case|case
name|NE
case|:
case|case
name|LTGT
case|:
switch|switch
condition|(
name|op_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|cmp
operator|=
name|flag_unsafe_math_optimizations
condition|?
name|gen_tstsfeq_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpsfeq_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|cmp
operator|=
name|flag_unsafe_math_optimizations
condition|?
name|gen_tstdfeq_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpdfeq_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
switch|switch
condition|(
name|op_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|cmp
operator|=
name|flag_unsafe_math_optimizations
condition|?
name|gen_tstsfgt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpsfgt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|cmp
operator|=
name|flag_unsafe_math_optimizations
condition|?
name|gen_tstdfgt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpdfgt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
switch|switch
condition|(
name|op_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|cmp
operator|=
name|flag_unsafe_math_optimizations
condition|?
name|gen_tstsflt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpsflt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|cmp
operator|=
name|flag_unsafe_math_optimizations
condition|?
name|gen_tstdflt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpdflt_gpr
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Synthesize LE and GE from LT/GT || EQ.  */
if|if
condition|(
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GEU
condition|)
block|{
name|emit_insn
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
name|code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|code
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|code
operator|=
name|GT
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|compare_result2
operator|=
name|gen_reg_rtx
argument_list|(
name|CCFPmode
argument_list|)
expr_stmt|;
comment|/* Do the EQ.  */
switch|switch
condition|(
name|op_mode
condition|)
block|{
case|case
name|SFmode
case|:
name|cmp
operator|=
name|flag_unsafe_math_optimizations
condition|?
name|gen_tstsfeq_gpr
argument_list|(
name|compare_result2
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpsfeq_gpr
argument_list|(
name|compare_result2
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|cmp
operator|=
name|flag_unsafe_math_optimizations
condition|?
name|gen_tstdfeq_gpr
argument_list|(
name|compare_result2
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
else|:
name|gen_cmpdfeq_gpr
argument_list|(
name|compare_result2
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
comment|/* OR them together.  */
name|or_result
operator|=
name|gen_reg_rtx
argument_list|(
name|CCFPmode
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|gen_e500_cr_ior_compare
argument_list|(
name|or_result
argument_list|,
name|compare_result
argument_list|,
name|compare_result2
argument_list|)
expr_stmt|;
name|compare_result
operator|=
name|or_result
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LTGT
condition|)
name|code
operator|=
name|NE
expr_stmt|;
else|else
name|code
operator|=
name|EQ
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|cmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate XLC-compatible TFmode compare as PARALLEL with extra 	 CLOBBERs to match cmptf_internal2 pattern.  */
if|if
condition|(
name|comp_mode
operator|==
name|CCFPmode
operator|&&
name|TARGET_XL_COMPAT
operator|&&
name|GET_MODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
operator|==
name|TFmode
operator|&&
operator|!
name|TARGET_IEEEQUAD
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
operator|&&
name|TARGET_LONG_DOUBLE_128
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|9
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|compare_result
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|comp_mode
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|DFmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rs6000_compare_op1
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|rs6000_compare_op1
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_SP_TEST
condition|)
block|{
name|rtx
name|op1
init|=
name|XVECEXP
argument_list|(
name|rs6000_compare_op1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|comp_mode
operator|=
name|CCEQmode
expr_stmt|;
name|compare_result
operator|=
name|gen_reg_rtx
argument_list|(
name|CCEQmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_stack_protect_testdi
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_stack_protect_testsi
argument_list|(
name|compare_result
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|compare_result
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|comp_mode
argument_list|,
name|rs6000_compare_op0
argument_list|,
name|rs6000_compare_op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Some kinds of FP comparisons need an OR operation;      under flag_finite_math_only we don't bother.  */
if|if
condition|(
name|rs6000_compare_fp_p
operator|&&
operator|!
name|flag_finite_math_only
operator|&&
operator|!
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_E500
operator|&&
operator|!
name|TARGET_FPRS
operator|)
operator|&&
operator|(
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNLT
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|or1
decl_stmt|,
name|or2
decl_stmt|;
name|rtx
name|or1_rtx
decl_stmt|,
name|or2_rtx
decl_stmt|,
name|compare2_rtx
decl_stmt|;
name|rtx
name|or_result
init|=
name|gen_reg_rtx
argument_list|(
name|CCEQmode
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
name|or1
operator|=
name|LT
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|or1
operator|=
name|GT
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|LTGT
case|:
name|or1
operator|=
name|LT
expr_stmt|;
name|or2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|or1
operator|=
name|UNORDERED
expr_stmt|;
name|or2
operator|=
name|LT
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|validate_condition_mode
argument_list|(
name|or1
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|validate_condition_mode
argument_list|(
name|or2
argument_list|,
name|comp_mode
argument_list|)
expr_stmt|;
name|or1_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|or1
argument_list|,
name|SImode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|or2_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|or2
argument_list|,
name|SImode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|compare2_rtx
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|CCEQmode
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|or1_rtx
argument_list|,
name|or2_rtx
argument_list|)
argument_list|,
name|const_true_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|or_result
argument_list|,
name|compare2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|compare_result
operator|=
name|or_result
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|compare_result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|compare_result
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit the RTL for an sCOND pattern.  */
end_comment

begin_function
name|void
name|rs6000_emit_sCOND
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|result
parameter_list|)
block|{
name|rtx
name|condition_rtx
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
decl_stmt|;
name|enum
name|rtx_code
name|cond_code
decl_stmt|;
name|condition_rtx
operator|=
name|rs6000_generate_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|cond_code
operator|=
name|GET_CODE
argument_list|(
name|condition_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_E500
operator|&&
name|rs6000_compare_fp_p
operator|&&
operator|!
name|TARGET_FPRS
operator|&&
name|TARGET_HARD_FLOAT
condition|)
block|{
name|rtx
name|t
decl_stmt|;
name|PUT_MODE
argument_list|(
name|condition_rtx
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|t
operator|=
name|XEXP
argument_list|(
name|condition_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|cond_code
operator|==
name|NE
operator|||
name|cond_code
operator|==
name|EQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_code
operator|==
name|NE
condition|)
name|emit_insn
argument_list|(
name|gen_e500_flip_gt_bit
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_move_from_CR_gt_bit
argument_list|(
name|result
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cond_code
operator|==
name|NE
operator|||
name|cond_code
operator|==
name|GE
operator|||
name|cond_code
operator|==
name|LE
operator|||
name|cond_code
operator|==
name|GEU
operator|||
name|cond_code
operator|==
name|LEU
operator|||
name|cond_code
operator|==
name|ORDERED
operator|||
name|cond_code
operator|==
name|UNGE
operator|||
name|cond_code
operator|==
name|UNLE
condition|)
block|{
name|rtx
name|not_result
init|=
name|gen_reg_rtx
argument_list|(
name|CCEQmode
argument_list|)
decl_stmt|;
name|rtx
name|not_op
decl_stmt|,
name|rev_cond_rtx
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|condition_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rev_cond_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|rs6000_reverse_condition
argument_list|(
name|cc_mode
argument_list|,
name|cond_code
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|condition_rtx
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|not_op
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|CCEQmode
argument_list|,
name|rev_cond_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|not_result
argument_list|,
name|not_op
argument_list|)
argument_list|)
expr_stmt|;
name|condition_rtx
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|not_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|rs6000_compare_op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_POWERPC64
operator|&&
operator|(
name|op_mode
operator|==
name|DImode
operator|||
name|rs6000_compare_fp_p
operator|)
condition|)
block|{
name|PUT_MODE
argument_list|(
name|condition_rtx
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|result
argument_list|,
name|condition_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_MODE
argument_list|(
name|condition_rtx
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|result
argument_list|,
name|condition_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a branch of kind CODE to location LOC.  */
end_comment

begin_function
name|void
name|rs6000_emit_cbranch
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|loc
parameter_list|)
block|{
name|rtx
name|condition_rtx
decl_stmt|,
name|loc_ref
decl_stmt|;
name|condition_rtx
operator|=
name|rs6000_generate_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|loc_ref
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|condition_rtx
argument_list|,
name|loc_ref
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, which is    the operand number of the label, or -1 if the branch is really a    conditional return.     OP is the conditional expression.  XEXP (OP, 0) is assumed to be a    condition code register and its mode specifies what kind of    comparison we made.     REVERSED is nonzero if we should reverse the sense of the comparison.     INSN is the insn.  */
end_comment

begin_function
name|char
modifier|*
name|output_cbranch
parameter_list|(
name|rtx
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|reversed
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
literal|64
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
decl_stmt|;
name|int
name|cc_regno
init|=
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
operator|-
name|CR0_REGNO
decl_stmt|;
name|int
name|need_longbranch
init|=
name|label
operator|!=
name|NULL
operator|&&
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|==
literal|8
decl_stmt|;
name|int
name|really_reversed
init|=
name|reversed
operator|^
name|need_longbranch
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|ccode
decl_stmt|;
specifier|const
name|char
modifier|*
name|pred
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|validate_condition_mode
argument_list|(
name|code
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Work out which way this really branches.  We could use      reverse_condition_maybe_unordered here always but this      makes the resulting assembler clearer.  */
if|if
condition|(
name|really_reversed
condition|)
block|{
comment|/* Reversal of FP compares takes care -- an ordered compare 	 becomes an unordered compare and vice versa.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
condition|)
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TARGET_E500
operator|&&
operator|!
name|TARGET_FPRS
operator|&&
name|TARGET_HARD_FLOAT
operator|)
operator|&&
name|mode
operator|==
name|CCFPmode
condition|)
block|{
comment|/* The efscmp/tst* instructions twiddle bit 2, which maps nicely 	 to the GT bit.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
comment|/* Opposite of GT.  */
name|code
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|code
operator|=
name|UNLE
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Not all of these are actually distinct opcodes, but 	 we distinguish them for clarity of the resulting assembler.  */
case|case
name|NE
case|:
case|case
name|LTGT
case|:
name|ccode
operator|=
literal|"ne"
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
name|ccode
operator|=
literal|"eq"
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|ccode
operator|=
literal|"ge"
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|UNGT
case|:
name|ccode
operator|=
literal|"gt"
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|ccode
operator|=
literal|"le"
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|UNLT
case|:
name|ccode
operator|=
literal|"lt"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|ccode
operator|=
literal|"un"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|ccode
operator|=
literal|"nu"
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|ccode
operator|=
literal|"nl"
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|ccode
operator|=
literal|"ng"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Maybe we have a guess as to how likely the branch is.      The old mnemonics don't have a way to specify this information.  */
name|pred
operator|=
literal|""
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|!=
name|NULL_RTX
condition|)
block|{
comment|/* PROB is the difference from 50%.  */
name|int
name|prob
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
comment|/* Only hint for highly probable/improbable branches on newer 	 cpus as static prediction overrides processor dynamic 	 prediction.  For older cpus we may as well always hint, but 	 assume not taken for branches that are very close to 50% as a 	 mispredicted taken branch is more expensive than a 	 mispredicted not-taken branch.  */
if|if
condition|(
name|rs6000_always_hint
operator|||
operator|(
name|abs
argument_list|(
name|prob
argument_list|)
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
literal|48
operator|&&
name|br_prob_note_reliable_p
argument_list|(
name|note
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|prob
argument_list|)
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|20
operator|&&
operator|(
operator|(
name|prob
operator|>
literal|0
operator|)
operator|^
name|need_longbranch
operator|)
condition|)
name|pred
operator|=
literal|"+"
expr_stmt|;
else|else
name|pred
operator|=
literal|"-"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|label
operator|==
name|NULL
condition|)
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"{b%sr|b%slr%s} "
argument_list|,
name|ccode
argument_list|,
name|ccode
argument_list|,
name|pred
argument_list|)
expr_stmt|;
else|else
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"{b%s|b%s%s} "
argument_list|,
name|ccode
argument_list|,
name|ccode
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* We need to escape any '%' characters in the reg_names string.      Assume they'd only be the first character....  */
if|if
condition|(
name|reg_names
index|[
name|cc_regno
operator|+
name|CR0_REGNO
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'%'
expr_stmt|;
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|cc_regno
operator|+
name|CR0_REGNO
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
comment|/* If the branch distance was too far, we may have to use an 	 unconditional branch to go the distance.  */
if|if
condition|(
name|need_longbranch
condition|)
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|",$+8\n\tb %s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|s
operator|+=
name|sprintf
argument_list|(
name|s
argument_list|,
literal|",%s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return the string to flip the GT bit on a CR.  */
end_comment

begin_function
name|char
modifier|*
name|output_e500_flip_gt_bit
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
literal|64
index|]
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|REG
operator|&&
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* GT bit.  */
name|a
operator|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|1
expr_stmt|;
name|b
operator|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|-
name|CR0_REGNO
operator|)
operator|+
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"crnot %d,%d"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return insn index for the vector compare instruction for given CODE,    and DEST_MODE, OP_MODE. Return INSN_NOT_AVAILABLE if valid insn is    not available.  */
end_comment

begin_function
specifier|static
name|int
name|get_vec_cmp_insn
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|dest_mode
parameter_list|,
name|enum
name|machine_mode
name|op_mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_ALTIVEC
condition|)
return|return
name|INSN_NOT_AVAILABLE
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|dest_mode
operator|==
name|V16QImode
operator|&&
name|op_mode
operator|==
name|V16QImode
condition|)
return|return
name|UNSPEC_VCMPEQUB
return|;
if|if
condition|(
name|dest_mode
operator|==
name|V8HImode
operator|&&
name|op_mode
operator|==
name|V8HImode
condition|)
return|return
name|UNSPEC_VCMPEQUH
return|;
if|if
condition|(
name|dest_mode
operator|==
name|V4SImode
operator|&&
name|op_mode
operator|==
name|V4SImode
condition|)
return|return
name|UNSPEC_VCMPEQUW
return|;
if|if
condition|(
name|dest_mode
operator|==
name|V4SImode
operator|&&
name|op_mode
operator|==
name|V4SFmode
condition|)
return|return
name|UNSPEC_VCMPEQFP
return|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|dest_mode
operator|==
name|V4SImode
operator|&&
name|op_mode
operator|==
name|V4SFmode
condition|)
return|return
name|UNSPEC_VCMPGEFP
return|;
case|case
name|GT
case|:
if|if
condition|(
name|dest_mode
operator|==
name|V16QImode
operator|&&
name|op_mode
operator|==
name|V16QImode
condition|)
return|return
name|UNSPEC_VCMPGTSB
return|;
if|if
condition|(
name|dest_mode
operator|==
name|V8HImode
operator|&&
name|op_mode
operator|==
name|V8HImode
condition|)
return|return
name|UNSPEC_VCMPGTSH
return|;
if|if
condition|(
name|dest_mode
operator|==
name|V4SImode
operator|&&
name|op_mode
operator|==
name|V4SImode
condition|)
return|return
name|UNSPEC_VCMPGTSW
return|;
if|if
condition|(
name|dest_mode
operator|==
name|V4SImode
operator|&&
name|op_mode
operator|==
name|V4SFmode
condition|)
return|return
name|UNSPEC_VCMPGTFP
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|dest_mode
operator|==
name|V16QImode
operator|&&
name|op_mode
operator|==
name|V16QImode
condition|)
return|return
name|UNSPEC_VCMPGTUB
return|;
if|if
condition|(
name|dest_mode
operator|==
name|V8HImode
operator|&&
name|op_mode
operator|==
name|V8HImode
condition|)
return|return
name|UNSPEC_VCMPGTUH
return|;
if|if
condition|(
name|dest_mode
operator|==
name|V4SImode
operator|&&
name|op_mode
operator|==
name|V4SImode
condition|)
return|return
name|UNSPEC_VCMPGTUW
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|INSN_NOT_AVAILABLE
return|;
block|}
end_function

begin_comment
comment|/* Emit vector compare for operands OP0 and OP1 using code RCODE.    DMODE is expected destination mode. This is a recursive function.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_emit_vector_compare
parameter_list|(
name|enum
name|rtx_code
name|rcode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|enum
name|machine_mode
name|dmode
parameter_list|)
block|{
name|int
name|vec_cmp_insn
decl_stmt|;
name|rtx
name|mask
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TARGET_ALTIVEC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Floating point vector compare instructions uses destination V4SImode.      Move destination to appropriate mode later.  */
if|if
condition|(
name|dmode
operator|==
name|V4SFmode
condition|)
name|dest_mode
operator|=
name|V4SImode
expr_stmt|;
else|else
name|dest_mode
operator|=
name|dmode
expr_stmt|;
name|mask
operator|=
name|gen_reg_rtx
argument_list|(
name|dest_mode
argument_list|)
expr_stmt|;
name|vec_cmp_insn
operator|=
name|get_vec_cmp_insn
argument_list|(
name|rcode
argument_list|,
name|dest_mode
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vec_cmp_insn
operator|==
name|INSN_NOT_AVAILABLE
condition|)
block|{
name|bool
name|swap_operands
init|=
name|false
decl_stmt|;
name|bool
name|try_again
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|rcode
condition|)
block|{
case|case
name|LT
case|:
name|rcode
operator|=
name|GT
expr_stmt|;
name|swap_operands
operator|=
name|true
expr_stmt|;
name|try_again
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|rcode
operator|=
name|GTU
expr_stmt|;
name|swap_operands
operator|=
name|true
expr_stmt|;
name|try_again
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NE
case|:
comment|/* Treat A != B as ~(A==B).  */
block|{
name|enum
name|insn_code
name|nor_code
decl_stmt|;
name|rtx
name|eq_rtx
init|=
name|rs6000_emit_vector_compare
argument_list|(
name|EQ
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|dest_mode
argument_list|)
decl_stmt|;
name|nor_code
operator|=
name|one_cmpl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|dest_mode
index|]
operator|.
name|insn_code
expr_stmt|;
name|gcc_assert
argument_list|(
name|nor_code
operator|!=
name|CODE_FOR_nothing
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|nor_code
argument_list|)
argument_list|(
name|mask
argument_list|,
name|eq_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmode
operator|!=
name|dest_mode
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|dest_mode
argument_list|)
decl_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|mask
return|;
block|}
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
comment|/* Try GT/GTU/LT/LTU OR EQ */
block|{
name|rtx
name|c_rtx
decl_stmt|,
name|eq_rtx
decl_stmt|;
name|enum
name|insn_code
name|ior_code
decl_stmt|;
name|enum
name|rtx_code
name|new_code
decl_stmt|;
switch|switch
condition|(
name|rcode
condition|)
block|{
case|case
name|GE
case|:
name|new_code
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|new_code
operator|=
name|GTU
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|new_code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|new_code
operator|=
name|LTU
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|c_rtx
operator|=
name|rs6000_emit_vector_compare
argument_list|(
name|new_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|dest_mode
argument_list|)
expr_stmt|;
name|eq_rtx
operator|=
name|rs6000_emit_vector_compare
argument_list|(
name|EQ
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|dest_mode
argument_list|)
expr_stmt|;
name|ior_code
operator|=
name|ior_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|dest_mode
index|]
operator|.
name|insn_code
expr_stmt|;
name|gcc_assert
argument_list|(
name|ior_code
operator|!=
name|CODE_FOR_nothing
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|ior_code
argument_list|)
argument_list|(
name|mask
argument_list|,
name|c_rtx
argument_list|,
name|eq_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmode
operator|!=
name|dest_mode
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|dest_mode
argument_list|)
decl_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|mask
return|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|try_again
condition|)
block|{
name|vec_cmp_insn
operator|=
name|get_vec_cmp_insn
argument_list|(
name|rcode
argument_list|,
name|dest_mode
argument_list|,
name|op_mode
argument_list|)
expr_stmt|;
comment|/* You only get two chances.  */
name|gcc_assert
argument_list|(
name|vec_cmp_insn
operator|!=
name|INSN_NOT_AVAILABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swap_operands
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mask
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|dest_mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|vec_cmp_insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmode
operator|!=
name|dest_mode
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|dest_mode
argument_list|)
decl_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Return vector select instruction for MODE. Return INSN_NOT_AVAILABLE, if    valid insn doesn exist for given mode.  */
end_comment

begin_function
specifier|static
name|int
name|get_vsel_insn
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V4SImode
case|:
return|return
name|UNSPEC_VSEL4SI
return|;
break|break;
case|case
name|V4SFmode
case|:
return|return
name|UNSPEC_VSEL4SF
return|;
break|break;
case|case
name|V8HImode
case|:
return|return
name|UNSPEC_VSEL8HI
return|;
break|break;
case|case
name|V16QImode
case|:
return|return
name|UNSPEC_VSEL16QI
return|;
break|break;
default|default:
return|return
name|INSN_NOT_AVAILABLE
return|;
break|break;
block|}
return|return
name|INSN_NOT_AVAILABLE
return|;
block|}
end_function

begin_comment
comment|/* Emit vector select insn where DEST is destination using    operands OP1, OP2 and MASK.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_emit_vector_select
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|rtx
name|mask
parameter_list|)
block|{
name|rtx
name|t
decl_stmt|,
name|temp
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|vsel_insn_index
init|=
name|get_vsel_insn
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|dest_mode
argument_list|)
expr_stmt|;
comment|/* For each vector element, select op1 when mask is 1 otherwise      select op2.  */
name|t
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|dest_mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|3
argument_list|,
name|op2
argument_list|,
name|op1
argument_list|,
name|mask
argument_list|)
argument_list|,
name|vsel_insn_index
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Emit vector conditional expression.    DEST is destination. OP1 and OP2 are two VEC_COND_EXPR operands.    CC_OP0 and CC_OP1 are the two operands for the relation operation COND.  */
end_comment

begin_function
name|int
name|rs6000_emit_vector_cond_expr
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|rtx
name|cond
parameter_list|,
name|rtx
name|cc_op0
parameter_list|,
name|rtx
name|cc_op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|dest_mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|rcode
init|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|rtx
name|mask
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC
condition|)
return|return
literal|0
return|;
comment|/* Get the vector mask for the given relational operations.  */
name|mask
operator|=
name|rs6000_emit_vector_compare
argument_list|(
name|rcode
argument_list|,
name|cc_op0
argument_list|,
name|cc_op1
argument_list|,
name|dest_mode
argument_list|)
expr_stmt|;
name|rs6000_emit_vector_select
argument_list|(
name|dest
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Emit a conditional move: move TRUE_COND to DEST if OP of the    operands of the last comparison is nonzero/true, FALSE_COND if it    is zero/false.  Return 0 if the hardware has no such operation.  */
end_comment

begin_function
name|int
name|rs6000_emit_cmove
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|op
parameter_list|,
name|rtx
name|true_cond
parameter_list|,
name|rtx
name|false_cond
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|rs6000_compare_op0
decl_stmt|;
name|rtx
name|op1
init|=
name|rs6000_compare_op1
decl_stmt|;
name|REAL_VALUE_TYPE
name|c1
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|result_mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|bool
name|is_against_zero
decl_stmt|;
comment|/* These modes should always match.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|compare_mode
comment|/* In the isel case however, we can use a compare immediate, so 	 op1 may be a small constant.  */
operator|&&
operator|(
operator|!
name|TARGET_ISEL
operator|||
operator|!
name|short_cint_operand
argument_list|(
name|op1
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|true_cond
argument_list|)
operator|!=
name|result_mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|false_cond
argument_list|)
operator|!=
name|result_mode
condition|)
return|return
literal|0
return|;
comment|/* First, work out if the hardware can do this at all, or      if it's too slow....  */
if|if
condition|(
operator|!
name|rs6000_compare_fp_p
condition|)
block|{
if|if
condition|(
name|TARGET_ISEL
condition|)
return|return
name|rs6000_emit_int_cmove
argument_list|(
name|dest
argument_list|,
name|op
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_E500
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
operator|!
name|TARGET_FPRS
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|compare_mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|is_against_zero
operator|=
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
comment|/* A floating-point subtract might overflow, underflow, or produce      an inexact result, thus changing the floating-point flags, so it      can't be generated if we care about that.  It's safe if one side      of the construct is zero, since then no subtract will be      generated.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|compare_mode
argument_list|)
operator|&&
name|flag_trapping_math
operator|&&
operator|!
name|is_against_zero
condition|)
return|return
literal|0
return|;
comment|/* Eliminate half of the comparisons by switching operands, this      makes the remaining code simpler.  */
if|if
condition|(
name|code
operator|==
name|UNLT
operator|||
name|code
operator|==
name|UNGT
operator|||
name|code
operator|==
name|UNORDERED
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|UNLE
condition|)
block|{
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|temp
operator|=
name|true_cond
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
block|}
comment|/* UNEQ and LTGT take four instructions for a comparison with zero,      it'll probably be faster to use a branch here too.  */
if|if
condition|(
name|code
operator|==
name|UNEQ
operator|&&
name|HONOR_NANS
argument_list|(
name|compare_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|c1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* We're going to try to implement comparisons by performing      a subtract, then comparing against zero.  Unfortunately,      Inf - Inf is NaN which is not zero, and so if we don't      know that the operand is finite and the comparison      would treat EQ different to UNORDERED, we can't do it.  */
if|if
condition|(
name|HONOR_INFINITIES
argument_list|(
name|compare_mode
argument_list|)
operator|&&
name|code
operator|!=
name|GT
operator|&&
name|code
operator|!=
name|UNGE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|real_isinf
argument_list|(
operator|&
name|c1
argument_list|)
operator|)
comment|/* Constructs of the form (a OP b ? a : b) are safe.  */
operator|&&
operator|(
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|false_cond
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|false_cond
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|true_cond
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|true_cond
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* At this point we know we can use fsel.  */
comment|/* Reduce the comparison to a comparison against zero.  */
if|if
condition|(
operator|!
name|is_against_zero
condition|)
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't care about NaNs we can reduce some of the comparisons      down to faster ones.  */
if|if
condition|(
operator|!
name|HONOR_NANS
argument_list|(
name|compare_mode
argument_list|)
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
name|code
operator|=
name|LE
expr_stmt|;
name|temp
operator|=
name|true_cond
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|code
operator|=
name|GE
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Now, reduce everything down to a GE.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE
case|:
break|break;
case|case
name|LE
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_ABS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|gen_rtx_ABS
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
comment|/* a UNGE 0<-> (a GE 0 || -a UNLT 0) */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|false_cond
operator|=
name|true_cond
expr_stmt|;
name|true_cond
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|GT
case|:
comment|/* a GT 0<-> (a GE 0&& -a UNLT 0) */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|true_cond
operator|=
name|false_cond
expr_stmt|;
name|false_cond
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|compare_mode
argument_list|,
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|result_mode
argument_list|,
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Same as above, but for ints (isel).  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_emit_int_cmove
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|op
parameter_list|,
name|rtx
name|true_cond
parameter_list|,
name|rtx
name|false_cond
parameter_list|)
block|{
name|rtx
name|condition_rtx
decl_stmt|,
name|cr
decl_stmt|;
comment|/* All isel implementations thus far are 32-bits.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|rs6000_compare_op0
argument_list|)
operator|!=
name|SImode
condition|)
return|return
literal|0
return|;
comment|/* We still have to do the compare, because isel doesn't do a      compare, it just looks at the CRx bits set by a previous compare      instruction.  */
name|condition_rtx
operator|=
name|rs6000_generate_compare
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|cr
operator|=
name|XEXP
argument_list|(
name|condition_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|cr
argument_list|)
operator|==
name|CCmode
condition|)
name|emit_insn
argument_list|(
name|gen_isel_signed
argument_list|(
name|dest
argument_list|,
name|condition_rtx
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|,
name|cr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_isel_unsigned
argument_list|(
name|dest
argument_list|,
name|condition_rtx
argument_list|,
name|true_cond
argument_list|,
name|false_cond
argument_list|,
name|cr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|output_isel
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|NE
condition|)
block|{
name|PUT_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|reverse_condition
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"isel %0,%3,%2,%j1"
return|;
block|}
else|else
return|return
literal|"isel %0,%2,%3,%j1"
return|;
block|}
end_function

begin_function
name|void
name|rs6000_emit_minmax
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|c
decl_stmt|;
name|rtx
name|target
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|SMIN
condition|)
name|c
operator|=
name|GE
expr_stmt|;
else|else
name|c
operator|=
name|GEU
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|UMAX
condition|)
name|target
operator|=
name|emit_conditional_move
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|emit_conditional_move
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|dest
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit instructions to perform a load-reserved/store-conditional operation.    The operation performed is an atomic    (set M (CODE:MODE M OP))    If not NULL, BEFORE is atomically set to M before the operation, and    AFTER is set to M after the operation (that is, (CODE:MODE M OP)).    If SYNC_P then a memory barrier is emitted before the operation.    Either OP or M may be wrapped in a NOT operation.  */
end_comment

begin_function
name|void
name|rs6000_emit_sync
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|m
parameter_list|,
name|rtx
name|op
parameter_list|,
name|rtx
name|before_param
parameter_list|,
name|rtx
name|after_param
parameter_list|,
name|bool
name|sync_p
parameter_list|)
block|{
name|enum
name|machine_mode
name|used_mode
decl_stmt|;
name|rtx
name|the_op
decl_stmt|,
name|set_before
decl_stmt|,
name|set_after
decl_stmt|,
name|set_atomic
decl_stmt|,
name|cc_scratch
decl_stmt|,
name|before
decl_stmt|,
name|after
decl_stmt|;
name|rtx
name|used_m
decl_stmt|;
name|rtvec
name|vec
decl_stmt|;
name|HOST_WIDE_INT
name|imask
init|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|shift
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|sync_p
condition|)
name|emit_insn
argument_list|(
name|gen_memory_barrier
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|m
argument_list|)
operator|==
name|NOT
condition|)
name|used_m
operator|=
name|XEXP
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|used_m
operator|=
name|m
expr_stmt|;
comment|/* If this is smaller than SImode, we'll have to use SImode with      adjustments.  */
if|if
condition|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
condition|)
block|{
name|rtx
name|newop
decl_stmt|,
name|oldop
decl_stmt|;
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|used_m
argument_list|)
operator|>=
literal|32
condition|)
block|{
name|int
name|ishift
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|ishift
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|shift
operator|=
name|GEN_INT
argument_list|(
name|ishift
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|addrSI
decl_stmt|,
name|aligned_addr
decl_stmt|;
name|int
name|shift_mask
init|=
name|mode
operator|==
name|QImode
condition|?
literal|0x18
else|:
literal|0x10
decl_stmt|;
name|addrSI
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|gen_lowpart_common
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|used_m
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shift
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rlwinm
argument_list|(
name|shift
argument_list|,
name|addrSI
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|shift_mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorsi3
argument_list|(
name|shift
argument_list|,
name|shift
argument_list|,
name|GEN_INT
argument_list|(
name|shift_mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|aligned_addr
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|XEXP
argument_list|(
name|used_m
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|used_m
operator|=
name|change_address
argument_list|(
name|used_m
argument_list|,
name|SImode
argument_list|,
name|aligned_addr
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|used_m
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* It's safe to keep the old alias set of USED_M, because 	     the operation is atomic and only affects the original 	     USED_M.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|m
argument_list|)
operator|==
name|NOT
condition|)
name|m
operator|=
name|gen_rtx_NOT
argument_list|(
name|SImode
argument_list|,
name|used_m
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|used_m
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|oldop
operator|=
name|lowpart_subreg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|oldop
operator|=
name|gen_rtx_NOT
argument_list|(
name|SImode
argument_list|,
name|oldop
argument_list|)
expr_stmt|;
block|}
else|else
name|oldop
operator|=
name|lowpart_subreg
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|IOR
case|:
case|case
name|XOR
case|:
name|newop
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|and_optab
argument_list|,
name|oldop
argument_list|,
name|GEN_INT
argument_list|(
name|imask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|newop
argument_list|,
name|newop
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|newop
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|oldop
argument_list|,
name|GEN_INT
argument_list|(
operator|~
name|imask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rotlsi3
argument_list|(
name|newop
argument_list|,
name|newop
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
block|{
name|rtx
name|mask
decl_stmt|;
name|newop
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|and_optab
argument_list|,
name|oldop
argument_list|,
name|GEN_INT
argument_list|(
name|imask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|newop
argument_list|,
name|newop
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mask
argument_list|,
name|GEN_INT
argument_list|(
name|imask
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|mask
argument_list|,
name|mask
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
name|newop
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|m
argument_list|,
name|newop
argument_list|)
expr_stmt|;
else|else
name|newop
operator|=
name|gen_rtx_MINUS
argument_list|(
name|SImode
argument_list|,
name|m
argument_list|,
name|newop
argument_list|)
expr_stmt|;
name|newop
operator|=
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|newop
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|newop
operator|=
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|newop
argument_list|,
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|SImode
argument_list|,
name|mask
argument_list|)
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|m
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|rtx
name|mask
decl_stmt|,
name|xorm
decl_stmt|;
name|mask
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mask
argument_list|,
name|GEN_INT
argument_list|(
name|imask
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|mask
argument_list|,
name|mask
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|xorm
operator|=
name|gen_rtx_XOR
argument_list|(
name|SImode
argument_list|,
name|used_m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* Depending on the value of 'op', the XOR or the operation might 	     be able to be simplified away.  */
name|newop
operator|=
name|simplify_gen_binary
argument_list|(
name|code
argument_list|,
name|SImode
argument_list|,
name|xorm
argument_list|,
name|newop
argument_list|)
expr_stmt|;
block|}
name|op
operator|=
name|newop
expr_stmt|;
name|used_mode
operator|=
name|SImode
expr_stmt|;
name|before
operator|=
name|gen_reg_rtx
argument_list|(
name|used_mode
argument_list|)
expr_stmt|;
name|after
operator|=
name|gen_reg_rtx
argument_list|(
name|used_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|used_mode
operator|=
name|mode
expr_stmt|;
name|before
operator|=
name|before_param
expr_stmt|;
name|after
operator|=
name|after_param
expr_stmt|;
if|if
condition|(
name|before
operator|==
name|NULL_RTX
condition|)
name|before
operator|=
name|gen_reg_rtx
argument_list|(
name|used_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|NULL_RTX
condition|)
name|after
operator|=
name|gen_reg_rtx
argument_list|(
name|used_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|m
argument_list|)
operator|==
name|NOT
operator|)
operator|&&
name|used_mode
operator|!=
name|mode
condition|)
name|the_op
operator|=
name|op
expr_stmt|;
comment|/* Computed above.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|m
argument_list|)
operator|!=
name|NOT
condition|)
name|the_op
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|used_mode
argument_list|,
name|op
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|the_op
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|used_mode
argument_list|,
name|m
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|set_after
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|after
argument_list|,
name|the_op
argument_list|)
expr_stmt|;
name|set_before
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|before
argument_list|,
name|used_m
argument_list|)
expr_stmt|;
name|set_atomic
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|used_m
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|used_mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|the_op
argument_list|)
argument_list|,
name|UNSPEC_SYNC_OP
argument_list|)
argument_list|)
expr_stmt|;
name|cc_scratch
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|CCmode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|used_mode
operator|!=
name|mode
condition|)
name|vec
operator|=
name|gen_rtvec
argument_list|(
literal|5
argument_list|,
name|set_after
argument_list|,
name|set_before
argument_list|,
name|set_atomic
argument_list|,
name|cc_scratch
argument_list|,
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|SImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|set_after
argument_list|,
name|set_before
argument_list|,
name|set_atomic
argument_list|,
name|cc_scratch
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shift and mask the return values properly.  */
if|if
condition|(
name|used_mode
operator|!=
name|mode
operator|&&
name|before_param
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|before
argument_list|,
name|before
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|before_param
argument_list|,
name|before
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used_mode
operator|!=
name|mode
operator|&&
name|after_param
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|after
argument_list|,
name|after
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|after_param
argument_list|,
name|after
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The previous sequence will end with a branch that's dependent on      the conditional store, so placing an isync will ensure that no      other instructions (especially, no load or store instructions)      can start before the atomic operation completes.  */
if|if
condition|(
name|sync_p
condition|)
name|emit_insn
argument_list|(
name|gen_isync
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of the atomic operation splitters.  Jump to LABEL if    COND is true.  Mark the jump as unlikely to be taken.  */
end_comment

begin_function
specifier|static
name|void
name|emit_unlikely_jump
parameter_list|(
name|rtx
name|cond
parameter_list|,
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|very_unlikely
init|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|-
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|label
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|x
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|x
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|very_unlikely
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of the atomic operation splitters.  Emit a load-locked    instruction in MODE.  */
end_comment

begin_function
specifier|static
name|void
name|emit_load_locked
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
name|mem
parameter_list|)
block|{
name|rtx
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
init|=
name|NULL
function_decl|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|fn
operator|=
name|gen_load_locked_si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|fn
operator|=
name|gen_load_locked_di
expr_stmt|;
name|emit_insn
argument_list|(
name|fn
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of the atomic operation splitters.  Emit a store-conditional    instruction in MODE.  */
end_comment

begin_function
specifier|static
name|void
name|emit_store_conditional
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|res
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|val
parameter_list|)
block|{
name|rtx
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
init|=
name|NULL
function_decl|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|fn
operator|=
name|gen_store_conditional_si
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|fn
operator|=
name|gen_store_conditional_di
expr_stmt|;
comment|/* Emit sync before stwcx. to address PPC405 Erratum.  */
if|if
condition|(
name|PPC405_ERRATUM77
condition|)
name|emit_insn
argument_list|(
name|gen_memory_barrier
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|fn
argument_list|(
name|res
argument_list|,
name|mem
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an an atomic fetch-and-operate pattern.  CODE is the binary operation    to perform.  MEM is the memory on which to operate.  VAL is the second    operand of the binary operator.  BEFORE and AFTER are optional locations to    return the value of MEM either before of after the operation.  SCRATCH is    a scratch register.  */
end_comment

begin_function
name|void
name|rs6000_split_atomic_op
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|val
parameter_list|,
name|rtx
name|before
parameter_list|,
name|rtx
name|after
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|rtx
name|label
decl_stmt|,
name|x
decl_stmt|,
name|cond
init|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_memory_barrier
argument_list|()
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
operator|==
name|NULL_RTX
condition|)
name|before
operator|=
name|scratch
expr_stmt|;
name|emit_load_locked
argument_list|(
name|mode
argument_list|,
name|before
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOT
condition|)
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|before
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|AND
condition|)
name|x
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|before
argument_list|,
name|val
argument_list|)
argument_list|,
name|UNSPEC_AND
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|before
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|!=
name|NULL_RTX
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|after
argument_list|,
name|copy_rtx
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_store_conditional
argument_list|(
name|mode
argument_list|,
name|cond
argument_list|,
name|mem
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_unlikely_jump
argument_list|(
name|x
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_isync
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an atomic compare and swap operation.  MEM is the memory on which    to operate.  OLDVAL is the old value to be compared.  NEWVAL is the new    value to be stored.  SCRATCH is a scratch GPR.  */
end_comment

begin_function
name|void
name|rs6000_split_compare_and_swap
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|oldval
parameter_list|,
name|rtx
name|newval
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|rtx
name|label1
decl_stmt|,
name|label2
decl_stmt|,
name|x
decl_stmt|,
name|cond
init|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_memory_barrier
argument_list|()
argument_list|)
expr_stmt|;
name|label1
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
name|label2
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|XEXP
argument_list|(
name|label1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_load_locked
argument_list|(
name|mode
argument_list|,
name|retval
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|CCmode
argument_list|,
name|retval
argument_list|,
name|oldval
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_unlikely_jump
argument_list|(
name|x
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|newval
argument_list|)
expr_stmt|;
name|emit_store_conditional
argument_list|(
name|mode
argument_list|,
name|cond
argument_list|,
name|mem
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_unlikely_jump
argument_list|(
name|x
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_isync
argument_list|()
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|XEXP
argument_list|(
name|label2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an atomic test and set operation.  MEM is the memory on which    to operate.  VAL is the value set.  SCRATCH is a scratch GPR.  */
end_comment

begin_function
name|void
name|rs6000_split_lock_test_and_set
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|val
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|rtx
name|label
decl_stmt|,
name|x
decl_stmt|,
name|cond
init|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_memory_barrier
argument_list|()
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_load_locked
argument_list|(
name|mode
argument_list|,
name|retval
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|emit_store_conditional
argument_list|(
name|mode
argument_list|,
name|cond
argument_list|,
name|mem
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_unlikely_jump
argument_list|(
name|x
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_isync
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rs6000_expand_compare_and_swapqhi
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|oldval
parameter_list|,
name|rtx
name|newval
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|rtx
name|addrSI
decl_stmt|,
name|align
decl_stmt|,
name|wdst
decl_stmt|,
name|shift
decl_stmt|,
name|mask
decl_stmt|;
name|HOST_WIDE_INT
name|shift_mask
init|=
name|mode
operator|==
name|QImode
condition|?
literal|0x18
else|:
literal|0x10
decl_stmt|;
name|HOST_WIDE_INT
name|imask
init|=
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Shift amount for subword relative to aligned word.  */
name|addrSI
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|gen_lowpart_common
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shift
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rlwinm
argument_list|(
name|shift
argument_list|,
name|addrSI
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|shift_mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorsi3
argument_list|(
name|shift
argument_list|,
name|shift
argument_list|,
name|GEN_INT
argument_list|(
name|shift_mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shift and mask old value into position within word.  */
name|oldval
operator|=
name|convert_modes
argument_list|(
name|SImode
argument_list|,
name|mode
argument_list|,
name|oldval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|and_optab
argument_list|,
name|oldval
argument_list|,
name|GEN_INT
argument_list|(
name|imask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|oldval
argument_list|,
name|oldval
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shift and mask new value into position within word.  */
name|newval
operator|=
name|convert_modes
argument_list|(
name|SImode
argument_list|,
name|mode
argument_list|,
name|newval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newval
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|and_optab
argument_list|,
name|newval
argument_list|,
name|GEN_INT
argument_list|(
name|imask
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|newval
argument_list|,
name|newval
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mask for insertion.  */
name|mask
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mask
argument_list|,
name|GEN_INT
argument_list|(
name|imask
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|mask
argument_list|,
name|mask
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Address of aligned word containing subword.  */
name|align
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|mem
operator|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|SImode
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|wdst
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sync_compare_and_swapqhi_internal
argument_list|(
name|wdst
argument_list|,
name|mask
argument_list|,
name|oldval
argument_list|,
name|newval
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|wdst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rs6000_split_compare_and_swapqhi
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|mask
parameter_list|,
name|rtx
name|oldval
parameter_list|,
name|rtx
name|newval
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rtx
name|label1
decl_stmt|,
name|label2
decl_stmt|,
name|x
decl_stmt|,
name|cond
init|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_memory_barrier
argument_list|()
argument_list|)
expr_stmt|;
name|label1
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
name|label2
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|XEXP
argument_list|(
name|label1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_load_locked
argument_list|(
name|SImode
argument_list|,
name|scratch
argument_list|,
name|mem
argument_list|)
expr_stmt|;
comment|/* Mask subword within loaded value for comparison with oldval.      Use UNSPEC_AND to avoid clobber.*/
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|dest
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|scratch
argument_list|,
name|mask
argument_list|)
argument_list|,
name|UNSPEC_AND
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|CCmode
argument_list|,
name|dest
argument_list|,
name|oldval
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_unlikely_jump
argument_list|(
name|x
argument_list|,
name|label2
argument_list|)
expr_stmt|;
comment|/* Clear subword within loaded value for insertion of new value.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|scratch
argument_list|,
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|SImode
argument_list|,
name|mask
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iorsi3
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|newval
argument_list|)
argument_list|)
expr_stmt|;
name|emit_store_conditional
argument_list|(
name|SImode
argument_list|,
name|cond
argument_list|,
name|mem
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_unlikely_jump
argument_list|(
name|x
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_isync
argument_list|()
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|XEXP
argument_list|(
name|label2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit instructions to move SRC to DST.  Called by splitters for    multi-register moves.  It will emit at most one instruction for    each register that is accessed; that is, it won't emit li/lis pairs    (or equivalent for 64-bit code).  One of SRC or DST must be a hard    register.  */
end_comment

begin_function
name|void
name|rs6000_split_multireg_move
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
comment|/* The register number of the first register being moved.  */
name|int
name|reg
decl_stmt|;
comment|/* The mode that is to be moved.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The mode that the move is being done in, and its size.  */
name|enum
name|machine_mode
name|reg_mode
decl_stmt|;
name|int
name|reg_mode_size
decl_stmt|;
comment|/* The number of registers that will be moved.  */
name|int
name|nregs
decl_stmt|;
name|reg
operator|=
name|REG_P
argument_list|(
name|dst
argument_list|)
condition|?
name|REGNO
argument_list|(
name|dst
argument_list|)
else|:
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|hard_regno_nregs
index|[
name|reg
index|]
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|reg
argument_list|)
condition|)
name|reg_mode
operator|=
name|DFmode
expr_stmt|;
elseif|else
if|if
condition|(
name|ALTIVEC_REGNO_P
argument_list|(
name|reg
argument_list|)
condition|)
name|reg_mode
operator|=
name|V16QImode
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_E500_DOUBLE
operator|&&
name|mode
operator|==
name|TFmode
condition|)
name|reg_mode
operator|=
name|DFmode
expr_stmt|;
else|else
name|reg_mode
operator|=
name|word_mode
expr_stmt|;
name|reg_mode_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|reg_mode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|reg_mode_size
operator|*
name|nregs
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|dst
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
block|{
comment|/* Move register range backwards, if we might have destructive 	 overlap.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nregs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|dst
argument_list|,
name|mode
argument_list|,
name|i
operator|*
name|reg_mode_size
argument_list|)
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|src
argument_list|,
name|mode
argument_list|,
name|i
operator|*
name|reg_mode_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|used_update
init|=
name|false
decl_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|src
argument_list|)
operator|&&
name|INT_REGNO_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|breg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
name|rtx
name|delta_rtx
decl_stmt|;
name|breg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta_rtx
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|?
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
else|:
name|GEN_INT
argument_list|(
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|replace_equiv_address
argument_list|(
name|src
argument_list|,
name|breg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rs6000_offsettable_memref_p
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|rtx
name|basereg
decl_stmt|;
name|basereg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|basereg
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|replace_equiv_address
argument_list|(
name|src
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
block|}
name|breg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|breg
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|breg
argument_list|)
operator|==
name|LO_SUM
condition|)
name|breg
operator|=
name|XEXP
argument_list|(
name|breg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the base register we are using to address memory is 	     also a destination reg, then change that register last.  */
if|if
condition|(
name|REG_P
argument_list|(
name|breg
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|breg
argument_list|)
operator|>=
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|breg
argument_list|)
operator|<
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|+
name|nregs
condition|)
name|j
operator|=
name|REGNO
argument_list|(
name|breg
argument_list|)
operator|-
name|REGNO
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
operator|&&
name|INT_REGNO_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|breg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
name|rtx
name|delta_rtx
decl_stmt|;
name|breg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta_rtx
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|?
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
else|:
name|GEN_INT
argument_list|(
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* We have to update the breg before doing the store. 		 Use store with update, if available.  */
if|if
condition|(
name|TARGET_UPDATE
condition|)
block|{
name|rtx
name|nsrc
init|=
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|src
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
operator|(
name|TARGET_POWERPC64
condition|?
name|gen_movdi_si_update
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|,
name|nsrc
argument_list|)
else|:
name|gen_movsi_update
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|,
name|nsrc
argument_list|)
operator|)
else|:
name|gen_movdi_di_update
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|,
name|nsrc
argument_list|)
argument_list|)
expr_stmt|;
name|used_update
operator|=
name|true
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|breg
argument_list|,
name|breg
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|replace_equiv_address
argument_list|(
name|dst
argument_list|,
name|breg
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
name|rs6000_offsettable_memref_p
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Calculate index to next subword.  */
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|nregs
condition|)
name|j
operator|=
literal|0
expr_stmt|;
comment|/* If compiler already emitted move of first word by 	     store with update, no need to do anything.  */
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
name|used_update
condition|)
continue|continue;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|dst
argument_list|,
name|mode
argument_list|,
name|j
operator|*
name|reg_mode_size
argument_list|)
argument_list|,
name|simplify_gen_subreg
argument_list|(
name|reg_mode
argument_list|,
name|src
argument_list|,
name|mode
argument_list|,
name|j
operator|*
name|reg_mode_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the    function prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/* Return the first fixed-point register that is required to be    saved. 32 if none.  */
end_comment

begin_function
name|int
name|first_reg_to_save
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|13
init|;
name|first_reg
operator|<=
literal|31
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
operator|&&
operator|(
operator|!
name|call_used_regs
index|[
name|first_reg
index|]
operator|||
operator|(
name|first_reg
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|||
operator|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|)
operator|)
operator|)
condition|)
break|break;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
operator|&&
name|first_reg
operator|>
name|RS6000_PIC_OFFSET_TABLE_REGNUM
condition|)
return|return
name|RS6000_PIC_OFFSET_TABLE_REGNUM
return|;
endif|#
directive|endif
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Similar, for FP regs.  */
end_comment

begin_function
name|int
name|first_fp_reg_to_save
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|14
operator|+
literal|32
init|;
name|first_reg
operator|<=
literal|63
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
condition|)
break|break;
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Similar, for AltiVec regs.  */
end_comment

begin_function
specifier|static
name|int
name|first_altivec_reg_to_save
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Stack frame remains as is unless we are in AltiVec ABI.  */
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
condition|)
return|return
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
return|;
comment|/* On Darwin, the unwind routines are compiled without      TARGET_ALTIVEC, and use save_world to save/restore the       altivec registers when necessary.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|current_function_calls_eh_return
operator|&&
operator|!
name|TARGET_ALTIVEC
condition|)
return|return
name|FIRST_ALTIVEC_REGNO
operator|+
literal|20
return|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
operator|+
literal|20
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
break|break;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return a 32-bit mask of the AltiVec registers we need to set in    VRSAVE.  Bit n of the return value is 1 if Vn is live.  The MSB in    the 32-bit word is 0.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|compute_vrsave_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|;
comment|/* On Darwin, the unwind routines are compiled without      TARGET_ALTIVEC, and use save_world to save/restore the       call-saved altivec registers when necessary.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|current_function_calls_eh_return
operator|&&
operator|!
name|TARGET_ALTIVEC
condition|)
name|mask
operator||=
literal|0xFFF
expr_stmt|;
comment|/* First, find out if we use _any_ altivec registers.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|mask
operator||=
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
name|mask
return|;
comment|/* Next, remove the argument registers from the set.  These must      be in the VRSAVE mask set by the caller, so we don't need to add      them in again.  More importantly, the mask we compute here is      used to generate CLOBBERs in the set_vrsave insn, and we do not      wish the argument registers to die.  */
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|args_info
operator|.
name|vregno
operator|-
literal|1
init|;
name|i
operator|>=
name|ALTIVEC_ARG_MIN_REG
condition|;
operator|--
name|i
control|)
name|mask
operator|&=
operator|~
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Similarly, remove the return value from the set.  */
block|{
name|bool
name|yes
init|=
name|false
decl_stmt|;
name|diddle_return_value
argument_list|(
name|is_altivec_return_reg
argument_list|,
operator|&
name|yes
argument_list|)
expr_stmt|;
if|if
condition|(
name|yes
condition|)
name|mask
operator|&=
operator|~
name|ALTIVEC_REG_BIT
argument_list|(
name|ALTIVEC_ARG_RETURN
argument_list|)
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* For a very restricted set of circumstances, we can cut down the    size of prologues/epilogues by calling our own save/restore-the-world    routines.  */
end_comment

begin_function
specifier|static
name|void
name|compute_save_world_info
parameter_list|(
name|rs6000_stack_t
modifier|*
name|info_ptr
parameter_list|)
block|{
name|info_ptr
operator|->
name|world_save_p
operator|=
literal|1
expr_stmt|;
name|info_ptr
operator|->
name|world_save_p
operator|=
operator|(
name|WORLD_SAVE_P
argument_list|(
name|info_ptr
argument_list|)
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
operator|!
operator|(
name|current_function_calls_setjmp
operator|&&
name|flag_exceptions
operator|)
operator|&&
name|info_ptr
operator|->
name|first_fp_reg_save
operator|==
name|FIRST_SAVED_FP_REGNO
operator|&&
name|info_ptr
operator|->
name|first_gp_reg_save
operator|==
name|FIRST_SAVED_GP_REGNO
operator|&&
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|==
name|FIRST_SAVED_ALTIVEC_REGNO
operator|&&
name|info_ptr
operator|->
name|cr_save_p
operator|)
expr_stmt|;
comment|/* This will not work in conjunction with sibcalls.  Make sure there      are none.  (This check is expensive, but seldom executed.) */
if|if
condition|(
name|WORLD_SAVE_P
argument_list|(
name|info_ptr
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn_anywhere
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|info_ptr
operator|->
name|world_save_p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|WORLD_SAVE_P
argument_list|(
name|info_ptr
argument_list|)
condition|)
block|{
comment|/* Even if we're not touching VRsave, make sure there's room on the 	 stack for it, if it looks like we're calling SAVE_WORLD, which 	 will attempt to save it. */
name|info_ptr
operator|->
name|vrsave_size
operator|=
literal|4
expr_stmt|;
comment|/* "Save" the VRsave register too if we're saving the world.  */
if|if
condition|(
name|info_ptr
operator|->
name|vrsave_mask
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|vrsave_mask
operator|=
name|compute_vrsave_mask
argument_list|()
expr_stmt|;
comment|/* Because the Darwin register save/restore routines only handle 	 F14 .. F31 and V20 .. V31 as per the ABI, perform a consistency 	 check.  */
name|gcc_assert
argument_list|(
name|info_ptr
operator|->
name|first_fp_reg_save
operator|>=
name|FIRST_SAVED_FP_REGNO
operator|&&
operator|(
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|>=
name|FIRST_SAVED_ALTIVEC_REGNO
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|is_altivec_return_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|xyes
parameter_list|)
block|{
name|bool
modifier|*
name|yes
init|=
operator|(
name|bool
operator|*
operator|)
name|xyes
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|==
name|ALTIVEC_ARG_RETURN
condition|)
operator|*
name|yes
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the stack information for the current function.  This is    complicated by having two separate calling sequences, the AIX calling    sequence and the V.4 calling sequence.     AIX (and Darwin/Mac OS X) stack frames look like: 							  32-bit  64-bit 	SP---->	+---------------------------------------+ 		| back chain to caller			| 0	  0 		+---------------------------------------+ 		| saved CR				| 4       8 (8-11) 		+---------------------------------------+ 		| saved LR				| 8       16 		+---------------------------------------+ 		| reserved for compilers		| 12      24 		+---------------------------------------+ 		| reserved for binders			| 16      32 		+---------------------------------------+ 		| saved TOC pointer			| 20      40 		+---------------------------------------+ 		| Parameter save area (P)		| 24      48 		+---------------------------------------+ 		| Alloca space (A)			| 24+P    etc. 		+---------------------------------------+ 		| Local variable space (L)		| 24+P+A 		+---------------------------------------+ 		| Float/int conversion temporary (X)	| 24+P+A+L 		+---------------------------------------+ 		| Save area for AltiVec registers (W)	| 24+P+A+L+X 		+---------------------------------------+ 		| AltiVec alignment padding (Y)		| 24+P+A+L+X+W 		+---------------------------------------+ 		| Save area for VRSAVE register (Z)	| 24+P+A+L+X+W+Y 		+---------------------------------------+ 		| Save area for GP registers (G)	| 24+P+A+X+L+X+W+Y+Z 		+---------------------------------------+ 		| Save area for FP registers (F)	| 24+P+A+X+L+X+W+Y+Z+G 		+---------------------------------------+ 	old SP->| back chain to caller's caller		| 		+---------------------------------------+     The required alignment for AIX configurations is two words (i.e., 8    or 16 bytes).      V.4 stack frames look like:  	SP---->	+---------------------------------------+ 		| back chain to caller			| 0 		+---------------------------------------+ 		| caller's saved LR			| 4 		+---------------------------------------+ 		| Parameter save area (P)		| 8 		+---------------------------------------+ 		| Alloca space (A)			| 8+P 		+---------------------------------------+ 		| Varargs save area (V)			| 8+P+A 		+---------------------------------------+ 		| Local variable space (L)		| 8+P+A+V 		+---------------------------------------+ 		| Float/int conversion temporary (X)	| 8+P+A+V+L 		+---------------------------------------+ 		| Save area for AltiVec registers (W)	| 8+P+A+V+L+X 		+---------------------------------------+ 		| AltiVec alignment padding (Y)		| 8+P+A+V+L+X+W 		+---------------------------------------+ 		| Save area for VRSAVE register (Z)	| 8+P+A+V+L+X+W+Y 		+---------------------------------------+ 		| SPE: area for 64-bit GP registers	| 		+---------------------------------------+ 		| SPE alignment padding			| 		+---------------------------------------+ 		| saved CR (C)				| 8+P+A+V+L+X+W+Y+Z 		+---------------------------------------+ 		| Save area for GP registers (G)	| 8+P+A+V+L+X+W+Y+Z+C 		+---------------------------------------+ 		| Save area for FP registers (F)	| 8+P+A+V+L+X+W+Y+Z+C+G 		+---------------------------------------+ 	old SP->| back chain to caller's caller		| 		+---------------------------------------+     The required alignment for V.4 is 16 bytes, or 8 bytes if -meabi is    given.  (But note below and in sysv4.h that we require only 8 and    may round up the size of our stack frame anyways.  The historical    reason is early versions of powerpc-linux which didn't properly    align the stack at program startup.  A happy side-effect is that    -mno-eabi libraries can be used with -meabi programs.)     The EABI configuration defaults to the V.4 layout.  However,    the stack alignment requirements may differ.  If -mno-eabi is not    given, the required stack alignment is 8 bytes; if -mno-eabi is    given, the required alignment is 16 bytes.  (But see V.4 comment    above.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ABI_STACK_BOUNDARY
end_ifndef

begin_define
define|#
directive|define
name|ABI_STACK_BOUNDARY
value|STACK_BOUNDARY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|rs6000_stack_t
modifier|*
name|rs6000_stack_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|rs6000_stack_t
name|info
decl_stmt|;
name|rs6000_stack_t
modifier|*
name|info_ptr
init|=
operator|&
name|info
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|int
name|ehrd_size
decl_stmt|;
name|int
name|save_align
decl_stmt|;
name|HOST_WIDE_INT
name|non_fixed_size
decl_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE
condition|)
block|{
comment|/* Cache value so we don't rescan instruction chain over and over.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|insn_chain_scanned_p
operator|==
literal|0
condition|)
name|cfun
operator|->
name|machine
operator|->
name|insn_chain_scanned_p
operator|=
name|spe_func_has_64bit_regs_p
argument_list|()
operator|+
literal|1
expr_stmt|;
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|=
name|cfun
operator|->
name|machine
operator|->
name|insn_chain_scanned_p
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Select which calling sequence.  */
name|info_ptr
operator|->
name|abi
operator|=
name|DEFAULT_ABI
expr_stmt|;
comment|/* Calculate which registers need to be saved& save area size.  */
name|info_ptr
operator|->
name|first_gp_reg_save
operator|=
name|first_reg_to_save
argument_list|()
expr_stmt|;
comment|/* Assume that we will have to save RS6000_PIC_OFFSET_TABLE_REGNUM,      even if it currently looks like we won't.  */
if|if
condition|(
operator|(
operator|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|||
operator|(
name|flag_pic
operator|==
literal|1
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
operator|)
operator|&&
name|info_ptr
operator|->
name|first_gp_reg_save
operator|>
name|RS6000_PIC_OFFSET_TABLE_REGNUM
condition|)
name|info_ptr
operator|->
name|gp_size
operator|=
name|reg_size
operator|*
operator|(
literal|32
operator|-
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|gp_size
operator|=
name|reg_size
operator|*
operator|(
literal|32
operator|-
name|info_ptr
operator|->
name|first_gp_reg_save
operator|)
expr_stmt|;
comment|/* For the SPE, we have an additional upper 32-bits on each GPR.      Ideally we should save the entire 64-bits only when the upper      half is used in SIMD instructions.  Since we only record      registers live (not the size they are used in), this proves      difficult because we'd have to traverse the instruction chain at      the right time, taking reload into account.  This is a real pain,      so we opt to save the GPRs in 64-bits always if but one register      gets used in 64-bits.  Otherwise, all the registers in the frame      get saved in 32-bits.       So... since when we save all GPRs (except the SP) in 64-bits, the      traditional GP save area will be empty.  */
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|gp_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|first_fp_reg_save
operator|=
name|first_fp_reg_to_save
argument_list|()
expr_stmt|;
name|info_ptr
operator|->
name|fp_size
operator|=
literal|8
operator|*
operator|(
literal|64
operator|-
name|info_ptr
operator|->
name|first_fp_reg_save
operator|)
expr_stmt|;
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|=
name|first_altivec_reg_to_save
argument_list|()
expr_stmt|;
name|info_ptr
operator|->
name|altivec_size
operator|=
literal|16
operator|*
operator|(
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
operator|-
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|)
expr_stmt|;
comment|/* Does this function call anything?  */
name|info_ptr
operator|->
name|calls_p
operator|=
operator|(
operator|!
name|current_function_is_leaf
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ra_needs_full_frame
operator|)
expr_stmt|;
comment|/* Determine if we need to save the link register.  */
if|if
condition|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|current_function_profile
operator|&&
operator|!
name|TARGET_PROFILE_KERNEL
operator|)
ifdef|#
directive|ifdef
name|TARGET_RELOCATABLE
operator|||
operator|(
name|TARGET_RELOCATABLE
operator|&&
operator|(
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
endif|#
directive|endif
operator|||
operator|(
name|info_ptr
operator|->
name|first_fp_reg_save
operator|!=
literal|64
operator|&&
operator|!
name|FP_SAVE_INLINE
argument_list|(
name|info_ptr
operator|->
name|first_fp_reg_save
argument_list|)
operator|)
operator|||
name|info_ptr
operator|->
name|first_altivec_reg_save
operator|<=
name|LAST_ALTIVEC_REGNO
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|current_function_calls_alloca
operator|)
operator|||
name|info_ptr
operator|->
name|calls_p
operator|||
name|rs6000_ra_ever_killed
argument_list|()
condition|)
block|{
name|info_ptr
operator|->
name|lr_save_p
operator|=
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|LINK_REGISTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Determine if we need to save the condition code registers.  */
if|if
condition|(
name|regs_ever_live
index|[
name|CR2_REGNO
index|]
operator|||
name|regs_ever_live
index|[
name|CR3_REGNO
index|]
operator|||
name|regs_ever_live
index|[
name|CR4_REGNO
index|]
condition|)
block|{
name|info_ptr
operator|->
name|cr_save_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
name|info_ptr
operator|->
name|cr_size
operator|=
name|reg_size
expr_stmt|;
block|}
comment|/* If the current function calls __builtin_eh_return, then we need      to allocate stack space for registers that will hold data for      the exception handler.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
operator|!=
name|INVALID_REGNUM
condition|;
operator|++
name|i
control|)
continue|continue;
comment|/* SPE saves EH registers in 64-bits.  */
name|ehrd_size
operator|=
name|i
operator|*
operator|(
name|TARGET_SPE_ABI
operator|&&
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|?
name|UNITS_PER_SPE_WORD
else|:
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
else|else
name|ehrd_size
operator|=
literal|0
expr_stmt|;
comment|/* Determine various sizes.  */
name|info_ptr
operator|->
name|reg_size
operator|=
name|reg_size
expr_stmt|;
name|info_ptr
operator|->
name|fixed_size
operator|=
name|RS6000_SAVE_AREA
expr_stmt|;
name|info_ptr
operator|->
name|vars_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|get_frame_size
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|info_ptr
operator|->
name|parm_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|current_function_outgoing_args_size
argument_list|,
name|TARGET_ALTIVEC
condition|?
literal|16
else|:
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|FRAME_GROWS_DOWNWARD
condition|)
name|info_ptr
operator|->
name|vars_size
operator|+=
name|RS6000_ALIGN
argument_list|(
name|info_ptr
operator|->
name|fixed_size
operator|+
name|info_ptr
operator|->
name|vars_size
operator|+
name|info_ptr
operator|->
name|parm_size
argument_list|,
name|ABI_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|-
operator|(
name|info_ptr
operator|->
name|fixed_size
operator|+
name|info_ptr
operator|->
name|vars_size
operator|+
name|info_ptr
operator|->
name|parm_size
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|spe_gp_size
operator|=
literal|8
operator|*
operator|(
literal|32
operator|-
name|info_ptr
operator|->
name|first_gp_reg_save
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|spe_gp_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
name|info_ptr
operator|->
name|vrsave_mask
operator|=
name|compute_vrsave_mask
argument_list|()
expr_stmt|;
else|else
name|info_ptr
operator|->
name|vrsave_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_VRSAVE
operator|&&
name|info_ptr
operator|->
name|vrsave_mask
condition|)
name|info_ptr
operator|->
name|vrsave_size
operator|=
literal|4
expr_stmt|;
else|else
name|info_ptr
operator|->
name|vrsave_size
operator|=
literal|0
expr_stmt|;
name|compute_save_world_info
argument_list|(
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* Calculate the offsets.  */
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
case|case
name|ABI_NONE
case|:
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
case|case
name|ABI_DARWIN
case|:
name|info_ptr
operator|->
name|fp_save_offset
operator|=
operator|-
name|info_ptr
operator|->
name|fp_size
expr_stmt|;
name|info_ptr
operator|->
name|gp_save_offset
operator|=
name|info_ptr
operator|->
name|fp_save_offset
operator|-
name|info_ptr
operator|->
name|gp_size
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
block|{
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|info_ptr
operator|->
name|vrsave_size
expr_stmt|;
comment|/* Align stack so vector save area is on a quadword boundary.   	     The padding goes above the vectors.  */
if|if
condition|(
name|info_ptr
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
name|info_ptr
operator|->
name|vrsave_save_offset
operator|&
literal|0xF
expr_stmt|;
else|else
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
name|info_ptr
operator|->
name|vrsave_save_offset
operator|-
name|info_ptr
operator|->
name|altivec_padding_size
operator|-
name|info_ptr
operator|->
name|altivec_size
expr_stmt|;
name|gcc_assert
argument_list|(
name|info_ptr
operator|->
name|altivec_size
operator|==
literal|0
operator|||
name|info_ptr
operator|->
name|altivec_save_offset
operator|%
literal|16
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Adjust for AltiVec case.  */
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|altivec_save_offset
operator|-
name|ehrd_size
expr_stmt|;
block|}
else|else
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|ehrd_size
expr_stmt|;
name|info_ptr
operator|->
name|cr_save_offset
operator|=
name|reg_size
expr_stmt|;
comment|/* first word when 64-bit.  */
name|info_ptr
operator|->
name|lr_save_offset
operator|=
literal|2
operator|*
name|reg_size
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
name|info_ptr
operator|->
name|fp_save_offset
operator|=
operator|-
name|info_ptr
operator|->
name|fp_size
expr_stmt|;
name|info_ptr
operator|->
name|gp_save_offset
operator|=
name|info_ptr
operator|->
name|fp_save_offset
operator|-
name|info_ptr
operator|->
name|gp_size
expr_stmt|;
name|info_ptr
operator|->
name|cr_save_offset
operator|=
name|info_ptr
operator|->
name|gp_save_offset
operator|-
name|info_ptr
operator|->
name|cr_size
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
comment|/* Align stack so SPE GPR save area is aligned on a 	     double-word boundary.  */
if|if
condition|(
name|info_ptr
operator|->
name|spe_gp_size
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|spe_padding_size
operator|=
literal|8
operator|-
operator|(
operator|-
name|info_ptr
operator|->
name|cr_save_offset
operator|%
literal|8
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|spe_padding_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|spe_gp_save_offset
operator|=
name|info_ptr
operator|->
name|cr_save_offset
operator|-
name|info_ptr
operator|->
name|spe_padding_size
operator|-
name|info_ptr
operator|->
name|spe_gp_size
expr_stmt|;
comment|/* Adjust for SPE case.  */
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|spe_gp_save_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
block|{
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
name|info_ptr
operator|->
name|cr_save_offset
operator|-
name|info_ptr
operator|->
name|vrsave_size
expr_stmt|;
comment|/* Align stack so vector save area is on a quadword boundary.  */
if|if
condition|(
name|info_ptr
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|16
operator|-
operator|(
operator|-
name|info_ptr
operator|->
name|vrsave_save_offset
operator|%
literal|16
operator|)
expr_stmt|;
else|else
name|info_ptr
operator|->
name|altivec_padding_size
operator|=
literal|0
expr_stmt|;
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
name|info_ptr
operator|->
name|vrsave_save_offset
operator|-
name|info_ptr
operator|->
name|altivec_padding_size
operator|-
name|info_ptr
operator|->
name|altivec_size
expr_stmt|;
comment|/* Adjust for AltiVec case.  */
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|altivec_save_offset
expr_stmt|;
block|}
else|else
name|info_ptr
operator|->
name|ehrd_offset
operator|=
name|info_ptr
operator|->
name|cr_save_offset
expr_stmt|;
name|info_ptr
operator|->
name|ehrd_offset
operator|-=
name|ehrd_size
expr_stmt|;
name|info_ptr
operator|->
name|lr_save_offset
operator|=
name|reg_size
expr_stmt|;
break|break;
block|}
name|save_align
operator|=
operator|(
name|TARGET_ALTIVEC_ABI
operator|||
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
name|info_ptr
operator|->
name|save_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|info_ptr
operator|->
name|fp_size
operator|+
name|info_ptr
operator|->
name|gp_size
operator|+
name|info_ptr
operator|->
name|altivec_size
operator|+
name|info_ptr
operator|->
name|altivec_padding_size
operator|+
name|info_ptr
operator|->
name|spe_gp_size
operator|+
name|info_ptr
operator|->
name|spe_padding_size
operator|+
name|ehrd_size
operator|+
name|info_ptr
operator|->
name|cr_size
operator|+
name|info_ptr
operator|->
name|vrsave_size
argument_list|,
name|save_align
argument_list|)
expr_stmt|;
name|non_fixed_size
operator|=
operator|(
name|info_ptr
operator|->
name|vars_size
operator|+
name|info_ptr
operator|->
name|parm_size
operator|+
name|info_ptr
operator|->
name|save_size
operator|)
expr_stmt|;
name|info_ptr
operator|->
name|total_size
operator|=
name|RS6000_ALIGN
argument_list|(
name|non_fixed_size
operator|+
name|info_ptr
operator|->
name|fixed_size
argument_list|,
name|ABI_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Determine if we need to allocate any stack frame:       For AIX we need to push the stack if a frame pointer is needed      (because the stack might be dynamically adjusted), if we are      debugging, if we make calls, or if the sum of fp_save, gp_save,      and local variables are more than the space needed to save all      non-volatile registers: 32-bit: 18*8 + 19*4 = 220 or 64-bit: 18*8      + 18*8 = 288 (GPR13 reserved).       For V.4 we don't have the stack cushion that AIX uses, but assume      that the debugger can handle stackless frames.  */
if|if
condition|(
name|info_ptr
operator|->
name|calls_p
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
name|non_fixed_size
operator|!=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_pointer_needed
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_XCOFF
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|info_ptr
operator|->
name|push_p
operator|=
literal|1
expr_stmt|;
else|else
name|info_ptr
operator|->
name|push_p
operator|=
name|non_fixed_size
operator|>
operator|(
name|TARGET_32BIT
condition|?
literal|220
else|:
literal|288
operator|)
expr_stmt|;
comment|/* Zero offsets if we're not saving those registers.  */
if|if
condition|(
name|info_ptr
operator|->
name|fp_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|fp_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info_ptr
operator|->
name|gp_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|gp_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
operator|||
name|info_ptr
operator|->
name|altivec_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|altivec_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ALTIVEC_ABI
operator|||
name|info_ptr
operator|->
name|vrsave_mask
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|vrsave_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_SPE_ABI
operator|||
name|info_ptr
operator|->
name|spe_64bit_regs_used
operator|==
literal|0
operator|||
name|info_ptr
operator|->
name|spe_gp_size
operator|==
literal|0
condition|)
name|info_ptr
operator|->
name|spe_gp_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info_ptr
operator|->
name|lr_save_p
condition|)
name|info_ptr
operator|->
name|lr_save_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info_ptr
operator|->
name|cr_save_p
condition|)
name|info_ptr
operator|->
name|cr_save_offset
operator|=
literal|0
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Return true if the current function uses any GPRs in 64-bit SIMD    mode.  */
end_comment

begin_function
specifier|static
name|bool
name|spe_func_has_64bit_regs_p
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insns
decl_stmt|,
name|insn
decl_stmt|;
comment|/* Functions that save and restore all the call-saved registers will      need to save/restore the registers in 64-bits.  */
if|if
condition|(
name|current_function_calls_eh_return
operator|||
name|current_function_calls_setjmp
operator|||
name|current_function_has_nonlocal_goto
condition|)
return|return
name|true
return|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insns
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|i
decl_stmt|;
comment|/* FIXME: This should be implemented with attributes...  	         (set_attr "spe64" "true")....then, 	         if (get_spe64(insn)) return true;  	     It's the only reliable way to do the stuff below.  */
name|i
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|SET
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TARGET_E500_DOUBLE
operator|&&
name|mode
operator|==
name|DFmode
condition|)
return|return
name|true
return|;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_stack_info
parameter_list|(
name|rs6000_stack_t
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|abi_string
decl_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
name|info
operator|=
name|rs6000_stack_info
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nStack information for function %s:\n"
argument_list|,
operator|(
operator|(
name|current_function_decl
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
else|:
literal|"<unknown>"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|abi
condition|)
block|{
default|default:
name|abi_string
operator|=
literal|"Unknown"
expr_stmt|;
break|break;
case|case
name|ABI_NONE
case|:
name|abi_string
operator|=
literal|"NONE"
expr_stmt|;
break|break;
case|case
name|ABI_AIX
case|:
name|abi_string
operator|=
literal|"AIX"
expr_stmt|;
break|break;
case|case
name|ABI_DARWIN
case|:
name|abi_string
operator|=
literal|"Darwin"
expr_stmt|;
break|break;
case|case
name|ABI_V4
case|:
name|abi_string
operator|=
literal|"V.4"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tABI                 = %5s\n"
argument_list|,
name|abi_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ALTIVEC_ABI
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tALTIVEC ABI extensions enabled.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tSPE ABI extensions enabled.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_gp_reg_save
operator|!=
literal|32
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_gp_reg_save   = %5d\n"
argument_list|,
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_fp_reg_save   = %5d\n"
argument_list|,
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_altivec_reg_save
operator|<=
name|LAST_ALTIVEC_REGNO
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfirst_altivec_reg_save = %5d\n"
argument_list|,
name|info
operator|->
name|first_altivec_reg_save
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlr_save_p           = %5d\n"
argument_list|,
name|info
operator|->
name|lr_save_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_save_p           = %5d\n"
argument_list|,
name|info
operator|->
name|cr_save_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_mask
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_mask         = 0x%x\n"
argument_list|,
name|info
operator|->
name|vrsave_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|push_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tpush_p              = %5d\n"
argument_list|,
name|info
operator|->
name|push_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|calls_p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcalls_p             = %5d\n"
argument_list|,
name|info
operator|->
name|calls_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|gp_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tgp_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|gp_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fp_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfp_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|fp_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_save_offset = %5d\n"
argument_list|,
name|info
operator|->
name|altivec_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|spe_gp_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tspe_gp_save_offset  = %5d\n"
argument_list|,
name|info
operator|->
name|spe_gp_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_save_offset  = %5d\n"
argument_list|,
name|info
operator|->
name|vrsave_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlr_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|lr_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_save_offset      = %5d\n"
argument_list|,
name|info
operator|->
name|cr_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|varargs_save_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvarargs_save_offset = %5d\n"
argument_list|,
name|info
operator|->
name|varargs_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|total_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttotal_size          = "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|info
operator|->
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vars_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvars_size           = "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|info
operator|->
name|vars_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|parm_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tparm_size           = %5d\n"
argument_list|,
name|info
operator|->
name|parm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fixed_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfixed_size          = %5d\n"
argument_list|,
name|info
operator|->
name|fixed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|gp_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tgp_size             = %5d\n"
argument_list|,
name|info
operator|->
name|gp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|spe_gp_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tspe_gp_size         = %5d\n"
argument_list|,
name|info
operator|->
name|spe_gp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|fp_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfp_size             = %5d\n"
argument_list|,
name|info
operator|->
name|fp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_size        = %5d\n"
argument_list|,
name|info
operator|->
name|altivec_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vrsave_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvrsave_size         = %5d\n"
argument_list|,
name|info
operator|->
name|vrsave_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|altivec_padding_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\taltivec_padding_size= %5d\n"
argument_list|,
name|info
operator|->
name|altivec_padding_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|spe_padding_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tspe_padding_size    = %5d\n"
argument_list|,
name|info
operator|->
name|spe_padding_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|cr_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcr_size             = %5d\n"
argument_list|,
name|info
operator|->
name|cr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|save_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsave_size           = %5d\n"
argument_list|,
name|info
operator|->
name|save_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|reg_size
operator|!=
literal|4
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\treg_size            = %5d\n"
argument_list|,
name|info
operator|->
name|reg_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|rs6000_return_addr
parameter_list|(
name|int
name|count
parameter_list|,
name|rtx
name|frame
parameter_list|)
block|{
comment|/* Currently we don't optimize very well between prolog and body      code and for PIC code the code can be actually quite bad, so      don't try to be too clever here.  */
if|if
condition|(
name|count
operator|!=
literal|0
operator|||
operator|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|flag_pic
operator|)
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|ra_needs_full_frame
operator|=
literal|1
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|copy_to_reg
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|frame
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|RETURN_ADDRESS_OFFSET
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|cfun
operator|->
name|machine
operator|->
name|ra_need_lr
operator|=
literal|1
expr_stmt|;
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Say whether a function is a candidate for sibcall handling or not.    We do not allow indirect calls to be optimized into sibling calls.    Also, we can't do it if there are any vector parameters; there's    nowhere to put the VRsave code so it works; note that functions with    vector parameters are required to have a prototype, so the argument    type info must be available here.  (The tail recursion case can work    with vector parameters, but there's no way to distinguish here.) */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
if|if
condition|(
name|TARGET_ALTIVEC_VRSAVE
condition|)
block|{
for|for
control|(
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|type
condition|;
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|||
operator|(
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
block|{
name|tree
name|attr_list
init|=
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"longcall"
argument_list|,
name|attr_list
argument_list|)
operator|||
name|lookup_attribute
argument_list|(
literal|"shortcall"
argument_list|,
name|attr_list
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* NULL if INSN insn is valid within a low-overhead loop.    Otherwise return why doloop cannot be applied.    PowerPC uses the COUNT register for branch on table instructions.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_invalid_within_doloop
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|"Function call in the loop."
return|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
return|return
literal|"Computed branch in the loop."
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rs6000_ra_ever_killed
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|top
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|current_function_is_thunk
condition|)
return|return
literal|0
return|;
comment|/* regs_ever_live has LR marked as used if any sibcalls are present,      but this should not force saving and restoring in the      pro/epilogue.  Likewise, reg_set_between_p thinks a sibcall      clobbers LR, so that is inappropriate.  */
comment|/* Also, the prologue can generate a store into LR that      doesn't really count, like this:          move LR->R0         bcl to set PIC register         move LR->R31         move R0->LR       When we're called from the epilogue, we need to avoid counting      this as a store.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
name|top
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|top
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_INC
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|set_of
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|prologue_epilogue_contains
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a REG_MAYBE_DEAD note to the insn.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_maybe_dead
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit instructions needed to load the TOC register.    This is only needed when TARGET_TOC, TARGET_MINIMAL_TOC, and there is    a constant pool; or for SVR4 -fpic.  */
end_comment

begin_function
name|void
name|rs6000_emit_load_toc_table
parameter_list|(
name|int
name|fromprolog
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|insn
decl_stmt|;
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RS6000_PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ELF
operator|&&
name|TARGET_SECURE_PLT
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|flag_pic
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|rtx
name|lab
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|got
decl_stmt|,
name|tempLR
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCF"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|lab
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
name|got
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|toc_label_name
argument_list|)
expr_stmt|;
else|else
name|got
operator|=
name|rs6000_got_sym
argument_list|()
expr_stmt|;
name|tmp1
operator|=
name|tmp2
operator|=
name|dest
expr_stmt|;
if|if
condition|(
operator|!
name|fromprolog
condition|)
block|{
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
name|tempLR
operator|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1
argument_list|(
name|tempLR
argument_list|,
name|lab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|tmp1
argument_list|,
name|tempLR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_3b
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|got
argument_list|,
name|lab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_3c
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|got
argument_list|,
name|lab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ELF
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|rtx
name|tempLR
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_v4_pic_si
argument_list|(
name|tempLR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|tempLR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ELF
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|rtx
name|tempLR
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|temp0
init|=
operator|(
name|fromprolog
condition|?
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|fromprolog
condition|)
block|{
name|rtx
name|symF
decl_stmt|,
name|symL
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCF"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|symF
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCL"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|symL
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1
argument_list|(
name|tempLR
argument_list|,
name|symF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|tempLR
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_2
argument_list|(
name|temp0
argument_list|,
name|dest
argument_list|,
name|symL
argument_list|,
name|symF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tocsym
decl_stmt|;
name|tocsym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|toc_label_name
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_toc_v4_PIC_1b
argument_list|(
name|tempLR
argument_list|,
name|tocsym
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|tempLR
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp0
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dest
argument_list|,
name|temp0
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ELF
operator|&&
operator|!
name|TARGET_AIX
operator|&&
name|flag_pic
operator|==
literal|0
operator|&&
name|TARGET_MINIMAL_TOC
condition|)
block|{
comment|/* This is for AIX code running in non-PIC ELF32.  */
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|rtx
name|realsym
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCTOC"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|realsym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|dest
argument_list|,
name|realsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|dest
argument_list|,
name|dest
argument_list|,
name|realsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_32BIT
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_aix_si
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_toc_aix_di
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromprolog
condition|)
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit instructions to restore the link register after determining where    its value has been stored.  */
end_comment

begin_function
name|void
name|rs6000_emit_eh_reg_restore
parameter_list|(
name|rtx
name|source
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|source
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|scratch
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|frame_rtx
init|=
name|stack_pointer_rtx
decl_stmt|;
name|HOST_WIDE_INT
name|sp_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
operator|||
name|current_function_calls_alloca
operator|||
name|info
operator|->
name|total_size
operator|>
literal|32767
condition|)
block|{
name|tmp
operator|=
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|frame_rtx
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|push_p
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|frame_rtx
argument_list|,
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|set
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|get_TOC_alias_set
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|set
operator|==
operator|-
literal|1
condition|)
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* This returns nonzero if the current function uses the TOC.  This is    determined by the presence of (use (unspec ... UNSPEC_TOC)), which    is generated by the ABI_V4 load_toc_* patterns.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_function
specifier|static
name|int
name|uses_TOC
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|USE
condition|)
block|{
name|sub
operator|=
name|XEXP
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TOC
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|rtx
name|create_TOC_reference
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
name|regs_ever_live
index|[
name|TOC_REGISTER
index|]
operator|=
literal|1
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|TOC_REGISTER
argument_list|)
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|symbol
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|toc_label_name
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If _Unwind_* has been called from within the same module,    toc register is not guaranteed to be saved to 40(1) on function    entry.  Save it there in that case.  */
end_comment

begin_function
name|void
name|rs6000_aix_emit_builtin_unwind_init
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|mem
decl_stmt|;
name|rtx
name|stack_top
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|opcode_addr
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|opcode
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|tocompare
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|no_toc_save_needed
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|stack_top
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_top
argument_list|,
name|GEN_INT
argument_list|(
literal|2
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|opcode_addr
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|opcode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|opcode_addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tocompare
argument_list|,
name|gen_int_mode
argument_list|(
name|TARGET_32BIT
condition|?
literal|0x80410014
else|:
literal|0xE8410028
argument_list|,
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|opcode
argument_list|,
name|tocompare
argument_list|,
name|EQ
argument_list|,
literal|1
argument_list|,
name|SImode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|no_toc_save_needed
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_top
argument_list|,
name|GEN_INT
argument_list|(
literal|5
operator|*
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|no_toc_save_needed
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This ties together stack memory (MEM with an alias set of frame_alias_set)    and the change to the stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_emit_stack_tie
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_stack_tie
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the correct code for allocating stack space, as insns.    If COPY_R12, make sure a copy of the old frame is left in r12.    The generated code may use hard register 0 as a temporary.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_emit_allocate_stack
parameter_list|(
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|copy_r12
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|stack_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|tmp_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|todec
init|=
name|gen_int_mode
argument_list|(
operator|-
name|size
argument_list|,
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|todec
argument_list|)
operator|!=
operator|-
name|size
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"stack frame too large"
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_trap
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|current_function_limit_stack
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|>
literal|1
operator|&&
name|REGNO
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|<=
literal|31
condition|)
block|{
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|tmp_reg
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|tmp_reg
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cond_trap
argument_list|(
name|LTU
argument_list|,
name|stack_reg
argument_list|,
name|tmp_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|stack_limit_rtx
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|TARGET_32BIT
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
block|{
name|rtx
name|toload
init|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_limit_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_high
argument_list|(
name|tmp_reg
argument_list|,
name|toload
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_elf_low
argument_list|(
name|tmp_reg
argument_list|,
name|tmp_reg
argument_list|,
name|toload
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cond_trap
argument_list|(
name|LTU
argument_list|,
name|stack_reg
argument_list|,
name|tmp_reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"stack limit expression is not supported"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_r12
operator|||
operator|!
name|TARGET_UPDATE
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
argument_list|,
name|stack_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_UPDATE
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|32767
condition|)
block|{
comment|/* Need a note here so that try_split doesn't get confused.  */
if|if
condition|(
name|get_last_insn
argument_list|()
operator|==
name|NULL_RTX
condition|)
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|tmp_reg
argument_list|,
name|todec
argument_list|)
expr_stmt|;
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|todec
operator|=
name|tmp_reg
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_movsi_update
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|,
name|stack_reg
argument_list|)
else|:
name|gen_movdi_di_update
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|,
name|stack_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|stack_reg
argument_list|,
name|stack_reg
argument_list|,
name|todec
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|stack_reg
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced    with (plus:P (reg 1) VAL), and with REG2 replaced with RREG if REG2    is not NULL.  It would be nice if dwarf2out_frame_debug_expr could    deduce these equivalences by itself so it wasn't necessary to hold    its hand so much.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_frame_related
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|,
name|rtx
name|reg2
parameter_list|,
name|rtx
name|rreg
parameter_list|)
block|{
name|rtx
name|real
decl_stmt|,
name|temp
decl_stmt|;
comment|/* copy_rtx will not make unique copies of registers, so we need to      ensure we don't have unwanted sharing here.  */
if|if
condition|(
name|reg
operator|==
name|reg2
condition|)
name|reg
operator|=
name|gen_raw_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|rreg
condition|)
name|reg
operator|=
name|gen_raw_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|real
operator|=
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg2
operator|!=
name|NULL_RTX
condition|)
name|real
operator|=
name|replace_rtx
argument_list|(
name|real
argument_list|,
name|reg2
argument_list|,
name|rreg
argument_list|)
expr_stmt|;
name|real
operator|=
name|replace_rtx
argument_list|(
name|real
argument_list|,
name|reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We expect that 'real' is either a SET or a PARALLEL containing      SETs (and possibly other stuff).  In a PARALLEL, all the SETs      are important so they all have to be marked RTX_FRAME_RELATED_P.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|real
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|set
init|=
name|real
decl_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|real
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|real
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|real
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|real
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|set
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_SPE
condition|)
name|real
operator|=
name|spe_synthesize_frame_save
argument_list|(
name|real
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|real
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an SPE frame note, return a PARALLEL of SETs with the    original note, plus a synthetic register save.  */
end_comment

begin_function
specifier|static
name|rtx
name|spe_synthesize_frame_save
parameter_list|(
name|rtx
name|real
parameter_list|)
block|{
name|rtx
name|synth
decl_stmt|,
name|offset
decl_stmt|,
name|reg
decl_stmt|,
name|real2
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|real
argument_list|)
operator|!=
name|SET
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|real
argument_list|)
argument_list|)
operator|!=
name|V2SImode
condition|)
return|return
name|real
return|;
comment|/* For the SPE, registers saved in 64-bits, get a PARALLEL for their      frame related note.  The parallel contains a set of the register      being saved, and another set to a synthetic register (n+1200).      This is so we can differentiate between 64-bit and 32-bit saves.      Words cannot describe this nastiness.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|real
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|real
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|real
argument_list|)
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
comment|/* Transform:        (set (mem (plus (reg x) (const y)))             (reg z))      into:        (set (mem (plus (reg x) (const y+4)))             (reg z+1200))   */
name|real2
operator|=
name|copy_rtx
argument_list|(
name|real
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|real2
argument_list|)
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SET_SRC
argument_list|(
name|real2
argument_list|)
expr_stmt|;
name|real2
operator|=
name|replace_rtx
argument_list|(
name|real2
argument_list|,
name|reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|synth
operator|=
name|copy_rtx
argument_list|(
name|real2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|real2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|real2
operator|=
name|replace_rtx
argument_list|(
name|real2
argument_list|,
name|offset
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|SET_SRC
argument_list|(
name|synth
argument_list|)
expr_stmt|;
name|synth
operator|=
name|replace_rtx
argument_list|(
name|synth
argument_list|,
name|reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
literal|1200
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|synth
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|synth
operator|=
name|replace_rtx
argument_list|(
name|synth
argument_list|,
name|offset
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|+
operator|(
name|BYTES_BIG_ENDIAN
condition|?
literal|0
else|:
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|synth
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|real2
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|real
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|synth
argument_list|,
name|real2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|real
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|real2
argument_list|,
name|synth
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|real
return|;
block|}
end_function

begin_comment
comment|/* Returns an insn that has a vrsave set operation with the    appropriate CLOBBERs.  */
end_comment

begin_function
specifier|static
name|rtx
name|generate_set_vrsave
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rs6000_stack_t
modifier|*
name|info
parameter_list|,
name|int
name|epiloguep
parameter_list|)
block|{
name|int
name|nclobs
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|clobs
index|[
name|TOTAL_ALTIVEC_REGS
operator|+
literal|1
index|]
decl_stmt|;
name|rtx
name|vrsave
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|VRSAVE_REGNO
argument_list|)
decl_stmt|;
name|clobs
index|[
literal|0
index|]
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|vrsave
argument_list|,
name|gen_rtx_UNSPEC_VOLATILE
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|reg
argument_list|,
name|vrsave
argument_list|)
argument_list|,
name|UNSPECV_SET_VRSAVE
argument_list|)
argument_list|)
expr_stmt|;
name|nclobs
operator|=
literal|1
expr_stmt|;
comment|/* We need to clobber the registers in the mask so the scheduler      does not move sets to VRSAVE before sets of AltiVec registers.       However, if the function receives nonlocal gotos, reload will set      all call saved registers live.  We will end up with:       	(set (reg 999) (mem)) 	(parallel [ (set (reg vrsave) (unspec blah)) 		    (clobber (reg 999))])       The clobber will cause the store into reg 999 to be dead, and      flow will attempt to delete an epilogue insn.  In this case, we      need an unspec use/set of the register.  */
for|for
control|(
name|i
operator|=
name|FIRST_ALTIVEC_REGNO
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|epiloguep
operator|||
name|call_used_regs
index|[
name|i
index|]
condition|)
name|clobs
index|[
name|nclobs
operator|++
index|]
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|clobs
index|[
name|nclobs
operator|++
index|]
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|27
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nclobs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nclobs
condition|;
operator|++
name|i
control|)
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|clobs
index|[
name|i
index|]
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Save a register into the frame, and emit RTX_FRAME_RELATED_P notes.    Save REGNO into [FRAME_REG + OFFSET] in mode MODE.  */
end_comment

begin_function
specifier|static
name|void
name|emit_frame_save
parameter_list|(
name|rtx
name|frame_reg
parameter_list|,
name|rtx
name|frame_ptr
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|int
name|offset
parameter_list|,
name|HOST_WIDE_INT
name|total_size
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|,
name|offset_rtx
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|,
name|addr
decl_stmt|,
name|int_rtx
decl_stmt|;
name|rtx
name|replacea
decl_stmt|,
name|replaceb
decl_stmt|;
name|int_rtx
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* Some cases that need register indexed addressing.  */
if|if
condition|(
operator|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|TARGET_E500_DOUBLE
operator|&&
name|mode
operator|==
name|DFmode
operator|)
operator|||
operator|(
name|TARGET_SPE_ABI
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
operator|)
condition|)
block|{
comment|/* Whomever calls us must make sure r11 is available in the 	 flow path of instructions in the prologue.  */
name|offset_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset_rtx
argument_list|,
name|int_rtx
argument_list|)
expr_stmt|;
name|replacea
operator|=
name|offset_rtx
expr_stmt|;
name|replaceb
operator|=
name|int_rtx
expr_stmt|;
block|}
else|else
block|{
name|offset_rtx
operator|=
name|int_rtx
expr_stmt|;
name|replacea
operator|=
name|NULL_RTX
expr_stmt|;
name|replaceb
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr
argument_list|,
name|total_size
argument_list|,
name|replacea
argument_list|,
name|replaceb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an offset memory reference suitable for a frame store, while    converting to a valid addressing mode.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_frame_mem_offset
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|rtx
name|int_rtx
decl_stmt|,
name|offset_rtx
decl_stmt|;
name|int_rtx
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TARGET_SPE_ABI
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|TARGET_E500_DOUBLE
operator|&&
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
name|offset_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FIXED_SCRATCH
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset_rtx
argument_list|,
name|int_rtx
argument_list|)
expr_stmt|;
block|}
else|else
name|offset_rtx
operator|=
name|int_rtx
expr_stmt|;
return|return
name|gen_frame_mem
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look for user-defined global regs.  We should not save and restore these,    and cannot use stmw/lmw if there are any in its range.  */
end_comment

begin_function
specifier|static
name|bool
name|no_global_regs_above
parameter_list|(
name|int
name|first_greg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|first_greg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|first_greg
operator|+
name|i
index|]
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_FIX_AND_CONTINUE
end_ifndef

begin_define
define|#
directive|define
name|TARGET_FIX_AND_CONTINUE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Emit function prologue as insns.  */
end_comment

begin_function
name|void
name|rs6000_emit_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|Pmode
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|rtx
name|sp_reg_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|frame_ptr_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|rtx
name|frame_reg_rtx
init|=
name|sp_reg_rtx
decl_stmt|;
name|rtx
name|cr_save_rtx
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|saving_FPRs_inline
decl_stmt|;
name|int
name|using_store_multiple
decl_stmt|;
name|HOST_WIDE_INT
name|sp_offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TARGET_FIX_AND_CONTINUE
condition|)
block|{
comment|/* gdb on darwin arranges to forward a function from the old 	 address by modifying the first 5 instructions of the function 	 to branch to the overriding function.  This is necessary to 	 permit function pointers that point to the old function to 	 actually forward to the new function.  */
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
name|reg_mode
operator|=
name|V2SImode
expr_stmt|;
name|reg_size
operator|=
literal|8
expr_stmt|;
block|}
name|using_store_multiple
operator|=
operator|(
name|TARGET_MULTIPLE
operator|&&
operator|!
name|TARGET_POWERPC64
operator|&&
operator|(
operator|!
name|TARGET_SPE_ABI
operator|||
name|info
operator|->
name|spe_64bit_regs_used
operator|==
literal|0
operator|)
operator|&&
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|31
operator|&&
name|no_global_regs_above
argument_list|(
name|info
operator|->
name|first_gp_reg_save
argument_list|)
operator|)
expr_stmt|;
name|saving_FPRs_inline
operator|=
operator|(
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|||
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
operator|||
name|current_function_calls_eh_return
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ra_need_lr
operator|)
expr_stmt|;
comment|/* For V.4, update stack before we do any saving and set back pointer.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|info
operator|->
name|push_p
operator|&&
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|||
name|current_function_calls_eh_return
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|total_size
operator|<
literal|32767
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
else|else
name|frame_reg_rtx
operator|=
name|frame_ptr_rtx
expr_stmt|;
name|rs6000_emit_allocate_stack
argument_list|(
name|info
operator|->
name|total_size
argument_list|,
operator|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
operator|&&
operator|(
name|info
operator|->
name|cr_save_p
operator|||
name|info
operator|->
name|lr_save_p
operator|||
name|info
operator|->
name|first_fp_reg_save
operator|<
literal|64
operator|||
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|32
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
condition|)
name|rs6000_emit_stack_tie
argument_list|()
expr_stmt|;
block|}
comment|/* Handle world saves specially here.  */
if|if
condition|(
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sz
decl_stmt|;
name|rtx
name|treg
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
name|rtx
name|reg0
decl_stmt|;
comment|/* save_world expects lr in r0. */
name|reg0
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg0
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The SAVE_WORLD and RESTORE_WORLD routines make a number of 	 assumptions about the offsets of various bits of the stack 	 frame.  */
name|gcc_assert
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|==
operator|-
literal|220
operator|&&
name|info
operator|->
name|fp_save_offset
operator|==
operator|-
literal|144
operator|&&
name|info
operator|->
name|lr_save_offset
operator|==
literal|8
operator|&&
name|info
operator|->
name|cr_save_offset
operator|==
literal|4
operator|&&
name|info
operator|->
name|push_p
operator|&&
name|info
operator|->
name|lr_save_p
operator|&&
operator|(
operator|!
name|current_function_calls_eh_return
operator|||
name|info
operator|->
name|ehrd_offset
operator|==
operator|-
literal|432
operator|)
operator|&&
name|info
operator|->
name|vrsave_save_offset
operator|==
operator|-
literal|224
operator|&&
name|info
operator|->
name|altivec_save_offset
operator|==
operator|-
literal|416
argument_list|)
expr_stmt|;
name|treg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|treg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|info
operator|->
name|total_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SAVE_WORLD takes the caller's LR in R0 and the frame size 	 in R11.  It also clobbers R12, so beware!  */
comment|/* Preserve CR2 for save_world prologues */
name|sz
operator|=
literal|5
expr_stmt|;
name|sz
operator|+=
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
expr_stmt|;
name|sz
operator|+=
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
expr_stmt|;
name|sz
operator|+=
name|LAST_ALTIVEC_REGNO
operator|-
name|info
operator|->
name|first_altivec_reg_save
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"*save_world"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do floats first so that the instruction pattern matches 	 properly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info
operator|->
name|first_altivec_reg_save
operator|+
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|info
operator|->
name|first_altivec_reg_save
operator|+
name|i
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|altivec_save_offset
operator|+
name|sp_offset
operator|+
literal|16
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|V4SImode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* CR register traditionally saved as CR2.  */
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|CR2_REGNO
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|cr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Explain about use of R0.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg0
argument_list|)
expr_stmt|;
block|}
comment|/* Explain what happens to the stack pointer.  */
block|{
name|rtx
name|newval
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sp_reg_rtx
argument_list|,
name|treg
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sp_reg_rtx
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|treg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|info
operator|->
name|total_size
argument_list|)
argument_list|)
expr_stmt|;
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
block|}
comment|/* If we use the link register, get it into r0.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we need to save CR, put it into r12.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|info
operator|->
name|cr_save_p
operator|&&
name|frame_reg_rtx
operator|!=
name|frame_ptr_rtx
condition|)
block|{
name|rtx
name|set
decl_stmt|;
name|cr_save_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_movesi_from_cr
argument_list|(
name|cr_save_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now, there's no way that dwarf2out_frame_debug_expr is going 	 to understand '(unspec:SI [(reg:CC 68) ...] UNSPEC_MOVESI_FROM_CR)'. 	 But that's OK.  All we have to do is specify that _one_ condition 	 code register is saved in this stack slot.  The thrower's epilogue 	 will then restore all the call-saved registers. 	 We use CR2_REGNO (70) to be compatible with gcc-2.95 on Linux.  */
name|set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cr_save_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|CR2_REGNO
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|set
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do any required saving of fpr's.  If only one or two to save, do      it ourselves.  Otherwise, call function.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|saving_FPRs_inline
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|)
condition|)
name|emit_frame_save
argument_list|(
name|frame_reg_rtx
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|,
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|,
name|info
operator|->
name|total_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|rname
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|alloc_rname
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
operator|+
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rname
argument_list|,
literal|"%s%d%s"
argument_list|,
name|SAVE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|SAVE_FP_SUFFIX
argument_list|)
expr_stmt|;
name|alloc_rname
operator|=
name|ggc_strdup
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|alloc_rname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Save GPRs.  This is done as a PARALLEL if we are using      the store-multiple instructions.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|using_store_multiple
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|&&
operator|(
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|)
operator|)
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
init|=
name|info
operator|->
name|spe_gp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
decl_stmt|;
name|rtx
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|b
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FIXED_SCRATCH
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|b
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|V2SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|CONST_INT
condition|)
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|b
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* ??? There's no need to emit actual instructions here, but it's the      easiest way to get the frame unwind information emitted.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
comment|/* In AIX ABI we need to pretend we save r2 here.  */
if|if
condition|(
name|TARGET_AIX
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
operator|+
literal|5
operator|*
name|reg_size
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_blockage
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|regno
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|emit_frame_save
argument_list|(
name|frame_reg_rtx
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|reg_mode
argument_list|,
name|regno
argument_list|,
name|info
operator|->
name|ehrd_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
operator|(
name|int
operator|)
name|i
argument_list|,
name|info
operator|->
name|total_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save lr if we used it.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* This should not be of frame_alias_set, because of 	 __builtin_return_address.  */
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Save CR if we use any that must be preserved.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|cr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* See the large comment above about why CR2_REGNO is used.  */
name|rtx
name|magic_eh_cr_reg
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|CR2_REGNO
argument_list|)
decl_stmt|;
comment|/* If r12 was used to hold the original sp, copy cr into r0 now 	 that it's free.  */
if|if
condition|(
name|REGNO
argument_list|(
name|frame_reg_rtx
argument_list|)
operator|==
literal|12
condition|)
block|{
name|rtx
name|set
decl_stmt|;
name|cr_save_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_movesi_from_cr
argument_list|(
name|cr_save_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cr_save_rtx
argument_list|,
name|magic_eh_cr_reg
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|set
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|cr_save_rtx
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Update stack and set back pointer unless this is V.4,      for which it was done previously.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|info
operator|->
name|push_p
operator|&&
operator|!
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|||
name|current_function_calls_eh_return
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|total_size
operator|<
literal|32767
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
else|else
name|frame_reg_rtx
operator|=
name|frame_ptr_rtx
expr_stmt|;
name|rs6000_emit_allocate_stack
argument_list|(
name|info
operator|->
name|total_size
argument_list|,
operator|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
operator|&&
operator|(
operator|(
name|info
operator|->
name|altivec_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|info
operator|->
name|vrsave_mask
operator|!=
literal|0
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
condition|)
name|rs6000_emit_stack_tie
argument_list|()
expr_stmt|;
block|}
comment|/* Set frame pointer, if needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|sp_reg_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Save AltiVec registers if needed.  Save here because the red zone does      not include AltiVec registers.  */
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
operator|&&
name|TARGET_ALTIVEC_ABI
operator|&&
name|info
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* There should be a non inline version of this, for when we          are saving lots of vector registers.  */
for|for
control|(
name|i
operator|=
name|info
operator|->
name|first_altivec_reg_save
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|rtx
name|areg
decl_stmt|,
name|savereg
decl_stmt|,
name|mem
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|info
operator|->
name|altivec_save_offset
operator|+
name|sp_offset
operator|+
literal|16
operator|*
operator|(
name|i
operator|-
name|info
operator|->
name|first_altivec_reg_save
operator|)
expr_stmt|;
name|savereg
operator|=
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|areg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|areg
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* AltiVec addressing mode is [reg+reg].  */
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|areg
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|savereg
argument_list|)
expr_stmt|;
name|rs6000_frame_related
argument_list|(
name|insn
argument_list|,
name|frame_ptr_rtx
argument_list|,
name|info
operator|->
name|total_size
argument_list|,
name|areg
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* VRSAVE is a bit vector representing which AltiVec registers      are used.  The OS uses this to determine which vector      registers to save on a context switch.  We need to save      VRSAVE on the stack frame, add whatever AltiVec registers we      used in this function, and do the corresponding magic in the      epilogue.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_VRSAVE
operator|&&
name|info
operator|->
name|vrsave_mask
operator|!=
literal|0
condition|)
block|{
name|rtx
name|reg
decl_stmt|,
name|mem
decl_stmt|,
name|vrsave
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* Get VRSAVE onto a GPR.  Note that ABI_V4 might be using r12          as frame_reg_rtx and r11 as the static chain pointer for          nested functions.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vrsave
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|VRSAVE_REGNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MACHO
condition|)
name|emit_insn
argument_list|(
name|gen_get_vrsave_internal
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|vrsave
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
condition|)
block|{
comment|/* Save VRSAVE.  */
name|offset
operator|=
name|info
operator|->
name|vrsave_save_offset
operator|+
name|sp_offset
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Include the registers in the mask.  */
name|emit_insn
argument_list|(
name|gen_iorsi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|info
operator|->
name|vrsave_mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|generate_set_vrsave
argument_list|(
name|reg
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are using RS6000_PIC_OFFSET_TABLE_REGNUM, we need to set it up.  */
if|if
condition|(
operator|(
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|&&
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
operator|(
name|flag_pic
operator|==
literal|1
operator|||
operator|(
name|flag_pic
operator|&&
name|TARGET_SECURE_PLT
operator|)
operator|)
operator|&&
name|regs_ever_live
index|[
name|RS6000_PIC_OFFSET_TABLE_REGNUM
index|]
operator|)
condition|)
block|{
comment|/* If emit_load_toc_table will use the link register, we need to save 	 it.  We use R12 for this purpose because emit_load_toc_table 	 can use register 0.  This allows us to use a plain 'blr' to return 	 from the procedure more often.  */
name|int
name|save_LR_around_toc_setup
init|=
operator|(
name|TARGET_ELF
operator|&&
name|DEFAULT_ABI
operator|!=
name|ABI_AIX
operator|&&
name|flag_pic
operator|&&
operator|!
name|info
operator|->
name|lr_save_p
operator|&&
name|EDGE_COUNT
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|preds
argument_list|)
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|save_LR_around_toc_setup
condition|)
block|{
name|rtx
name|lr
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
decl_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|frame_ptr_rtx
argument_list|,
name|lr
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rs6000_emit_load_toc_table
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|lr
argument_list|,
name|frame_ptr_rtx
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rs6000_emit_load_toc_table
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
condition|)
block|{
name|rtx
name|lr
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|machopic_function_base_sym
argument_list|()
decl_stmt|;
comment|/* Save and restore LR locally around this call (in R0).  */
if|if
condition|(
operator|!
name|info
operator|->
name|lr_save_p
condition|)
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|emit_insn
argument_list|(
name|gen_load_macho_picbase
argument_list|(
name|lr
argument_list|,
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RS6000_PIC_OFFSET_TABLE_REGNUM
argument_list|)
argument_list|,
name|lr
argument_list|)
expr_stmt|;
name|rs6000_maybe_dead
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|lr_save_p
condition|)
name|rs6000_maybe_dead
argument_list|(
name|emit_move_insn
argument_list|(
name|lr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_stack_info
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Write .extern for any function we will call to save and restore      fp values.  */
if|if
condition|(
name|info
operator|->
name|first_fp_reg_save
operator|<
literal|64
operator|&&
operator|!
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.extern %s%d%s\n\t.extern %s%d%s\n"
argument_list|,
name|SAVE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|SAVE_FP_SUFFIX
argument_list|,
name|RESTORE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|RESTORE_FP_SUFFIX
argument_list|)
expr_stmt|;
comment|/* Write .extern for AIX common mode routines, if needed.  */
if|if
condition|(
operator|!
name|TARGET_POWER
operator|&&
operator|!
name|TARGET_POWERPC
operator|&&
operator|!
name|common_mode_defined
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.extern __mulh\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __mull\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __divss\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __divus\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __quoss\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.extern __quous\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|common_mode_defined
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HAVE_prologue
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* A NOTE_INSN_DELETED is supposed to be at the start and end of 	 the "toplevel" insn chain.  */
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|rs6000_emit_prologue
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Expand INSN_ADDRESSES so final() doesn't crash.  */
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|addr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_rtx_list
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|file
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
name|rs6000_pic_labelno
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit function epilogue as insns.     At present, dwarf2out_frame_debug_expr doesn't understand    register restores, so we don't bother setting RTX_FRAME_RELATED_P    anywhere in the epilogue.  Most of the insns below would in any case    need special notes to explain where r11 is in relation to the stack.  */
end_comment

begin_function
name|void
name|rs6000_emit_epilogue
parameter_list|(
name|int
name|sibcall
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
decl_stmt|;
name|int
name|restoring_FPRs_inline
decl_stmt|;
name|int
name|using_load_multiple
decl_stmt|;
name|int
name|using_mfcr_multiple
decl_stmt|;
name|int
name|use_backchain_to_restore_sp
decl_stmt|;
name|int
name|sp_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|sp_reg_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|frame_reg_rtx
init|=
name|sp_reg_rtx
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|Pmode
decl_stmt|;
name|int
name|reg_size
init|=
name|TARGET_32BIT
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|int
name|i
decl_stmt|;
name|info
operator|=
name|rs6000_stack_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
name|reg_mode
operator|=
name|V2SImode
expr_stmt|;
name|reg_size
operator|=
literal|8
expr_stmt|;
block|}
name|using_load_multiple
operator|=
operator|(
name|TARGET_MULTIPLE
operator|&&
operator|!
name|TARGET_POWERPC64
operator|&&
operator|(
operator|!
name|TARGET_SPE_ABI
operator|||
name|info
operator|->
name|spe_64bit_regs_used
operator|==
literal|0
operator|)
operator|&&
name|info
operator|->
name|first_gp_reg_save
operator|<
literal|31
operator|&&
name|no_global_regs_above
argument_list|(
name|info
operator|->
name|first_gp_reg_save
argument_list|)
operator|)
expr_stmt|;
name|restoring_FPRs_inline
operator|=
operator|(
name|sibcall
operator|||
name|current_function_calls_eh_return
operator|||
name|info
operator|->
name|first_fp_reg_save
operator|==
literal|64
operator|||
name|FP_SAVE_INLINE
argument_list|(
name|info
operator|->
name|first_fp_reg_save
argument_list|)
operator|)
expr_stmt|;
name|use_backchain_to_restore_sp
operator|=
operator|(
name|frame_pointer_needed
operator|||
name|current_function_calls_alloca
operator|||
name|info
operator|->
name|total_size
operator|>
literal|32767
operator|)
expr_stmt|;
name|using_mfcr_multiple
operator|=
operator|(
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC601
operator|||
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC603
operator|||
name|rs6000_cpu
operator|==
name|PROCESSOR_PPC750
operator|||
name|optimize_size
operator|)
expr_stmt|;
if|if
condition|(
name|WORLD_SAVE_P
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|rname
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|alloc_rname
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
comment|/* eh_rest_world_r10 will return to the location saved in the LR 	 stack slot (which is not likely to be our caller.) 	 Input: R10 -- stack adjustment.  Clobbers R0, R11, R12, R7, R8. 	 rest_world is similar, except any R10 parameter is ignored. 	 The exception-handling stuff that was here in 2.95 is no 	 longer necessary.  */
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|9
operator|+
literal|1
operator|+
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
operator|+
name|LAST_ALTIVEC_REGNO
operator|+
literal|1
operator|-
name|info
operator|->
name|first_altivec_reg_save
operator|+
literal|63
operator|+
literal|1
operator|-
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rname
argument_list|,
operator|(
operator|(
name|current_function_calls_eh_return
operator|)
condition|?
literal|"*eh_rest_world_r10"
else|:
literal|"*rest_world"
operator|)
argument_list|)
expr_stmt|;
name|alloc_rname
operator|=
name|ggc_strdup
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|alloc_rname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The instruction pattern requires a clobber here; 	 it is shared with the restVEC helper. */
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* CR register traditionally saved as CR2.  */
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|CR2_REGNO
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|cr_save_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info
operator|->
name|first_altivec_reg_save
operator|+
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|info
operator|->
name|first_altivec_reg_save
operator|+
name|i
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|altivec_save_offset
operator|+
literal|16
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|V4SImode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
operator|<=
literal|63
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|j
operator|++
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set sp_offset based on the stack push from the prologue.  */
if|if
condition|(
name|info
operator|->
name|total_size
operator|<
literal|32767
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
comment|/* Restore AltiVec registers if needed.  */
if|if
condition|(
name|TARGET_ALTIVEC_ABI
operator|&&
name|info
operator|->
name|altivec_size
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|first_altivec_reg_save
init|;
name|i
operator|<=
name|LAST_ALTIVEC_REGNO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|info
operator|->
name|vrsave_mask
operator|&
name|ALTIVEC_REG_BIT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|areg
decl_stmt|,
name|mem
decl_stmt|;
name|areg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|areg
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|altivec_save_offset
operator|+
name|sp_offset
operator|+
literal|16
operator|*
operator|(
name|i
operator|-
name|info
operator|->
name|first_altivec_reg_save
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* AltiVec addressing mode is [reg+reg].  */
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|areg
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|V4SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|V4SImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore VRSAVE if needed.  */
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_VRSAVE
operator|&&
name|info
operator|->
name|vrsave_mask
operator|!=
literal|0
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|,
name|reg
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|vrsave_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|generate_set_vrsave
argument_list|(
name|reg
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp_offset
operator|=
literal|0
expr_stmt|;
comment|/* If we have a frame pointer, a call to alloca,  or a large stack      frame, restore the old stack pointer using the backchain.  Otherwise,      we know what size to update it with.  */
if|if
condition|(
name|use_backchain_to_restore_sp
condition|)
block|{
comment|/* Under V.4, don't reset the stack pointer until after we're done 	 loading the saved registers.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
condition|)
name|frame_reg_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|frame_reg_rtx
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|sp_reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|push_p
condition|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|||
name|current_function_calls_eh_return
condition|)
name|sp_offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
else|else
block|{
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|total_size
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|total_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the old lr if we saved it.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_frame_mem_offset
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|info
operator|->
name|lr_save_offset
operator|+
name|sp_offset
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Get the old cr if we saved it.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|cr_save_offset
operator|+
name|sp_offset
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Set LR here to try to overlap restores below.  */
if|if
condition|(
name|info
operator|->
name|lr_save_p
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load exception handler data registers, if needed.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
if|if
condition|(
name|TARGET_AIX
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
operator|+
literal|5
operator|*
name|reg_size
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
literal|2
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|mem
decl_stmt|;
name|regno
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|mem
operator|=
name|gen_frame_mem_offset
argument_list|(
name|reg_mode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|info
operator|->
name|ehrd_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore GPRs.  This is done as a PARALLEL if we are using      the load-multiple instructions.  */
if|if
condition|(
name|using_load_multiple
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
operator|-
name|info
operator|->
name|first_gp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|&&
operator|(
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
index|]
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
name|TARGET_TOC
operator|&&
name|TARGET_MINIMAL_TOC
operator|)
operator|)
operator|)
operator|||
operator|(
name|i
operator|+
name|info
operator|->
name|first_gp_reg_save
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|flag_pic
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
operator|&&
name|flag_pic
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|gp_save_offset
operator|+
name|sp_offset
operator|+
name|reg_size
operator|*
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_frame_mem
argument_list|(
name|reg_mode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/* Restore 64-bit quantities for SPE.  */
if|if
condition|(
name|TARGET_SPE_ABI
operator|&&
name|info
operator|->
name|spe_64bit_regs_used
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
init|=
name|info
operator|->
name|spe_gp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
decl_stmt|;
name|rtx
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|SPE_CONST_OFFSET_OK
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|b
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FIXED_SCRATCH
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|b
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|V2SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_mode
argument_list|,
name|info
operator|->
name|first_gp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* Restore fpr's if we need to do it without calling a function.  */
if|if
condition|(
name|restoring_FPRs_inline
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
index|]
operator|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
name|sp_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
comment|/* If we saved cr, restore it here.  Just those that were used.  */
if|if
condition|(
name|info
operator|->
name|cr_save_p
condition|)
block|{
name|rtx
name|r12_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|using_mfcr_multiple
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
name|count
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|using_mfcr_multiple
operator|&&
name|count
operator|>
literal|1
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
block|{
name|rtvec
name|r
init|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|r12_rtx
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
literal|1
operator|<<
operator|(
literal|7
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|ndx
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
operator|+
name|i
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|CCmode
argument_list|,
name|r
argument_list|,
name|UNSPEC_MOVESI_TO_CR
argument_list|)
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ndx
operator|==
name|count
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|CR0_REGNO
operator|+
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|CR0_REGNO
operator|+
name|i
index|]
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi_to_cr_one
argument_list|(
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CR0_REGNO
operator|+
name|i
argument_list|)
argument_list|,
name|r12_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is V.4, unwind the stack pointer after all of the loads      have been done.  */
if|if
condition|(
name|frame_reg_rtx
operator|!=
name|sp_reg_rtx
condition|)
block|{
comment|/* This blockage is needed so that sched doesn't decide to move 	 the sp change before the register restores.  */
name|rs6000_emit_stack_tie
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|sp_reg_rtx
argument_list|,
name|frame_reg_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp_offset
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
argument_list|)
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|sp_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|rtx
name|sa
init|=
name|EH_RETURN_STACKADJ_RTX
decl_stmt|;
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|sa
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|sp_reg_rtx
argument_list|,
name|sp_reg_rtx
argument_list|,
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sibcall
condition|)
block|{
name|rtvec
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|restoring_FPRs_inline
condition|)
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|3
operator|+
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have to restore more than two FP registers, branch to the 	 restore function.  It will return to our caller.  */
if|if
condition|(
operator|!
name|restoring_FPRs_inline
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|rname
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|alloc_rname
decl_stmt|;
name|sprintf
argument_list|(
name|rname
argument_list|,
literal|"%s%d%s"
argument_list|,
name|RESTORE_FP_PREFIX
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|-
literal|32
argument_list|,
name|RESTORE_FP_SUFFIX
argument_list|)
expr_stmt|;
name|alloc_rname
operator|=
name|ggc_strdup
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|alloc_rname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
decl_stmt|,
name|mem
decl_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sp_reg_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|info
operator|->
name|fp_save_offset
operator|+
literal|8
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|3
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|info
operator|->
name|first_fp_reg_save
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|HAVE_epilogue
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write anything except 	 the trace table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
comment|/* This is slightly ugly, but at least we don't have two 	     copies of the epilogue-emitting code.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* A NOTE_INSN_DELETED is supposed to be at the start 	     and end of the "toplevel" insn chain.  */
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|rs6000_emit_epilogue
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Expand INSN_ADDRESSES so final() doesn't crash.  */
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|addr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_STACK
condition|)
name|debug_rtx_list
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|file
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
if|#
directive|if
name|TARGET_MACHO
name|macho_branch_islands
argument_list|()
expr_stmt|;
comment|/* Mach-O doesn't support labels at the end of objects, so if      it looks like we might want one, insert a NOP.  */
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|insn
operator|&&
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED_LABEL
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
operator|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
operator|)
condition|)
name|fputs
argument_list|(
literal|"\tnop\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Output a traceback table here.  See /usr/include/sys/debug.h for info      on its format.       We don't output a traceback table if -finhibit-size-directive was      used.  The documentation for -finhibit-size-directive reads      ``don't output a @code{.size} assembler directive, or anything      else that would cause trouble if the function is split in the      middle, and the two halves are placed at locations far apart in      memory.''  The traceback table has this property, since it      includes the offset from the start of the function to the      traceback table itself.       System V.4 Powerpc's (and the embedded ABI derived from it) use a      different traceback table.  */
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
operator|!
name|flag_inhibit_size_directive
operator|&&
name|rs6000_traceback
operator|!=
name|traceback_none
operator|&&
operator|!
name|current_function_is_thunk
condition|)
block|{
specifier|const
name|char
modifier|*
name|fname
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|language_string
init|=
name|lang_hooks
operator|.
name|name
decl_stmt|;
name|int
name|fixed_parms
init|=
literal|0
decl_stmt|,
name|float_parms
init|=
literal|0
decl_stmt|,
name|parm_info
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|optional_tbtab
decl_stmt|;
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
if|if
condition|(
name|rs6000_traceback
operator|==
name|traceback_full
condition|)
name|optional_tbtab
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rs6000_traceback
operator|==
name|traceback_part
condition|)
name|optional_tbtab
operator|=
literal|0
expr_stmt|;
else|else
name|optional_tbtab
operator|=
operator|!
name|optimize_size
operator|&&
operator|!
name|TARGET_ELF
expr_stmt|;
if|if
condition|(
name|optional_tbtab
condition|)
block|{
name|fname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|fname
operator|==
literal|'.'
condition|)
comment|/* V.4 encodes . in the name */
name|fname
operator|++
expr_stmt|;
comment|/* Need label immediately before tbtab, so we can compute 	     its offset from the function start.  */
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LT"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* The .tbtab pseudo-op can only be used for the first eight 	 expressions, since it can't handle the possibly variable 	 length fields that follow.  However, if you omit the optional 	 fields, the assembler outputs zeros for all optional fields 	 anyways, giving each variable length field is minimum length 	 (as defined in sys/debug.h).  Thus we can not use the .tbtab 	 pseudo-op at all.  */
comment|/* An all-zero word flags the start of the tbtab, for debuggers 	 that have to find it by searching forward from the entry 	 point or from the current pc.  */
name|fputs
argument_list|(
literal|"\t.long 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Tbtab format type.  Use format type 0.  */
name|fputs
argument_list|(
literal|"\t.byte 0,"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Language type.  Unfortunately, there does not seem to be any 	 official way to discover the language being compiled, so we 	 use language_string. 	 C is 0.  Fortran is 1.  Pascal is 2.  Ada is 3.  C++ is 9. 	 Java is 13.  Objective-C is 14.  Objective-C++ isn't assigned 	 a number, so for now use 9.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C"
argument_list|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F95"
argument_list|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Pascal"
argument_list|)
condition|)
name|i
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
condition|)
name|i
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Objective-C++"
argument_list|)
condition|)
name|i
operator|=
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Java"
argument_list|)
condition|)
name|i
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Objective-C"
argument_list|)
condition|)
name|i
operator|=
literal|14
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 8 single bit fields: global linkage (not set for C extern linkage, 	 apparently a PL/I convention?), out-of-line epilogue/prologue, offset 	 from start of procedure stored in tbtab, internal function, function 	 has controlled storage, function has no toc, function uses fp, 	 function logs/aborts fp operations.  */
comment|/* Assume that fp operations are used if any fp reg must be saved.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
name|optional_tbtab
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|info
operator|->
name|first_fp_reg_save
operator|!=
literal|64
operator|)
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 6 bitfields: function is interrupt handler, name present in 	 proc table, function calls alloca, on condition directives 	 (controls stack walks, 3 bits), saves condition reg, saves 	 link reg.  */
comment|/* The `function calls alloca' bit seems to be set whenever reg 31 is 	 set up as a frame pointer, even when there is no alloca call.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
operator|(
name|optional_tbtab
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|optional_tbtab
operator|&
name|frame_pointer_needed
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|info
operator|->
name|cr_save_p
operator|<<
literal|1
operator|)
operator||
operator|(
name|info
operator|->
name|lr_save_p
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 3 bitfields: saves backchain, fixup code, number of fpr saved 	 (6 bits).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
name|info
operator|->
name|push_p
operator|<<
literal|7
operator|)
operator||
operator|(
literal|64
operator|-
name|info
operator|->
name|first_fp_reg_save
operator|)
argument_list|)
expr_stmt|;
comment|/* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
literal|32
operator|-
name|first_reg_to_save
argument_list|()
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optional_tbtab
condition|)
block|{
comment|/* Compute the parameter info from the function decl argument 	     list.  */
name|tree
name|decl
decl_stmt|;
name|int
name|next_parm_info_bit
init|=
literal|31
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|rtx
name|parameter
init|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|parameter
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|parameter
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|int
name|bits
decl_stmt|;
name|float_parms
operator|++
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
name|bits
operator|=
literal|0x2
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
case|case
name|TFmode
case|:
name|bits
operator|=
literal|0x3
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If only one bit will fit, don't or in this entry.  */
if|if
condition|(
name|next_parm_info_bit
operator|>
literal|0
condition|)
name|parm_info
operator||=
operator|(
name|bits
operator|<<
operator|(
name|next_parm_info_bit
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|next_parm_info_bit
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fixed_parms
operator|+=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|next_parm_info_bit
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Number of fixed point parameters.  */
comment|/* This is actually the number of words of fixed point parameters; thus 	 an 8 byte struct counts as 2; and thus the maximum value is 8.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|fixed_parms
argument_list|)
expr_stmt|;
comment|/* 2 bitfields: number of floating point parameters (7 bits), parameters 	 all on stack.  */
comment|/* This is actually the number of fp registers that hold parameters; 	 and thus the maximum value is 13.  */
comment|/* Set parameters on stack bit if parameters are not in their original 	 registers, regardless of whether they are on the stack?  Xlc 	 seems to set the bit when not optimizing.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
operator|(
name|float_parms
operator|<<
literal|1
operator|)
operator||
operator|(
operator|!
name|optimize
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optional_tbtab
condition|)
return|return;
comment|/* Optional fields follow.  Some are variable length.  */
comment|/* Parameter types, left adjusted bit fields: 0 fixed, 10 single float, 	 11 double float.  */
comment|/* There is an entry for each parameter in a register, in the order that 	 they occur in the parameter list.  Any intervening arguments on the 	 stack are ignored.  If the list overflows a long (max possible length 	 34 bits) then completely leave off all elements that don't fit.  */
comment|/* Only emit this long if there was at least one parameter.  */
if|if
condition|(
name|fixed_parms
operator|||
name|float_parms
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long %d\n"
argument_list|,
name|parm_info
argument_list|)
expr_stmt|;
comment|/* Offset from start of code to tb table.  */
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_AIX
condition|)
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|rs6000_output_function_entry
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Interrupt handler mask.  */
comment|/* Omit this long, since we never set the interrupt handler bit 	 above.  */
comment|/* Number of CTL (controlled storage) anchors.  */
comment|/* Omit this long, since the has_ctl bit is never set above.  */
comment|/* Displacement into stack of each CTL anchor.  */
comment|/* Omit this list of longs, because there are no CTL anchors.  */
comment|/* Length of function name.  */
if|if
condition|(
operator|*
name|fname
operator|==
literal|'*'
condition|)
operator|++
name|fname
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.short %d\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Function name.  */
name|assemble_string
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register for alloca automatic storage; this is always reg 31. 	 Only emit this if the alloca bit was set above.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fputs
argument_list|(
literal|"\t.byte 31\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.align 2\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement that outputs the assembler code for a thunk    function, used to implement C++ virtual function calls with    multiple inheritance.  The thunk acts as a wrapper around a virtual    function, adjusting the implicit object parameter before handing    control off to the real function.     First, emit code to add the integer DELTA to the location that    contains the incoming first argument.  Assume that this argument    contains a pointer, and is the one used to pass the `this' pointer    in C++.  This is the incoming argument *before* the function    prologue, e.g. `%o0' on a sparc.  The addition must preserve the    values of all other incoming arguments.     After the addition, emit code to jump to FUNCTION, which is a    `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does    not touch the return address.  Hence returning from FUNCTION will    return to whoever called the current `thunk'.     The effect must be as if FUNCTION had been called directly with the    adjusted first argument.  This macro is responsible for emitting    all of the code for a thunk function; output_function_prologue()    and output_function_epilogue() are not invoked.     The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already    been extracted from it.)  It might possibly be useful on some    targets, but probably not.     If you do not define this macro, the target-independent code in the    C++ frontend will generate a less efficient heavyweight thunk that    calls FUNCTION instead of jumping to it.  The generic approach does    not support varargs.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk_fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|this
decl_stmt|,
name|insn
decl_stmt|,
name|funexp
decl_stmt|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|epilogue_completed
operator|=
literal|1
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|reset_block_changes
argument_list|()
expr_stmt|;
comment|/* Mark the end of the (empty) prologue.  */
name|emit_note
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|)
expr_stmt|;
comment|/* Find the "this" pointer.  If the function returns a structure,      the structure return pointer is in r3.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|)
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Apply the constant offset, if required.  */
if|if
condition|(
name|delta
condition|)
block|{
name|rtx
name|delta_rtx
init|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|delta_rtx
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Apply the offset from the vtable, if required.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
name|rtx
name|vcall_offset_rtx
init|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
decl_stmt|;
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|vcall_offset
operator|)
operator|+
literal|0x8000
operator|>=
literal|0x10000
condition|)
block|{
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|vcall_offset_rtx
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|vcall_offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|loc
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|vcall_offset_rtx
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|loc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|TARGET_32BIT
condition|?
name|gen_addsi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|tmp
argument_list|)
else|:
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate a tail call to the target function.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funexp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
name|funexp
operator|=
name|machopic_indirect_call_target
argument_list|(
name|funexp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* gen_sibcall expects reload to convert scratch pseudo to LR so we must      generate sibcall RTL explicitly.  */
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|gen_rtx_CALL
argument_list|(
name|VOIDmode
argument_list|,
name|funexp
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Run just enough of rest_of_compilation to get the insns emitted.      There's not really enough bulk here to make other passes such as      instruction scheduling worth while.  Note that use_thunk calls      assemble_start_function and assemble_end_function.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|insn_locators_initialize
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|epilogue_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A quick summary of the various types of 'constant-pool tables'    under PowerPC:     Target	Flags		Name		One table per    AIX		(none)		AIX TOC		object file    AIX		-mfull-toc	AIX TOC		object file    AIX		-mminimal-toc	AIX minimal TOC	translation unit    SVR4/EABI	(none)		SVR4 SDATA	object file    SVR4/EABI	-fpic		SVR4 pic	object file    SVR4/EABI	-fPIC		SVR4 PIC	translation unit    SVR4/EABI	-mrelocatable	EABI TOC	function    SVR4/EABI	-maix		AIX TOC		object file    SVR4/EABI	-maix -mminimal-toc 				AIX minimal TOC	translation unit     Name			Reg.	Set by	entries	      contains: 					made by	 addrs?	fp?	sum?     AIX TOC		2	crt0	as	 Y	option	option    AIX minimal TOC	30	prolog	gcc	 Y	Y	option    SVR4 SDATA		13	crt0	gcc	 N	Y	N    SVR4 pic		30	prolog	ld	 Y	not yet	N    SVR4 PIC		30	prolog	gcc	 Y	option	option    EABI TOC		30	prolog	gcc	 Y	option	option  */
end_comment

begin_comment
comment|/* Hash functions for the hash table.  */
end_comment

begin_function
specifier|static
name|unsigned
name|rs6000_hash_constant
parameter_list|(
name|rtx
name|k
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|k
argument_list|)
decl_stmt|;
name|unsigned
name|result
init|=
operator|(
name|code
operator|<<
literal|3
operator|)
operator|^
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|flen
decl_stmt|,
name|fidx
decl_stmt|;
name|format
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|fidx
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
return|return
name|result
operator|*
literal|1231
operator|+
operator|(
name|unsigned
operator|)
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|real_hash
argument_list|(
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|k
argument_list|)
argument_list|)
operator|*
name|result
return|;
name|flen
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|fidx
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
init|;
name|fidx
operator|<
name|flen
condition|;
name|fidx
operator|++
control|)
switch|switch
condition|(
name|format
index|[
name|fidx
index|]
condition|)
block|{
case|case
literal|'s'
case|:
block|{
name|unsigned
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|result
operator|*
literal|613
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|str
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
name|result
operator|=
name|result
operator|*
literal|1231
operator|+
name|rs6000_hash_constant
argument_list|(
name|XEXP
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|XINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|XWINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
condition|;
name|i
operator|++
control|)
name|result
operator|=
name|result
operator|*
literal|613
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|XWINT
argument_list|(
name|k
argument_list|,
name|fidx
argument_list|)
operator|>>
name|CHAR_BIT
operator|*
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|toc_hash_function
parameter_list|(
specifier|const
name|void
modifier|*
name|hash_entry
parameter_list|)
block|{
specifier|const
name|struct
name|toc_hash_struct
modifier|*
name|thc
init|=
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|hash_entry
decl_stmt|;
return|return
name|rs6000_hash_constant
argument_list|(
name|thc
operator|->
name|key
argument_list|)
operator|^
name|thc
operator|->
name|key_mode
return|;
block|}
end_function

begin_comment
comment|/* Compare H1 and H2 for equivalence.  */
end_comment

begin_function
specifier|static
name|int
name|toc_hash_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|h1
parameter_list|,
specifier|const
name|void
modifier|*
name|h2
parameter_list|)
block|{
name|rtx
name|r1
init|=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h1
operator|)
operator|->
name|key
decl_stmt|;
name|rtx
name|r2
init|=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h2
operator|)
operator|->
name|key
decl_stmt|;
if|if
condition|(
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h1
operator|)
operator|->
name|key_mode
operator|!=
operator|(
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|)
name|h2
operator|)
operator|->
name|key_mode
condition|)
return|return
literal|0
return|;
return|return
name|rtx_equal_p
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These are the names given by the C++ front-end to vtables, and    vtable-like objects.  Ideally, this logic should not be here;    instead, there should be some programmatic way of inquiring as    to whether or not an object is a vtable.  */
end_comment

begin_define
define|#
directive|define
name|VTABLE_NAME_P
parameter_list|(
name|NAME
parameter_list|)
define|\
value|(strncmp ("_vt.", name, strlen ("_vt.")) == 0		\   || strncmp ("_ZTV", name, strlen ("_ZTV")) == 0	\   || strncmp ("_ZTT", name, strlen ("_ZTT")) == 0	\   || strncmp ("_ZTI", name, strlen ("_ZTI")) == 0	\   || strncmp ("_ZTC", name, strlen ("_ZTC")) == 0)
end_define

begin_function
name|void
name|rs6000_output_symbol_ref
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
comment|/* Currently C++ toc references to vtables can be emitted before it      is decided whether the vtable is public or private.  If this is      the case, then the linker will eventually complain that there is      a reference to an unknown section.  Thus, for vtables only,      we emit the TOC reference to reference the symbol and not the      section.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|VTABLE_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a TOC entry.  We derive the entry name from what is being    written.  */
end_comment

begin_function
name|void
name|output_toc
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|labelno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|rtx
name|base
init|=
name|x
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TARGET_NO_TOC
argument_list|)
expr_stmt|;
comment|/* When the linker won't eliminate them, don't output duplicate      TOC entries (this happens on AIX if there is any kind of TOC,      and on SVR4 under -fPIC or -mrelocatable).  Don't do this for      CODE_LABELs.  */
if|if
condition|(
name|TARGET_TOC
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LABEL_REF
condition|)
block|{
name|struct
name|toc_hash_struct
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|found
decl_stmt|;
comment|/* Create toc_hash_table.  This can't be done at OVERRIDE_OPTIONS 	 time because GGC is not initialized at that point.  */
if|if
condition|(
name|toc_hash_table
operator|==
name|NULL
condition|)
name|toc_hash_table
operator|=
name|htab_create_ggc
argument_list|(
literal|1021
argument_list|,
name|toc_hash_function
argument_list|,
name|toc_hash_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|key
operator|=
name|x
expr_stmt|;
name|h
operator|->
name|key_mode
operator|=
name|mode
expr_stmt|;
name|h
operator|->
name|labelno
operator|=
name|labelno
expr_stmt|;
name|found
operator|=
name|htab_find_slot
argument_list|(
name|toc_hash_table
argument_list|,
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|found
operator|==
name|NULL
condition|)
operator|*
name|found
operator|=
name|h
expr_stmt|;
else|else
comment|/* This is indeed a duplicate. 	       Set this label equal to that label.  */
block|{
name|fputs
argument_list|(
literal|"\t.set "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
operator|(
operator|*
operator|(
specifier|const
expr|struct
name|toc_hash_struct
operator|*
operator|*
operator|)
name|found
operator|)
operator|->
name|labelno
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we're going to put a double constant in the TOC, make sure it's      aligned properly when strict alignment is on.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|STRICT_ALIGNMENT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|64
operator|&&
operator|!
operator|(
name|TARGET_NO_FP_IN_TOC
operator|&&
operator|!
name|TARGET_MINIMAL_TOC
operator|)
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* Handle FP constants specially.  Note that if we have a minimal      TOC, things we put here aren't actually in the TOC, so we can allow      FP constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|TFmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|TDmode
operator|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|k
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|REAL_VALUE_TO_TARGET_DECIMAL128
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FT_%lx_%lx_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|2
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|3
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx,0x%lx%08lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|2
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|3
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FT_%lx_%lx_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|2
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|3
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx,0x%lx,0x%lx,0x%lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|2
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|3
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DDmode
operator|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|k
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|REAL_VALUE_TO_TARGET_DECIMAL64
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FD_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FD_%lx_%lx[TC],"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx,0x%lx\n"
argument_list|,
name|k
index|[
literal|0
index|]
operator|&
literal|0xffffffff
argument_list|,
name|k
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SDmode
operator|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|REAL_VALUE_TO_TARGET_DECIMAL32
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
else|else
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FS_%lx[TC],"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx00000000\n"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FS_%lx[TC],"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx\n"
argument_list|,
name|l
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|low
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|high
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
block|{
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|high
operator|=
operator|(
name|low
operator|&
literal|0x80000000
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
block|}
else|#
directive|else
block|{
name|low
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
name|high
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TOC entries are always Pmode-sized, but since this 	 is a bigendian machine then if we're putting smaller 	 integer constants in the TOC we have to pad them. 	 (This is still a win over putting the constants in 	 a separate constant pool, because then we'd have 	 to have both a TOC entry _and_ the actual constant.)  	 For a 32-bit target, CONST_INT values are loaded and shifted 	 entirely within `low' and can be stored in one TOC entry.  */
comment|/* It would be easy to make this work, but it doesn't now.  */
name|gcc_assert
argument_list|(
operator|!
name|TARGET_64BIT
operator|||
name|POINTER_SIZE
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_SIZE
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|lshift_double
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|POINTER_SIZE
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|POINTER_SIZE
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|low
operator||=
name|high
operator|<<
literal|32
expr_stmt|;
name|low
operator|<<=
name|POINTER_SIZE
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|high
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|low
operator|>>
literal|32
expr_stmt|;
name|low
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc ID_%lx_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx\n"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|POINTER_SIZE
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc ID_%lx_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx,0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|high
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
literal|"\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc IS_%lx[TC],"
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|low
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
name|name
operator|=
name|XSTR
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|real_name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
name|fputs
argument_list|(
name|TARGET_32BIT
condition|?
literal|"\t.long "
else|:
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc %s"
argument_list|,
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".N"
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".P"
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"[TC],"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Currently C++ toc references to vtables can be emitted before it      is decided whether the vtable is public or private.  If this is      the case, then the linker will eventually complain that there is      a TOC reference to an unknown section.  Thus, for vtables only,      we emit the TOC reference to reference the symbol and not the      section.  */
if|if
condition|(
name|VTABLE_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an assembler pseudo-op to write an ASCII string of N characters    starting at P to FILE.     On the RS/6000, we have to do this using the .byte operation and    write out special characters outside the quoted string.    Also, the assembler is broken; very long strings are truncated,    so we must artificially break them up early.  */
end_comment

begin_function
name|void
name|output_ascii
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|for_string
init|=
literal|"\t.byte \""
decl_stmt|;
specifier|const
name|char
modifier|*
name|for_decimal
init|=
literal|"\t.byte "
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_close
init|=
name|NULL
decl_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
if|if
condition|(
name|for_string
condition|)
name|fputs
argument_list|(
name|for_string
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Write two quotes to get one.  */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|++
name|count_string
expr_stmt|;
block|}
name|for_string
operator|=
name|NULL
expr_stmt|;
name|for_decimal
operator|=
literal|"\"\n\t.byte "
expr_stmt|;
name|to_close
operator|=
literal|"\"\n"
expr_stmt|;
operator|++
name|count_string
expr_stmt|;
if|if
condition|(
name|count_string
operator|>=
literal|512
condition|)
block|{
name|fputs
argument_list|(
name|to_close
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|for_string
operator|=
literal|"\t.byte \""
expr_stmt|;
name|for_decimal
operator|=
literal|"\t.byte "
expr_stmt|;
name|to_close
operator|=
name|NULL
expr_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|for_decimal
condition|)
name|fputs
argument_list|(
name|for_decimal
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|for_string
operator|=
literal|"\n\t.byte \""
expr_stmt|;
name|for_decimal
operator|=
literal|", "
expr_stmt|;
name|to_close
operator|=
literal|"\n"
expr_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now close the string if we have written one.  Then end the line.  */
if|if
condition|(
name|to_close
condition|)
name|fputs
argument_list|(
name|to_close
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a unique section name for FILENAME for a section type    represented by SECTION_DESC.  Output goes into BUF.     SECTION_DESC can be any string, as long as it is different for each    possible section type.     We name the section in the same manner as xlc.  The name begins with an    underscore followed by the filename (after stripping any leading directory    names) with the last period replaced by the string SECTION_DESC.  If    FILENAME does not contain a period, SECTION_DESC is appended to the end of    the name.  */
end_comment

begin_function
name|void
name|rs6000_gen_section_name
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|section_desc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|after_last_slash
decl_stmt|,
modifier|*
name|last_period
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|after_last_slash
operator|=
name|filename
expr_stmt|;
for|for
control|(
name|q
operator|=
name|filename
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'/'
condition|)
name|after_last_slash
operator|=
name|q
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
name|last_period
operator|=
name|q
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|after_last_slash
argument_list|)
operator|+
name|strlen
argument_list|(
name|section_desc
argument_list|)
operator|+
literal|2
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|q
operator|=
name|after_last_slash
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|==
name|last_period
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|section_desc
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|section_desc
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
block|}
if|if
condition|(
name|last_period
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|section_desc
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit profile function.  */
end_comment

begin_function
name|void
name|output_profile_hook
parameter_list|(
name|int
name|labelno
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Non-standard profiling for kernels, which just saves LR then calls      _mcount without worrying about arg saves.  The idea is to change      the function prologue as little as possible as it isn't easy to      account for arg save/restore code added just for _mcount.  */
if|if
condition|(
name|TARGET_PROFILE_KERNEL
condition|)
return|return;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
define|#
directive|define
name|NO_PROFILE_COUNTERS
value|0
endif|#
directive|endif
if|if
condition|(
name|NO_PROFILE_COUNTERS
condition|)
name|emit_library_call
argument_list|(
name|init_one_libfunc
argument_list|(
name|RS6000_MCOUNT
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|label_name
decl_stmt|;
name|rtx
name|fun
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|label_name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fun
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_name
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|init_one_libfunc
argument_list|(
name|RS6000_MCOUNT
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|fun
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_DARWIN
condition|)
block|{
specifier|const
name|char
modifier|*
name|mcount_name
init|=
name|RS6000_MCOUNT
decl_stmt|;
name|int
name|caller_addr_regno
init|=
name|LINK_REGISTER_REGNUM
decl_stmt|;
comment|/* Be conservative and always set this, at least for now.  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* For PIC code, set up a stub and collect the caller's address 	 from r0, which is where the prologue puts it.  */
if|if
condition|(
name|MACHOPIC_INDIRECT
operator|&&
name|current_function_uses_pic_offset_table
condition|)
name|caller_addr_regno
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|mcount_name
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|caller_addr_regno
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write function profiler code.  */
end_comment

begin_function
name|void
name|output_function_profiler
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|labelno
parameter_list|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|ABI_V4
case|:
if|if
condition|(
operator|!
name|TARGET_32BIT
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"no profiling of 64-bit code for this ABI"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|NO_PROFILE_COUNTERS
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,4(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_SECURE_PLT
operator|&&
name|flag_pic
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbcl 20,31,1f\n1:\n\t{st|stw} %s,4(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cau|addis} %s,%s,"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"-1b@ha\n\t{cal|la} %s,"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"-1b@l(%s)\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|fputs
argument_list|(
literal|"\tbl _GLOBAL_OFFSET_TABLE_@local-4\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,4(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{l|lwz} %s,"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"@got(%s)\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|>
literal|1
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,4(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Now, we need to get the address of the label.  */
name|fputs
argument_list|(
literal|"\tbcl 20,31,1f\n\t.long "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-.\n1:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{l|lwz} %s,0(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cax|add} %s,%s,%s\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{liu|lis} %s,"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@ha\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{st|stw} %s,4(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t{cal|la} %s,"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"@l(%s)\n"
argument_list|,
name|reg_names
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* ABI_V4 saves the static chain reg with ASM_OUTPUT_REG_PUSH.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbl %s%s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|,
name|flag_pic
condition|?
literal|"@plt"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABI_AIX
case|:
case|case
name|ABI_DARWIN
case|:
if|if
condition|(
operator|!
name|TARGET_PROFILE_KERNEL
condition|)
block|{
comment|/* Don't do anything, done in output_profile_hook ().  */
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|TARGET_32BIT
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr %s\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstd %s,16(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|static_chain_decl
operator|!=
name|NULL
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstd %s,24(%s)\n"
argument_list|,
name|reg_names
index|[
name|STATIC_CHAIN_REGNUM
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbl %s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld %s,24(%s)\n"
argument_list|,
name|reg_names
index|[
name|STATIC_CHAIN_REGNUM
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbl %s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Power4 load update and store update instructions are cracked into a    load or store and an integer insn which are executed in the same cycle.    Branches have their own dispatch slot which does not count against the    GCC issue rate, but it changes the program flow so there are no other    instructions to issue in this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_variable_issue
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|more
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|more
return|;
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
if|if
condition|(
name|is_microcoded_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|is_cracked_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|more
operator|>
literal|2
condition|?
name|more
operator|-
literal|2
else|:
literal|0
return|;
block|}
return|return
name|more
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
if|if
condition|(
operator|!
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Data dependency; DEP_INSN writes a register that INSN reads 	 some cycles later.  */
comment|/* Separate a load from a narrower, dependent store.  */
if|if
condition|(
name|rs6000_sched_groups
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|cost
operator|+
literal|14
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_JMPREG
case|:
comment|/* Tell the first scheduling pass about the latency between 	     a mtctr and bctr (and mtlr and br/blr).  The first 	     scheduling pass will not know about this latency since 	     the mtctr instruction, which has the latency associated 	     to it, will be generated by reload.  */
return|return
name|TARGET_POWER
condition|?
literal|5
else|:
literal|4
return|;
case|case
name|TYPE_BRANCH
case|:
comment|/* Leave some extra cycles between a compare and its 	     dependent branch, to inhibit expensive mispredicts.  */
if|if
condition|(
operator|(
name|rs6000_cpu_attr
operator|==
name|CPU_PPC603
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC604
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC604E
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC620
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC630
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC750
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC7400
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_PPC7450
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_POWER4
operator|||
name|rs6000_cpu_attr
operator|==
name|CPU_POWER5
operator|)
operator|&&
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|&&
operator|(
name|INSN_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_CMP
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_DELAYED_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_IMUL_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LMUL_COMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_FPCOMPARE
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_CR_LOGICAL
operator|||
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_DELAYED_CR
operator|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
default|default:
break|break;
block|}
comment|/* Fall out to return default cost.  */
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* The function returns a true if INSN is microcoded.    Return false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|is_microcoded_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
name|enum
name|attr_type
name|type
init|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_LOAD_EXT_U
operator|||
name|type
operator|==
name|TYPE_LOAD_EXT_UX
operator|||
name|type
operator|==
name|TYPE_LOAD_UX
operator|||
name|type
operator|==
name|TYPE_STORE_UX
operator|||
name|type
operator|==
name|TYPE_MFCR
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The function returns a nonzero value if INSN can be scheduled only    as the first insn in a dispatch group ("dispatch-slot restricted").    In this case, the returned value indicates how many dispatch slots    the insn occupies (at the beginning of the group).    Return 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|is_dispatch_slot_restricted
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|attr_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|rs6000_sched_groups
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|insn
operator|||
name|insn
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_MFCR
case|:
case|case
name|TYPE_MFCRF
case|:
case|case
name|TYPE_MTCR
case|:
case|case
name|TYPE_DELAYED_CR
case|:
case|case
name|TYPE_CR_LOGICAL
case|:
case|case
name|TYPE_MTJMPR
case|:
case|case
name|TYPE_MFJMPR
case|:
return|return
literal|1
return|;
case|case
name|TYPE_IDIV
case|:
case|case
name|TYPE_LDIV
case|:
return|return
literal|2
return|;
case|case
name|TYPE_LOAD_L
case|:
case|case
name|TYPE_STORE_C
case|:
case|case
name|TYPE_ISYNC
case|:
case|case
name|TYPE_SYNC
case|:
return|return
literal|4
return|;
default|default:
if|if
condition|(
name|rs6000_cpu
operator|==
name|PROCESSOR_POWER5
operator|&&
name|is_cracked_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* The function returns true if INSN is cracked into 2 instructions    by the processor (and therefore occupies 2 issue slots).  */
end_comment

begin_function
specifier|static
name|bool
name|is_cracked_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
name|enum
name|attr_type
name|type
init|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_LOAD_U
operator|||
name|type
operator|==
name|TYPE_STORE_U
operator|||
name|type
operator|==
name|TYPE_FPLOAD_U
operator|||
name|type
operator|==
name|TYPE_FPSTORE_U
operator|||
name|type
operator|==
name|TYPE_FPLOAD_UX
operator|||
name|type
operator|==
name|TYPE_FPSTORE_UX
operator|||
name|type
operator|==
name|TYPE_LOAD_EXT
operator|||
name|type
operator|==
name|TYPE_DELAYED_CR
operator|||
name|type
operator|==
name|TYPE_COMPARE
operator|||
name|type
operator|==
name|TYPE_DELAYED_COMPARE
operator|||
name|type
operator|==
name|TYPE_IMUL_COMPARE
operator|||
name|type
operator|==
name|TYPE_LMUL_COMPARE
operator|||
name|type
operator|==
name|TYPE_IDIV
operator|||
name|type
operator|==
name|TYPE_LDIV
operator|||
name|type
operator|==
name|TYPE_INSERT_WORD
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The function returns true if INSN can be issued only from    the branch slot.  */
end_comment

begin_function
specifier|static
name|bool
name|is_branch_slot_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rs6000_sched_groups
condition|)
block|{
name|enum
name|attr_type
name|type
init|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_BRANCH
operator|||
name|type
operator|==
name|TYPE_JMPREG
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A C statement (sans semicolon) to update the integer scheduling    priority INSN_PRIORITY (INSN). Increase the priority to execute the    INSN earlier, reduce the priority to execute INSN later.  Do not    define this macro if you do not need to adjust the scheduling    priorities of insns.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_adjust_priority
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
comment|/* On machines (like the 750) which have asymmetric integer units,      where one integer unit can do multiply and divides and the other      can't, reduce the priority of multiply/divide so it is scheduled      before other integer operations.  */
if|#
directive|if
literal|0
block|if (! INSN_P (insn))     return priority;    if (GET_CODE (PATTERN (insn)) == USE)     return priority;    switch (rs6000_cpu_attr) {   case CPU_PPC750:     switch (get_attr_type (insn))       {       default: 	break;        case TYPE_IMUL:       case TYPE_IDIV: 	fprintf (stderr, "priority was %#x (%d) before adjustment\n", 		 priority, priority); 	if (priority>= 0&& priority< 0x01000000) 	  priority>>= 3; 	break;       }   }
endif|#
directive|endif
if|if
condition|(
name|is_dispatch_slot_restricted
argument_list|(
name|insn
argument_list|)
operator|&&
name|reload_completed
operator|&&
name|current_sched_info
operator|->
name|sched_max_insns_priority
operator|&&
name|rs6000_sched_restricted_insns_priority
condition|)
block|{
comment|/* Prioritize insns that can be dispatched only in the first 	 dispatch slot.  */
if|if
condition|(
name|rs6000_sched_restricted_insns_priority
operator|==
literal|1
condition|)
comment|/* Attach highest priority to insn. This means that in 	   haifa-sched.c:ready_sort(), dispatch-slot restriction considerations 	   precede 'priority' (critical path) considerations.  */
return|return
name|current_sched_info
operator|->
name|sched_max_insns_priority
return|;
elseif|else
if|if
condition|(
name|rs6000_sched_restricted_insns_priority
operator|==
literal|2
condition|)
comment|/* Increase priority of insn by a minimal amount. This means that in 	   haifa-sched.c:ready_sort(), only 'priority' (critical path) 	   considerations precede dispatch-slot restriction considerations.  */
return|return
operator|(
name|priority
operator|+
literal|1
operator|)
return|;
block|}
return|return
name|priority
return|;
block|}
end_function

begin_comment
comment|/* Return how many instructions the machine can issue per cycle.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Use issue rate of 1 for first scheduling pass to decrease degradation.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|rs6000_cpu_attr
condition|)
block|{
case|case
name|CPU_RIOS1
case|:
comment|/* ? */
case|case
name|CPU_RS64A
case|:
case|case
name|CPU_PPC601
case|:
comment|/* ? */
case|case
name|CPU_PPC7450
case|:
return|return
literal|3
return|;
case|case
name|CPU_PPC440
case|:
case|case
name|CPU_PPC603
case|:
case|case
name|CPU_PPC750
case|:
case|case
name|CPU_PPC7400
case|:
case|case
name|CPU_PPC8540
case|:
return|return
literal|2
return|;
case|case
name|CPU_RIOS2
case|:
case|case
name|CPU_PPC604
case|:
case|case
name|CPU_PPC604E
case|:
case|case
name|CPU_PPC620
case|:
case|case
name|CPU_PPC630
case|:
return|return
literal|4
return|;
case|case
name|CPU_POWER4
case|:
case|case
name|CPU_POWER5
case|:
return|return
literal|5
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return how many instructions to look ahead for better insn    scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_use_sched_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|rs6000_cpu_attr
operator|==
name|CPU_PPC8540
condition|)
return|return
literal|4
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine is PAT refers to memory.  */
end_comment

begin_function
specifier|static
name|bool
name|is_mem_ref
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|true
return|;
comment|/* Recursively process the pattern.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
operator|!
name|ret
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|ret
operator||=
name|is_mem_ref
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|ret
operator||=
name|is_mem_ref
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Determine if PAT is a PATTERN of a load insn.  */
end_comment

begin_function
specifier|static
name|bool
name|is_load_insn1
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pat
operator|||
name|pat
operator|==
name|NULL_RTX
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
return|return
name|is_mem_ref
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_load_insn1
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine if INSN loads from memory.  */
end_comment

begin_function
specifier|static
name|bool
name|is_load_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
name|false
return|;
return|return
name|is_load_insn1
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if PAT is a PATTERN of a store insn.  */
end_comment

begin_function
specifier|static
name|bool
name|is_store_insn1
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pat
operator|||
name|pat
operator|==
name|NULL_RTX
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
return|return
name|is_mem_ref
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_store_insn1
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine if INSN stores to memory.  */
end_comment

begin_function
specifier|static
name|bool
name|is_store_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|is_store_insn1
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns whether the dependence between INSN and NEXT is considered    costly by the given target.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_is_costly_dependence
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|next
parameter_list|,
name|rtx
name|link
parameter_list|,
name|int
name|cost
parameter_list|,
name|int
name|distance
parameter_list|)
block|{
comment|/* If the flag is not enabled - no dependence is considered costly;      allow all dependent insns in the same group.      This is the most aggressive option.  */
if|if
condition|(
name|rs6000_sched_costly_dep
operator|==
name|no_dep_costly
condition|)
return|return
name|false
return|;
comment|/* If the flag is set to 1 - a dependence is always considered costly;      do not allow dependent instructions in the same group.      This is the most conservative option.  */
if|if
condition|(
name|rs6000_sched_costly_dep
operator|==
name|all_deps_costly
condition|)
return|return
name|true
return|;
if|if
condition|(
name|rs6000_sched_costly_dep
operator|==
name|store_to_load_dep_costly
operator|&&
name|is_load_insn
argument_list|(
name|next
argument_list|)
operator|&&
name|is_store_insn
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* Prevent load after store in the same group.  */
return|return
name|true
return|;
if|if
condition|(
name|rs6000_sched_costly_dep
operator|==
name|true_store_to_load_dep_costly
operator|&&
name|is_load_insn
argument_list|(
name|next
argument_list|)
operator|&&
name|is_store_insn
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|link
operator|||
operator|(
name|int
operator|)
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* Prevent load after store in the same group if it is a true 	dependence.  */
return|return
name|true
return|;
comment|/* The flag is set to X; dependences with latency>= X are considered costly,      and will not be scheduled in the same group.  */
if|if
condition|(
name|rs6000_sched_costly_dep
operator|<=
name|max_dep_latency
operator|&&
operator|(
operator|(
name|cost
operator|-
name|distance
operator|)
operator|>=
operator|(
name|int
operator|)
name|rs6000_sched_costly_dep
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the next insn after INSN that is found before TAIL is reached,    skipping any "non-active" insns - insns that will not actually occupy    an issue slot.  Return NULL_RTX if such an insn is not found.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_next_active_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
operator|||
name|insn
operator|==
name|tail
condition|)
return|return
name|NULL_RTX
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
operator|||
name|insn
operator|==
name|tail
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_FOR_stack_tie
operator|)
condition|)
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return whether the presence of INSN causes a dispatch group termination    of group WHICH_GROUP.     If WHICH_GROUP == current_group, this function will return true if INSN    causes the termination of the current group (i.e, the dispatch group to    which INSN belongs). This means that INSN will be the last insn in the    group it belongs to.     If WHICH_GROUP == previous_group, this function will return true if INSN    causes the termination of the previous group (i.e, the dispatch group that    precedes the group to which INSN belongs).  This means that INSN will be    the first insn in the group it belongs to).  */
end_comment

begin_function
specifier|static
name|bool
name|insn_terminates_group_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|group_termination
name|which_group
parameter_list|)
block|{
name|enum
name|attr_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
name|false
return|;
name|type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_microcoded_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|which_group
operator|==
name|current_group
condition|)
block|{
if|if
condition|(
name|is_branch_slot_insn
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|which_group
operator|==
name|previous_group
condition|)
block|{
if|if
condition|(
name|is_dispatch_slot_restricted
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if it is recommended to keep NEXT_INSN "far" (in a separate    dispatch group) from the insns in GROUP_INSNS.  Return false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|is_costly_group
parameter_list|(
name|rtx
modifier|*
name|group_insns
parameter_list|,
name|rtx
name|next_insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|int
name|issue_rate
init|=
name|rs6000_issue_rate
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|group_insns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
continue|continue;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|next_insn
condition|)
block|{
name|cost
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs6000_is_costly_dependence
argument_list|(
name|insn
argument_list|,
name|next_insn
argument_list|,
name|link
argument_list|,
name|cost
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Utility of the function redefine_groups.    Check if it is too costly to schedule NEXT_INSN together with GROUP_INSNS    in the same dispatch group.  If so, insert nops before NEXT_INSN, in order    to keep it "far" (in a separate group) from GROUP_INSNS, following    one of the following schemes, depending on the value of the flag    -minsert_sched_nops = X:    (1) X == sched_finish_regroup_exact: insert exactly as many nops as needed        in order to force NEXT_INSN into a separate group.    (2) X< sched_finish_regroup_exact: insert exactly X nops.    GROUP_END, CAN_ISSUE_MORE and GROUP_COUNT record the state after nop    insertion (has a group just ended, how many vacant issue slots remain in the    last group, and how many dispatch groups were encountered so far).  */
end_comment

begin_function
specifier|static
name|int
name|force_new_group
parameter_list|(
name|int
name|sched_verbose
parameter_list|,
name|FILE
modifier|*
name|dump
parameter_list|,
name|rtx
modifier|*
name|group_insns
parameter_list|,
name|rtx
name|next_insn
parameter_list|,
name|bool
modifier|*
name|group_end
parameter_list|,
name|int
name|can_issue_more
parameter_list|,
name|int
modifier|*
name|group_count
parameter_list|)
block|{
name|rtx
name|nop
decl_stmt|;
name|bool
name|force
decl_stmt|;
name|int
name|issue_rate
init|=
name|rs6000_issue_rate
argument_list|()
decl_stmt|;
name|bool
name|end
init|=
operator|*
name|group_end
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|next_insn
operator|==
name|NULL_RTX
condition|)
return|return
name|can_issue_more
return|;
if|if
condition|(
name|rs6000_sched_insert_nops
operator|>
name|sched_finish_regroup_exact
condition|)
return|return
name|can_issue_more
return|;
name|force
operator|=
name|is_costly_group
argument_list|(
name|group_insns
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
return|return
name|can_issue_more
return|;
if|if
condition|(
name|sched_verbose
operator|>
literal|6
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"force: group count = %d, can_issue_more = %d\n"
argument_list|,
operator|*
name|group_count
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs6000_sched_insert_nops
operator|==
name|sched_finish_regroup_exact
condition|)
block|{
if|if
condition|(
operator|*
name|group_end
condition|)
name|can_issue_more
operator|=
literal|0
expr_stmt|;
comment|/* Since only a branch can be issued in the last issue_slot, it is 	 sufficient to insert 'can_issue_more - 1' nops if next_insn is not 	 a branch. If next_insn is a branch, we insert 'can_issue_more' nops; 	 in this case the last nop will start a new group and the branch 	 will be forced to the new group.  */
if|if
condition|(
name|can_issue_more
operator|&&
operator|!
name|is_branch_slot_insn
argument_list|(
name|next_insn
argument_list|)
condition|)
name|can_issue_more
operator|--
expr_stmt|;
while|while
condition|(
name|can_issue_more
operator|>
literal|0
condition|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|nop
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
name|can_issue_more
operator|--
expr_stmt|;
block|}
operator|*
name|group_end
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|rs6000_sched_insert_nops
operator|<
name|sched_finish_regroup_exact
condition|)
block|{
name|int
name|n_nops
init|=
name|rs6000_sched_insert_nops
decl_stmt|;
comment|/* Nops can't be issued from the branch slot, so the effective 	 issue_rate for nops is 'issue_rate - 1'.  */
if|if
condition|(
name|can_issue_more
operator|==
literal|0
condition|)
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|can_issue_more
operator|--
expr_stmt|;
if|if
condition|(
name|can_issue_more
operator|==
literal|0
condition|)
block|{
name|can_issue_more
operator|=
name|issue_rate
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|group_count
operator|)
operator|++
expr_stmt|;
name|end
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|group_insns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|n_nops
operator|>
literal|0
condition|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|nop
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_issue_more
operator|==
name|issue_rate
operator|-
literal|1
condition|)
comment|/* new group begins */
name|end
operator|=
name|false
expr_stmt|;
name|can_issue_more
operator|--
expr_stmt|;
if|if
condition|(
name|can_issue_more
operator|==
literal|0
condition|)
block|{
name|can_issue_more
operator|=
name|issue_rate
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|group_count
operator|)
operator|++
expr_stmt|;
name|end
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|group_insns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|n_nops
operator|--
expr_stmt|;
block|}
comment|/* Scale back relative to 'issue_rate' (instead of 'issue_rate - 1').  */
name|can_issue_more
operator|++
expr_stmt|;
comment|/* Is next_insn going to start a new group?  */
operator|*
name|group_end
operator|=
operator|(
name|end
operator|||
operator|(
name|can_issue_more
operator|==
literal|1
operator|&&
operator|!
name|is_branch_slot_insn
argument_list|(
name|next_insn
argument_list|)
operator|)
operator|||
operator|(
name|can_issue_more
operator|<=
literal|2
operator|&&
name|is_cracked_insn
argument_list|(
name|next_insn
argument_list|)
operator|)
operator|||
operator|(
name|can_issue_more
operator|<
name|issue_rate
operator|&&
name|insn_terminates_group_p
argument_list|(
name|next_insn
argument_list|,
name|previous_group
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|group_end
operator|&&
name|end
condition|)
operator|(
operator|*
name|group_count
operator|)
operator|--
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>
literal|6
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"done force: group count = %d, can_issue_more = %d\n"
argument_list|,
operator|*
name|group_count
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
return|return
name|can_issue_more
return|;
block|}
return|return
name|can_issue_more
return|;
block|}
end_function

begin_comment
comment|/* This function tries to synch the dispatch groups that the compiler "sees"    with the dispatch groups that the processor dispatcher is expected to    form in practice.  It tries to achieve this synchronization by forcing the    estimated processor grouping on the compiler (as opposed to the function    'pad_goups' which tries to force the scheduler's grouping on the processor).     The function scans the insn sequence between PREV_HEAD_INSN and TAIL and    examines the (estimated) dispatch groups that will be formed by the processor    dispatcher.  It marks these group boundaries to reflect the estimated    processor grouping, overriding the grouping that the scheduler had marked.    Depending on the value of the flag '-minsert-sched-nops' this function can    force certain insns into separate groups or force a certain distance between    them by inserting nops, for example, if there exists a "costly dependence"    between the insns.     The function estimates the group boundaries that the processor will form as    follows:  It keeps track of how many vacant issue slots are available after    each insn.  A subsequent insn will start a new group if one of the following    4 cases applies:    - no more vacant issue slots remain in the current dispatch group.    - only the last issue slot, which is the branch slot, is vacant, but the next      insn is not a branch.    - only the last 2 or less issue slots, including the branch slot, are vacant,      which means that a cracked insn (which occupies two issue slots) can't be      issued in this group.    - less than 'issue_rate' slots are vacant, and the next insn always needs to      start a new group.  */
end_comment

begin_function
specifier|static
name|int
name|redefine_groups
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
name|prev_head_insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next_insn
decl_stmt|;
name|int
name|issue_rate
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|group_end
decl_stmt|;
name|int
name|group_count
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|group_insns
decl_stmt|;
comment|/* Initialize.  */
name|issue_rate
operator|=
name|rs6000_issue_rate
argument_list|()
expr_stmt|;
name|group_insns
operator|=
name|alloca
argument_list|(
name|issue_rate
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|group_insns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|slot
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|get_next_active_insn
argument_list|(
name|prev_head_insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|group_end
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|slot
operator|=
operator|(
name|issue_rate
operator|-
name|can_issue_more
operator|)
expr_stmt|;
name|group_insns
index|[
name|slot
index|]
operator|=
name|insn
expr_stmt|;
name|can_issue_more
operator|=
name|rs6000_variable_issue
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_terminates_group_p
argument_list|(
name|insn
argument_list|,
name|current_group
argument_list|)
condition|)
name|can_issue_more
operator|=
literal|0
expr_stmt|;
name|next_insn
operator|=
name|get_next_active_insn
argument_list|(
name|insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_insn
operator|==
name|NULL_RTX
condition|)
return|return
name|group_count
operator|+
literal|1
return|;
comment|/* Is next_insn going to start a new group?  */
name|group_end
operator|=
operator|(
name|can_issue_more
operator|==
literal|0
operator|||
operator|(
name|can_issue_more
operator|==
literal|1
operator|&&
operator|!
name|is_branch_slot_insn
argument_list|(
name|next_insn
argument_list|)
operator|)
operator|||
operator|(
name|can_issue_more
operator|<=
literal|2
operator|&&
name|is_cracked_insn
argument_list|(
name|next_insn
argument_list|)
operator|)
operator|||
operator|(
name|can_issue_more
operator|<
name|issue_rate
operator|&&
name|insn_terminates_group_p
argument_list|(
name|next_insn
argument_list|,
name|previous_group
argument_list|)
operator|)
operator|)
expr_stmt|;
name|can_issue_more
operator|=
name|force_new_group
argument_list|(
name|sched_verbose
argument_list|,
name|dump
argument_list|,
name|group_insns
argument_list|,
name|next_insn
argument_list|,
operator|&
name|group_end
argument_list|,
name|can_issue_more
argument_list|,
operator|&
name|group_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_end
condition|)
block|{
name|group_count
operator|++
expr_stmt|;
name|can_issue_more
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
block|{
name|group_insns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|TImode
operator|&&
name|can_issue_more
condition|)
name|PUT_MODE
argument_list|(
name|next_insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|can_issue_more
operator|&&
name|GET_MODE
argument_list|(
name|next_insn
argument_list|)
operator|!=
name|TImode
condition|)
name|PUT_MODE
argument_list|(
name|next_insn
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next_insn
expr_stmt|;
if|if
condition|(
name|can_issue_more
operator|==
literal|0
condition|)
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
block|}
comment|/* while */
return|return
name|group_count
return|;
block|}
end_function

begin_comment
comment|/* Scan the insn sequence between PREV_HEAD_INSN and TAIL and examine the    dispatch group boundaries that the scheduler had marked.  Pad with nops    any dispatch groups which have vacant issue slots, in order to force the    scheduler's grouping on the processor dispatcher.  The function    returns the number of dispatch groups found.  */
end_comment

begin_function
specifier|static
name|int
name|pad_groups
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
name|prev_head_insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next_insn
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
name|int
name|issue_rate
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
name|int
name|group_end
decl_stmt|;
name|int
name|group_count
init|=
literal|0
decl_stmt|;
comment|/* Initialize issue_rate.  */
name|issue_rate
operator|=
name|rs6000_issue_rate
argument_list|()
expr_stmt|;
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|insn
operator|=
name|get_next_active_insn
argument_list|(
name|prev_head_insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|next_insn
operator|=
name|get_next_active_insn
argument_list|(
name|insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|can_issue_more
operator|=
name|rs6000_variable_issue
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
name|group_end
operator|=
operator|(
name|next_insn
operator|==
name|NULL_RTX
operator|||
name|GET_MODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|TImode
operator|)
expr_stmt|;
if|if
condition|(
name|next_insn
operator|==
name|NULL_RTX
condition|)
break|break;
if|if
condition|(
name|group_end
condition|)
block|{
comment|/* If the scheduler had marked group termination at this location 	     (between insn and next_indn), and neither insn nor next_insn will 	     force group termination, pad the group with nops to force group 	     termination.  */
if|if
condition|(
name|can_issue_more
operator|&&
operator|(
name|rs6000_sched_insert_nops
operator|==
name|sched_finish_pad_groups
operator|)
operator|&&
operator|!
name|insn_terminates_group_p
argument_list|(
name|insn
argument_list|,
name|current_group
argument_list|)
operator|&&
operator|!
name|insn_terminates_group_p
argument_list|(
name|next_insn
argument_list|,
name|previous_group
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_branch_slot_insn
argument_list|(
name|next_insn
argument_list|)
condition|)
name|can_issue_more
operator|--
expr_stmt|;
while|while
condition|(
name|can_issue_more
condition|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|nop
argument_list|,
name|next_insn
argument_list|)
expr_stmt|;
name|can_issue_more
operator|--
expr_stmt|;
block|}
block|}
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|group_count
operator|++
expr_stmt|;
block|}
name|insn
operator|=
name|next_insn
expr_stmt|;
name|next_insn
operator|=
name|get_next_active_insn
argument_list|(
name|insn
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
return|return
name|group_count
return|;
block|}
end_function

begin_comment
comment|/* The following function is called at the end of scheduling BB.    After reload, it inserts nops at insn group bundling.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_sched_finish
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|)
block|{
name|int
name|n_groups
decl_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"=== Finishing schedule.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|&&
name|rs6000_sched_groups
condition|)
block|{
if|if
condition|(
name|rs6000_sched_insert_nops
operator|==
name|sched_finish_none
condition|)
return|return;
if|if
condition|(
name|rs6000_sched_insert_nops
operator|==
name|sched_finish_pad_groups
condition|)
name|n_groups
operator|=
name|pad_groups
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|current_sched_info
operator|->
name|prev_head
argument_list|,
name|current_sched_info
operator|->
name|next_tail
argument_list|)
expr_stmt|;
else|else
name|n_groups
operator|=
name|redefine_groups
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|current_sched_info
operator|->
name|prev_head
argument_list|,
name|current_sched_info
operator|->
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"ngroups = %d\n"
argument_list|,
name|n_groups
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump
argument_list|,
name|current_sched_info
operator|->
name|prev_head
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"Done finish_sched\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Length in units of the trampoline for entering a nested function.  */
end_comment

begin_function
name|int
name|rs6000_trampoline_size
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|ABI_AIX
case|:
name|ret
operator|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|12
else|:
literal|24
expr_stmt|;
break|break;
case|case
name|ABI_DARWIN
case|:
case|case
name|ABI_V4
case|:
name|ret
operator|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|40
else|:
literal|48
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|rs6000_initialize_trampoline
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|)
block|{
name|int
name|regsize
init|=
operator|(
name|TARGET_32BIT
operator|)
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|rtx
name|ctx_reg
init|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|cxt
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|DEFAULT_ABI
condition|)
block|{
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Macros to shorten the code expansions below.  */
define|#
directive|define
name|MEM_DEREF
parameter_list|(
name|addr
parameter_list|)
value|gen_rtx_MEM (Pmode, memory_address (Pmode, addr))
define|#
directive|define
name|MEM_PLUS
parameter_list|(
name|addr
parameter_list|,
name|offset
parameter_list|)
define|\
value|gen_rtx_MEM (Pmode, memory_address (Pmode, plus_constant (addr, offset)))
comment|/* Under AIX, just build the 3 word function descriptor */
case|case
name|ABI_AIX
case|:
block|{
name|rtx
name|fn_reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|toc_reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|fn_reg
argument_list|,
name|MEM_DEREF
argument_list|(
name|fnaddr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|toc_reg
argument_list|,
name|MEM_PLUS
argument_list|(
name|fnaddr
argument_list|,
name|regsize
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_DEREF
argument_list|(
name|addr
argument_list|)
argument_list|,
name|fn_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_PLUS
argument_list|(
name|addr
argument_list|,
name|regsize
argument_list|)
argument_list|,
name|toc_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|MEM_PLUS
argument_list|(
name|addr
argument_list|,
literal|2
operator|*
name|regsize
argument_list|)
argument_list|,
name|ctx_reg
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Under V.4/eabi/darwin, __trampoline_setup does the real work.  */
case|case
name|ABI_DARWIN
case|:
case|case
name|ABI_V4
case|:
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__trampoline_setup"
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|,
name|addr
argument_list|,
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|rs6000_trampoline_size
argument_list|()
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|fnaddr
argument_list|,
name|Pmode
argument_list|,
name|ctx_reg
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|rs6000_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"altivec"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|rs6000_handle_altivec_attribute
block|}
block|,
block|{
literal|"longcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|rs6000_handle_longcall_attribute
block|}
block|,
block|{
literal|"shortcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|rs6000_handle_longcall_attribute
block|}
block|,
block|{
literal|"ms_struct"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|rs6000_handle_struct_attribute
block|}
block|,
block|{
literal|"gcc_struct"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|rs6000_handle_struct_attribute
block|}
block|,
ifdef|#
directive|ifdef
name|SUBTARGET_ATTRIBUTE_TABLE
name|SUBTARGET_ATTRIBUTE_TABLE
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the "altivec" attribute.  The attribute may have    arguments as follows:  	__attribute__((altivec(vector__))) 	__attribute__((altivec(pixel__)))	(always followed by 'unsigned short') 	__attribute__((altivec(bool__)))	(always followed by 'unsigned')    and may appear more than once (e.g., 'vector bool char') in a   given declaration.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_handle_altivec_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|,
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsigned_p
decl_stmt|;
name|char
name|altivec_type
init|=
operator|(
operator|(
name|args
operator|&&
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|?
operator|*
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
else|:
literal|'?'
operator|)
decl_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Check for invalid AltiVec type qualifiers.  */
if|if
condition|(
name|type
operator|==
name|long_unsigned_type_node
operator|||
name|type
operator|==
name|long_integer_type_node
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|error
argument_list|(
literal|"use of %<long%> in AltiVec types is invalid for 64-bit code"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rs6000_warn_altivec_long
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"use of %<long%> in AltiVec types is deprecated; use %<int%>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|long_long_unsigned_type_node
operator|||
name|type
operator|==
name|long_long_integer_type_node
condition|)
name|error
argument_list|(
literal|"use of %<long long%> in AltiVec types is invalid"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|error
argument_list|(
literal|"use of %<double%> in AltiVec types is invalid"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|error
argument_list|(
literal|"use of %<long double%> in AltiVec types is invalid"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|boolean_type_node
condition|)
name|error
argument_list|(
literal|"use of boolean types in AltiVec types is invalid"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|error
argument_list|(
literal|"use of %<complex%> in AltiVec types is invalid"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|error
argument_list|(
literal|"use of decimal floating point types in AltiVec types is invalid"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|altivec_type
condition|)
block|{
case|case
literal|'v'
case|:
name|unsigned_p
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SImode
case|:
name|result
operator|=
operator|(
name|unsigned_p
condition|?
name|unsigned_V4SI_type_node
else|:
name|V4SI_type_node
operator|)
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|result
operator|=
operator|(
name|unsigned_p
condition|?
name|unsigned_V8HI_type_node
else|:
name|V8HI_type_node
operator|)
expr_stmt|;
break|break;
case|case
name|QImode
case|:
name|result
operator|=
operator|(
name|unsigned_p
condition|?
name|unsigned_V16QI_type_node
else|:
name|V16QI_type_node
operator|)
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
name|result
operator|=
name|V4SF_type_node
expr_stmt|;
break|break;
comment|/* If the user says 'vector int bool', we may be handed the 'bool' 	     attribute _before_ the 'vector' attribute, and so select the 	     proper type in the 'b' case below.  */
case|case
name|V4SImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V16QImode
case|:
case|case
name|V4SFmode
case|:
name|result
operator|=
name|type
expr_stmt|;
default|default:
break|break;
block|}
break|break;
case|case
literal|'b'
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SImode
case|:
case|case
name|V4SImode
case|:
name|result
operator|=
name|bool_V4SI_type_node
expr_stmt|;
break|break;
case|case
name|HImode
case|:
case|case
name|V8HImode
case|:
name|result
operator|=
name|bool_V8HI_type_node
expr_stmt|;
break|break;
case|case
name|QImode
case|:
case|case
name|V16QImode
case|:
name|result
operator|=
name|bool_V16QI_type_node
expr_stmt|;
default|default:
break|break;
block|}
break|break;
case|case
literal|'p'
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V8HImode
case|:
name|result
operator|=
name|pixel_V8HI_type_node
expr_stmt|;
default|default:
break|break;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|result
operator|&&
name|result
operator|!=
name|type
operator|&&
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
name|result
operator|=
name|build_qualified_type
argument_list|(
name|result
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
comment|/* No need to hang on to the attribute.  */
if|if
condition|(
name|result
condition|)
operator|*
name|node
operator|=
name|reconstruct_complex_type
argument_list|(
operator|*
name|node
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* AltiVec defines four built-in scalar types that serve as vector    elements; we must teach the compiler how to mangle them.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_mangle_fundamental_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|bool_char_type_node
condition|)
return|return
literal|"U6__boolc"
return|;
if|if
condition|(
name|type
operator|==
name|bool_short_type_node
condition|)
return|return
literal|"U6__bools"
return|;
if|if
condition|(
name|type
operator|==
name|pixel_type_node
condition|)
return|return
literal|"u7__pixel"
return|;
if|if
condition|(
name|type
operator|==
name|bool_int_type_node
condition|)
return|return
literal|"U6__booli"
return|;
comment|/* Mangle IBM extended float long double as `g' (__float128) on      powerpc*-linux where long-double-64 previously was the default.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|long_double_type_node
operator|&&
name|TARGET_ELF
operator|&&
name|TARGET_LONG_DOUBLE_128
operator|&&
operator|!
name|TARGET_IEEEQUAD
condition|)
return|return
literal|"g"
return|;
comment|/* For all other types, use normal C++ mangling.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Handle a "longcall" or "shortcall" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_handle_longcall_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set longcall attributes on all functions declared when    rs6000_default_long_calls is true.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_set_default_type_attributes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|rs6000_default_long_calls
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"longcall"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
name|darwin_set_default_type_attributes
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return a reference suitable for calling a function with the    longcall attribute.  */
end_comment

begin_function
name|rtx
name|rs6000_longcall_ref
parameter_list|(
name|rtx
name|call_ref
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|call_name
decl_stmt|;
name|tree
name|node
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_ref
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|call_ref
return|;
comment|/* System V adds '.' to the internal name, so skip them.  */
name|call_name
operator|=
name|XSTR
argument_list|(
name|call_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|call_name
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
operator|*
name|call_name
operator|==
literal|'.'
condition|)
name|call_name
operator|++
expr_stmt|;
name|node
operator|=
name|get_identifier
argument_list|(
name|call_name
argument_list|)
expr_stmt|;
name|call_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|call_ref
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_USE_MS_BITFIELD_LAYOUT
end_ifndef

begin_define
define|#
directive|define
name|TARGET_USE_MS_BITFIELD_LAYOUT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle a "ms_struct" or "gcc_struct" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_handle_struct_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|is_attribute_p
argument_list|(
literal|"ms_struct"
argument_list|,
name|name
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"gcc_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|is_attribute_p
argument_list|(
literal|"gcc_struct"
argument_list|,
name|name
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"ms_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs incompatible attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|rs6000_ms_bitfield_layout_p
parameter_list|(
name|tree
name|record_type
parameter_list|)
block|{
return|return
operator|(
name|TARGET_USE_MS_BITFIELD_LAYOUT
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"gcc_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|record_type
argument_list|)
argument_list|)
operator|)
operator|||
name|lookup_attribute
argument_list|(
literal|"ms_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|record_type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|USING_ELFOS_H
end_ifdef

begin_comment
comment|/* A get_unnamed_section callback, used for switching to toc_section.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_output_toc_section_asm_op
parameter_list|(
specifier|const
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
name|TARGET_MINIMAL_TOC
operator|&&
operator|!
name|TARGET_RELOCATABLE
condition|)
block|{
if|if
condition|(
operator|!
name|toc_initialized
condition|)
block|{
name|toc_initialized
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|TOC_SECTION_ASM_OP
argument_list|)
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"LCTOC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.tc "
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
literal|"LCTOC1[TC],"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
literal|"LCTOC1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|MINIMAL_TOC_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
literal|"LCTOC1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" = .+32768\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|MINIMAL_TOC_SECTION_ASM_OP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
operator|&&
operator|!
name|TARGET_RELOCATABLE
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|TOC_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|MINIMAL_TOC_SECTION_ASM_OP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toc_initialized
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
literal|"LCTOC1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" = .+32768\n"
argument_list|)
expr_stmt|;
name|toc_initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Implement TARGET_ASM_INIT_SECTIONS.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_asm_init_sections
parameter_list|(
name|void
parameter_list|)
block|{
name|toc_section
operator|=
name|get_unnamed_section
argument_list|(
literal|0
argument_list|,
name|rs6000_elf_output_toc_section_asm_op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sdata2_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_WRITE
argument_list|,
name|output_section_asm_op
argument_list|,
name|SDATA2_SECTION_ASM_OP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_SELECT_RTX_SECTION.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|rs6000_elf_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
if|if
condition|(
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|toc_section
return|;
else|else
return|return
name|default_elf_select_rtx_section
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|align
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For a SYMBOL_REF, set generic flags and then perform some    target-specific processing.     When the AIX ABI is requested on a non-AIX system, replace the    function name with the real name (with a leading .) rather than the    function descriptor name.  This saves a lot of overriding code to    read the prefixes.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TARGET_AIX
operator|&&
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
name|rtx
name|sym_ref
init|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|memcpy
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|rs6000_elf_in_small_data_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|rs6000_sdata
operator|==
name|SDATA_NONE
condition|)
return|return
name|false
return|;
comment|/* We want to merge strings, so we never consider them small data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|false
return|;
comment|/* Functions are never in the small data area.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sdata2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sbss2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".PPC.EMB.sdata0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|size
operator|<=
name|g_switch_value
comment|/* If it's not public, and we're not going to reference it there, 	     there's no need to put it in the small data section.  */
operator|&&
operator|(
name|rs6000_sdata
operator|!=
name|SDATA_DATA
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USING_ELFOS_H */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Implement TARGET_USE_BLOCKS_FOR_CONSTANT_P.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_use_blocks_for_constant_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
return|return
operator|!
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.     r0 is special and we must not select it as an address    register by this routine since our caller will try to    increment the returned register via an "la" instruction.  */
end_comment

begin_function
name|rtx
name|find_addr_reg
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_function
name|void
name|rs6000_fatal_bad_address
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|fatal_insn
argument_list|(
literal|"bad address"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_decl_stmt
specifier|static
name|tree
name|branch_island_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember to generate a branch island for far calls to the given    function.  */
end_comment

begin_function
specifier|static
name|void
name|add_compiler_branch_island
parameter_list|(
name|tree
name|label_name
parameter_list|,
name|tree
name|function_name
parameter_list|,
name|int
name|line_number
parameter_list|)
block|{
name|tree
name|branch_island
init|=
name|build_tree_list
argument_list|(
name|function_name
argument_list|,
name|label_name
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|branch_island
argument_list|)
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|branch_island
argument_list|)
operator|=
name|branch_island_list
expr_stmt|;
name|branch_island_list
operator|=
name|branch_island
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BRANCH_ISLAND_LABEL_NAME
parameter_list|(
name|BRANCH_ISLAND
parameter_list|)
value|TREE_VALUE (BRANCH_ISLAND)
end_define

begin_define
define|#
directive|define
name|BRANCH_ISLAND_FUNCTION_NAME
parameter_list|(
name|BRANCH_ISLAND
parameter_list|)
value|TREE_PURPOSE (BRANCH_ISLAND)
end_define

begin_define
define|#
directive|define
name|BRANCH_ISLAND_LINE_NUMBER
parameter_list|(
name|BRANCH_ISLAND
parameter_list|)
define|\
value|TREE_INT_CST_LOW (TREE_TYPE (BRANCH_ISLAND))
end_define

begin_comment
comment|/* Generate far-jump branch islands for everything on the    branch_island_list.  Invoked immediately after the last instruction    of the epilogue has been emitted; the branch-islands must be    appended to, and contiguous with, the function body.  Mach-O stubs    are generated in machopic_output_stub().  */
end_comment

begin_function
specifier|static
name|void
name|macho_branch_islands
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|tmp_buf
index|[
literal|512
index|]
decl_stmt|;
name|tree
name|branch_island
decl_stmt|;
for|for
control|(
name|branch_island
operator|=
name|branch_island_list
init|;
name|branch_island
condition|;
name|branch_island
operator|=
name|TREE_CHAIN
argument_list|(
name|branch_island
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|label
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|BRANCH_ISLAND_LABEL_NAME
argument_list|(
name|branch_island
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|BRANCH_ISLAND_FUNCTION_NAME
argument_list|(
name|branch_island
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|name_buf
index|[
literal|512
index|]
decl_stmt|;
comment|/* Cheap copy of the details from the Darwin ASM_OUTPUT_LABELREF().  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|strcpy
argument_list|(
name|name_buf
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|name_buf
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|name_buf
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tmp_buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|dbxout_stabd
argument_list|(
name|N_SLINE
argument_list|,
name|BRANCH_ISLAND_LINE_NUMBER
argument_list|(
name|branch_island
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
if|if
condition|(
name|flag_pic
condition|)
block|{
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|":\n\tmflr r0\n\tbcl 20,31,"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"_pic\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"_pic:\n\tmflr r11\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"\taddis r11,r11,ha16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"_pic)\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"\tmtlr r0\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"\taddi r12,r11,lo16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"_pic)\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|"\tmtctr r12\n\tbctr\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|":\nlis r12,hi16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|")\n\tori r12,r12,lo16("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
name|name_buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp_buf
argument_list|,
literal|")\n\tmtctr r12\n\tbctr"
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|tmp_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|dbxout_stabd
argument_list|(
name|N_SLINE
argument_list|,
name|BRANCH_ISLAND_LINE_NUMBER
argument_list|(
name|branch_island
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
block|}
name|branch_island_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NO_PREVIOUS_DEF checks in the link list whether the function name is    already there or not.  */
end_comment

begin_function
specifier|static
name|int
name|no_previous_def
parameter_list|(
name|tree
name|function_name
parameter_list|)
block|{
name|tree
name|branch_island
decl_stmt|;
for|for
control|(
name|branch_island
operator|=
name|branch_island_list
init|;
name|branch_island
condition|;
name|branch_island
operator|=
name|TREE_CHAIN
argument_list|(
name|branch_island
argument_list|)
control|)
if|if
condition|(
name|function_name
operator|==
name|BRANCH_ISLAND_FUNCTION_NAME
argument_list|(
name|branch_island
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* GET_PREV_LABEL gets the label name from the previous definition of    the function.  */
end_comment

begin_function
specifier|static
name|tree
name|get_prev_label
parameter_list|(
name|tree
name|function_name
parameter_list|)
block|{
name|tree
name|branch_island
decl_stmt|;
for|for
control|(
name|branch_island
operator|=
name|branch_island_list
init|;
name|branch_island
condition|;
name|branch_island
operator|=
name|TREE_CHAIN
argument_list|(
name|branch_island
argument_list|)
control|)
if|if
condition|(
name|function_name
operator|==
name|BRANCH_ISLAND_FUNCTION_NAME
argument_list|(
name|branch_island
argument_list|)
condition|)
return|return
name|BRANCH_ISLAND_LABEL_NAME
argument_list|(
name|branch_island
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|DARWIN_LINKER_GENERATES_ISLANDS
end_ifndef

begin_define
define|#
directive|define
name|DARWIN_LINKER_GENERATES_ISLANDS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KEXTs still need branch islands.  */
end_comment

begin_define
define|#
directive|define
name|DARWIN_GENERATE_ISLANDS
value|(!DARWIN_LINKER_GENERATES_ISLANDS \ 				 || flag_mkernel || flag_apple_kext)
end_define

begin_comment
comment|/* INSN is either a function call or a millicode call.  It may have an    unconditional jump in its delay slot.     CALL_DEST is the routine we are calling.  */
end_comment

begin_function
name|char
modifier|*
name|output_call
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|dest_operand_number
parameter_list|,
name|int
name|cookie_operand_number
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|DARWIN_GENERATE_ISLANDS
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
name|dest_operand_number
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|INTVAL
argument_list|(
name|operands
index|[
name|cookie_operand_number
index|]
argument_list|)
operator|&
name|CALL_LONG
operator|)
condition|)
block|{
name|tree
name|labelname
decl_stmt|;
name|tree
name|funname
init|=
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|operands
index|[
name|dest_operand_number
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|no_previous_def
argument_list|(
name|funname
argument_list|)
condition|)
block|{
name|int
name|line_number
init|=
literal|0
decl_stmt|;
name|rtx
name|label_rtx
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|char
modifier|*
name|label_buf
decl_stmt|,
name|temp_buf
index|[
literal|256
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|temp_buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|label_buf
operator|=
name|temp_buf
index|[
literal|0
index|]
operator|==
literal|'*'
condition|?
name|temp_buf
operator|+
literal|1
else|:
name|temp_buf
expr_stmt|;
name|labelname
operator|=
name|get_identifier
argument_list|(
name|label_buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
condition|)
name|line_number
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_compiler_branch_island
argument_list|(
name|labelname
argument_list|,
name|funname
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
block|}
else|else
name|labelname
operator|=
name|get_prev_label
argument_list|(
name|funname
argument_list|)
expr_stmt|;
comment|/* "jbsr foo, L42" is Mach-O for "Link as 'bl foo' if a 'bl' 	 instruction will reach 'foo', otherwise link as 'bl L42'". 	 "L42" should be a 'branch island', that will do a far jump to 	 'foo'.  Branch islands are generated in 	 macho_branch_islands().  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"jbsr %%z%d,%.246s"
argument_list|,
name|dest_operand_number
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|labelname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"bl %%z%d"
argument_list|,
name|dest_operand_number
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Generate PIC and indirect symbol stubs.  */
end_comment

begin_function
name|void
name|machopic_output_stub
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|symb
parameter_list|,
specifier|const
name|char
modifier|*
name|stub
parameter_list|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|symbol_name
decl_stmt|,
modifier|*
name|lazy_ptr_name
decl_stmt|;
name|char
modifier|*
name|local_label_0
decl_stmt|;
specifier|static
name|int
name|label
init|=
literal|0
decl_stmt|;
comment|/* Lose our funky encoding stuff so it doesn't contaminate the stub.  */
name|symb
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_SYMBOL_NAME_FOR_SYMBOL
argument_list|(
name|symbol_name
argument_list|,
name|symb
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|lazy_ptr_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_LAZY_PTR_NAME_FOR_SYMBOL
argument_list|(
name|lazy_ptr_name
argument_list|,
name|symb
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|machopic_picsymbol_stub1_section
index|]
argument_list|)
expr_stmt|;
else|else
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|machopic_symbol_stub1_section
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align 5\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|label
operator|++
expr_stmt|;
name|local_label_0
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
literal|"\"L00000000000$spb\""
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|local_label_0
argument_list|,
literal|"\"L%011d$spb\""
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr r0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbcl 20,31,%s\n"
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n\tmflr r11\n"
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddis r11,r11,ha16(%s-%s)\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtlr r0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s r12,lo16(%s-%s)(r11)\n"
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|"ldu"
else|:
literal|"lwzu"
operator|)
argument_list|,
name|lazy_ptr_name
argument_list|,
name|local_label_0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtctr r12\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbctr\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.align 4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlis r11,ha16(%s)\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s r12,lo16(%s)(r11)\n"
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|"ldu"
else|:
literal|"lwzu"
operator|)
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtctr r12\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbctr\n"
argument_list|)
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|machopic_lazy_symbol_ptr_section
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%sdyld_stub_binding_helper\n"
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
name|DOUBLE_INT_ASM_OP
else|:
literal|"\t.long\t"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already    position-independent, we return ORIG.  Newly generated    position-independent addresses go into a reg.  This is REG if non    zero, otherwise we allocate register(s) as necessary.  */
end_comment

begin_define
define|#
directive|define
name|SMALL_INT
parameter_list|(
name|X
parameter_list|)
value|((UINTVAL (X) + 0x8000)< 0x10000)
end_define

begin_function
name|rtx
name|rs6000_machopic_legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
operator|&&
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|reg_temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
argument_list|)
expr_stmt|;
comment|/* Use a different reg for the intermediate value, as 	 it will be marked UNCHANGING.  */
name|reg_temp
operator|=
name|no_new_pseudos
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|base
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg_temp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rs6000_machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|mem
init|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
decl_stmt|;
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|mem
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
return|;
block|}
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/* Fall back on generic machopic code.  */
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|orig
argument_list|,
name|mode
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output a .machine directive for the Darwin assembler, and call    the generic start_file routine.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_darwin_file_start
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|if_set
decl_stmt|;
block|}
name|mapping
index|[]
init|=
block|{
block|{
literal|"ppc64"
block|,
literal|"ppc64"
block|,
name|MASK_64BIT
block|}
block|,
block|{
literal|"970"
block|,
literal|"ppc970"
block|,
name|MASK_PPC_GPOPT
operator||
name|MASK_MFCRF
operator||
name|MASK_POWERPC64
block|}
block|,
block|{
literal|"power4"
block|,
literal|"ppc970"
block|,
literal|0
block|}
block|,
block|{
literal|"G5"
block|,
literal|"ppc970"
block|,
literal|0
block|}
block|,
block|{
literal|"7450"
block|,
literal|"ppc7450"
block|,
literal|0
block|}
block|,
block|{
literal|"7400"
block|,
literal|"ppc7400"
block|,
name|MASK_ALTIVEC
block|}
block|,
block|{
literal|"G4"
block|,
literal|"ppc7400"
block|,
literal|0
block|}
block|,
block|{
literal|"750"
block|,
literal|"ppc750"
block|,
literal|0
block|}
block|,
block|{
literal|"740"
block|,
literal|"ppc750"
block|,
literal|0
block|}
block|,
block|{
literal|"G3"
block|,
literal|"ppc750"
block|,
literal|0
block|}
block|,
block|{
literal|"604e"
block|,
literal|"ppc604e"
block|,
literal|0
block|}
block|,
block|{
literal|"604"
block|,
literal|"ppc604"
block|,
literal|0
block|}
block|,
block|{
literal|"603e"
block|,
literal|"ppc603"
block|,
literal|0
block|}
block|,
block|{
literal|"603"
block|,
literal|"ppc603"
block|,
literal|0
block|}
block|,
block|{
literal|"601"
block|,
literal|"ppc601"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|"ppc"
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|char
modifier|*
name|cpu_id
init|=
literal|""
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|rs6000_file_start
argument_list|()
expr_stmt|;
name|darwin_file_start
argument_list|()
expr_stmt|;
comment|/* Determine the argument to -mcpu=.  Default to G3 if not specified.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rs6000_select
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rs6000_select
index|[
name|i
index|]
operator|.
name|set_arch_p
operator|&&
name|rs6000_select
index|[
name|i
index|]
operator|.
name|string
operator|&&
name|rs6000_select
index|[
name|i
index|]
operator|.
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|cpu_id
operator|=
name|rs6000_select
index|[
name|i
index|]
operator|.
name|string
expr_stmt|;
comment|/* Look through the mapping array.  Pick the first name that either      matches the argument, has a bit set in IF_SET that is also set      in the target flags, or has a NULL name.  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mapping
index|[
name|i
index|]
operator|.
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|mapping
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
name|cpu_id
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|mapping
index|[
name|i
index|]
operator|.
name|if_set
operator|&
name|target_flags
operator|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.machine %s\n"
argument_list|,
name|mapping
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_MACHO */
end_comment

begin_if
if|#
directive|if
name|TARGET_ELF
end_if

begin_function
specifier|static
name|int
name|rs6000_elf_reloc_rw_mask
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|flag_pic
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
return|return
literal|2
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record an element in the table of global constructors.  SYMBOL is    a SYMBOL_REF of the function to be called; PRIORITY is a number    between 0 and MAX_INIT_PRIORITY.     This differs from default_named_section_asm_out_constructor in    that we have special handling for -mrelocatable.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_elf_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".ctors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".ctors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|get_section
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.long ("
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")@fixup\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_elf_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
literal|".dtors"
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|priority
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".dtors.%.5u"
argument_list|,
comment|/* Invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|priority
argument_list|)
expr_stmt|;
name|section
operator|=
name|buf
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|get_section
argument_list|(
name|section
argument_list|,
name|SECTION_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RELOCATABLE
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.long ("
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")@fixup\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rs6000_elf_declare_function_name
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.section\t\".opd\",\"aw\"\n\t.align 3\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|DOUBLE_INT_ASM_OP
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|rs6000_output_function_entry
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",.TOC.@tocbase,0\n\t.previous\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOT_SYMBOLS
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.size\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",24\n\t.type\t."
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",@function\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.globl\t."
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ASM_OUTPUT_TYPE_DIRECTIVE
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
name|ASM_DECLARE_RESULT
argument_list|(
name|file
argument_list|,
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|rs6000_output_function_entry
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TARGET_RELOCATABLE
operator|&&
operator|!
name|TARGET_SECURE_PLT
operator|&&
operator|(
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|||
name|current_function_profile
operator|)
operator|&&
name|uses_TOC
argument_list|()
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|file
argument_list|,
literal|"LCL"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCTOC"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LCF"
argument_list|,
name|rs6000_pic_labelno
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_TYPE_DIRECTIVE
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
name|ASM_DECLARE_RESULT
argument_list|(
name|file
argument_list|,
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
block|{
specifier|const
name|char
modifier|*
name|desc_name
decl_stmt|,
modifier|*
name|orig_name
decl_stmt|;
name|orig_name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|desc_name
operator|=
name|orig_name
expr_stmt|;
while|while
condition|(
operator|*
name|desc_name
operator|==
literal|'.'
condition|)
name|desc_name
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.globl %s\n"
argument_list|,
name|desc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|MINIMAL_TOC_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|desc_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long %s\n"
argument_list|,
name|orig_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.long _GLOBAL_OFFSET_TABLE_\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEFAULT_ABI
operator|==
name|ABI_AIX
condition|)
name|fputs
argument_list|(
literal|"\t.long 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.previous\n"
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_elf_end_indicate_exec_stack
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|NEED_INDICATE_EXEC_STACK
condition|)
name|file_end_indicate_exec_stack
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET_XCOFF
end_if

begin_function
specifier|static
name|void
name|rs6000_xcoff_asm_output_anchor
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"$ + "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_xcoff_asm_globalize_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fputs
argument_list|(
name|GLOBAL_ASM_OP
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A get_unnamed_decl callback, used for read-only sections.  PTR    points to the section string variable.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_output_readonly_section_asm_op
parameter_list|(
specifier|const
name|void
modifier|*
name|directive
parameter_list|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.csect %s[RO],3\n"
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|directive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise for read-write sections.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_output_readwrite_section_asm_op
parameter_list|(
specifier|const
name|void
modifier|*
name|directive
parameter_list|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.csect %s[RW],3\n"
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|directive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A get_unnamed_section callback, used for switching to toc_section.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_output_toc_section_asm_op
parameter_list|(
specifier|const
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_MINIMAL_TOC
condition|)
block|{
comment|/* toc_section is always selected at least once from 	 rs6000_xcoff_file_start, so this is guaranteed to 	 always be defined once and only once in each file.  */
if|if
condition|(
operator|!
name|toc_initialized
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.toc\nLCTOC..1:\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.tc toc_table[TC],toc_table[RW]\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|toc_initialized
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.csect toc_table[RW]%s\n"
argument_list|,
operator|(
name|TARGET_32BIT
condition|?
literal|""
else|:
literal|",3"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"\t.toc\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_ASM_INIT_SECTIONS.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_asm_init_sections
parameter_list|(
name|void
parameter_list|)
block|{
name|read_only_data_section
operator|=
name|get_unnamed_section
argument_list|(
literal|0
argument_list|,
name|rs6000_xcoff_output_readonly_section_asm_op
argument_list|,
operator|&
name|xcoff_read_only_section_name
argument_list|)
expr_stmt|;
name|private_data_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_WRITE
argument_list|,
name|rs6000_xcoff_output_readwrite_section_asm_op
argument_list|,
operator|&
name|xcoff_private_data_section_name
argument_list|)
expr_stmt|;
name|read_only_private_data_section
operator|=
name|get_unnamed_section
argument_list|(
literal|0
argument_list|,
name|rs6000_xcoff_output_readonly_section_asm_op
argument_list|,
operator|&
name|xcoff_private_data_section_name
argument_list|)
expr_stmt|;
name|toc_section
operator|=
name|get_unnamed_section
argument_list|(
literal|0
argument_list|,
name|rs6000_xcoff_output_toc_section_asm_op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|readonly_data_section
operator|=
name|read_only_data_section
expr_stmt|;
name|exception_section
operator|=
name|data_section
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rs6000_xcoff_reloc_rw_mask
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|3
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_xcoff_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|smclass
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|suffix
index|[
literal|3
index|]
init|=
block|{
literal|"PR"
block|,
literal|"RO"
block|,
literal|"RW"
block|}
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
name|smclass
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
name|smclass
operator|=
literal|2
expr_stmt|;
else|else
name|smclass
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.csect %s%s[%s],%u\n"
argument_list|,
operator|(
name|flags
operator|&
name|SECTION_CODE
operator|)
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|name
argument_list|,
name|suffix
index|[
name|smclass
index|]
argument_list|,
name|flags
operator|&
name|SECTION_ENTSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|section
modifier|*
name|rs6000_xcoff_select_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|read_only_data_section
return|;
else|else
return|return
name|read_only_private_data_section
return|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|data_section
return|;
else|else
return|return
name|private_data_section
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_xcoff_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Use select_section for private and uninitialized data.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
operator|(
name|flag_zero_initialized_in_bss
operator|&&
name|initializer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select section for constant in constant pool.     On RS/6000, all constants are in the private read-only data area.    However, if this is being placed in the TOC it must be output as a    toc entry.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|rs6000_xcoff_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY_P
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|toc_section
return|;
else|else
return|return
name|read_only_private_data_section
return|;
block|}
end_function

begin_comment
comment|/* Remove any trailing [DS] or the like from the symbol name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_xcoff_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'*'
condition|)
name|name
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
return|return
name|ggc_alloc_string
argument_list|(
name|name
argument_list|,
name|len
operator|-
literal|4
argument_list|)
return|;
else|else
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Section attributes.  AIX is always PIC.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rs6000_xcoff_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
name|default_section_type_flags
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
decl_stmt|;
comment|/* Align to at least UNIT size.  */
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
name|align
operator|=
name|MIN_UNITS_PER_WORD
expr_stmt|;
else|else
comment|/* Increase alignment of large objects if not already stricter.  */
name|align
operator|=
name|MAX
argument_list|(
operator|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|>
name|MIN_UNITS_PER_WORD
condition|?
name|UNITS_PER_FP_WORD
else|:
name|MIN_UNITS_PER_WORD
argument_list|)
expr_stmt|;
return|return
name|flags
operator||
operator|(
name|exact_log2
argument_list|(
name|align
argument_list|)
operator|&
name|SECTION_ENTSIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output at beginning of assembler file.     Initialize the section names for the RS/6000 at this point.     Specify filename, including full path, to assembler.     We want to go into the TOC section so at least one .toc will be emitted.    Also, in order to output proper .bs/.es pairs, we need at least one static    [RW] section emitted.     Finally, declare mcount when profiling to make the assembler happy.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|rs6000_gen_section_name
argument_list|(
operator|&
name|xcoff_bss_section_name
argument_list|,
name|main_input_filename
argument_list|,
literal|".bss_"
argument_list|)
expr_stmt|;
name|rs6000_gen_section_name
argument_list|(
operator|&
name|xcoff_private_data_section_name
argument_list|,
name|main_input_filename
argument_list|,
literal|".rw_"
argument_list|)
expr_stmt|;
name|rs6000_gen_section_name
argument_list|(
operator|&
name|xcoff_read_only_section_name
argument_list|,
name|main_input_filename
argument_list|,
literal|".ro_"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.file\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|switch_to_section
argument_list|(
name|private_data_section
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_flag
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.extern %s\n"
argument_list|,
name|RS6000_MCOUNT
argument_list|)
expr_stmt|;
name|rs6000_file_start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output at end of assembler file.    On the RS/6000, referencing data should automatically pull in text.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_xcoff_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"_section_.text:\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|data_section
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|TARGET_32BIT
condition|?
literal|"\t.long _section_.text\n"
else|:
literal|"\t.llong _section_.text\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_XCOFF */
end_comment

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* On the RS/6000, if it is valid in the insn, it is free.  */
case|case
name|CONST_INT
case|:
if|if
condition|(
operator|(
operator|(
name|outer_code
operator|==
name|SET
operator|||
name|outer_code
operator|==
name|PLUS
operator|||
name|outer_code
operator|==
name|MINUS
operator|)
operator|&&
operator|(
name|satisfies_constraint_I
argument_list|(
name|x
argument_list|)
operator|||
name|satisfies_constraint_L
argument_list|(
name|x
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|outer_code
operator|==
name|AND
operator|&&
operator|(
name|satisfies_constraint_K
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|mode
operator|==
name|SImode
condition|?
name|satisfies_constraint_L
argument_list|(
name|x
argument_list|)
else|:
name|satisfies_constraint_J
argument_list|(
name|x
argument_list|)
operator|)
operator|||
name|mask_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|mode
operator|==
name|DImode
operator|&&
name|mask64_operand
argument_list|(
name|x
argument_list|,
name|DImode
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|outer_code
operator|==
name|IOR
operator|||
name|outer_code
operator|==
name|XOR
operator|)
operator|&&
operator|(
name|satisfies_constraint_K
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|mode
operator|==
name|SImode
condition|?
name|satisfies_constraint_L
argument_list|(
name|x
argument_list|)
else|:
name|satisfies_constraint_J
argument_list|(
name|x
argument_list|)
operator|)
operator|)
operator|)
operator|||
name|outer_code
operator|==
name|ASHIFT
operator|||
name|outer_code
operator|==
name|ASHIFTRT
operator|||
name|outer_code
operator|==
name|LSHIFTRT
operator|||
name|outer_code
operator|==
name|ROTATE
operator|||
name|outer_code
operator|==
name|ROTATERT
operator|||
name|outer_code
operator|==
name|ZERO_EXTRACT
operator|||
operator|(
name|outer_code
operator|==
name|MULT
operator|&&
name|satisfies_constraint_I
argument_list|(
name|x
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|outer_code
operator|==
name|DIV
operator|||
name|outer_code
operator|==
name|UDIV
operator|||
name|outer_code
operator|==
name|MOD
operator|||
name|outer_code
operator|==
name|UMOD
operator|)
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|outer_code
operator|==
name|COMPARE
operator|&&
operator|(
name|satisfies_constraint_I
argument_list|(
name|x
argument_list|)
operator|||
name|satisfies_constraint_K
argument_list|(
name|x
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|outer_code
operator|==
name|EQ
operator|&&
operator|(
name|satisfies_constraint_I
argument_list|(
name|x
argument_list|)
operator|||
name|satisfies_constraint_K
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|mode
operator|==
name|SImode
condition|?
name|satisfies_constraint_L
argument_list|(
name|x
argument_list|)
else|:
name|satisfies_constraint_J
argument_list|(
name|x
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|outer_code
operator|==
name|GTU
operator|&&
name|satisfies_constraint_I
argument_list|(
name|x
argument_list|)
operator|)
operator|||
operator|(
name|outer_code
operator|==
name|LTU
operator|&&
name|satisfies_constraint_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|outer_code
operator|==
name|PLUS
operator|&&
name|reg_or_add_cint_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|||
operator|(
name|outer_code
operator|==
name|MINUS
operator|&&
name|reg_or_sub_cint_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|outer_code
operator|==
name|SET
operator|||
name|outer_code
operator|==
name|IOR
operator|||
name|outer_code
operator|==
name|XOR
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* FALLTHRU */
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|code
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
operator|(
name|outer_code
operator|==
name|IOR
operator|||
name|outer_code
operator|==
name|XOR
operator|)
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|outer_code
operator|==
name|AND
operator|&&
name|and64_2_operand
argument_list|(
name|x
argument_list|,
name|DImode
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|outer_code
operator|==
name|SET
operator|||
name|outer_code
operator|==
name|IOR
operator|||
name|outer_code
operator|==
name|XOR
operator|)
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|CONST
case|:
case|case
name|HIGH
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|MEM
case|:
comment|/* When optimizing for size, MEM should be slightly more expensive 	 than generating address, e.g., (plus (reg) (const)). 	 L1 cache latency is about two instructions.  */
operator|*
name|total
operator|=
name|optimize_size
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
else|:
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|LABEL_REF
case|:
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
comment|/* FNMA accounted in outer NEG.  */
if|if
condition|(
name|outer_code
operator|==
name|NEG
condition|)
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|dmul
operator|-
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|dmul
expr_stmt|;
block|}
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
comment|/* FNMA accounted in outer NEG.  */
if|if
condition|(
name|outer_code
operator|==
name|NEG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
block|}
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|MINUS
case|:
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
comment|/* FNMA accounted in outer NEG.  */
if|if
condition|(
name|outer_code
operator|==
name|NEG
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|dmul
expr_stmt|;
block|}
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
comment|/* FNMA accounted in outer NEG.  */
if|if
condition|(
name|outer_code
operator|==
name|NEG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
block|}
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|satisfies_constraint_I
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|-
literal|256
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|255
condition|)
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|mulsi_const9
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|mulsi_const
expr_stmt|;
block|}
comment|/* FMA accounted in outer PLUS/MINUS.  */
elseif|else
if|if
condition|(
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|SFmode
operator|)
operator|&&
operator|(
name|outer_code
operator|==
name|PLUS
operator|||
name|outer_code
operator|==
name|MINUS
operator|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|dmul
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|muldi
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|mulsi
expr_stmt|;
return|return
name|false
return|;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
name|mode
operator|==
name|DFmode
condition|?
name|rs6000_cost
operator|->
name|ddiv
else|:
name|rs6000_cost
operator|->
name|sdiv
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|DIV
operator|||
name|code
operator|==
name|MOD
condition|)
comment|/* Shift, addze */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
comment|/* Shift */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|divdi
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|divsi
expr_stmt|;
block|}
comment|/* Add in shift and subtract for MOD. */
if|if
condition|(
name|code
operator|==
name|MOD
operator|||
name|code
operator|==
name|UMOD
condition|)
operator|*
name|total
operator|+=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|FFS
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|NOT
case|:
if|if
condition|(
name|outer_code
operator|==
name|AND
operator|||
name|outer_code
operator|==
name|IOR
operator|||
name|outer_code
operator|==
name|XOR
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ZERO_EXTRACT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
comment|/* Handle mul_highpart.  */
if|if
condition|(
name|outer_code
operator|==
name|TRUNCATE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|muldi
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|mulsi
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|outer_code
operator|==
name|AND
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|COMPARE
case|:
case|case
name|NEG
case|:
case|case
name|ABS
case|:
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|FLOAT
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|FLOAT_TRUNCATE
case|:
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
return|return
name|false
return|;
case|case
name|FLOAT_EXTEND
case|:
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
return|return
name|false
return|;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_FRSP
case|:
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
return|return
name|true
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|CALL
case|:
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|optimize_size
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|TARGET_PPC_GFXOPT
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
block|{
operator|*
name|total
operator|=
name|rs6000_cost
operator|->
name|fp
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
name|EQ
case|:
case|case
name|GTU
case|:
case|case
name|LTU
case|:
comment|/* Carry bit requires mode == Pmode. 	 NEG or PLUS already counted so only add one.  */
if|if
condition|(
name|mode
operator|==
name|Pmode
operator|&&
operator|(
name|outer_code
operator|==
name|NEG
operator|||
name|outer_code
operator|==
name|PLUS
operator|)
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|outer_code
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|Pmode
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|GT
case|:
case|case
name|LT
case|:
case|case
name|UNORDERED
case|:
if|if
condition|(
name|outer_code
operator|==
name|SET
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|)
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* CC COMPARE.  */
if|if
condition|(
name|outer_code
operator|==
name|COMPARE
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A C expression returning the cost of moving data from a register of class    CLASS1 to one of CLASS2.  */
end_comment

begin_function
name|int
name|rs6000_register_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|from
parameter_list|,
name|enum
name|reg_class
name|to
parameter_list|)
block|{
comment|/*  Moves from/to GENERAL_REGS.  */
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|to
argument_list|,
name|GENERAL_REGS
argument_list|)
operator|||
name|reg_classes_intersect_p
argument_list|(
name|from
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|reg_classes_intersect_p
argument_list|(
name|to
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
name|from
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|FLOAT_REGS
operator|||
name|from
operator|==
name|ALTIVEC_REGS
condition|)
return|return
operator|(
name|rs6000_memory_move_cost
argument_list|(
name|mode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
operator|+
name|rs6000_memory_move_cost
argument_list|(
name|mode
argument_list|,
name|GENERAL_REGS
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* It's more expensive to move CR_REGS than CR0_REGS because of the 	 shift.  */
elseif|else
if|if
condition|(
name|from
operator|==
name|CR_REGS
condition|)
return|return
literal|4
return|;
else|else
comment|/* A move will cost one instruction per GPR moved.  */
return|return
literal|2
operator|*
name|hard_regno_nregs
index|[
literal|0
index|]
index|[
name|mode
index|]
return|;
block|}
comment|/* Moving between two similar registers is just one instruction.  */
elseif|else
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|mode
operator|==
name|TFmode
condition|?
literal|4
else|:
literal|2
return|;
comment|/* Everything else has to go through GENERAL_REGS.  */
else|else
return|return
operator|(
name|rs6000_register_move_cost
argument_list|(
name|mode
argument_list|,
name|GENERAL_REGS
argument_list|,
name|to
argument_list|)
operator|+
name|rs6000_register_move_cost
argument_list|(
name|mode
argument_list|,
name|from
argument_list|,
name|GENERAL_REGS
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A C expressions returning the cost of moving data of MODE from a register to    or from memory.  */
end_comment

begin_function
name|int
name|rs6000_memory_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|,
name|int
name|in
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
return|return
literal|4
operator|*
name|hard_regno_nregs
index|[
literal|0
index|]
index|[
name|mode
index|]
return|;
elseif|else
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|class
argument_list|,
name|FLOAT_REGS
argument_list|)
condition|)
return|return
literal|4
operator|*
name|hard_regno_nregs
index|[
literal|32
index|]
index|[
name|mode
index|]
return|;
elseif|else
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|class
argument_list|,
name|ALTIVEC_REGS
argument_list|)
condition|)
return|return
literal|4
operator|*
name|hard_regno_nregs
index|[
name|FIRST_ALTIVEC_REGNO
index|]
index|[
name|mode
index|]
return|;
else|else
return|return
literal|4
operator|+
name|rs6000_register_move_cost
argument_list|(
name|mode
argument_list|,
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Newton-Raphson approximation of single-precision floating point divide n/d.    Assumes no trapping math and finite arguments.  */
end_comment

begin_function
name|void
name|rs6000_emit_swdivsf
parameter_list|(
name|rtx
name|res
parameter_list|,
name|rtx
name|n
parameter_list|,
name|rtx
name|d
parameter_list|)
block|{
name|rtx
name|x0
decl_stmt|,
name|e0
decl_stmt|,
name|e1
decl_stmt|,
name|y1
decl_stmt|,
name|u0
decl_stmt|,
name|v0
decl_stmt|,
name|one
decl_stmt|;
name|x0
operator|=
name|gen_reg_rtx
argument_list|(
name|SFmode
argument_list|)
expr_stmt|;
name|e0
operator|=
name|gen_reg_rtx
argument_list|(
name|SFmode
argument_list|)
expr_stmt|;
name|e1
operator|=
name|gen_reg_rtx
argument_list|(
name|SFmode
argument_list|)
expr_stmt|;
name|y1
operator|=
name|gen_reg_rtx
argument_list|(
name|SFmode
argument_list|)
expr_stmt|;
name|u0
operator|=
name|gen_reg_rtx
argument_list|(
name|SFmode
argument_list|)
expr_stmt|;
name|v0
operator|=
name|gen_reg_rtx
argument_list|(
name|SFmode
argument_list|)
expr_stmt|;
name|one
operator|=
name|force_reg
argument_list|(
name|SFmode
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|dconst1
argument_list|,
name|SFmode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* x0 = 1./d estimate */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x0
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|SFmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|d
argument_list|)
argument_list|,
name|UNSPEC_FRES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* e0 = 1. - d * x0 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|e0
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|SFmode
argument_list|,
name|one
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|SFmode
argument_list|,
name|d
argument_list|,
name|x0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* e1 = e0 + e0 * e0 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|e1
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|SFmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|SFmode
argument_list|,
name|e0
argument_list|,
name|e0
argument_list|)
argument_list|,
name|e0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* y1 = x0 + e1 * x0 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|y1
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|SFmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|SFmode
argument_list|,
name|e1
argument_list|,
name|x0
argument_list|)
argument_list|,
name|x0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* u0 = n * y1 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|u0
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|SFmode
argument_list|,
name|n
argument_list|,
name|y1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* v0 = n - d * u0 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|v0
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|SFmode
argument_list|,
name|n
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|SFmode
argument_list|,
name|d
argument_list|,
name|u0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* res = u0 + v0 * y1 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|res
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|SFmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|SFmode
argument_list|,
name|v0
argument_list|,
name|y1
argument_list|)
argument_list|,
name|u0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Newton-Raphson approximation of double-precision floating point divide n/d.    Assumes no trapping math and finite arguments.  */
end_comment

begin_function
name|void
name|rs6000_emit_swdivdf
parameter_list|(
name|rtx
name|res
parameter_list|,
name|rtx
name|n
parameter_list|,
name|rtx
name|d
parameter_list|)
block|{
name|rtx
name|x0
decl_stmt|,
name|e0
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|y3
decl_stmt|,
name|u0
decl_stmt|,
name|v0
decl_stmt|,
name|one
decl_stmt|;
name|x0
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|e0
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|e1
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|e2
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|y1
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|y2
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|y3
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|u0
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|v0
operator|=
name|gen_reg_rtx
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
name|one
operator|=
name|force_reg
argument_list|(
name|DFmode
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|dconst1
argument_list|,
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* x0 = 1./d estimate */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x0
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|DFmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|d
argument_list|)
argument_list|,
name|UNSPEC_FRES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* e0 = 1. - d * x0 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|e0
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|DFmode
argument_list|,
name|one
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|SFmode
argument_list|,
name|d
argument_list|,
name|x0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* y1 = x0 + e0 * x0 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|y1
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DFmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DFmode
argument_list|,
name|e0
argument_list|,
name|x0
argument_list|)
argument_list|,
name|x0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* e1 = e0 * e0 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|e1
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DFmode
argument_list|,
name|e0
argument_list|,
name|e0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* y2 = y1 + e1 * y1 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|y2
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DFmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DFmode
argument_list|,
name|e1
argument_list|,
name|y1
argument_list|)
argument_list|,
name|y1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* e2 = e1 * e1 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|e2
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DFmode
argument_list|,
name|e1
argument_list|,
name|e1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* y3 = y2 + e2 * y2 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|y3
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DFmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DFmode
argument_list|,
name|e2
argument_list|,
name|y2
argument_list|)
argument_list|,
name|y2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* u0 = n * y3 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|u0
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DFmode
argument_list|,
name|n
argument_list|,
name|y3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* v0 = n - d * u0 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|v0
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|DFmode
argument_list|,
name|n
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DFmode
argument_list|,
name|d
argument_list|,
name|u0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* res = u0 + v0 * y3 */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|res
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DFmode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|DFmode
argument_list|,
name|v0
argument_list|,
name|y3
argument_list|)
argument_list|,
name|u0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an RTX representing where to find the function value of a    function returning MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|rs6000_complex_function_value
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|enum
name|machine_mode
name|inner
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inner_bytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
name|regno
operator|=
name|FP_ARG_RETURN
expr_stmt|;
else|else
block|{
name|regno
operator|=
name|GP_ARG_RETURN
expr_stmt|;
comment|/* 32-bit is OK since it'll go in r3/r4.  */
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|inner_bytes
operator|>=
literal|4
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
if|if
condition|(
name|inner_bytes
operator|>=
literal|8
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
name|r1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|inner
argument_list|,
name|gen_rtx_REG
argument_list|(
name|inner
argument_list|,
name|regno
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|r2
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|inner
argument_list|,
name|gen_rtx_REG
argument_list|(
name|inner
argument_list|,
name|regno
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|inner_bytes
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a function.    VALTYPE is the data type of the value (as a tree).    If the precise function being called is known, FUNC is its FUNCTION_DECL;    otherwise, FUNC is 0.     On the SPE, both FPs and vectors are returned in r3.     On RS/6000 an integer value is in r3 and a floating-point value is in    fp1, unless -msoft-float.  */
end_comment

begin_function
name|rtx
name|rs6000_function_value
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
name|func
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* Special handling for structs in darwin64.  */
if|if
condition|(
name|rs6000_darwin64_abi
operator|&&
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|BLKmode
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
operator|>
literal|0
condition|)
block|{
name|CUMULATIVE_ARGS
name|valcum
decl_stmt|;
name|rtx
name|valret
decl_stmt|;
name|valcum
operator|.
name|words
operator|=
literal|0
expr_stmt|;
name|valcum
operator|.
name|fregno
operator|=
name|FP_ARG_MIN_REG
expr_stmt|;
name|valcum
operator|.
name|vregno
operator|=
name|ALTIVEC_ARG_MIN_REG
expr_stmt|;
comment|/* Do a trial code generation as if this were going to be passed as 	 an argument; if any part goes in memory, we return NULL.  */
name|valret
operator|=
name|rs6000_darwin64_record_arg
argument_list|(
operator|&
name|valcum
argument_list|,
name|valtype
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|valret
condition|)
return|return
name|valret
return|;
comment|/* Otherwise fall through to standard ABI rules.  */
block|}
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
operator|&&
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|DImode
condition|)
block|{
comment|/* Long long return value need be split in -mpowerpc64, 32bit ABI.  */
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|DImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
operator|&&
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|DCmode
condition|)
block|{
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|DCmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
operator|+
literal|2
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
operator|+
literal|3
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|12
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|valtype
argument_list|)
condition|)
name|mode
operator|=
name|TARGET_32BIT
condition|?
name|SImode
else|:
name|DImode
expr_stmt|;
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|regno
operator|=
name|GP_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
name|regno
operator|=
name|FP_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
condition|)
return|return
name|rs6000_complex_function_value
argument_list|(
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_ABI
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|regno
operator|=
name|ALTIVEC_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_E500_DOUBLE
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DCmode
operator|)
condition|)
return|return
name|spe_build_register_parallel
argument_list|(
name|mode
argument_list|,
name|GP_ARG_RETURN
argument_list|)
return|;
else|else
name|regno
operator|=
name|GP_ARG_RETURN
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a library function    assuming the value has mode MODE.  */
end_comment

begin_function
name|rtx
name|rs6000_libcall_value
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|TARGET_32BIT
operator|&&
name|TARGET_POWERPC64
operator|&&
name|mode
operator|==
name|DImode
condition|)
block|{
comment|/* Long long return value need be split in -mpowerpc64, 32bit ABI.  */
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|DImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|GP_ARG_RETURN
operator|+
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|regno
operator|=
name|GP_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPRS
condition|)
name|regno
operator|=
name|FP_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|TARGET_ALTIVEC
operator|&&
name|TARGET_ALTIVEC_ABI
condition|)
name|regno
operator|=
name|ALTIVEC_ARG_RETURN
expr_stmt|;
elseif|else
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|split_complex_arg
condition|)
return|return
name|rs6000_complex_function_value
argument_list|(
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TARGET_E500_DOUBLE
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DCmode
operator|)
condition|)
return|return
name|spe_build_register_parallel
argument_list|(
name|mode
argument_list|,
name|GP_ARG_RETURN
argument_list|)
return|;
else|else
name|regno
operator|=
name|GP_ARG_RETURN
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define the offset between two registers, FROM to be eliminated and its    replacement TO, at the start of a routine.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|rs6000_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|rs6000_stack_t
modifier|*
name|info
init|=
name|rs6000_stack_info
argument_list|()
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|offset
operator|=
name|info
operator|->
name|push_p
condition|?
literal|0
else|:
operator|-
name|info
operator|->
name|total_size
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
name|offset
operator|=
name|info
operator|->
name|push_p
condition|?
literal|0
else|:
operator|-
name|info
operator|->
name|total_size
expr_stmt|;
if|if
condition|(
name|FRAME_GROWS_DOWNWARD
condition|)
name|offset
operator|+=
name|info
operator|->
name|fixed_size
operator|+
name|info
operator|->
name|vars_size
operator|+
name|info
operator|->
name|parm_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|offset
operator|=
name|FRAME_GROWS_DOWNWARD
condition|?
name|info
operator|->
name|fixed_size
operator|+
name|info
operator|->
name|vars_size
operator|+
name|info
operator|->
name|parm_size
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|offset
operator|=
name|info
operator|->
name|total_size
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|offset
operator|=
name|info
operator|->
name|push_p
condition|?
name|info
operator|->
name|total_size
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|RS6000_PIC_OFFSET_TABLE_REGNUM
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE is a SPE or AltiVec opaque type.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_is_opaque_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|==
name|opaque_V2SI_type_node
operator|||
name|type
operator|==
name|opaque_V2SF_type_node
operator|||
name|type
operator|==
name|opaque_p_V2SI_type_node
operator|||
name|type
operator|==
name|opaque_V4SI_type_node
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|rs6000_dwarf_register_span
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|unsigned
name|regno
decl_stmt|;
if|if
condition|(
name|TARGET_SPE
operator|&&
operator|(
name|SPE_VECTOR_MODE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|||
operator|(
name|TARGET_E500_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|DFmode
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
name|NULL_RTX
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* The duality of the SPE register size wreaks all kinds of havoc.      This is a way of distinguishing r0 in 32-bits from r0 in      64-bits.  */
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|BYTES_BIG_ENDIAN
condition|?
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
operator|+
literal|1200
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
argument_list|)
else|:
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
operator|+
literal|1200
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Map internal gcc register numbers to DWARF2 register numbers.  */
end_comment

begin_function
name|unsigned
name|int
name|rs6000_dbx_register_number
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<=
literal|63
operator|||
name|write_symbols
operator|!=
name|DWARF2_DEBUG
condition|)
return|return
name|regno
return|;
if|if
condition|(
name|regno
operator|==
name|MQ_REGNO
condition|)
return|return
literal|100
return|;
if|if
condition|(
name|regno
operator|==
name|LINK_REGISTER_REGNUM
condition|)
return|return
literal|108
return|;
if|if
condition|(
name|regno
operator|==
name|COUNT_REGISTER_REGNUM
condition|)
return|return
literal|109
return|;
if|if
condition|(
name|CR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|regno
operator|-
name|CR0_REGNO
operator|+
literal|86
return|;
if|if
condition|(
name|regno
operator|==
name|XER_REGNO
condition|)
return|return
literal|101
return|;
if|if
condition|(
name|ALTIVEC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|regno
operator|-
name|FIRST_ALTIVEC_REGNO
operator|+
literal|1124
return|;
if|if
condition|(
name|regno
operator|==
name|VRSAVE_REGNO
condition|)
return|return
literal|356
return|;
if|if
condition|(
name|regno
operator|==
name|VSCR_REGNO
condition|)
return|return
literal|67
return|;
if|if
condition|(
name|regno
operator|==
name|SPE_ACC_REGNO
condition|)
return|return
literal|99
return|;
if|if
condition|(
name|regno
operator|==
name|SPEFSCR_REGNO
condition|)
return|return
literal|612
return|;
comment|/* SPE high reg number.  We get these values of regno from      rs6000_dwarf_register_span.  */
name|gcc_assert
argument_list|(
name|regno
operator|>=
literal|1200
operator|&&
name|regno
operator|<
literal|1232
argument_list|)
expr_stmt|;
return|return
name|regno
return|;
block|}
end_function

begin_comment
comment|/* target hook eh_return_filter_mode */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|rs6000_eh_return_filter_mode
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_32BIT
condition|?
name|SImode
else|:
name|word_mode
return|;
block|}
end_function

begin_comment
comment|/* Target hook for scalar_mode_supported_p.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_scalar_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|default_scalar_mode_supported_p
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Target hook for vector_mode_supported_p.  */
end_comment

begin_function
specifier|static
name|bool
name|rs6000_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|TARGET_SPE
operator|&&
name|SPE_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|TARGET_ALTIVEC
operator|&&
name|ALTIVEC_VECTOR_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Target hook for invalid_arg_for_unprototyped_fn. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|invalid_arg_for_unprototyped_fn
parameter_list|(
name|tree
name|typelist
parameter_list|,
name|tree
name|funcdecl
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
return|return
operator|(
operator|!
name|rs6000_darwin64_abi
operator|&&
name|typelist
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
operator|(
name|funcdecl
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|funcdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|funcdecl
argument_list|)
operator|!=
name|BUILT_IN_MD
operator|)
operator|)
operator|)
condition|?
name|N_
argument_list|(
literal|"AltiVec argument passed to unprototyped function"
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* For TARGET_SECURE_PLT 32-bit PIC code we can save PIC register    setup by using __stack_chk_fail_local hidden function instead of    calling __stack_chk_fail directly.  Otherwise it is better to call    __stack_chk_fail directly.  */
end_comment

begin_function
specifier|static
name|tree
name|rs6000_stack_protect_fail
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|DEFAULT_ABI
operator|==
name|ABI_V4
operator|&&
name|TARGET_SECURE_PLT
operator|&&
name|flag_pic
operator|)
condition|?
name|default_hidden_stack_protect_fail
argument_list|()
else|:
name|default_external_stack_protect_fail
argument_list|()
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-rs6000.h"
end_include

end_unit

