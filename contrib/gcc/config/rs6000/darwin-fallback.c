begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fallback frame-state unwinder for Darwin.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     In addition to the permissions in the GNU General Public License, the    Free Software Foundation gives you unlimited permission to link the    compiled version of this file into combinations with other programs,    and to distribute those combinations without any restriction coming    from the use of this file.  (The General Public License restrictions    do apply in other respects; for example, they cover modification of    the file, and distribution when not linked into a combined    executable.)     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_include
include|#
directive|include
file|"unwind-dw2.h"
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_typedef
typedef|typedef
name|unsigned
name|long
name|reg_unit
typedef|;
end_typedef

begin_comment
comment|/* Place in GPRS the parameters to the first 'sc' instruction that would    have been executed if we were returning from this CONTEXT, or    return false if an unexpected instruction is encountered.  */
end_comment

begin_function
specifier|static
name|bool
name|interpret_libc
parameter_list|(
name|reg_unit
name|gprs
index|[
literal|32
index|]
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|uint32_t
modifier|*
name|pc
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|uint32_t
name|cr
decl_stmt|;
name|reg_unit
name|lr
init|=
operator|(
name|reg_unit
operator|)
name|pc
decl_stmt|;
name|reg_unit
name|ctr
init|=
literal|0
decl_stmt|;
name|uint32_t
modifier|*
name|invalid_address
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
name|gprs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|gprs
index|[
literal|1
index|]
operator|=
name|_Unwind_GetCFA
argument_list|(
name|context
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|gprs
index|[
name|i
index|]
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cr
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|CR2_REGNO
argument_list|)
expr_stmt|;
comment|/* For each supported Libc, we have to track the code flow      all the way back into the kernel.         This code is believed to support all released Libc/Libsystem builds since      Jaguar 6C115, including all the security updates.  To be precise,       Libc	Libsystem	Build(s)      262~1	60~37		6C115      262~1	60.2~4		6D52      262~1	61~3		6F21-6F22      262~1	63~24		6G30-6G37      262~1	63~32		6I34-6I35      262~1	63~64		6L29-6L60      262.4.1~1	63~84		6L123-6R172            320~1	71~101		7B85-7D28      320~1	71~266		7F54-7F56      320~1	71~288		7F112      320~1	71~289		7F113      320.1.3~1	71.1.1~29	7H60-7H105      320.1.3~1	71.1.1~30	7H110-7H113      320.1.3~1	71.1.1~31	7H114            That's a big table!  It would be insane to try to keep track of      every little detail, so we just read the code itself and do what      it would do.   */
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint32_t
name|ins
init|=
operator|*
name|pc
operator|++
decl_stmt|;
if|if
condition|(
operator|(
name|ins
operator|&
literal|0xFC000003
operator|)
operator|==
literal|0x48000000
condition|)
comment|/* b instruction */
block|{
name|pc
operator|+=
operator|(
operator|(
operator|(
operator|(
name|int32_t
operator|)
name|ins
operator|&
literal|0x3FFFFFC
operator|)
operator|^
literal|0x2000000
operator|)
operator|-
literal|0x2000004
operator|)
operator|/
literal|4
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ins
operator|&
literal|0xFC600000
operator|)
operator|==
literal|0x2C000000
condition|)
comment|/* cmpwi */
block|{
name|int32_t
name|val1
init|=
operator|(
name|int16_t
operator|)
name|ins
decl_stmt|;
name|int32_t
name|val2
init|=
name|gprs
index|[
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
index|]
decl_stmt|;
comment|/* Only beq and bne instructions are supported, so we only 	     need to set the EQ bit.  */
name|uint32_t
name|mask
init|=
literal|0xF
operator|<<
operator|(
operator|(
name|ins
operator|>>
literal|21
operator|&
literal|0x1C
operator|)
operator|^
literal|0x1C
operator|)
decl_stmt|;
if|if
condition|(
name|val1
operator|==
name|val2
condition|)
name|cr
operator||=
name|mask
expr_stmt|;
else|else
name|cr
operator|&=
operator|~
name|mask
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ins
operator|&
literal|0xFEC38003
operator|)
operator|==
literal|0x40820000
condition|)
comment|/* forwards beq/bne */
block|{
if|if
condition|(
operator|(
name|cr
operator|>>
operator|(
operator|(
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
operator|)
operator|^
literal|0x1F
operator|)
operator|&
literal|1
operator|)
operator|==
operator|(
name|ins
operator|>>
literal|24
operator|&
literal|1
operator|)
condition|)
name|pc
operator|+=
operator|(
name|ins
operator|&
literal|0x7FFC
operator|)
operator|/
literal|4
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ins
operator|&
literal|0xFC0007FF
operator|)
operator|==
literal|0x7C000378
condition|)
comment|/* or, including mr */
block|{
name|gprs
index|[
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
index|]
operator|=
operator|(
name|gprs
index|[
name|ins
operator|>>
literal|11
operator|&
literal|0x1F
index|]
operator||
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|>>
literal|26
operator|==
literal|0x0E
condition|)
comment|/* addi, including li */
block|{
name|reg_unit
name|src
init|=
operator|(
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|gprs
index|[
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
index|]
decl_stmt|;
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
operator|=
name|src
operator|+
operator|(
name|int16_t
operator|)
name|ins
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|>>
literal|26
operator|==
literal|0x0F
condition|)
comment|/* addis, including lis */
block|{
name|reg_unit
name|src
init|=
operator|(
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|gprs
index|[
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
index|]
decl_stmt|;
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
operator|=
name|src
operator|+
operator|(
operator|(
name|int16_t
operator|)
name|ins
operator|<<
literal|16
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|>>
literal|26
operator|==
literal|0x20
condition|)
comment|/* lwz */
block|{
name|reg_unit
name|src
init|=
operator|(
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|gprs
index|[
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|src
operator|+
operator|(
name|int16_t
operator|)
name|ins
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|invalid_address
condition|)
return|return
name|false
return|;
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
operator|=
operator|*
name|p
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|>>
literal|26
operator|==
literal|0x21
condition|)
comment|/* lwzu */
block|{
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|gprs
index|[
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
index|]
operator|+=
operator|(
name|int16_t
operator|)
name|ins
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|invalid_address
condition|)
return|return
name|false
return|;
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
operator|=
operator|*
name|p
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|>>
literal|26
operator|==
literal|0x24
condition|)
comment|/* stw */
comment|/* What we hope this is doing is '--in_sigtramp'.  We don't want 	   to actually store to memory, so just make a note of the 	   address and refuse to load from it.  */
block|{
name|reg_unit
name|src
init|=
operator|(
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|gprs
index|[
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|src
operator|+
operator|(
name|int16_t
operator|)
name|ins
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|invalid_address
operator|!=
name|NULL
condition|)
return|return
name|false
return|;
name|invalid_address
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|>>
literal|26
operator|==
literal|0x2E
condition|)
comment|/* lmw */
block|{
name|reg_unit
name|src
init|=
operator|(
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|gprs
index|[
name|ins
operator|>>
literal|16
operator|&
literal|0x1F
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|src
operator|+
operator|(
name|int16_t
operator|)
name|ins
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
operator|)
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|==
name|invalid_address
condition|)
return|return
name|false
return|;
name|gprs
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|ins
operator|&
literal|0xFC1FFFFF
operator|)
operator|==
literal|0x7c0803a6
condition|)
comment|/* mtlr */
block|{
name|lr
operator|=
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ins
operator|&
literal|0xFC1FFFFF
operator|)
operator|==
literal|0x7c0802a6
condition|)
comment|/* mflr */
block|{
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
operator|=
name|lr
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ins
operator|&
literal|0xFC1FFFFF
operator|)
operator|==
literal|0x7c0903a6
condition|)
comment|/* mtctr */
block|{
name|ctr
operator|=
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* The PowerPC User's Manual says that bit 11 of the mtcrf 	 instruction is reserved and should be set to zero, but it 	 looks like the Darwin assembler doesn't do that... */
if|if
condition|(
operator|(
name|ins
operator|&
literal|0xFC000FFF
operator|)
operator|==
literal|0x7c000120
condition|)
comment|/* mtcrf */
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|mask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|mask
operator||=
operator|(
operator|(
operator|-
operator|(
name|ins
operator|>>
operator|(
literal|12
operator|+
name|i
operator|)
operator|&
literal|1
operator|)
operator|)
operator|&
literal|0xF
operator|)
operator|<<
literal|4
operator|*
name|i
expr_stmt|;
name|cr
operator|=
operator|(
name|cr
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|gprs
index|[
name|ins
operator|>>
literal|21
operator|&
literal|0x1F
index|]
operator|&
name|mask
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|==
literal|0x429f0005
condition|)
comment|/* bcl- 20,4*cr7+so,.+4, loads pc into LR */
block|{
name|lr
operator|=
operator|(
name|reg_unit
operator|)
name|pc
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|==
literal|0x4e800420
condition|)
comment|/* bctr */
block|{
name|pc
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|ctr
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ins
operator|==
literal|0x44000002
condition|)
comment|/* sc */
return|return
name|true
return|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* We used to include<ucontext.h> and<mach/thread_status.h>,    but they change so much between different Darwin system versions    that it's much easier to just write the structures involved here    directly.  */
end_comment

begin_comment
comment|/* These defines are from the kernel's bsd/dev/ppc/unix_signal.c.  */
end_comment

begin_define
define|#
directive|define
name|UC_TRAD
value|1
end_define

begin_define
define|#
directive|define
name|UC_TRAD_VEC
value|6
end_define

begin_define
define|#
directive|define
name|UC_TRAD64
value|20
end_define

begin_define
define|#
directive|define
name|UC_TRAD64_VEC
value|25
end_define

begin_define
define|#
directive|define
name|UC_FLAVOR
value|30
end_define

begin_define
define|#
directive|define
name|UC_FLAVOR_VEC
value|35
end_define

begin_define
define|#
directive|define
name|UC_FLAVOR64
value|40
end_define

begin_define
define|#
directive|define
name|UC_FLAVOR64_VEC
value|45
end_define

begin_define
define|#
directive|define
name|UC_DUAL
value|50
end_define

begin_define
define|#
directive|define
name|UC_DUAL_VEC
value|55
end_define

begin_struct
struct|struct
name|gcc_ucontext
block|{
name|int
name|onstack
decl_stmt|;
name|sigset_t
name|sigmask
decl_stmt|;
name|void
modifier|*
name|stack_sp
decl_stmt|;
name|size_t
name|stack_sz
decl_stmt|;
name|int
name|stack_flags
decl_stmt|;
name|struct
name|gcc_ucontext
modifier|*
name|link
decl_stmt|;
name|size_t
name|mcsize
decl_stmt|;
name|struct
name|gcc_mcontext32
modifier|*
name|mcontext
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gcc_float_vector_state
block|{
name|double
name|fpregs
index|[
literal|32
index|]
decl_stmt|;
name|uint32_t
name|fpscr_pad
decl_stmt|;
name|uint32_t
name|fpscr
decl_stmt|;
name|uint32_t
name|save_vr
index|[
literal|32
index|]
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|save_vscr
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gcc_mcontext32
block|{
name|uint32_t
name|dar
decl_stmt|;
name|uint32_t
name|dsisr
decl_stmt|;
name|uint32_t
name|exception
decl_stmt|;
name|uint32_t
name|padding1
index|[
literal|5
index|]
decl_stmt|;
name|uint32_t
name|srr0
decl_stmt|;
name|uint32_t
name|srr1
decl_stmt|;
name|uint32_t
name|gpr
index|[
literal|32
index|]
decl_stmt|;
name|uint32_t
name|cr
decl_stmt|;
name|uint32_t
name|xer
decl_stmt|;
name|uint32_t
name|lr
decl_stmt|;
name|uint32_t
name|ctr
decl_stmt|;
name|uint32_t
name|mq
decl_stmt|;
name|uint32_t
name|vrsave
decl_stmt|;
name|struct
name|gcc_float_vector_state
name|fvs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* These are based on /usr/include/ppc/ucontext.h and    /usr/include/mach/ppc/thread_status.h, but rewritten to be more    convenient, to compile on Jaguar, and to work around Radar 3712064    on Panther, which is that the 'es' field of 'struct mcontext64' has    the wrong type (doh!).  */
end_comment

begin_struct
struct|struct
name|gcc_mcontext64
block|{
name|uint64_t
name|dar
decl_stmt|;
name|uint32_t
name|dsisr
decl_stmt|;
name|uint32_t
name|exception
decl_stmt|;
name|uint32_t
name|padding1
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|srr0
decl_stmt|;
name|uint64_t
name|srr1
decl_stmt|;
name|uint32_t
name|gpr
index|[
literal|32
index|]
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|cr
decl_stmt|;
name|uint32_t
name|xer
index|[
literal|2
index|]
decl_stmt|;
comment|/* These are arrays because the original structure has them misaligned.  */
name|uint32_t
name|lr
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|ctr
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|vrsave
decl_stmt|;
name|struct
name|gcc_float_vector_state
name|fvs
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UC_FLAVOR_SIZE
define|\
value|(sizeof (struct gcc_mcontext32) - 33*16)
end_define

begin_define
define|#
directive|define
name|UC_FLAVOR_VEC_SIZE
value|(sizeof (struct gcc_mcontext32))
end_define

begin_define
define|#
directive|define
name|UC_FLAVOR64_SIZE
define|\
value|(sizeof (struct gcc_mcontext64) - 33*16)
end_define

begin_define
define|#
directive|define
name|UC_FLAVOR64_VEC_SIZE
value|(sizeof (struct gcc_mcontext64))
end_define

begin_comment
comment|/* Given GPRS as input to a 'sc' instruction, and OLD_CFA, update FS    to represent the execution of a signal return; or, if not a signal    return, return false.  */
end_comment

begin_function
specifier|static
name|bool
name|handle_syscall
parameter_list|(
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|,
specifier|const
name|reg_unit
name|gprs
index|[
literal|32
index|]
parameter_list|,
name|_Unwind_Ptr
name|old_cfa
parameter_list|)
block|{
name|struct
name|gcc_ucontext
modifier|*
name|uctx
decl_stmt|;
name|bool
name|is_64
decl_stmt|,
name|is_vector
decl_stmt|;
name|struct
name|gcc_float_vector_state
modifier|*
name|float_vector_state
decl_stmt|;
name|_Unwind_Ptr
name|new_cfa
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|_Unwind_Ptr
name|return_addr
decl_stmt|;
comment|/* Yay!  We're in a Libc that we understand, and it's made a      system call.  It'll be one of two kinds: either a Jaguar-style      SYS_sigreturn, or a Panther-style 'syscall' call with 184, which       is also SYS_sigreturn.  */
if|if
condition|(
name|gprs
index|[
literal|0
index|]
operator|==
literal|0x67
comment|/* SYS_SIGRETURN */
condition|)
block|{
name|uctx
operator|=
operator|(
expr|struct
name|gcc_ucontext
operator|*
operator|)
name|gprs
index|[
literal|3
index|]
expr_stmt|;
name|is_vector
operator|=
operator|(
name|uctx
operator|->
name|mcsize
operator|==
name|UC_FLAVOR64_VEC_SIZE
operator|||
name|uctx
operator|->
name|mcsize
operator|==
name|UC_FLAVOR_VEC_SIZE
operator|)
expr_stmt|;
name|is_64
operator|=
operator|(
name|uctx
operator|->
name|mcsize
operator|==
name|UC_FLAVOR64_VEC_SIZE
operator|||
name|uctx
operator|->
name|mcsize
operator|==
name|UC_FLAVOR64_SIZE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gprs
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|gprs
index|[
literal|3
index|]
operator|==
literal|184
condition|)
block|{
name|int
name|ctxstyle
init|=
name|gprs
index|[
literal|5
index|]
decl_stmt|;
name|uctx
operator|=
operator|(
expr|struct
name|gcc_ucontext
operator|*
operator|)
name|gprs
index|[
literal|4
index|]
expr_stmt|;
name|is_vector
operator|=
operator|(
name|ctxstyle
operator|==
name|UC_FLAVOR_VEC
operator|||
name|ctxstyle
operator|==
name|UC_FLAVOR64_VEC
operator|||
name|ctxstyle
operator|==
name|UC_TRAD_VEC
operator|||
name|ctxstyle
operator|==
name|UC_TRAD64_VEC
operator|)
expr_stmt|;
name|is_64
operator|=
operator|(
name|ctxstyle
operator|==
name|UC_FLAVOR64_VEC
operator|||
name|ctxstyle
operator|==
name|UC_TRAD64_VEC
operator|||
name|ctxstyle
operator|==
name|UC_FLAVOR64
operator|||
name|ctxstyle
operator|==
name|UC_TRAD64
operator|)
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
define|#
directive|define
name|set_offset
parameter_list|(
name|r
parameter_list|,
name|addr
parameter_list|)
define|\
value|(fs->regs.reg[r].how = REG_SAVED_OFFSET,			\    fs->regs.reg[r].loc.offset = (_Unwind_Ptr)(addr) - new_cfa)
comment|/* Restore even the registers that are not call-saved, since they      might be being used in the prologue to save other registers,      for instance GPR0 is sometimes used to save LR.  */
comment|/* Handle the GPRs, and produce the information needed to do the rest.  */
if|if
condition|(
name|is_64
condition|)
block|{
comment|/* The context is 64-bit, but it doesn't carry any extra information 	 for us because only the low 32 bits of the registers are 	 call-saved.  */
name|struct
name|gcc_mcontext64
modifier|*
name|m64
init|=
operator|(
expr|struct
name|gcc_mcontext64
operator|*
operator|)
name|uctx
operator|->
name|mcontext
decl_stmt|;
name|int
name|i
decl_stmt|;
name|float_vector_state
operator|=
operator|&
name|m64
operator|->
name|fvs
expr_stmt|;
name|new_cfa
operator|=
name|m64
operator|->
name|gpr
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|set_offset
argument_list|(
name|CR2_REGNO
argument_list|,
operator|&
name|m64
operator|->
name|cr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|set_offset
argument_list|(
name|i
argument_list|,
name|m64
operator|->
name|gpr
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set_offset
argument_list|(
name|XER_REGNO
argument_list|,
name|m64
operator|->
name|xer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set_offset
argument_list|(
name|LINK_REGISTER_REGNUM
argument_list|,
name|m64
operator|->
name|lr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set_offset
argument_list|(
name|COUNT_REGISTER_REGNUM
argument_list|,
name|m64
operator|->
name|ctr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_vector
condition|)
name|set_offset
argument_list|(
name|VRSAVE_REGNO
argument_list|,
operator|&
name|m64
operator|->
name|vrsave
argument_list|)
expr_stmt|;
comment|/* Sometimes, srr0 points to the instruction that caused the exception, 	 and sometimes to the next instruction to be executed; we want 	 the latter.  */
if|if
condition|(
name|m64
operator|->
name|exception
operator|==
literal|3
operator|||
name|m64
operator|->
name|exception
operator|==
literal|4
operator|||
name|m64
operator|->
name|exception
operator|==
literal|6
operator|||
operator|(
name|m64
operator|->
name|exception
operator|==
literal|7
operator|&&
operator|!
operator|(
name|m64
operator|->
name|srr1
operator|&
literal|0x10000
operator|)
operator|)
condition|)
name|return_addr
operator|=
name|m64
operator|->
name|srr0
operator|+
literal|4
expr_stmt|;
else|else
name|return_addr
operator|=
name|m64
operator|->
name|srr0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|gcc_mcontext32
modifier|*
name|m
init|=
name|uctx
operator|->
name|mcontext
decl_stmt|;
name|int
name|i
decl_stmt|;
name|float_vector_state
operator|=
operator|&
name|m
operator|->
name|fvs
expr_stmt|;
name|new_cfa
operator|=
name|m
operator|->
name|gpr
index|[
literal|1
index|]
expr_stmt|;
name|set_offset
argument_list|(
name|CR2_REGNO
argument_list|,
operator|&
name|m
operator|->
name|cr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|set_offset
argument_list|(
name|i
argument_list|,
name|m
operator|->
name|gpr
operator|+
name|i
argument_list|)
expr_stmt|;
name|set_offset
argument_list|(
name|XER_REGNO
argument_list|,
operator|&
name|m
operator|->
name|xer
argument_list|)
expr_stmt|;
name|set_offset
argument_list|(
name|LINK_REGISTER_REGNUM
argument_list|,
operator|&
name|m
operator|->
name|lr
argument_list|)
expr_stmt|;
name|set_offset
argument_list|(
name|COUNT_REGISTER_REGNUM
argument_list|,
operator|&
name|m
operator|->
name|ctr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_vector
condition|)
name|set_offset
argument_list|(
name|VRSAVE_REGNO
argument_list|,
operator|&
name|m
operator|->
name|vrsave
argument_list|)
expr_stmt|;
comment|/* Sometimes, srr0 points to the instruction that caused the exception, 	 and sometimes to the next instruction to be executed; we want 	 the latter.  */
if|if
condition|(
name|m
operator|->
name|exception
operator|==
literal|3
operator|||
name|m
operator|->
name|exception
operator|==
literal|4
operator|||
name|m
operator|->
name|exception
operator|==
literal|6
operator|||
operator|(
name|m
operator|->
name|exception
operator|==
literal|7
operator|&&
operator|!
operator|(
name|m
operator|->
name|srr1
operator|&
literal|0x10000
operator|)
operator|)
condition|)
name|return_addr
operator|=
name|m
operator|->
name|srr0
operator|+
literal|4
expr_stmt|;
else|else
name|return_addr
operator|=
name|m
operator|->
name|srr0
expr_stmt|;
block|}
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|new_cfa
operator|-
name|old_cfa
expr_stmt|;
empty_stmt|;
comment|/* The choice of column for the return address is somewhat tricky.      Fortunately, the actual choice is private to this file, and      the space it's reserved from is the GCC register space, not the      DWARF2 numbering.  So any free element of the right size is an OK      choice.  Thus: */
name|fs
operator|->
name|retaddr_column
operator|=
name|ARG_POINTER_REGNUM
expr_stmt|;
comment|/* FIXME: this should really be done using a DWARF2 location expression,      not using a static variable.  In fact, this entire file should      be implemented in DWARF2 expressions.  */
name|set_offset
argument_list|(
name|ARG_POINTER_REGNUM
argument_list|,
operator|&
name|return_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|set_offset
argument_list|(
literal|32
operator|+
name|i
argument_list|,
name|float_vector_state
operator|->
name|fpregs
operator|+
name|i
argument_list|)
expr_stmt|;
name|set_offset
argument_list|(
name|SPEFSCR_REGNO
argument_list|,
operator|&
name|float_vector_state
operator|->
name|fpscr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_vector
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|set_offset
argument_list|(
name|FIRST_ALTIVEC_REGNO
operator|+
name|i
argument_list|,
name|float_vector_state
operator|->
name|save_vr
operator|+
name|i
argument_list|)
expr_stmt|;
name|set_offset
argument_list|(
name|VSCR_REGNO
argument_list|,
name|float_vector_state
operator|->
name|save_vscr
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is also prototyped in rs6000/darwin.h, inside the    MD_FALLBACK_FRAME_STATE_FOR macro.  */
end_comment

begin_function_decl
specifier|extern
name|bool
name|_Unwind_fallback_frame_state_for
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Implement the MD_FALLBACK_FRAME_STATE_FOR macro,    returning true iff the frame was a sigreturn() frame that we    can understand.  */
end_comment

begin_function
name|bool
name|_Unwind_fallback_frame_state_for
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|reg_unit
name|gprs
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|interpret_libc
argument_list|(
name|gprs
argument_list|,
name|context
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|handle_syscall
argument_list|(
name|fs
argument_list|,
name|gprs
argument_list|,
name|_Unwind_GetCFA
argument_list|(
name|context
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

