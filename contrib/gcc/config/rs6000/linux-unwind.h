begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 EH unwinding support for PowerPC and PowerPC64 Linux.    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     In addition to the permissions in the GNU General Public License,    the Free Software Foundation gives you unlimited permission to link    the compiled version of this file with other programs, and to    distribute those programs without any restriction coming from the    use of this file.  (The General Public License restrictions do    apply in other respects; for example, they cover modification of    the file, and distribution when not linked into another program.)     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file defines our own versions of various kernel and user    structs, so that system headers are not needed, which otherwise    can make bootstrapping a new toolchain difficult.  Do not use    these structs elsewhere;  Many fields are missing, particularly    from the end of the structures.  */
end_comment

begin_struct
struct|struct
name|gcc_vregs
block|{
name|__attribute__
argument_list|(
argument|(vector_size (
literal|16
argument|))
argument_list|)
name|int
name|vr
index|[
literal|32
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|unsigned
name|int
name|pad1
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|int
name|vscr
decl_stmt|;
name|unsigned
name|int
name|vsave
decl_stmt|;
name|unsigned
name|int
name|pad2
index|[
literal|3
index|]
decl_stmt|;
else|#
directive|else
name|unsigned
name|int
name|vsave
decl_stmt|;
name|unsigned
name|int
name|pad
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|vscr
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gcc_regs
block|{
name|unsigned
name|long
name|gpr
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|long
name|nip
decl_stmt|;
name|unsigned
name|long
name|msr
decl_stmt|;
name|unsigned
name|long
name|orig_gpr3
decl_stmt|;
name|unsigned
name|long
name|ctr
decl_stmt|;
name|unsigned
name|long
name|link
decl_stmt|;
name|unsigned
name|long
name|xer
decl_stmt|;
name|unsigned
name|long
name|ccr
decl_stmt|;
name|unsigned
name|long
name|softe
decl_stmt|;
name|unsigned
name|long
name|trap
decl_stmt|;
name|unsigned
name|long
name|dar
decl_stmt|;
name|unsigned
name|long
name|dsisr
decl_stmt|;
name|unsigned
name|long
name|result
decl_stmt|;
name|unsigned
name|long
name|pad1
index|[
literal|4
index|]
decl_stmt|;
name|double
name|fpr
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|int
name|pad2
decl_stmt|;
name|unsigned
name|int
name|fpscr
decl_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|struct
name|gcc_vregs
modifier|*
name|vp
decl_stmt|;
else|#
directive|else
name|unsigned
name|int
name|pad3
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|gcc_vregs
name|vregs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gcc_ucontext
block|{
ifdef|#
directive|ifdef
name|__powerpc64__
name|unsigned
name|long
name|pad
index|[
literal|28
index|]
decl_stmt|;
else|#
directive|else
name|unsigned
name|long
name|pad
index|[
literal|12
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|gcc_regs
modifier|*
name|regs
decl_stmt|;
name|struct
name|gcc_regs
name|rsave
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc64__
end_ifdef

begin_enum
enum|enum
block|{
name|SIGNAL_FRAMESIZE
init|=
literal|128
block|}
enum|;
end_enum

begin_comment
comment|/* If PC is at a sigreturn trampoline, return a pointer to the    regs.  Otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|gcc_regs
modifier|*
name|get_regs
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pc
init|=
name|context
operator|->
name|ra
decl_stmt|;
comment|/* addi r1, r1, 128; li r0, 0x0077; sc  (sigreturn) */
comment|/* addi r1, r1, 128; li r0, 0x00AC; sc  (rt_sigreturn) */
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|0
operator|)
operator|!=
literal|0x38210000
operator|+
name|SIGNAL_FRAMESIZE
operator|||
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|8
operator|)
operator|!=
literal|0x44000002
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|4
operator|)
operator|==
literal|0x38000077
condition|)
block|{
struct|struct
name|sigframe
block|{
name|char
name|gap
index|[
name|SIGNAL_FRAMESIZE
index|]
decl_stmt|;
name|unsigned
name|long
name|pad
index|[
literal|7
index|]
decl_stmt|;
name|struct
name|gcc_regs
modifier|*
name|regs
decl_stmt|;
block|}
modifier|*
name|frame
init|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
name|context
operator|->
name|cfa
struct|;
return|return
name|frame
operator|->
name|regs
return|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|4
operator|)
operator|==
literal|0x380000AC
condition|)
block|{
comment|/* This works for 2.4 kernels, but not for 2.6 kernels with vdso 	 because pc isn't pointing into the stack.  Can be removed when 	 no one is running 2.4.19 or 2.4.20, the first two ppc64 	 kernels released.  */
struct|struct
name|rt_sigframe_24
block|{
name|int
name|tramp
index|[
literal|6
index|]
decl_stmt|;
name|void
modifier|*
name|pinfo
decl_stmt|;
name|struct
name|gcc_ucontext
modifier|*
name|puc
decl_stmt|;
block|}
modifier|*
name|frame24
init|=
operator|(
expr|struct
name|rt_sigframe_24
operator|*
operator|)
name|pc
struct|;
comment|/* Test for magic value in *puc of vdso.  */
if|if
condition|(
operator|(
name|long
operator|)
name|frame24
operator|->
name|puc
operator|!=
operator|-
literal|21
operator|*
literal|8
condition|)
return|return
name|frame24
operator|->
name|puc
operator|->
name|regs
return|;
else|else
block|{
comment|/* This works for 2.4.21 and later kernels.  */
struct|struct
name|rt_sigframe
block|{
name|char
name|gap
index|[
name|SIGNAL_FRAMESIZE
index|]
decl_stmt|;
name|struct
name|gcc_ucontext
name|uc
decl_stmt|;
name|unsigned
name|long
name|pad
index|[
literal|2
index|]
decl_stmt|;
name|int
name|tramp
index|[
literal|6
index|]
decl_stmt|;
name|void
modifier|*
name|pinfo
decl_stmt|;
name|struct
name|gcc_ucontext
modifier|*
name|puc
decl_stmt|;
block|}
modifier|*
name|frame
init|=
operator|(
expr|struct
name|rt_sigframe
operator|*
operator|)
name|context
operator|->
name|cfa
struct|;
return|return
name|frame
operator|->
name|uc
operator|.
name|regs
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__powerpc64__ */
end_comment

begin_enum
enum|enum
block|{
name|SIGNAL_FRAMESIZE
init|=
literal|64
block|}
enum|;
end_enum

begin_function
specifier|static
name|struct
name|gcc_regs
modifier|*
name|get_regs
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pc
init|=
name|context
operator|->
name|ra
decl_stmt|;
comment|/* li r0, 0x7777; sc  (sigreturn old)  */
comment|/* li r0, 0x0077; sc  (sigreturn new)  */
comment|/* li r0, 0x6666; sc  (rt_sigreturn old)  */
comment|/* li r0, 0x00AC; sc  (rt_sigreturn new)  */
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|4
operator|)
operator|!=
literal|0x44000002
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|0
operator|)
operator|==
literal|0x38007777
operator|||
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|0
operator|)
operator|==
literal|0x38000077
condition|)
block|{
struct|struct
name|sigframe
block|{
name|char
name|gap
index|[
name|SIGNAL_FRAMESIZE
index|]
decl_stmt|;
name|unsigned
name|long
name|pad
index|[
literal|7
index|]
decl_stmt|;
name|struct
name|gcc_regs
modifier|*
name|regs
decl_stmt|;
block|}
modifier|*
name|frame
init|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
name|context
operator|->
name|cfa
struct|;
return|return
name|frame
operator|->
name|regs
return|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|0
operator|)
operator|==
literal|0x38006666
operator|||
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|pc
operator|+
literal|0
operator|)
operator|==
literal|0x380000AC
condition|)
block|{
struct|struct
name|rt_sigframe
block|{
name|char
name|gap
index|[
name|SIGNAL_FRAMESIZE
operator|+
literal|16
index|]
decl_stmt|;
name|char
name|siginfo
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|gcc_ucontext
name|uc
decl_stmt|;
block|}
modifier|*
name|frame
init|=
operator|(
expr|struct
name|rt_sigframe
operator|*
operator|)
name|context
operator|->
name|cfa
struct|;
return|return
name|frame
operator|->
name|uc
operator|.
name|regs
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Find an entry in the process auxiliary vector.  The canonical way to    test for VMX is to look at AT_HWCAP.  */
end_comment

begin_function
specifier|static
name|long
name|ppc_linux_aux_vector
parameter_list|(
name|long
name|which
parameter_list|)
block|{
comment|/* __libc_stack_end holds the original stack passed to a process.  */
specifier|extern
name|long
modifier|*
name|__libc_stack_end
decl_stmt|;
name|long
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
struct|struct
name|auxv
block|{
name|long
name|a_type
decl_stmt|;
name|long
name|a_val
decl_stmt|;
block|}
modifier|*
name|auxp
struct|;
comment|/* The Linux kernel puts argc first on the stack.  */
name|argc
operator|=
name|__libc_stack_end
index|[
literal|0
index|]
expr_stmt|;
comment|/* Followed by argv, NULL terminated.  */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|__libc_stack_end
operator|+
literal|1
expr_stmt|;
comment|/* Followed by environment string pointers, NULL terminated. */
name|envp
operator|=
name|argv
operator|+
name|argc
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|envp
operator|++
condition|)
continue|continue;
comment|/* Followed by the aux vector, zero terminated.  */
for|for
control|(
name|auxp
operator|=
operator|(
expr|struct
name|auxv
operator|*
operator|)
name|envp
init|;
name|auxp
operator|->
name|a_type
operator|!=
literal|0
condition|;
operator|++
name|auxp
control|)
if|if
condition|(
name|auxp
operator|->
name|a_type
operator|==
name|which
condition|)
return|return
name|auxp
operator|->
name|a_val
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Do code reading to identify a signal frame, and set the frame    state data appropriately.  See unwind-dw2.c for the structs.  */
end_comment

begin_define
define|#
directive|define
name|MD_FALLBACK_FRAME_STATE_FOR
value|ppc_fallback_frame_state
end_define

begin_function
specifier|static
name|_Unwind_Reason_Code
name|ppc_fallback_frame_state
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
specifier|static
name|long
name|hwcap
init|=
literal|0
decl_stmt|;
name|struct
name|gcc_regs
modifier|*
name|regs
init|=
name|get_regs
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|long
name|new_cfa
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regs
operator|==
name|NULL
condition|)
return|return
name|_URC_END_OF_STACK
return|;
name|new_cfa
operator|=
name|regs
operator|->
name|gpr
index|[
name|STACK_POINTER_REGNUM
index|]
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|new_cfa
operator|-
operator|(
name|long
operator|)
name|context
operator|->
name|cfa
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|regs
operator|->
name|gpr
index|[
name|i
index|]
operator|-
name|new_cfa
expr_stmt|;
block|}
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|CR2_REGNO
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|CR2_REGNO
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|regs
operator|->
name|ccr
operator|-
name|new_cfa
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|LINK_REGISTER_REGNUM
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|LINK_REGISTER_REGNUM
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|regs
operator|->
name|link
operator|-
name|new_cfa
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|ARG_POINTER_REGNUM
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|ARG_POINTER_REGNUM
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|regs
operator|->
name|nip
operator|-
name|new_cfa
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
name|ARG_POINTER_REGNUM
expr_stmt|;
name|fs
operator|->
name|signal_frame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hwcap
operator|==
literal|0
condition|)
block|{
name|hwcap
operator|=
name|ppc_linux_aux_vector
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|/* These will already be set if we found AT_HWCAP.  A nonzero 	 value stops us looking again if for some reason we couldn't 	 find AT_HWCAP.  */
ifdef|#
directive|ifdef
name|__powerpc64__
name|hwcap
operator||=
literal|0xc0000000
expr_stmt|;
else|#
directive|else
name|hwcap
operator||=
literal|0x80000000
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If we have a FPU...  */
if|if
condition|(
name|hwcap
operator|&
literal|0x08000000
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|32
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|32
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|regs
operator|->
name|fpr
index|[
name|i
index|]
operator|-
name|new_cfa
expr_stmt|;
block|}
comment|/* If we have a VMX unit...  */
if|if
condition|(
name|hwcap
operator|&
literal|0x10000000
condition|)
block|{
name|struct
name|gcc_vregs
modifier|*
name|vregs
decl_stmt|;
ifdef|#
directive|ifdef
name|__powerpc64__
name|vregs
operator|=
name|regs
operator|->
name|vp
expr_stmt|;
else|#
directive|else
name|vregs
operator|=
operator|&
name|regs
operator|->
name|vregs
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|regs
operator|->
name|msr
operator|&
operator|(
literal|1
operator|<<
literal|25
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
name|FIRST_ALTIVEC_REGNO
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
name|FIRST_ALTIVEC_REGNO
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|vregs
index|[
name|i
index|]
operator|-
name|new_cfa
expr_stmt|;
block|}
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|VSCR_REGNO
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|VSCR_REGNO
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|vregs
operator|->
name|vscr
operator|-
name|new_cfa
expr_stmt|;
block|}
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|VRSAVE_REGNO
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|VRSAVE_REGNO
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|vregs
operator|->
name|vsave
operator|-
name|new_cfa
expr_stmt|;
block|}
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MD_FROB_UPDATE_CONTEXT
value|frob_update_context
end_define

begin_function
specifier|static
name|void
name|frob_update_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
modifier|*
name|pc
init|=
operator|(
specifier|const
name|unsigned
name|int
operator|*
operator|)
name|context
operator|->
name|ra
decl_stmt|;
comment|/* Fix up for 2.6.12 - 2.6.16 Linux kernels that have vDSO, but don't      have S flag in it.  */
ifdef|#
directive|ifdef
name|__powerpc64__
comment|/* addi r1, r1, 128; li r0, 0x0077; sc  (sigreturn) */
comment|/* addi r1, r1, 128; li r0, 0x00AC; sc  (rt_sigreturn) */
if|if
condition|(
name|pc
index|[
literal|0
index|]
operator|==
literal|0x38210000
operator|+
name|SIGNAL_FRAMESIZE
operator|&&
operator|(
name|pc
index|[
literal|1
index|]
operator|==
literal|0x38000077
operator|||
name|pc
index|[
literal|1
index|]
operator|==
literal|0x380000AC
operator|)
operator|&&
name|pc
index|[
literal|2
index|]
operator|==
literal|0x44000002
condition|)
name|_Unwind_SetSignalFrame
argument_list|(
name|context
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* li r0, 0x7777; sc  (sigreturn old)  */
comment|/* li r0, 0x0077; sc  (sigreturn new)  */
comment|/* li r0, 0x6666; sc  (rt_sigreturn old)  */
comment|/* li r0, 0x00AC; sc  (rt_sigreturn new)  */
if|if
condition|(
operator|(
name|pc
index|[
literal|0
index|]
operator|==
literal|0x38007777
operator|||
name|pc
index|[
literal|0
index|]
operator|==
literal|0x38000077
operator|||
name|pc
index|[
literal|0
index|]
operator|==
literal|0x38006666
operator|||
name|pc
index|[
literal|0
index|]
operator|==
literal|0x380000AC
operator|)
operator|&&
name|pc
index|[
literal|1
index|]
operator|==
literal|0x44000002
condition|)
name|_Unwind_SetSignalFrame
argument_list|(
name|context
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__powerpc64__
if|if
condition|(
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|2
index|]
operator|.
name|how
operator|==
name|REG_UNSAVED
condition|)
block|{
comment|/* If the current unwind info (FS) does not contain explicit info 	 saving R2, then we have to do a minor amount of code reading to 	 figure out if it was saved.  The big problem here is that the 	 code that does the save/restore is generated by the linker, so 	 we have no good way to determine at compile time what to do.  */
name|unsigned
name|int
modifier|*
name|insn
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|LINK_REGISTER_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|insn
operator|==
literal|0xE8410028
condition|)
name|_Unwind_SetGRPtr
argument_list|(
name|context
argument_list|,
literal|2
argument_list|,
name|context
operator|->
name|cfa
operator|+
literal|40
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

