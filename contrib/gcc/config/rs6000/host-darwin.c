begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Darwin/powerpc host-specific hook definitions.    Copyright (C) 2003 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 59 Temple Place - Suite 330, Boston,    MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucontext.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks-def.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_function_decl
specifier|static
name|void
name|segv_crash_handler
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|segv_handler
parameter_list|(
name|int
parameter_list|,
name|siginfo_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|darwin_rs6000_extra_signals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This doesn't have a prototype in signal.h in 10.2.x and earlier,    fixed in later releases.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|sigaltstack
parameter_list|(
specifier|const
name|struct
name|sigaltstack
modifier|*
parameter_list|,
name|struct
name|sigaltstack
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_undef
undef|#
directive|undef
name|HOST_HOOKS_EXTRA_SIGNALS
end_undef

begin_define
define|#
directive|define
name|HOST_HOOKS_EXTRA_SIGNALS
value|darwin_rs6000_extra_signals
end_define

begin_comment
comment|/* On Darwin/powerpc, hitting the stack limit turns into a SIGSEGV.    This code detects the difference between hitting the stack limit and    a true wild pointer dereference by looking at the instruction that    faulted; only a few kinds of instruction are used to access below    the previous bottom of the stack.  */
end_comment

begin_function
specifier|static
name|void
name|segv_crash_handler
parameter_list|(
name|int
name|sig
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"Segmentation Fault (code)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|segv_handler
parameter_list|(
name|int
name|sig
name|ATTRIBUTE_UNUSED
parameter_list|,
name|siginfo_t
modifier|*
name|sip
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|scp
parameter_list|)
block|{
name|ucontext_t
modifier|*
name|uc
init|=
operator|(
name|ucontext_t
operator|*
operator|)
name|scp
decl_stmt|;
name|unsigned
name|faulting_insn
decl_stmt|;
comment|/* The fault might have happened when trying to run some instruction, in      which case the next line will segfault _again_.  Handle this case.  */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|segv_crash_handler
argument_list|)
expr_stmt|;
name|faulting_insn
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|uc
operator|->
name|uc_mcontext
operator|->
name|ss
operator|.
name|srr0
expr_stmt|;
comment|/* Note that this only has to work for GCC, so we don't have to deal      with all the possible cases (GCC has no AltiVec code, for      instance).  It's complicated because Darwin allows stores to      below the stack pointer, and the prologue code takes advantage of      this.  */
if|if
condition|(
operator|(
name|faulting_insn
operator|&
literal|0xFFFF8000
operator|)
operator|==
literal|0x94218000
comment|/* stwu %r1, -xxx(%r1) */
operator|||
operator|(
name|faulting_insn
operator|&
literal|0xFFFF03FF
operator|)
operator|==
literal|0x7C21016E
comment|/* stwux %r1, xxx, %r1 */
operator|||
operator|(
name|faulting_insn
operator|&
literal|0xFC1F8000
operator|)
operator|==
literal|0x90018000
comment|/* stw xxx, -yyy(%r1) */
operator|||
operator|(
name|faulting_insn
operator|&
literal|0xFC1F8000
operator|)
operator|==
literal|0xD8018000
comment|/* stfd xxx, -yyy(%r1) */
operator|||
operator|(
name|faulting_insn
operator|&
literal|0xFC1F8000
operator|)
operator|==
literal|0xBC018000
comment|/* stmw xxx, -yyy(%r1) */
condition|)
block|{
name|char
modifier|*
name|shell_name
decl_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Out of stack space.\n"
argument_list|)
expr_stmt|;
name|shell_name
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell_name
operator|!=
name|NULL
condition|)
name|shell_name
operator|=
name|strrchr
argument_list|(
name|shell_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell_name
operator|!=
name|NULL
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|shell_commands
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|"sh"
block|,
literal|"ulimit -S -s unlimited"
block|}
block|,
block|{
literal|"bash"
block|,
literal|"ulimit -S -s unlimited"
block|}
block|,
block|{
literal|"tcsh"
block|,
literal|"limit stacksize unlimited"
block|}
block|,
block|{
literal|"csh"
block|,
literal|"limit stacksize unlimited"
block|}
block|,
comment|/* zsh doesn't have "unlimited", this will work under the 	       default configuration.  */
block|{
literal|"zsh"
block|,
literal|"limit stacksize 32m"
block|}
block|}
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|shell_commands
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|shell_commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|shell_name
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Try running `%s' in the shell to raise its limit.\n"
argument_list|,
name|shell_commands
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|global_dc
operator|->
name|abort_on_error
condition|)
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[address=%08lx pc=%08x]\n"
argument_list|,
name|uc
operator|->
name|uc_mcontext
operator|->
name|es
operator|.
name|dar
argument_list|,
name|uc
operator|->
name|uc_mcontext
operator|->
name|ss
operator|.
name|srr0
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"Segmentation Fault"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|darwin_rs6000_extra_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|sact
decl_stmt|;
name|stack_t
name|sigstk
decl_stmt|;
name|sigstk
operator|.
name|ss_sp
operator|=
name|xmalloc
argument_list|(
name|SIGSTKSZ
argument_list|)
expr_stmt|;
name|sigstk
operator|.
name|ss_size
operator|=
name|SIGSTKSZ
expr_stmt|;
name|sigstk
operator|.
name|ss_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigaltstack
argument_list|(
operator|&
name|sigstk
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"While setting up signal stack: %m"
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sact
operator|.
name|sa_flags
operator|=
name|SA_ONSTACK
operator||
name|SA_SIGINFO
expr_stmt|;
name|sact
operator|.
name|sa_sigaction
operator|=
name|segv_handler
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGSEGV
argument_list|,
operator|&
name|sact
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"While setting up signal handler: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
modifier|*
name|darwin_rs6000_gt_pch_get_address
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|darwin_rs6000_gt_pch_use_address
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_undef
undef|#
directive|undef
name|HOST_HOOKS_GT_PCH_GET_ADDRESS
end_undef

begin_define
define|#
directive|define
name|HOST_HOOKS_GT_PCH_GET_ADDRESS
value|darwin_rs6000_gt_pch_get_address
end_define

begin_undef
undef|#
directive|undef
name|HOST_HOOKS_GT_PCH_USE_ADDRESS
end_undef

begin_define
define|#
directive|define
name|HOST_HOOKS_GT_PCH_USE_ADDRESS
value|darwin_rs6000_gt_pch_use_address
end_define

begin_comment
comment|/* Yes, this is really supposed to work.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pch_address_space
index|[
literal|1024
operator|*
literal|1024
operator|*
literal|1024
index|]
name|__attribute__
argument_list|(
operator|(
name|aligned
argument_list|(
literal|4096
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the address of the PCH address space, if the PCH will fit in it.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|darwin_rs6000_gt_pch_get_address
parameter_list|(
name|size_t
name|sz
parameter_list|)
block|{
if|if
condition|(
name|sz
operator|<=
sizeof|sizeof
argument_list|(
name|pch_address_space
argument_list|)
condition|)
return|return
name|pch_address_space
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check ADDR and SZ for validity, and deallocate (using munmap) that part of    pch_address_space beyond SZ.  */
end_comment

begin_function
specifier|static
name|bool
name|darwin_rs6000_gt_pch_use_address
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
specifier|const
name|size_t
name|pagesize
init|=
name|getpagesize
argument_list|()
decl_stmt|;
name|bool
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|pch_address_space
operator|%
name|pagesize
operator|!=
literal|0
operator|||
sizeof|sizeof
argument_list|(
name|pch_address_space
argument_list|)
operator|%
name|pagesize
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
operator|(
name|addr
operator|==
name|pch_address_space
operator|&&
name|sz
operator|<=
sizeof|sizeof
argument_list|(
name|pch_address_space
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|sz
operator|=
literal|0
expr_stmt|;
comment|/* Round the size to a whole page size.  Normally this is a no-op.  */
name|sz
operator|=
operator|(
name|sz
operator|+
name|pagesize
operator|-
literal|1
operator|)
operator|/
name|pagesize
operator|*
name|pagesize
expr_stmt|;
if|if
condition|(
name|munmap
argument_list|(
name|pch_address_space
operator|+
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
name|pch_address_space
argument_list|)
operator|-
name|sz
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"couldn't unmap pch_address_space: %m\n"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|host_hooks
name|host_hooks
init|=
name|HOST_HOOKS_INITIALIZER
decl_stmt|;
end_decl_stmt

end_unit

