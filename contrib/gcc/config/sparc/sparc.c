begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Sun SPARC.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)    64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,    at Cygnus Support.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_comment
comment|/* 1 if the caller has placed an "unimp" insn immediately after the call.    This is used in v8 code when calling a function that returns a structure.    v9 doesn't have this.  Be careful to have this test be the same as that    used on the call.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_CALLERS_UNIMP_P
define|\
value|(!TARGET_ARCH64&& current_function_returns_struct			\&& ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl)))	\&& (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))	\      == INTEGER_CST))
end_define

begin_comment
comment|/* Global variables for machine-dependent things.  */
end_comment

begin_comment
comment|/* Size of frame.  Need to know this to emit return insns from leaf procedures.    ACTUAL_FSIZE is set by compute_frame_size() which is called during the    reload pass.  This is important as the value is later used in insn    scheduling (to see what can go in a delay slot).    APPARENT_FSIZE is the size of the stack less the register save area and less    the outgoing argument area.  It is used when saving call preserved regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apparent_fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|actual_fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of live general or floating point registers needed to be saved    (as 4-byte quantities).  This is only done if TARGET_EPILOGUE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_gfregs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save the operands last given to a compare for use when we    generate a scc or bcc insn.  */
end_comment

begin_decl_stmt
name|rtx
name|sparc_compare_op0
decl_stmt|,
name|sparc_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We may need an epilogue if we spill too many registers.    If this is non-zero, then we branch here for the epilogue.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|leaf_label
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
end_ifdef

begin_comment
comment|/* Vector to say how input registers are mapped to output    registers.  FRAME_POINTER_REGNUM cannot be remapped by    this function to eliminate it.  You must use -fomit-frame-pointer    to get that.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|leaf_reg_remap
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|14
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|15
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector, indexed by hard register number, which contains 1    for a register that is allowable in a candidate for leaf    function treatment.  */
end_comment

begin_decl_stmt
name|char
name|sparc_leaf_regs
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Name of where we pretend to think the frame pointer points.    Normally, this is "%fp", but if we are in a leaf procedure,    this is "%sp+something".  We record "something" separately as it may be    too big for reg+constant addressing.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|frame_base_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frame_base_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_init_modes
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|save_regs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|restore_regs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_big_number
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_arg_slotno
name|PARAMS
argument_list|(
operator|(
specifier|const
name|CUMULATIVE_ARGS
operator|*
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|supersparc_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hypersparc_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ultrasparc_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_output_addr_vec
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_output_addr_diff_vec
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_output_deferred_case_vectors
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_add_gc_roots
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_ultrasparc_pipeline_state
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_return_regs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epilogue_renumber
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|sparc_assemble_integer
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ultra_cmove_results_ready_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ultra_fpmode_conflict_exists
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|ultra_find_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ultra_build_types_avail
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ultra_flush_pipeline
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ultra_rescan_pipeline_state
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_extends
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_restore_regs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_output_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_output_function_epilogue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_flat_function_epilogue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_flat_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_nonflat_function_epilogue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_nonflat_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|sparc_elf_asm_named_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|ultrasparc_sched_reorder
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ultrasparc_variable_issue
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ultrasparc_sched_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sparc_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sparc_issue_rate
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sparc_variable_issue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_sched_init
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sparc_sched_reorder
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Option handling.  */
end_comment

begin_comment
comment|/* Code model option as passed by user.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|sparc_cmodel_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsed value.  */
end_comment

begin_decl_stmt
name|enum
name|cmodel
name|sparc_cmodel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|sparc_hard_reg_printed
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sparc_cpu_select
name|sparc_select
index|[]
init|=
block|{
comment|/* switch	name,		tune	arch */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"default"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mcpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mtune="
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU type.  This is set from TARGET_CPU_DEFAULT and -m{cpu,tune}=xxx.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|sparc_cpu
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_comment
comment|/* The sparc default is to use .half rather than .short for aligned    HI objects.  Use .word instead of .long on non-ELF systems.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.half\t"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
end_ifndef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\t.word\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.uahalf\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.uaword\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\t.uaxword\t"
end_define

begin_comment
comment|/* The target hook has to handle DI-mode values.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|sparc_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|sparc_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|sparc_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|sparc_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|sparc_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|sparc_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT
value|sparc_sched_init
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER
value|sparc_sched_reorder
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Validate and override various options, and do some machine dependent    initialization.  */
end_comment

begin_function
name|void
name|sparc_override_options
parameter_list|()
block|{
specifier|static
struct|struct
name|code_model
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|value
decl_stmt|;
block|}
decl|const
name|cmodels
index|[]
init|=
block|{
block|{
literal|"32"
block|,
name|CM_32
block|}
block|,
block|{
literal|"medlow"
block|,
name|CM_MEDLOW
block|}
block|,
block|{
literal|"medmid"
block|,
name|CM_MEDMID
block|}
block|,
block|{
literal|"medany"
block|,
name|CM_MEDANY
block|}
block|,
block|{
literal|"embmedany"
block|,
name|CM_EMBMEDANY
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|code_model
modifier|*
name|cmodel
decl_stmt|;
comment|/* Map TARGET_CPU_DEFAULT to value for -m{arch,tune}=.  */
specifier|static
struct|struct
name|cpu_default
block|{
specifier|const
name|int
name|cpu
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|}
decl|const
name|cpu_default
index|[]
init|=
block|{
comment|/* There must be one entry here for each TARGET_CPU value.  */
block|{
name|TARGET_CPU_sparc
block|,
literal|"cypress"
block|}
block|,
block|{
name|TARGET_CPU_sparclet
block|,
literal|"tsc701"
block|}
block|,
block|{
name|TARGET_CPU_sparclite
block|,
literal|"f930"
block|}
block|,
block|{
name|TARGET_CPU_v8
block|,
literal|"v8"
block|}
block|,
block|{
name|TARGET_CPU_hypersparc
block|,
literal|"hypersparc"
block|}
block|,
block|{
name|TARGET_CPU_sparclite86x
block|,
literal|"sparclite86x"
block|}
block|,
block|{
name|TARGET_CPU_supersparc
block|,
literal|"supersparc"
block|}
block|,
block|{
name|TARGET_CPU_v9
block|,
literal|"v9"
block|}
block|,
block|{
name|TARGET_CPU_ultrasparc
block|,
literal|"ultrasparc"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|cpu_default
modifier|*
name|def
decl_stmt|;
comment|/* Table of values for -m{cpu,tune}=.  */
specifier|static
struct|struct
name|cpu_table
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
name|int
name|disable
decl_stmt|;
specifier|const
name|int
name|enable
decl_stmt|;
block|}
decl|const
name|cpu_table
index|[]
init|=
block|{
block|{
literal|"v7"
block|,
name|PROCESSOR_V7
block|,
name|MASK_ISA
block|,
literal|0
block|}
block|,
block|{
literal|"cypress"
block|,
name|PROCESSOR_CYPRESS
block|,
name|MASK_ISA
block|,
literal|0
block|}
block|,
block|{
literal|"v8"
block|,
name|PROCESSOR_V8
block|,
name|MASK_ISA
block|,
name|MASK_V8
block|}
block|,
comment|/* TI TMS390Z55 supersparc */
block|{
literal|"supersparc"
block|,
name|PROCESSOR_SUPERSPARC
block|,
name|MASK_ISA
block|,
name|MASK_V8
block|}
block|,
block|{
literal|"sparclite"
block|,
name|PROCESSOR_SPARCLITE
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLITE
block|}
block|,
comment|/* The Fujitsu MB86930 is the original sparclite chip, with no fpu.        The Fujitsu MB86934 is the recent sparclite chip, with an fpu.  */
block|{
literal|"f930"
block|,
name|PROCESSOR_F930
block|,
name|MASK_ISA
operator||
name|MASK_FPU
block|,
name|MASK_SPARCLITE
block|}
block|,
block|{
literal|"f934"
block|,
name|PROCESSOR_F934
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLITE
operator||
name|MASK_FPU
block|}
block|,
block|{
literal|"hypersparc"
block|,
name|PROCESSOR_HYPERSPARC
block|,
name|MASK_ISA
block|,
name|MASK_V8
operator||
name|MASK_FPU
block|}
block|,
block|{
literal|"sparclite86x"
block|,
name|PROCESSOR_SPARCLITE86X
block|,
name|MASK_ISA
operator||
name|MASK_FPU
block|,
name|MASK_SPARCLITE
block|}
block|,
block|{
literal|"sparclet"
block|,
name|PROCESSOR_SPARCLET
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLET
block|}
block|,
comment|/* TEMIC sparclet */
block|{
literal|"tsc701"
block|,
name|PROCESSOR_TSC701
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLET
block|}
block|,
block|{
literal|"v9"
block|,
name|PROCESSOR_V9
block|,
name|MASK_ISA
block|,
name|MASK_V9
block|}
block|,
comment|/* TI ultrasparc I, II, IIi */
block|{
literal|"ultrasparc"
block|,
name|PROCESSOR_ULTRASPARC
block|,
name|MASK_ISA
block|,
name|MASK_V9
comment|/* Although insns using %y are deprecated, it is a clear win on current        ultrasparcs.  */
operator||
name|MASK_DEPRECATED_V8_INSNS
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|cpu_table
modifier|*
name|cpu
decl_stmt|;
specifier|const
name|struct
name|sparc_cpu_select
modifier|*
name|sel
decl_stmt|;
name|int
name|fpu
decl_stmt|;
ifndef|#
directive|ifndef
name|SPARC_BI_ARCH
comment|/* Check for unsupported architecture size.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|!=
name|DEFAULT_ARCH32_P
condition|)
name|error
argument_list|(
literal|"%s is not supported by this configuration"
argument_list|,
name|DEFAULT_ARCH32_P
condition|?
literal|"-m64"
else|:
literal|"-m32"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We force all 64bit archs to use 128 bit long double */
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|TARGET_LONG_DOUBLE_128
condition|)
block|{
name|error
argument_list|(
literal|"-mlong-double-64 not allowed with -m64"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|MASK_LONG_DOUBLE_128
expr_stmt|;
block|}
comment|/* Code model selection.  */
name|sparc_cmodel
operator|=
name|SPARC_DEFAULT_CMODEL
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARC_BI_ARCH
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|sparc_cmodel
operator|=
name|CM_32
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sparc_cmodel_string
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
for|for
control|(
name|cmodel
operator|=
operator|&
name|cmodels
index|[
literal|0
index|]
init|;
name|cmodel
operator|->
name|name
condition|;
name|cmodel
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sparc_cmodel_string
argument_list|,
name|cmodel
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cmodel
operator|->
name|name
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -mcmodel= switch"
argument_list|,
name|sparc_cmodel_string
argument_list|)
expr_stmt|;
else|else
name|sparc_cmodel
operator|=
name|cmodel
operator|->
name|value
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"-mcmodel= is not supported on 32 bit systems"
argument_list|)
expr_stmt|;
block|}
name|fpu
operator|=
name|TARGET_FPU
expr_stmt|;
comment|/* save current -mfpu status */
comment|/* Set the default CPU.  */
for|for
control|(
name|def
operator|=
operator|&
name|cpu_default
index|[
literal|0
index|]
init|;
name|def
operator|->
name|name
condition|;
operator|++
name|def
control|)
if|if
condition|(
name|def
operator|->
name|cpu
operator|==
name|TARGET_CPU_DEFAULT
condition|)
break|break;
if|if
condition|(
operator|!
name|def
operator|->
name|name
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sparc_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|def
operator|->
name|name
expr_stmt|;
for|for
control|(
name|sel
operator|=
operator|&
name|sparc_select
index|[
literal|0
index|]
init|;
name|sel
operator|->
name|name
condition|;
operator|++
name|sel
control|)
block|{
if|if
condition|(
name|sel
operator|->
name|string
condition|)
block|{
for|for
control|(
name|cpu
operator|=
operator|&
name|cpu_table
index|[
literal|0
index|]
init|;
name|cpu
operator|->
name|name
condition|;
operator|++
name|cpu
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sel
operator|->
name|string
argument_list|,
name|cpu
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|sel
operator|->
name|set_tune_p
condition|)
name|sparc_cpu
operator|=
name|cpu
operator|->
name|processor
expr_stmt|;
if|if
condition|(
name|sel
operator|->
name|set_arch_p
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|cpu
operator|->
name|disable
expr_stmt|;
name|target_flags
operator||=
name|cpu
operator|->
name|enable
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|cpu
operator|->
name|name
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|sel
operator|->
name|string
argument_list|,
name|sel
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -mfpu or -mno-fpu was explicitly used, don't override with      the processor default.  Clear MASK_FPU_SET to avoid confusing      the reverse mapping from switch values to names.  */
if|if
condition|(
name|TARGET_FPU_SET
condition|)
block|{
name|target_flags
operator|=
operator|(
name|target_flags
operator|&
operator|~
name|MASK_FPU
operator|)
operator||
name|fpu
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_FPU_SET
expr_stmt|;
block|}
comment|/* Don't allow -mvis if FPU is disabled.  */
if|if
condition|(
operator|!
name|TARGET_FPU
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_VIS
expr_stmt|;
comment|/* -mvis assumes UltraSPARC+, so we are sure v9 instructions      are available.      -m64 also implies v9.  */
if|if
condition|(
name|TARGET_VIS
operator|||
name|TARGET_ARCH64
condition|)
block|{
name|target_flags
operator||=
name|MASK_V9
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_V8
operator||
name|MASK_SPARCLET
operator||
name|MASK_SPARCLITE
operator|)
expr_stmt|;
block|}
comment|/* Use the deprecated v8 insns for sparc64 in 32 bit mode.  */
if|if
condition|(
name|TARGET_V9
operator|&&
name|TARGET_ARCH32
condition|)
name|target_flags
operator||=
name|MASK_DEPRECATED_V8_INSNS
expr_stmt|;
comment|/* V8PLUS requires V9, makes no sense in 64 bit mode.  */
if|if
condition|(
operator|!
name|TARGET_V9
operator|||
name|TARGET_ARCH64
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_V8PLUS
expr_stmt|;
comment|/* Don't use stack biasing in 32 bit mode.  */
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_STACK_BIAS
expr_stmt|;
comment|/* Supply a default value for align_functions.  */
if|if
condition|(
name|align_functions
operator|==
literal|0
operator|&&
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC
condition|)
name|align_functions
operator|=
literal|32
expr_stmt|;
comment|/* Validate PCC_STRUCT_RETURN.  */
if|if
condition|(
name|flag_pcc_struct_return
operator|==
name|DEFAULT_PCC_STRUCT_RETURN
condition|)
name|flag_pcc_struct_return
operator|=
operator|(
name|TARGET_ARCH64
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* Only use .uaxword when compiling for a 64-bit target.  */
if|if
condition|(
operator|!
name|TARGET_ARCH64
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
operator|.
name|di
operator|=
name|NULL
expr_stmt|;
comment|/* Do various machine dependent initializations.  */
name|sparc_init_modes
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|profile_flag
operator|)
operator|&&
name|sparc_cmodel
operator|!=
name|CM_32
operator|&&
name|sparc_cmodel
operator|!=
name|CM_MEDLOW
condition|)
block|{
name|error
argument_list|(
literal|"profiling does not support code models other than medlow"
argument_list|)
expr_stmt|;
block|}
comment|/* Register global variables with the garbage collector.  */
name|sparc_add_gc_roots
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous utilities.  */
end_comment

begin_comment
comment|/* Nonzero if CODE, a comparison, is suitable for use in v9 conditional move    or branch on register contents instructions.  */
end_comment

begin_function
name|int
name|v9_regcmp_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GT
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Operand constraints.  */
end_comment

begin_comment
comment|/* Return non-zero only if OP is a register of mode MODE,    or const0_rtx.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|op
operator|==
name|const0_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fp_zero_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point value with value 0.0.  */
end_comment

begin_function
name|int
name|fp_zero_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
return|return
literal|0
return|;
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point constant which can    be loaded into an integer register using a single    sethi instruction.  */
end_comment

begin_function
name|int
name|fp_sethi_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|i
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SPARC_SETHI_P
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point constant which can    be loaded into an integer register using a single    mov instruction.  */
end_comment

begin_function
name|int
name|fp_mov_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|i
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SPARC_SIMM13_P
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point constant which can    be loaded into an integer register using a high/losum    instruction sequence.  */
end_comment

begin_function
name|int
name|fp_high_losum_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
comment|/* The constraints calling this should only be in      SFmode move insns, so any constant which cannot      be moved using a single insn will do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|i
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SPARC_SETHI_P
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|SPARC_SIMM13_P
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is an integer register.  */
end_comment

begin_function
name|int
name|intreg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|register_operand
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point condition code register.  */
end_comment

begin_function
name|int
name|fcc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* This can happen when recog is called from combine.  Op may be a MEM.      Fail instead of calling abort in this case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CCFPmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CCFPEmode
operator|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* ??? ==> 1 when %fcc0-3 are pseudos first.  See gen_compare_reg().  */
block|if (reg_renumber == 0)     return REGNO (op)>= FIRST_PSEUDO_REGISTER;   return REGNO_OK_FOR_CCFP_P (REGNO (op));
else|#
directive|else
return|return
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|op
argument_list|)
operator|-
name|SPARC_FIRST_V9_FCC_REG
operator|<
literal|4
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Nonzero if OP is an integer or floating point condition code register.  */
end_comment

begin_function
name|int
name|icc_or_fcc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|SPARC_ICC_REG
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CCmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CCXmode
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
name|fcc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP can appear as the dest of a RESTORE insn.  */
end_comment

begin_function
name|int
name|restore_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
literal|8
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Call insn on SPARC can take a PC-relative constant address, or any regular    memory address.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|call_operand_address
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|omode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|omode
operator|!=
name|mode
operator|&&
name|omode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a symbolic memory    operand of mode MODE.  */
end_comment

begin_function
name|int
name|symbolic_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|HIGH
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a LABEL_REF of mode MODE.  */
end_comment

begin_function
name|int
name|label_ref_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is an argument used in generating pic references    in either the medium/low or medium/anywhere code models of sparc64.  */
end_comment

begin_function
name|int
name|sp64_medium_pic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Check for (const (minus (symbol_ref:GOT)                              (const (minus (label) (pc))))).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MINUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
comment|/* ??? Ensure symbol is GOT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MINUS
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a data segment reference.  This includes    the readonly data segment, or in other words anything but the text segment.    This is needed in the medium/anywhere code model on v9.  These values    are accessed with EMBMEDANY_BASE_REG.  */
end_comment

begin_function
name|int
name|data_segment_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
operator|!
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* Assume canonical format of symbol + constant. 	 Fall through.  */
case|case
name|CONST
case|:
return|return
name|data_segment_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
default|default :
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a text segment reference.    This is needed in the medium/anywhere code model on v9.  */
end_comment

begin_function
name|int
name|text_segment_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* Assume canonical format of symbol + constant. 	 Fall through.  */
case|case
name|CONST
case|:
return|return
name|text_segment_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
default|default :
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or a memory operand that is    not symbolic.  */
end_comment

begin_function
name|int
name|reg_or_nonsymb_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|symbolic_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|splittable_symbolic_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|splittable_immediate_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|immediate_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is EQ or NE.  */
end_comment

begin_function
name|int
name|eq_or_neq
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator, but not an EQ, NE, GEU,    or LTU for non-floating-point.  We handle those specially.  */
end_comment

begin_function
name|int
name|normal_comp_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPEmode
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|code
operator|!=
name|NE
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator.  This allows the use of    MATCH_OPERATOR to recognize all the branch insns.  */
end_comment

begin_function
name|int
name|noov_compare_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CC_NOOVmode
condition|)
comment|/* These are the only branches which work with CC_NOOVmode.  */
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a comparison operator suitable for use in v9    conditional move or branch on register contents instructions.  */
end_comment

begin_function
name|int
name|v9_regcmp_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
return|return
name|v9_regcmp_p
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */
end_comment

begin_function
name|int
name|extend_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ZERO_EXTEND
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is an operator of mode MODE which can set    the condition codes explicitly.  We do not include PLUS and MINUS    because these require CC_NOOVmode, which we handle explicitly.  */
end_comment

begin_function
name|int
name|cc_arithop
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|XOR
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is an operator of mode MODE which can bitwise    complement its second operand and set the condition codes explicitly.  */
end_comment

begin_function
name|int
name|cc_arithopn
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* XOR is not here because combine canonicalizes (xor (not ...) ...)      and (xor ... (not ...)) to (not (xor ...)).  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT that can fit in a    signed 13 bit immediate field.  This is an acceptable SImode operand for    most 3 address instructions.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|SPARC_SIMM13_P
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a constant 4096  */
end_comment

begin_function
name|int
name|arith_4096_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|val
operator|==
literal|4096
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is suitable as second operand for add/sub */
end_comment

begin_function
name|int
name|arith_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|arith_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|arith_4096_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a CONST_INT or a CONST_DOUBLE which can fit in the    immediate field of OR and XOR instructions.  Used for 64-bit    constant formation patterns.  */
end_comment

begin_function
name|int
name|const64_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SPARC_SIMM13_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|SPARC_SIMM13_P
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|(
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|?
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
else|:
literal|0
operator|)
operator|)
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The same, but only for sethi instructions.  */
end_comment

begin_function
name|int
name|const64_high_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xfffffc00
operator|)
operator|!=
literal|0
operator|&&
name|SPARC_SETHI_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
comment|/* Must be positive on non-64bit host else the 	      optimizer is fooled into thinking that sethi 	      sign extends, even though it does not.  */
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
endif|#
directive|endif
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0xfffffc00
operator|)
operator|!=
literal|0
operator|&&
name|SPARC_SETHI_P
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT that can fit in a    signed 11 bit immediate field.  This is an acceptable SImode operand for    the movcc instructions.  */
end_comment

begin_function
name|int
name|arith11_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SPARC_SIMM11_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT that can fit in a    signed 10 bit immediate field.  This is an acceptable SImode operand for    the movrcc instructions.  */
end_comment

begin_function
name|int
name|arith10_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SPARC_SIMM10_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, is a CONST_INT that fits in a 13 bit    immediate field, or is a CONST_DOUBLE whose both parts fit in a 13 bit    immediate field.    v9: Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that    can fit in a 13 bit immediate field.  This is an acceptable DImode operand    for most 3 address instructions.  */
end_comment

begin_function
name|int
name|arith_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|TARGET_ARCH64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x1000
argument_list|)
operator|<
literal|0x2000
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|+
literal|0x1000
argument_list|)
operator|<
literal|0x2000
operator|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x1000
argument_list|)
operator|<
literal|0x2000
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x1000
operator|)
operator|==
literal|0x1000
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x1000
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a constant 4096 for DImode on ARCH64 */
end_comment

begin_function
name|int
name|arith_double_4096_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|TARGET_ARCH64
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4096
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
literal|4096
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is suitable as second operand for add/sub in DImode */
end_comment

begin_function
name|int
name|arith_double_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|arith_double_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|arith_double_4096_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that    can fit in an 11 bit immediate field.  This is an acceptable DImode    operand for the movcc instructions.  */
end_comment

begin_comment
comment|/* ??? Replace with arith11_operand?  */
end_comment

begin_function
name|int
name|arith11_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x400
argument_list|)
operator|<
literal|0x800
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x400
operator|)
operator|==
literal|0x400
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x400
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x400
argument_list|)
operator|<
literal|0x800
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that    can fit in an 10 bit immediate field.  This is an acceptable DImode    operand for the movrcc instructions.  */
end_comment

begin_comment
comment|/* ??? Replace with arith10_operand?  */
end_comment

begin_function
name|int
name|arith10_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x200
argument_list|)
operator|<
literal|0x400
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x200
operator|)
operator|==
literal|0x200
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x200
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x200
argument_list|)
operator|<
literal|0x400
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is an integer which fits the    range constraining immediate operands in most three-address insns,    which have a 13 bit immediate field.  */
end_comment

begin_function
name|int
name|small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|small_int_or_double
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|SPARC_SIMM13_P
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Recognize operand values for the umul instruction.  That instruction sign    extends immediate values just like all other sparc instructions, but    interprets the extended result as an unsigned number.  */
end_comment

begin_function
name|int
name|uns_small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
comment|/* All allowed constants will fit a CONST_INT.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x1000
operator|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0xFFFFF000
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<=
literal|0xFFFFFFFF
operator|)
operator|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x1000
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|-
literal|0xFFFFF000
operator|<
literal|0x1000
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|uns_arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|uns_small_int
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a call-clobbered register.  */
end_comment

begin_function
name|int
name|clobbered_register
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the source of a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* If both modes are non-void they must be the same.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
literal|1
return|;
comment|/* Allow any one instruction integer constant, and all CONST_INT      variants when we are working in DImode and !arch64.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|SPARC_SETHI_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|TARGET_ARCH64
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|)
operator|||
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|QImode
operator|)
operator|)
operator|||
name|SPARC_SIMM13_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
operator|(
name|mode
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_ARCH64
operator|)
operator|)
operator|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|SPARC_SETHI_P
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|SPARC_SIMM13_P
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
else|#
directive|else
operator|(
name|SPARC_SIMM13_P
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If !arch64 and this is a DImode const, allow it so that      the splits can be generated.  */
if|if
condition|(
operator|!
name|TARGET_ARCH64
operator|&&
name|mode
operator|==
name|DImode
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
literal|1
return|;
comment|/* If this is a SUBREG, look inside so that we handle      paradoxical ones.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Check for valid MEM forms.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|inside
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inside
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
comment|/* We can't allow these because all of the splits 	     (eventually as they trickle down into DFmode 	     splits) require offsettable memory references.  */
if|if
condition|(
operator|!
name|TARGET_V9
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|TFmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|inside
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|inside
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|inside
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We know it can't be done in one insn when we get here,    the movsi expander guarentees this.  */
end_comment

begin_function
name|void
name|sparc_emit_set_const32
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|SPARC_SETHI_P
argument_list|(
name|value
argument_list|)
operator|||
name|SPARC_SIMM13_P
argument_list|(
name|value
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Full 2-insn decomposition is needed.  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|temp
operator|=
name|op0
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Emit them as real moves instead of a HIGH/LO_SUM, 	 this way CSE can see everything and reuse intermediate 	 values if it wants.  */
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_CONST_DOUBLE
argument_list|(
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|0xfffffc00
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|0xfffffc00
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|0x3ff
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A symbol, emit in the traditional way.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sparc-v9 code-model support.  */
end_comment

begin_function
name|void
name|sparc_emit_set_symbolic_const64
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|temp1
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|rtx
name|temp1
decl_stmt|;
block|{
switch|switch
condition|(
name|sparc_cmodel
condition|)
block|{
case|case
name|CM_MEDLOW
case|:
comment|/* The range spanned by all instructions in the object is less 	 than 2^31 bytes (2GB) and the distance from any instruction 	 to the location of the label _GLOBAL_OFFSET_TABLE_ is less 	 than 2^31 bytes (2GB).  	 The executable must be in the low 4TB of the virtual address 	 space.  	 sethi	%hi(symbol), %temp 	 or	%temp, %lo(symbol), %reg  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp1
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|DImode
argument_list|,
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CM_MEDMID
case|:
comment|/* The range spanned by all instructions in the object is less 	 than 2^31 bytes (2GB) and the distance from any instruction 	 to the location of the label _GLOBAL_OFFSET_TABLE_ is less 	 than 2^31 bytes (2GB).  	 The executable must be in the low 16TB of the virtual address 	 space.  	 sethi	%h44(symbol), %temp1 	 or	%temp1, %m44(symbol), %temp2 	 sllx	%temp2, 12, %temp3 	 or	%temp3, %l44(symbol), %reg  */
name|emit_insn
argument_list|(
name|gen_seth44
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setm44
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp1
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
literal|12
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setl44
argument_list|(
name|op0
argument_list|,
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CM_MEDANY
case|:
comment|/* The range spanned by all instructions in the object is less 	 than 2^31 bytes (2GB) and the distance from any instruction 	 to the location of the label _GLOBAL_OFFSET_TABLE_ is less 	 than 2^31 bytes (2GB).  	 The executable can be placed anywhere in the virtual address 	 space.  	 sethi	%hh(symbol), %temp1 	 sethi	%lm(symbol), %temp2 	 or	%temp1, %hm(symbol), %temp3 	 or	%temp2, %lo(symbol), %temp4 	 sllx	%temp3, 32, %temp5 	 or	%temp4, %temp5, %reg  */
comment|/* Getting this right wrt. reloading is really tricky. 	 We _MUST_ have a separate temporary at this point, 	 if we don't barf immediately instead of generating 	 incorrect code.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|temp1
argument_list|,
name|op0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sethh
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setlm
argument_list|(
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sethm
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setlo
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CM_EMBMEDANY
case|:
comment|/* Old old old backwards compatibility kruft here. 	 Essentially it is MEDLOW with a fixed 64-bit 	 virtual base added to all data segment addresses. 	 Text-segment stuff is computed like MEDANY, we can't 	 reuse the code above because the relocation knobs 	 look different.  	 Data segment:	sethi	%hi(symbol), %temp1 			or	%temp1, %lo(symbol), %temp2 			add	%temp2, EMBMEDANY_BASE_REG, %reg  	 Text segment:	sethi	%uhi(symbol), %temp1 			sethi	%hi(symbol), %temp2 			or	%temp1, %ulo(symbol), %temp3 			or	%temp2, %lo(symbol), %temp4 			sllx	%temp3, 32, %temp5 			or	%temp4, %temp5, %reg  */
if|if
condition|(
name|data_segment_operand
argument_list|(
name|op1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_embmedany_sethi
argument_list|(
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_brsum
argument_list|(
name|op0
argument_list|,
name|temp1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_losum
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Getting this right wrt. reloading is really tricky. 	     We _MUST_ have a separate temporary at this point, 	     so we barf immediately instead of generating 	     incorrect code.  */
if|if
condition|(
name|temp1
operator|==
name|op0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_textuhi
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_texthi
argument_list|(
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_textulo
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_textlo
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These avoid problems when cross compiling.  If we do not    go through all this hair then the optimizer will see    invalid REG_EQUAL notes or in some cases none at all.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|sparc_emit_set_safe_HIGH64
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_safe_SET64
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_safe_OR64
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_safe_XOR64
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|GEN_HIGHINT64
parameter_list|(
name|__x
parameter_list|)
value|GEN_INT ((__x)& 0xfffffc00)
end_define

begin_define
define|#
directive|define
name|GEN_INT64
parameter_list|(
name|__x
parameter_list|)
value|GEN_INT (__x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GEN_HIGHINT64
parameter_list|(
name|__x
parameter_list|)
define|\
value|gen_rtx_CONST_DOUBLE (VOIDmode, (__x)& 0xfffffc00, 0)
end_define

begin_define
define|#
directive|define
name|GEN_INT64
parameter_list|(
name|__x
parameter_list|)
define|\
value|gen_rtx_CONST_DOUBLE (VOIDmode, (__x)& 0xffffffff, \ 			      ((__x)& 0x80000000 \ 			       ? 0xffffffff : 0))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The optimizer is not to assume anything about exactly    which bits are set for a HIGH, they are unspecified.    Unfortunately this leads to many missed optimizations    during CSE.  We mask out the non-HIGH bits, and matches    a plain movdi, to alleviate this problem.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_emit_set_safe_HIGH64
parameter_list|(
name|dest
parameter_list|,
name|val
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|GEN_HIGHINT64
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_safe_SET64
parameter_list|(
name|dest
parameter_list|,
name|val
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
block|{
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|GEN_INT64
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_safe_OR64
parameter_list|(
name|src
parameter_list|,
name|val
parameter_list|)
name|rtx
name|src
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
block|{
return|return
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|,
name|GEN_INT64
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_safe_XOR64
parameter_list|(
name|src
parameter_list|,
name|val
parameter_list|)
name|rtx
name|src
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
block|{
return|return
name|gen_rtx_XOR
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|,
name|GEN_INT64
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Worker routines for 64-bit constant formation on arch64.    One of the key things to be doing in these emissions is    to create as many temp REGs as possible.  This makes it    possible for half-built constants to be used later when    such values are similar to something required later on.    Without doing this, the optimizer cannot see such    opportunities.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|sparc_emit_set_const64_quick1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sparc_emit_set_const64_quick1
parameter_list|(
name|op0
parameter_list|,
name|temp
parameter_list|,
name|low_bits
parameter_list|,
name|is_neg
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low_bits
decl_stmt|;
name|int
name|is_neg
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|;
if|if
condition|(
name|is_neg
condition|)
name|high_bits
operator|=
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
else|else
name|high_bits
operator|=
name|low_bits
expr_stmt|;
name|sparc_emit_set_safe_HIGH64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_neg
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_OR64
argument_list|(
name|temp
argument_list|,
operator|(
name|high_bits
operator|&
literal|0x3ff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we are XOR'ing with -1, then we should emit a one's complement 	 instead.  This way the combiner will notice logical operations 	 such as ANDN later on and substitute.  */
if|if
condition|(
operator|(
name|low_bits
operator|&
literal|0x3ff
operator|)
operator|==
literal|0x3ff
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_XOR64
argument_list|(
name|temp
argument_list|,
operator|(
operator|-
literal|0x400
operator||
operator|(
name|low_bits
operator|&
literal|0x3ff
operator|)
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|sparc_emit_set_const64_quick2
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sparc_emit_set_const64_quick2
parameter_list|(
name|op0
parameter_list|,
name|temp
parameter_list|,
name|high_bits
parameter_list|,
name|low_immediate
parameter_list|,
name|shift_count
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low_immediate
decl_stmt|;
name|int
name|shift_count
decl_stmt|;
block|{
name|rtx
name|temp2
init|=
name|op0
decl_stmt|;
if|if
condition|(
operator|(
name|high_bits
operator|&
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
block|{
name|sparc_emit_set_safe_HIGH64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|high_bits
operator|&
operator|~
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_OR64
argument_list|(
name|temp
argument_list|,
operator|(
name|high_bits
operator|&
literal|0x3ff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp2
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_safe_SET64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Now shift it up into place.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp2
argument_list|,
name|GEN_INT
argument_list|(
name|shift_count
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is a low immediate part piece, finish up by      putting that in as well.  */
if|if
condition|(
name|low_immediate
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_OR64
argument_list|(
name|op0
argument_list|,
name|low_immediate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|sparc_emit_set_const64_longway
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Full 64-bit constant decomposition.  Even though this is the    'worst' case, we still optimize a few things away.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_emit_set_const64_longway
parameter_list|(
name|op0
parameter_list|,
name|temp
parameter_list|,
name|high_bits
parameter_list|,
name|low_bits
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low_bits
decl_stmt|;
block|{
name|rtx
name|sub_temp
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|sub_temp
operator|=
name|op0
expr_stmt|;
else|else
name|sub_temp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|high_bits
operator|&
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
block|{
name|sparc_emit_set_safe_HIGH64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|high_bits
operator|&
operator|~
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub_temp
argument_list|,
name|gen_safe_OR64
argument_list|(
name|temp
argument_list|,
operator|(
name|high_bits
operator|&
literal|0x3ff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sub_temp
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_safe_SET64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
argument_list|)
expr_stmt|;
name|sub_temp
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
block|{
name|rtx
name|temp2
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp3
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp4
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp4
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|sub_temp
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sparc_emit_set_safe_HIGH64
argument_list|(
name|temp2
argument_list|,
name|low_bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|low_bits
operator|&
operator|~
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp3
argument_list|,
name|gen_safe_OR64
argument_list|(
name|temp2
argument_list|,
operator|(
name|low_bits
operator|&
literal|0x3ff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|temp4
argument_list|,
name|temp3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|temp4
argument_list|,
name|temp2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|low1
init|=
name|GEN_INT
argument_list|(
operator|(
name|low_bits
operator|>>
operator|(
literal|32
operator|-
literal|12
operator|)
operator|)
operator|&
literal|0xfff
argument_list|)
decl_stmt|;
name|rtx
name|low2
init|=
name|GEN_INT
argument_list|(
operator|(
name|low_bits
operator|>>
operator|(
literal|32
operator|-
literal|12
operator|-
literal|12
operator|)
operator|)
operator|&
literal|0xfff
argument_list|)
decl_stmt|;
name|rtx
name|low3
init|=
name|GEN_INT
argument_list|(
operator|(
name|low_bits
operator|>>
operator|(
literal|32
operator|-
literal|12
operator|-
literal|12
operator|-
literal|8
operator|)
operator|)
operator|&
literal|0x0ff
argument_list|)
decl_stmt|;
name|int
name|to_shift
init|=
literal|12
decl_stmt|;
comment|/* We are in the middle of reload, so this is really 	 painful.  However we do still make an attempt to 	 avoid emitting truly stupid code.  */
if|if
condition|(
name|low1
operator|!=
name|const0_rtx
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|sub_temp
argument_list|,
name|GEN_INT
argument_list|(
name|to_shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|low1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sub_temp
operator|=
name|op0
expr_stmt|;
name|to_shift
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|to_shift
operator|+=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|low2
operator|!=
name|const0_rtx
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|sub_temp
argument_list|,
name|GEN_INT
argument_list|(
name|to_shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|low2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sub_temp
operator|=
name|op0
expr_stmt|;
name|to_shift
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|to_shift
operator|+=
literal|8
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|sub_temp
argument_list|,
name|GEN_INT
argument_list|(
name|to_shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|low3
operator|!=
name|const0_rtx
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|low3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* phew...  */
block|}
block|}
end_function

begin_comment
comment|/* Analyze a 64-bit constant for certain properties.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|analyze_64bit_constant
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|analyze_64bit_constant
parameter_list|(
name|high_bits
parameter_list|,
name|low_bits
parameter_list|,
name|hbsp
parameter_list|,
name|lbsp
parameter_list|,
name|abbasp
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|,
name|low_bits
decl_stmt|;
name|int
modifier|*
name|hbsp
decl_stmt|,
decl|*
name|lbsp
decl_stmt|,
modifier|*
name|abbasp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|lowest_bit_set
decl_stmt|,
name|highest_bit_set
decl_stmt|,
name|all_bits_between_are_set
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lowest_bit_set
operator|=
name|highest_bit_set
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|low_bits
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
condition|)
name|lowest_bit_set
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|high_bits
operator|>>
operator|(
literal|32
operator|-
name|i
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
condition|)
name|highest_bit_set
operator|=
operator|(
literal|64
operator|-
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
literal|32
operator|&&
operator|(
operator|(
name|highest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|i
operator|==
literal|32
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|high_bits
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
condition|)
name|lowest_bit_set
operator|=
name|i
operator|+
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|low_bits
operator|>>
operator|(
literal|32
operator|-
name|i
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
condition|)
name|highest_bit_set
operator|=
literal|32
operator|-
name|i
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
literal|32
operator|&&
operator|(
operator|(
name|highest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
do|;
block|}
comment|/* If there are no bits set this should have gone out      as one instruction!  */
if|if
condition|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|||
name|highest_bit_set
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|all_bits_between_are_set
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowest_bit_set
init|;
name|i
operator|<=
name|highest_bit_set
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|32
condition|)
block|{
if|if
condition|(
operator|(
name|low_bits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|high_bits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|32
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
name|all_bits_between_are_set
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|hbsp
operator|=
name|highest_bit_set
expr_stmt|;
operator|*
name|lbsp
operator|=
name|lowest_bit_set
expr_stmt|;
operator|*
name|abbasp
operator|=
name|all_bits_between_are_set
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|const64_is_2insns
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|const64_is_2insns
parameter_list|(
name|high_bits
parameter_list|,
name|low_bits
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|,
name|low_bits
decl_stmt|;
block|{
name|int
name|highest_bit_set
decl_stmt|,
name|lowest_bit_set
decl_stmt|,
name|all_bits_between_are_set
decl_stmt|;
if|if
condition|(
name|high_bits
operator|==
literal|0
operator|||
name|high_bits
operator|==
literal|0xffffffff
condition|)
return|return
literal|1
return|;
name|analyze_64bit_constant
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
operator|&
name|highest_bit_set
argument_list|,
operator|&
name|lowest_bit_set
argument_list|,
operator|&
name|all_bits_between_are_set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|==
literal|63
operator|||
name|lowest_bit_set
operator|==
literal|0
operator|)
operator|&&
name|all_bits_between_are_set
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|-
name|lowest_bit_set
operator|)
operator|<
literal|21
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|create_simple_focus_bits
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|create_simple_focus_bits
parameter_list|(
name|high_bits
parameter_list|,
name|low_bits
parameter_list|,
name|lowest_bit_set
parameter_list|,
name|shift
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|,
name|low_bits
decl_stmt|;
name|int
name|lowest_bit_set
decl_stmt|,
name|shift
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
if|if
condition|(
name|lowest_bit_set
operator|<
literal|32
condition|)
block|{
name|lo
operator|=
operator|(
name|low_bits
operator|>>
name|lowest_bit_set
operator|)
operator|<<
name|shift
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
name|high_bits
operator|<<
operator|(
literal|32
operator|-
name|lowest_bit_set
operator|)
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
name|high_bits
operator|>>
operator|(
name|lowest_bit_set
operator|-
literal|32
operator|)
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|hi
operator|&
name|lo
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|hi
operator||
name|lo
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Here we are sure to be arch64 and this is an integer constant    being loaded into a register.  Emit the most efficient    insn sequence possible.  Detection of all the 1-insn cases    has been done already.  */
end_comment

begin_function
name|void
name|sparc_emit_set_const64
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|,
name|low_bits
decl_stmt|;
name|int
name|lowest_bit_set
decl_stmt|,
name|highest_bit_set
decl_stmt|;
name|int
name|all_bits_between_are_set
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Sanity check that we know what we are working with.  */
if|if
condition|(
operator|!
name|TARGET_ARCH64
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|>=
name|SPARC_FIRST_FP_REG
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|<=
name|SPARC_LAST_V9_FP_REG
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|temp
operator|=
name|op0
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|sparc_emit_set_symbolic_const64
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
name|high_bits
operator|=
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
name|low_bits
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
else|#
directive|else
name|high_bits
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|low_bits
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
name|high_bits
operator|=
operator|(
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|low_bits
operator|=
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
else|#
directive|else
name|high_bits
operator|=
operator|(
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|)
condition|?
literal|0xffffffff
else|:
literal|0x00000000
operator|)
expr_stmt|;
name|low_bits
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* low_bits	bits 0  --> 31      high_bits	bits 32 --> 63  */
name|analyze_64bit_constant
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
operator|&
name|highest_bit_set
argument_list|,
operator|&
name|lowest_bit_set
argument_list|,
operator|&
name|all_bits_between_are_set
argument_list|)
expr_stmt|;
comment|/* First try for a 2-insn sequence.  */
comment|/* These situations are preferred because the optimizer can    * do more things with them:    * 1) mov	-1, %reg    *    sllx	%reg, shift, %reg    * 2) mov	-1, %reg    *    srlx	%reg, shift, %reg    * 3) mov	some_small_const, %reg    *    sllx	%reg, shift, %reg    */
if|if
condition|(
operator|(
operator|(
name|highest_bit_set
operator|==
literal|63
operator|||
name|lowest_bit_set
operator|==
literal|0
operator|)
operator|&&
name|all_bits_between_are_set
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|highest_bit_set
operator|-
name|lowest_bit_set
operator|)
operator|<
literal|12
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|the_const
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|shift
init|=
name|lowest_bit_set
decl_stmt|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|!=
literal|63
operator|&&
name|lowest_bit_set
operator|!=
literal|0
operator|)
operator|||
name|all_bits_between_are_set
operator|==
literal|0
condition|)
block|{
name|the_const
operator|=
name|create_simple_focus_bits
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
name|lowest_bit_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowest_bit_set
operator|==
literal|0
condition|)
name|shift
operator|=
operator|-
operator|(
literal|63
operator|-
name|highest_bit_set
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|SPARC_SIMM13_P
argument_list|(
name|the_const
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_safe_SET64
argument_list|(
name|temp
argument_list|,
name|the_const
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Now a range of 22 or less bits set somewhere.    * 1) sethi	%hi(focus_bits), %reg    *    sllx	%reg, shift, %reg    * 2) sethi	%hi(focus_bits), %reg    *    srlx	%reg, shift, %reg    */
if|if
condition|(
operator|(
name|highest_bit_set
operator|-
name|lowest_bit_set
operator|)
operator|<
literal|21
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|focus_bits
init|=
name|create_simple_focus_bits
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
name|lowest_bit_set
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SPARC_SETHI_P
argument_list|(
name|focus_bits
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sparc_emit_set_safe_HIGH64
argument_list|(
name|temp
argument_list|,
name|focus_bits
argument_list|)
expr_stmt|;
comment|/* If lowest_bit_set == 10 then a sethi alone could have done it.  */
if|if
condition|(
name|lowest_bit_set
operator|<
literal|10
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
literal|10
operator|-
name|lowest_bit_set
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lowest_bit_set
operator|>
literal|10
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|lowest_bit_set
operator|-
literal|10
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 1) sethi	%hi(low_bits), %reg    *    or	%reg, %lo(low_bits), %reg    * 2) sethi	%hi(~low_bits), %reg    *	xor	%reg, %lo(-0x400 | (low_bits& 0x3ff)), %reg    */
if|if
condition|(
name|high_bits
operator|==
literal|0
operator|||
name|high_bits
operator|==
literal|0xffffffff
condition|)
block|{
name|sparc_emit_set_const64_quick1
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|low_bits
argument_list|,
operator|(
name|high_bits
operator|==
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now, try 3-insn sequences.  */
comment|/* 1) sethi	%hi(high_bits), %reg    *    or	%reg, %lo(high_bits), %reg    *    sllx	%reg, 32, %reg    */
if|if
condition|(
name|low_bits
operator|==
literal|0
condition|)
block|{
name|sparc_emit_set_const64_quick2
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|high_bits
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We may be able to do something quick      when the constant is negated, so try that.  */
if|if
condition|(
name|const64_is_2insns
argument_list|(
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
argument_list|,
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0xfffffc00
argument_list|)
condition|)
block|{
comment|/* NOTE: The trailing bits get XOR'd so we need the 	 non-negated bits, not the negated ones.  */
name|unsigned
name|HOST_WIDE_INT
name|trailing_bits
init|=
name|low_bits
operator|&
literal|0x3ff
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0xffffffff
operator|&&
operator|(
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
name|fast_int
init|=
operator|(
operator|~
name|low_bits
operator|&
literal|0xffffffff
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|SPARC_SETHI_P
argument_list|(
name|fast_int
argument_list|)
operator|&&
operator|(
operator|~
name|high_bits
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0
operator|)
operator|||
name|SPARC_SIMM13_P
argument_list|(
name|fast_int
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_safe_SET64
argument_list|(
name|temp
argument_list|,
name|fast_int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sparc_emit_set_const64
argument_list|(
name|temp
argument_list|,
name|GEN_INT64
argument_list|(
name|fast_int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|negated_const
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
name|negated_const
operator|=
name|GEN_INT
argument_list|(
operator|(
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0xfffffc00
operator|)
operator||
operator|(
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
argument_list|)
operator|)
operator|<<
literal|32
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|negated_const
operator|=
name|gen_rtx_CONST_DOUBLE
argument_list|(
name|DImode
argument_list|,
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0xfffffc00
argument_list|,
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sparc_emit_set_const64
argument_list|(
name|temp
argument_list|,
name|negated_const
argument_list|)
expr_stmt|;
block|}
comment|/* If we are XOR'ing with -1, then we should emit a one's complement 	 instead.  This way the combiner will notice logical operations 	 such as ANDN later on and substitute.  */
if|if
condition|(
name|trailing_bits
operator|==
literal|0x3ff
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_XOR64
argument_list|(
name|temp
argument_list|,
operator|(
operator|-
literal|0x400
operator||
name|trailing_bits
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 1) sethi	%hi(xxx), %reg    *    or	%reg, %lo(xxx), %reg    *	sllx	%reg, yyy, %reg    *    * ??? This is just a generalized version of the low_bits==0    * thing above, FIXME...    */
if|if
condition|(
operator|(
name|highest_bit_set
operator|-
name|lowest_bit_set
operator|)
operator|<
literal|32
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|focus_bits
init|=
name|create_simple_focus_bits
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
name|lowest_bit_set
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We can't get here in this state.  */
if|if
condition|(
name|highest_bit_set
operator|<
literal|32
operator|||
name|lowest_bit_set
operator|>=
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* So what we know is that the set bits straddle the 	 middle of the 64-bit word.  */
name|sparc_emit_set_const64_quick2
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|focus_bits
argument_list|,
literal|0
argument_list|,
name|lowest_bit_set
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 1) sethi	%hi(high_bits), %reg    *    or	%reg, %lo(high_bits), %reg    *    sllx	%reg, 32, %reg    *	or	%reg, low_bits, %reg    */
if|if
condition|(
name|SPARC_SIMM13_P
argument_list|(
name|low_bits
argument_list|)
operator|&&
operator|(
operator|(
name|int
operator|)
name|low_bits
operator|>
literal|0
operator|)
condition|)
block|{
name|sparc_emit_set_const64_quick2
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|high_bits
argument_list|,
name|low_bits
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The easiest way when all else fails, is full decomposition.  */
if|#
directive|if
literal|0
block|printf ("sparc_emit_set_const64: Hard constant [%08lx%08lx] neg[%08lx%08lx]\n", 	  high_bits, low_bits, ~high_bits, ~low_bits);
endif|#
directive|endif
name|sparc_emit_set_const64_longway
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|high_bits
argument_list|,
name|low_bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,    return the mode to be used for the comparison.  For floating-point,    CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand    is a PLUS, MINUS, NEG, or ASHIFT.  CCmode should be used when no special    processing is needed.  */
end_comment

begin_function
name|enum
name|machine_mode
name|select_cc_mode
parameter_list|(
name|op
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|rtx_code
name|op
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|CCFPmode
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
return|return
name|CCFPEmode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
return|return
name|CCX_NOOVmode
return|;
else|else
return|return
name|CC_NOOVmode
return|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
return|return
name|CCXmode
return|;
else|else
return|return
name|CCmode
return|;
block|}
block|}
end_function

begin_comment
comment|/* X and Y are two things to compare using CODE.  Emit the compare insn and    return the rtx for the cc reg in the proper mode.  */
end_comment

begin_function
name|rtx
name|gen_compare_reg
parameter_list|(
name|code
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
decl_stmt|;
comment|/* ??? We don't have movcc patterns so we cannot generate pseudo regs for the      fcc regs (cse can't tell they're really call clobbered regs and will      remove a duplicate comparison even if there is an intervening function      call - it will then try to reload the cc reg via an int reg which is why      we need the movcc patterns).  It is possible to provide the movcc      patterns by using the ldxfsr/stxfsr v9 insns.  I tried it: you need two      registers (say %g1,%g5) and it takes about 6 insns.  A better fix would be      to tell cse that CCFPE mode registers (even pseudos) are call      clobbered.  */
comment|/* ??? This is an experiment.  Rather than making changes to cse which may      or may not be easy/clean, we do our own cse.  This is possible because      we will generate hard registers.  Cse knows they're call clobbered (it      doesn't know the same thing about pseudos). If we guess wrong, no big      deal, but if we win, great!  */
if|if
condition|(
name|TARGET_V9
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
if|#
directive|if
literal|1
comment|/* experiment */
block|{
name|int
name|reg
decl_stmt|;
comment|/* We cycle through the registers to ensure they're all exercised.  */
specifier|static
name|int
name|next_fcc_reg
init|=
literal|0
decl_stmt|;
comment|/* Previous x,y for each fcc reg.  */
specifier|static
name|rtx
name|prev_args
index|[
literal|4
index|]
index|[
literal|2
index|]
decl_stmt|;
comment|/* Scan prev_args for x,y.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|4
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|prev_args
index|[
name|reg
index|]
index|[
literal|0
index|]
operator|==
name|x
operator|&&
name|prev_args
index|[
name|reg
index|]
index|[
literal|1
index|]
operator|==
name|y
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
literal|4
condition|)
block|{
name|reg
operator|=
name|next_fcc_reg
expr_stmt|;
name|prev_args
index|[
name|reg
index|]
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|prev_args
index|[
name|reg
index|]
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
name|next_fcc_reg
operator|=
operator|(
name|next_fcc_reg
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|reg
operator|+
name|SPARC_FIRST_V9_FCC_REG
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|cc_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! experiment */
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SPARC_FCC_REG
argument_list|)
expr_stmt|;
else|else
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SPARC_ICC_REG
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_comment
comment|/* This function is used for v9 only.    CODE is the code for an Scc's comparison.    OPERANDS[0] is the target of the Scc insn.    OPERANDS[1] is the value we compare against const0_rtx (which hasn't    been generated yet).     This function is needed to turn  	   (set (reg:SI 110) 	       (gt (reg:CCX 100 %icc) 	           (const_int 0)))    into 	   (set (reg:SI 110) 	       (gt:DI (reg:CCX 100 %icc) 	           (const_int 0)))     IE: The instruction recognizer needs to see the mode of the comparison to    find the right instruction. We could use "gt:DI" right in the    define_expand, but leaving it out allows us to handle DI, SI, etc.     We refer to the global sparc compare operands sparc_compare_op0 and    sparc_compare_op1.  */
end_comment

begin_function
name|int
name|gen_v9_scc
parameter_list|(
name|compare_code
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|compare_code
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_ARCH64
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|sparc_compare_op0
argument_list|)
operator|==
name|DImode
operator|||
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Handle the case where operands[0] == sparc_compare_op0.      We "early clobber" the result.  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|sparc_compare_op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|sparc_compare_op0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|sparc_compare_op0
argument_list|)
expr_stmt|;
block|}
else|else
name|op0
operator|=
name|sparc_compare_op0
expr_stmt|;
comment|/* For consistency in the following.  */
name|op1
operator|=
name|sparc_compare_op1
expr_stmt|;
comment|/* Try to use the movrCC insns.  */
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|v9_regcmp_p
argument_list|(
name|compare_code
argument_list|)
condition|)
block|{
comment|/* Special case for op0 != 0.  This can be done with one instruction if 	 operands[0] == sparc_compare_op0.  We don't assume they are equal 	 now though.  */
if|if
condition|(
name|compare_code
operator|==
name|NE
operator|&&
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|DImode
argument_list|,
name|op0
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|DImode
condition|)
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|op0
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|DImode
argument_list|,
name|temp
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_compare_reg
argument_list|(
name|compare_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|CCmode
case|:
case|case
name|CCXmode
case|:
case|case
name|CCFPEmode
case|:
case|case
name|CCFPmode
case|:
break|break;
default|default :
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a conditional jump insn for the v9 architecture using comparison code    CODE and jump target LABEL.    This function exists to take advantage of the v9 brxx insns.  */
end_comment

begin_function
name|void
name|emit_v9_brxx_insn
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|label
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|label
decl_stmt|;
block|{
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DFmode part of a hard TFmode register.    REG is the TFmode hard register, LOW is 1 for the    low 64bit of the register and 0 otherwise.  */
end_comment

begin_function
name|rtx
name|gen_df_reg
parameter_list|(
name|reg
parameter_list|,
name|low
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|int
name|low
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|WORDS_BIG_ENDIAN
operator|==
literal|0
operator|)
operator|^
operator|(
name|low
operator|!=
literal|0
operator|)
condition|)
name|regno
operator|+=
operator|(
name|TARGET_ARCH64
operator|&&
name|regno
operator|<
literal|32
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if a return peephole merging return with    setting of output register is ok.  */
end_comment

begin_function
name|int
name|leaf_return_peephole_ok
parameter_list|()
block|{
return|return
operator|(
name|actual_fsize
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL can go into the function epilogue's    delay slot.  SLOT is the slot we are trying to fill.  */
end_comment

begin_function
name|int
name|eligible_for_epilogue_delay
parameter_list|(
name|trial
parameter_list|,
name|slot
parameter_list|)
name|rtx
name|trial
decl_stmt|;
name|int
name|slot
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|,
name|src
decl_stmt|;
if|if
condition|(
name|slot
operator|>=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* If there are any call-saved registers, we should scan TRIAL if it      does not reference them.  For now just make it easy.  */
if|if
condition|(
name|num_gfregs
condition|)
return|return
literal|0
return|;
comment|/* If the function uses __builtin_eh_return, the eh_return machinery      occupies the delay slot.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
return|return
literal|0
return|;
comment|/* In the case of a true leaf function, anything can go into the delay slot.      A delay slot only exists however if the frame size is zero, otherwise      we will put an insn to adjust the stack after the return.  */
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
block|{
if|if
condition|(
name|leaf_return_peephole_ok
argument_list|()
condition|)
return|return
operator|(
operator|(
name|get_attr_in_uncond_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_BRANCH_DELAY_TRUE
operator|)
operator|)
return|;
return|return
literal|0
return|;
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Otherwise, only operations which can be done in tandem with      a `restore' or `return' insn can go into the delay slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|<
literal|24
condition|)
return|return
literal|0
return|;
comment|/* If this instruction sets up floating point register and we have a return      instruction, it can probably go in.  But restore will not work      with FP_REGS.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|>=
literal|32
condition|)
block|{
if|if
condition|(
name|TARGET_V9
operator|&&
operator|!
name|epilogue_renumber
argument_list|(
operator|&
name|pat
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|get_attr_in_uncond_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_BRANCH_DELAY_TRUE
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* The set of insns matched here must agree precisely with the set of      patterns paired with a RETURN in sparc.md.  */
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* This matches "*return_[qhs]i" or even "*return_di" on TARGET_ARCH64.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|arith_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
return|;
else|else
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
return|;
block|}
comment|/* This matches "*return_di".  */
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|arith_double_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
return|;
comment|/* This matches "*return_sf_no_fpu".  */
elseif|else
if|if
condition|(
operator|!
name|TARGET_FPU
operator|&&
name|restore_operand
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|SFmode
argument_list|)
operator|&&
name|register_operand
argument_list|(
name|src
argument_list|,
name|SFmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If we have return instruction, anything that does not use      local or output registers and can go into a delay slot wins.  */
elseif|else
if|if
condition|(
name|TARGET_V9
operator|&&
operator|!
name|epilogue_renumber
argument_list|(
operator|&
name|pat
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|get_attr_in_uncond_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_BRANCH_DELAY_TRUE
operator|)
condition|)
return|return
literal|1
return|;
comment|/* This matches "*return_addsi".  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* This matches "*return_adddi".  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* This can match "*return_losum_[sd]i".      Catch only some cases, so that return_losum* don't have      to be too big.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LO_SUM
operator|&&
operator|!
name|TARGET_CM_MEDMID
operator|&&
operator|(
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|immediate_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|immediate_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* sll{,x} reg,1,reg2 is add reg,reg,reg2 as well.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ASHIFT
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL can go into the sibling call    delay slot.  */
end_comment

begin_function
name|int
name|eligible_for_sibcall_delay
parameter_list|(
name|trial
parameter_list|)
name|rtx
name|trial
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|,
name|src
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
block|{
comment|/* If the tail call is done using the call instruction, 	 we have to restore %o7 in the delay slot.  */
if|if
condition|(
operator|(
name|TARGET_ARCH64
operator|&&
operator|!
name|TARGET_CM_MEDLOW
operator|)
operator|||
name|flag_pic
condition|)
return|return
literal|0
return|;
comment|/* %g1 is used to build the function address */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pat
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/* Otherwise, only operations which can be done in tandem with      a `restore' insn can go into the delay slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|<
literal|24
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|>=
literal|32
condition|)
return|return
literal|0
return|;
comment|/* If it mentions %o7, it can't go in, because sibcall will clobber it      in most cases.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|15
argument_list|)
argument_list|,
name|pat
argument_list|)
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|arith_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
return|;
else|else
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|arith_double_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_FPU
operator|&&
name|restore_operand
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|SFmode
argument_list|)
operator|&&
name|register_operand
argument_list|(
name|src
argument_list|,
name|SFmode
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LO_SUM
operator|&&
operator|!
name|TARGET_CM_MEDMID
operator|&&
operator|(
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|immediate_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|immediate_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ASHIFT
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_return_regs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
name|IN_OR_GLOBAL_P
argument_list|(
name|x
argument_list|)
return|;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|SET
case|:
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|check_return_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
case|case
name|NOT
case|:
case|case
name|NEG
case|:
case|case
name|MEM
case|:
return|return
name|check_return_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if TRIAL references only in and global registers.  */
end_comment

begin_function
name|int
name|eligible_for_return_delay
parameter_list|(
name|trial
parameter_list|)
name|rtx
name|trial
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
return|return
name|check_return_regs
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|short_branch
parameter_list|(
name|uid1
parameter_list|,
name|uid2
parameter_list|)
name|int
name|uid1
decl_stmt|,
name|uid2
decl_stmt|;
block|{
name|int
name|delta
init|=
name|INSN_ADDRESSES
argument_list|(
name|uid1
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|uid2
argument_list|)
decl_stmt|;
comment|/* Leave a few words of "slop".  */
if|if
condition|(
name|delta
operator|>=
operator|-
literal|1023
operator|&&
name|delta
operator|<=
literal|1022
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if REG is not used after INSN.    We assume REG is a reload reg, and therefore does    not live past labels or calls or jumps.  */
end_comment

begin_function
name|int
name|reg_unused_after
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|,
name|prev_code
init|=
name|UNKNOWN
decl_stmt|;
while|while
condition|(
operator|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|in_src
init|=
name|set
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|in_src
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|set
operator|==
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The table we use to reference PIC data.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|global_offset_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function we use to get at it.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|get_pc_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|get_pc_symbol_name
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ensure that we are not using patterns that are not OK with PIC.  */
end_comment

begin_function
name|int
name|check_pic
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
switch|switch
condition|(
name|flag_pic
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|global_offset_table
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|)
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
literal|2
case|:
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if X is an address which needs a temporary register when     reloaded while generating PIC code.  */
end_comment

begin_function
name|int
name|pic_address_needs_scratch
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
comment|/* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already position-independent,    we return ORIG.  Newly generated position-independent addresses go into a    reg.  This is REG if non zero, otherwise we allocate register(s) as    necessary.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|rtx
name|pic_ref
decl_stmt|,
name|address
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
comment|/* If not during reload, allocate another temp reg here for loading 	     in the address, so that these instructions can be optimized 	     properly.  */
name|rtx
name|temp_reg
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
comment|/* Must put the SYMBOL_REF inside an UNSPEC here so that cse 	     won't get confused into thinking that these two instructions 	     are loading in the true address of the symbol.  If in the 	     future a PIC rtx exists, that should be used instead.  */
if|if
condition|(
name|Pmode
operator|==
name|SImode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi_high_pic
argument_list|(
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi_lo_sum_pic
argument_list|(
name|temp_reg
argument_list|,
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_movdi_high_pic
argument_list|(
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movdi_lo_sum_pic
argument_list|(
name|temp_reg
argument_list|,
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|address
operator|=
name|temp_reg
expr_stmt|;
block|}
else|else
name|address
operator|=
name|orig
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
comment|/* Put a REG_EQUAL note on this insn, so that it can be optimized 	 by loop.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|orig
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
comment|/* If we reach here, then something is seriously wrong.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
comment|/* ??? Why do we do this?  */
comment|/* Now movsi_pic_label_ref uses it, but we ought to be checking that        the register is live instead, in case it is eliminated.  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Emit special PIC prologues.  */
end_comment

begin_function
name|void
name|load_pic_register
parameter_list|()
block|{
comment|/* Labels to get the PC in the prologue of this function.  */
name|int
name|orig_flag_pic
init|=
name|flag_pic
decl_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we haven't emitted the special get_pc helper function, do so now.  */
if|if
condition|(
name|get_pc_symbol_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|int
name|align
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|get_pc_symbol_name
argument_list|,
literal|"LGETPC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LGETPC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tretl\n\tadd\t%o7, %l7, %l7\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize every time through, since we can't easily      know this to be permanent.  */
name|global_offset_table
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|get_pc_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|get_pc_symbol_name
argument_list|)
expr_stmt|;
name|flag_pic
operator|=
literal|0
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_get_pc
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|global_offset_table
argument_list|,
name|get_pc_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|flag_pic
operator|=
name|orig_flag_pic
expr_stmt|;
comment|/* Need to emit this whether or not we obey regdecls,      since setjmp/longjmp can cause life info to screw up.      ??? In the case where we don't obey regdecls, this is not sufficient      since we may not fall out the bottom.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if RTX is a MEM which is known to be aligned to at    least an 8 byte boundary.  */
end_comment

begin_function
name|int
name|mem_min_alignment
parameter_list|(
name|mem
parameter_list|,
name|desired
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|int
name|desired
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|,
name|base
decl_stmt|,
name|offset
decl_stmt|;
comment|/* If it's not a MEM we can't accept it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|offset
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* What we are saying here is that if the base 	     REG is aligned properly, the compiler will make 	     sure any REG based index upon it will be so 	     as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|addr
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|!=
name|NULL_RTX
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
comment|/* Check if the compiler has recorded some information 	     about the alignment of the base REG.  If reload has 	     completed, we already matched with proper alignments. 	     If not running global_alloc, reload might give us 	     unaligned pointer to local stack though.  */
if|if
condition|(
operator|(
operator|(
name|cfun
operator|!=
literal|0
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|regno
argument_list|)
operator|>=
name|desired
operator|*
name|BITS_PER_UNIT
operator|)
operator|||
operator|(
name|optimize
operator|&&
name|reload_completed
operator|)
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|&
operator|(
name|desired
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|SPARC_STACK_BIAS
operator|)
operator|&
operator|(
name|desired
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_UNALIGNED_DOUBLES
operator|||
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
comment|/* Anything else we know is properly aligned unless TARGET_UNALIGNED_DOUBLES 	 is true, in which case we can only assume that an access is aligned if 	 it is to a constant address, or the address involves a LO_SUM.  */
return|return
literal|1
return|;
block|}
comment|/* An obviously unaligned address.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Vectors to keep interesting information about registers where it can easily    be got.  We use to use the actual mode value as the bit number, but there    are more than 32 modes now.  Instead we use two tables: one indexed by    hard register number, and one indexed by mode.  */
end_comment

begin_comment
comment|/* The purpose of sparc_mode_class is to shrink the range of modes so that    they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is    mapped into one sparc_mode_class mode.  */
end_comment

begin_enum
enum|enum
name|sparc_mode_class
block|{
name|S_MODE
block|,
name|D_MODE
block|,
name|T_MODE
block|,
name|O_MODE
block|,
name|SF_MODE
block|,
name|DF_MODE
block|,
name|TF_MODE
block|,
name|OF_MODE
block|,
name|CC_MODE
block|,
name|CCFP_MODE
block|}
enum|;
end_enum

begin_comment
comment|/* Modes for single-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|S_MODES
value|((1<< (int) S_MODE) | (1<< (int) SF_MODE))
end_define

begin_comment
comment|/* Modes for double-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|D_MODES
value|(S_MODES | (1<< (int) D_MODE) | (1<< DF_MODE))
end_define

begin_comment
comment|/* Modes for quad-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|T_MODES
value|(D_MODES | (1<< (int) T_MODE) | (1<< (int) TF_MODE))
end_define

begin_comment
comment|/* Modes for 8-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|O_MODES
value|(T_MODES | (1<< (int) O_MODE) | (1<< (int) OF_MODE))
end_define

begin_comment
comment|/* Modes for single-float quantities.  We must allow any single word or    smaller quantity.  This is because the fix/float conversion instructions    take integer inputs/outputs from the float registers.  */
end_comment

begin_define
define|#
directive|define
name|SF_MODES
value|(S_MODES)
end_define

begin_comment
comment|/* Modes for double-float and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_MODES
value|(S_MODES | D_MODES)
end_define

begin_comment
comment|/* Modes for double-float only quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_MODES_NO_S
value|((1<< (int) D_MODE) | (1<< (int) DF_MODE))
end_define

begin_comment
comment|/* Modes for quad-float only quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_ONLY_MODES
value|(1<< (int) TF_MODE)
end_define

begin_comment
comment|/* Modes for quad-float and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_MODES
value|(DF_MODES | TF_ONLY_MODES)
end_define

begin_comment
comment|/* Modes for quad-float and double-float quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_MODES_NO_S
value|(DF_MODES_NO_S | TF_ONLY_MODES)
end_define

begin_comment
comment|/* Modes for quad-float pair only quantities.  */
end_comment

begin_define
define|#
directive|define
name|OF_ONLY_MODES
value|(1<< (int) OF_MODE)
end_define

begin_comment
comment|/* Modes for quad-float pairs and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|OF_MODES
value|(TF_MODES | OF_ONLY_MODES)
end_define

begin_define
define|#
directive|define
name|OF_MODES_NO_S
value|(TF_MODES_NO_S | OF_ONLY_MODES)
end_define

begin_comment
comment|/* Modes for condition codes.  */
end_comment

begin_define
define|#
directive|define
name|CC_MODES
value|(1<< (int) CC_MODE)
end_define

begin_define
define|#
directive|define
name|CCFP_MODES
value|(1<< (int) CCFP_MODE)
end_define

begin_comment
comment|/* Value is 1 if register/mode pair is acceptable on sparc.    The funny mixture of D and T modes is because integer operations    do not specially operate on tetra quantities, so non-quad-aligned    registers can hold quadword quantities (except %o4 and %i4 because    they cross fixed registers).  */
end_comment

begin_comment
comment|/* This points to either the 32 bit or the 64 bit version.  */
end_comment

begin_decl_stmt
specifier|const
name|int
modifier|*
name|hard_regno_mode_classes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|hard_32bit_mode_classes
index|[]
init|=
block|{
name|S_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
comment|/* FP regs f32 to f63.  Only the even numbered registers actually exist,      and none can hold SFmode/SImode values.  */
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|TF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
comment|/* %fcc[0123] */
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
comment|/* %icc */
name|CC_MODES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|hard_64bit_mode_classes
index|[]
init|=
block|{
name|D_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|O_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|O_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
comment|/* FP regs f32 to f63.  Only the even numbered registers actually exist,      and none can hold SFmode/SImode values.  */
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|TF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
comment|/* %fcc[0123] */
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
comment|/* %icc */
name|CC_MODES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sparc_mode_class
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reg_class
name|sparc_regno_reg_class
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sparc_init_modes
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
case|case
name|MODE_COMPLEX_INT
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|<=
literal|4
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|S_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|8
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|D_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|16
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|T_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|32
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|O_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|<=
literal|4
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|SF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|8
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|DF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|16
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|TF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|32
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|OF_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_CC
case|:
default|default:
comment|/* mode_class hasn't been initialized yet for EXTRA_CC_MODES, so 	     we must explicitly check for them here.  */
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|CCFPmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CCFPEmode
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|CCFP_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|CCmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CC_NOOVmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CCXmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CCX_NOOVmode
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|CC_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|TARGET_ARCH64
condition|)
name|hard_regno_mode_classes
operator|=
name|hard_64bit_mode_classes
expr_stmt|;
else|else
name|hard_regno_mode_classes
operator|=
name|hard_32bit_mode_classes
expr_stmt|;
comment|/* Initialize the array used by REGNO_REG_CLASS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|16
operator|&&
name|TARGET_V8PLUS
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|I64_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|32
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|GENERAL_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|64
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|FP_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|96
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|EXTRA_FP_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|100
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|FPCC_REGS
expr_stmt|;
else|else
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save non call used registers from LOW to HIGH at BASE+OFFSET.    N_REGS is the number of 4-byte regs saved thus far.  This applies even to    v9 int regs as it simplifies the code.  */
end_comment

begin_function
specifier|static
name|int
name|save_regs
parameter_list|(
name|file
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|,
name|n_regs
parameter_list|,
name|real_offset
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|n_regs
decl_stmt|;
name|int
name|real_offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|high
operator|<=
literal|32
condition|)
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstx\t%s, [%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|i
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstd\t%s, [%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|i
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t%s, [%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|i
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t%s, [%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
operator|+
literal|4
argument_list|)
expr_stmt|;
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|n_regs
return|;
block|}
end_function

begin_comment
comment|/* Restore non call used registers from LOW to HIGH at BASE+OFFSET.     N_REGS is the number of 4-byte regs saved thus far.  This applies even to    v9 int regs as it simplifies the code.  */
end_comment

begin_function
specifier|static
name|int
name|restore_regs
parameter_list|(
name|file
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|,
name|n_regs
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|n_regs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|high
operator|<=
literal|32
condition|)
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldx\t[%s+%d], %s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
operator|,
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldd\t[%s+%d], %s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
operator|,
name|n_regs
operator|+=
literal|2
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld\t[%s+%d], %s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
operator|,
name|n_regs
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld\t[%s+%d], %s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
operator|+
literal|4
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|,
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|n_regs
return|;
block|}
end_function

begin_comment
comment|/* Compute the frame size required by the function.  This function is called    during the reload pass and also by output_function_prologue().  */
end_comment

begin_function
name|int
name|compute_frame_size
parameter_list|(
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
name|int
name|n_regs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|int
name|outgoing_args_size
init|=
operator|(
name|current_function_outgoing_args_size
operator|+
name|REG_PARM_STACK_SPACE
argument_list|(
name|current_function_decl
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
condition|)
block|{
comment|/* N_REGS is the number of 4-byte regs saved thus far.  This applies 	 even to v9 int regs to be consistent with save_regs/restore_regs.  */
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
operator|(
name|TARGET_V9
condition|?
literal|96
else|:
literal|64
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Set up values for use in `function_epilogue'.  */
name|num_gfregs
operator|=
name|n_regs
expr_stmt|;
if|if
condition|(
name|leaf_function
operator|&&
name|n_regs
operator|==
literal|0
operator|&&
name|size
operator|==
literal|0
operator|&&
name|current_function_outgoing_args_size
operator|==
literal|0
condition|)
block|{
name|actual_fsize
operator|=
name|apparent_fsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We subtract STARTING_FRAME_OFFSET, remember it's negative.          The stack bias (if any) is taken out to undo its effects.  */
name|apparent_fsize
operator|=
operator|(
name|size
operator|-
name|STARTING_FRAME_OFFSET
operator|+
name|SPARC_STACK_BIAS
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
expr_stmt|;
name|apparent_fsize
operator|+=
name|n_regs
operator|*
literal|4
expr_stmt|;
name|actual_fsize
operator|=
name|apparent_fsize
operator|+
operator|(
operator|(
name|outgoing_args_size
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
operator|)
expr_stmt|;
block|}
comment|/* Make sure nothing can clobber our register windows.      If a SAVE must be done, or there is a stack-local variable,      the register window area must be allocated.      ??? For v8 we apparently need an additional 8 bytes of reserved space.  */
if|if
condition|(
name|leaf_function
operator|==
literal|0
operator|||
name|size
operator|>
literal|0
condition|)
name|actual_fsize
operator|+=
operator|(
literal|16
operator|*
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|TARGET_ARCH64
condition|?
literal|0
else|:
literal|8
operator|)
expr_stmt|;
return|return
name|SPARC_STACK_ALIGN
argument_list|(
name|actual_fsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a (32 bit) big number in a register.  */
end_comment

begin_comment
comment|/* ??? We may be able to use the set macro here too.  */
end_comment

begin_function
specifier|static
name|void
name|build_big_number
parameter_list|(
name|file
parameter_list|,
name|num
parameter_list|,
name|reg
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|num
decl_stmt|;
specifier|const
name|char
modifier|*
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|>=
literal|0
operator|||
operator|!
name|TARGET_ARCH64
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi\t%%hi(%d), %s\n"
argument_list|,
name|num
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor\t%s, %%lo(%d), %s\n"
argument_list|,
name|reg
argument_list|,
name|num
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* num< 0&& TARGET_ARCH64 */
block|{
comment|/* Sethi does not sign extend, so we must use a little trickery 	 to use it for negative numbers.  Invert the constant before 	 loading it in, then use xor immediate to invert the loaded bits 	 (along with the upper 32 bits) to the desired constant.  This 	 works because the sethi and immediate fields overlap.  */
name|int
name|asize
init|=
name|num
decl_stmt|;
name|int
name|inv
init|=
operator|~
name|asize
decl_stmt|;
name|int
name|low
init|=
operator|-
literal|0x400
operator|+
operator|(
name|asize
operator|&
literal|0x3FF
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi\t%%hi(%d), %s\n\txor\t%s, %d, %s\n"
argument_list|,
name|inv
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|low
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output any necessary .register pseudo-ops.  */
end_comment

begin_function
name|void
name|sparc_output_scratch_registers
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_AS_REGISTER_PSEUDO_OP
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
return|return;
comment|/* Check if %g[2367] were used without      .register being printed for them already.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|sparc_hard_reg_printed
index|[
name|i
index|]
condition|)
block|{
name|sparc_hard_reg_printed
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.register\t%%g%d, #scratch\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|i
operator|=
literal|5
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This function generates the assembly code for function entry.    FILE is a stdio stream to output the code to.    SIZE is an int: how many units of temporary storage to allocate.    Refer to the array `regs_ever_live' to determine which registers    to save; `regs_ever_live[I]' is nonzero if register number I    is ever used in the function.  This macro is responsible for    knowing which registers should not be saved even if used.  */
end_comment

begin_comment
comment|/* On SPARC, move-double insns between fpu and cpu need an 8-byte block    of memory.  If any fpu reg is used in the function, we allocate    such a block here, at the bottom of the frame, just in case it's needed.     If this function is a leaf procedure, then we may choose not    to do a "save" insn.  The decision about whether or not    to do this is made in regclass.c.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_FLAT
condition|)
name|sparc_flat_function_prologue
argument_list|(
name|file
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|sparc_nonflat_function_prologue
argument_list|(
name|file
argument_list|,
name|size
argument_list|,
name|current_function_uses_only_leaf_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code for the function prologue.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_nonflat_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
name|sparc_output_scratch_registers
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Need to use actual_fsize, since we are also allocating      space for our callee (and our own register save area).  */
name|actual_fsize
operator|=
name|compute_frame_size
argument_list|(
name|size
argument_list|,
name|leaf_function
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaf_function
condition|)
block|{
name|frame_base_name
operator|=
literal|"%sp"
expr_stmt|;
name|frame_base_offset
operator|=
name|actual_fsize
operator|+
name|SPARC_STACK_BIAS
expr_stmt|;
block|}
else|else
block|{
name|frame_base_name
operator|=
literal|"%fp"
expr_stmt|;
name|frame_base_offset
operator|=
name|SPARC_STACK_BIAS
expr_stmt|;
block|}
comment|/* This is only for the human reader.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#PROLOGUE# 0\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_fsize
operator|==
literal|0
condition|)
comment|/* do nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|leaf_function
condition|)
block|{
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave\t%%sp, -%d, %%sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave\t%%sp, -4096, %%sp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%%sp, -%d, %%sp\n"
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|build_big_number
argument_list|(
name|file
argument_list|,
operator|-
name|actual_fsize
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave\t%%sp, %%g1, %%sp\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* leaf function */
block|{
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%%sp, -%d, %%sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%%sp, -4096, %%sp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%%sp, -%d, %%sp\n"
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|build_big_number
argument_list|(
name|file
argument_list|,
operator|-
name|actual_fsize
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%%sp, %%g1, %%sp\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
operator|&&
name|actual_fsize
condition|)
block|{
name|char
modifier|*
name|label
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
comment|/* The canonical frame address refers to the top of the frame.  */
name|dwarf2out_def_cfa
argument_list|(
name|label
argument_list|,
operator|(
name|leaf_function
condition|?
name|STACK_POINTER_REGNUM
else|:
name|FRAME_POINTER_REGNUM
operator|)
argument_list|,
name|frame_base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaf_function
condition|)
block|{
comment|/* Note the register window save.  This tells the unwinder that 	     it needs to restore the window registers from the previous 	     frame's window save area at 0(cfa).  */
name|dwarf2out_window_save
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* The return address (-8) is now in %i7.  */
name|dwarf2out_return_reg
argument_list|(
name|label
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If doing anything with PIC, do it now.  */
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#PROLOGUE# 1\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
comment|/* Call saved registers are saved just above the outgoing argument area.  */
if|if
condition|(
name|num_gfregs
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|real_offset
decl_stmt|,
name|n_regs
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
name|real_offset
operator|=
operator|-
name|apparent_fsize
expr_stmt|;
name|offset
operator|=
operator|-
name|apparent_fsize
operator|+
name|frame_base_offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
operator|-
literal|4096
operator|||
name|offset
operator|+
name|num_gfregs
operator|*
literal|4
operator|>
literal|4096
condition|)
block|{
comment|/* ??? This might be optimized a little as %g1 might already have a 	     value close enough that a single add insn will do.  */
comment|/* ??? Although, all of this is probably only a temporary fix 	     because if %g1 can hold a function result, then 	     output_function_epilogue will lose (the result will get 	     clobbered).  */
name|build_big_number
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%s, %%g1, %%g1\n"
argument_list|,
name|frame_base_name
argument_list|)
expr_stmt|;
name|base
operator|=
literal|"%g1"
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|frame_base_name
expr_stmt|;
block|}
name|n_regs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|&&
operator|!
name|leaf_function
condition|)
comment|/* ??? Originally saved regs 0-15 here.  */
name|n_regs
operator|=
name|save_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|real_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|leaf_function
condition|)
comment|/* ??? Originally saved regs 0-31 here.  */
name|n_regs
operator|=
name|save_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|real_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
condition|)
name|save_regs
argument_list|(
name|file
argument_list|,
literal|32
argument_list|,
name|TARGET_V9
condition|?
literal|96
else|:
literal|64
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|n_regs
argument_list|,
name|real_offset
argument_list|)
expr_stmt|;
block|}
name|leaf_label
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|leaf_function
operator|&&
name|actual_fsize
operator|!=
literal|0
condition|)
block|{
comment|/* warning ("leaf procedure with frame size %d", actual_fsize); */
if|if
condition|(
operator|!
name|TARGET_EPILOGUE
condition|)
name|leaf_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output code to restore any call saved registers.  */
end_comment

begin_function
specifier|static
name|void
name|output_restore_regs
parameter_list|(
name|file
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|,
name|n_regs
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
name|offset
operator|=
operator|-
name|apparent_fsize
operator|+
name|frame_base_offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
operator|-
literal|4096
operator|||
name|offset
operator|+
name|num_gfregs
operator|*
literal|4
operator|>
literal|4096
operator|-
literal|8
comment|/*double*/
condition|)
block|{
name|build_big_number
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%s, %%g1, %%g1\n"
argument_list|,
name|frame_base_name
argument_list|)
expr_stmt|;
name|base
operator|=
literal|"%g1"
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|frame_base_name
expr_stmt|;
block|}
name|n_regs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|&&
operator|!
name|leaf_function
condition|)
comment|/* ??? Originally saved regs 0-15 here.  */
name|n_regs
operator|=
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|leaf_function
condition|)
comment|/* ??? Originally saved regs 0-31 here.  */
name|n_regs
operator|=
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
condition|)
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|32
argument_list|,
name|TARGET_V9
condition|?
literal|96
else|:
literal|64
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|n_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function generates the assembly code for function exit,    on machines that need it.     The function epilogue should not depend on the current stack pointer!    It should use the frame pointer only.  This is mandatory because    of alloca; we also take advantage of it to omit stack adjustments    before returning.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_FLAT
condition|)
name|sparc_flat_function_epilogue
argument_list|(
name|file
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|sparc_nonflat_function_epilogue
argument_list|(
name|file
argument_list|,
name|size
argument_list|,
name|current_function_uses_only_leaf_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code for the function epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_nonflat_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|leaf_label
condition|)
block|{
name|emit_label_after
argument_list|(
name|leaf_label
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_epilogue_delay_list
operator|==
literal|0
condition|)
block|{
comment|/* If code does not drop into the epilogue, we need 	 do nothing except output pending case vectors.  */
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
goto|goto
name|output_vectors
goto|;
block|}
if|if
condition|(
name|num_gfregs
condition|)
name|output_restore_regs
argument_list|(
name|file
argument_list|,
name|leaf_function
argument_list|)
expr_stmt|;
comment|/* Work out how to skip the caller's unimp instruction if required.  */
if|if
condition|(
name|leaf_function
condition|)
name|ret
operator|=
operator|(
name|SKIP_CALLERS_UNIMP_P
condition|?
literal|"jmp\t%o7+12"
else|:
literal|"retl"
operator|)
expr_stmt|;
else|else
name|ret
operator|=
operator|(
name|SKIP_CALLERS_UNIMP_P
condition|?
literal|"jmp\t%i7+12"
else|:
literal|"ret"
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|||
name|leaf_label
condition|)
block|{
name|int
name|old_target_epilogue
init|=
name|TARGET_EPILOGUE
decl_stmt|;
name|target_flags
operator|&=
operator|~
name|old_target_epilogue
expr_stmt|;
if|if
condition|(
operator|!
name|leaf_function
condition|)
block|{
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"\trestore\n\tretl\n\tadd\t%sp, %g1, %sp\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* If we wound up with things in our delay slot, flush them here.  */
elseif|else
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
block|{
name|rtx
name|delay
init|=
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_V9
operator|&&
operator|!
name|epilogue_renumber
argument_list|(
operator|&
name|delay
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|epilogue_renumber
argument_list|(
operator|&
name|delay
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|SKIP_CALLERS_UNIMP_P
condition|?
literal|"\treturn\t%i7+12\n"
else|:
literal|"\treturn\t%i7+8\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|insn
init|=
name|emit_jump_insn_after
argument_list|(
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|delay
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|!=
name|const1_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_SRC
argument_list|(
name|delay
argument_list|)
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|delay
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_V9
operator|&&
operator|!
name|SKIP_CALLERS_UNIMP_P
condition|)
name|fputs
argument_list|(
literal|"\treturn\t%i7+8\n\tnop\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n\trestore\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* All of the following cases are for leaf functions.  */
elseif|else
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
block|{
comment|/* eligible_for_epilogue_delay_slot ensures that if this is a 	     leaf function, then we will only have insn in the delay slot 	     if the frame size is zero, thus no adjust for the stack is 	     needed here.  */
if|if
condition|(
name|actual_fsize
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Output 'nop' instead of 'sub %sp,-0,%sp' when no frame, so as to 	 avoid generating confusing assembly language output.  */
elseif|else
if|if
condition|(
name|actual_fsize
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n\tnop\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n\tsub\t%%sp, -%d, %%sp\n"
argument_list|,
name|ret
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub\t%%sp, -4096, %%sp\n\t%s\n\tsub\t%%sp, -%d, %%sp\n"
argument_list|,
name|ret
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi\t%%hi(%d), %%g1\n\t%s\n\tadd\t%%sp, %%g1, %%sp\n"
argument_list|,
name|actual_fsize
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi\t%%hi(%d), %%g1\n\tor\t%%g1, %%lo(%d), %%g1\n\t%s\n\tadd\t%%sp, %%g1, %%sp\n"
argument_list|,
name|actual_fsize
argument_list|,
name|actual_fsize
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|old_target_epilogue
expr_stmt|;
block|}
name|output_vectors
label|:
name|sparc_output_deferred_case_vectors
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a sibling call.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_sibcall
parameter_list|(
name|insn
parameter_list|,
name|call_operand
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|call_operand
decl_stmt|;
block|{
name|int
name|leaf_regs
init|=
name|current_function_uses_only_leaf_regs
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|delay_slot
init|=
name|dbr_sequence_length
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|num_gfregs
condition|)
block|{
comment|/* Call to restore global regs might clobber 	 the delay slot. Instead of checking for this 	 output the delay slot now.  */
if|if
condition|(
name|delay_slot
condition|)
block|{
name|rtx
name|delay
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|delay
condition|)
name|abort
argument_list|()
expr_stmt|;
name|final_scan_insn
argument_list|(
name|delay
argument_list|,
name|asm_out_file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|delay
argument_list|)
operator|=
name|gen_blockage
argument_list|()
expr_stmt|;
name|INSN_CODE
argument_list|(
name|delay
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|delay_slot
operator|=
literal|0
expr_stmt|;
block|}
name|output_restore_regs
argument_list|(
name|asm_out_file
argument_list|,
name|leaf_regs
argument_list|)
expr_stmt|;
block|}
name|operands
index|[
literal|0
index|]
operator|=
name|call_operand
expr_stmt|;
if|if
condition|(
name|leaf_regs
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_AS_RELAX_OPTION
comment|/* If as and ld are relaxing tail call insns into branch always, 	 use or %o7,%g0,X; call Y; or X,%g0,%o7 always, so that it can 	 be optimized.  With sethi/jmpl as nor ld has no easy way how to 	 find out if somebody does not branch between the sethi and jmpl.  */
name|int
name|spare_slot
init|=
literal|0
decl_stmt|;
else|#
directive|else
name|int
name|spare_slot
init|=
operator|(
operator|(
name|TARGET_ARCH32
operator|||
name|TARGET_CM_MEDLOW
operator|)
operator|&&
operator|!
name|flag_pic
operator|)
decl_stmt|;
endif|#
directive|endif
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|actual_fsize
operator|||
operator|!
name|spare_slot
operator|)
operator|&&
name|delay_slot
condition|)
block|{
name|rtx
name|delay
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|delay
condition|)
name|abort
argument_list|()
expr_stmt|;
name|final_scan_insn
argument_list|(
name|delay
argument_list|,
name|asm_out_file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|delay
argument_list|)
operator|=
name|gen_blockage
argument_list|()
expr_stmt|;
name|INSN_CODE
argument_list|(
name|delay
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|delay_slot
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|actual_fsize
condition|)
block|{
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|size
operator|=
name|actual_fsize
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|fputs
argument_list|(
literal|"\tsub\t%sp, -4096, %sp\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|size
operator|=
name|actual_fsize
operator|-
literal|4096
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tsethi\t%%hi(%d), %%g1\n\tadd\t%%sp, %%g1, %%sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tsethi\t%%hi(%d), %%g1\n\tor\t%%g1, %%lo(%d), %%g1\n"
argument_list|,
name|actual_fsize
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tadd\t%%sp, %%g1, %%sp\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spare_slot
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"sethi\t%%hi(%a0), %%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmpl\t%%g1 + %%lo(%a0), %%g0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t sub\t%%sp, -%d, %%sp\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|delay_slot
condition|)
name|fputs
argument_list|(
literal|"\t nop\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tsub\t%%sp, -%d, %%sp\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Use or with rs2 %%g0 instead of mov, so that as/ld can optimize 	     it into branch if possible.  */
name|output_asm_insn
argument_list|(
literal|"or\t%%o7, %%g0, %%g1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"call\t%a0, 0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" or\t%%g1, %%g0, %%o7"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
name|output_asm_insn
argument_list|(
literal|"call\t%a0, 0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_slot
condition|)
block|{
name|rtx
name|delay
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|pat
decl_stmt|;
if|if
condition|(
operator|!
name|delay
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|pat
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" restore %r1, %2, %Y0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_SUM
case|:
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" restore %r1, %%lo(%a2), %Y0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" restore %r1, %r1, %Y0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|operands
index|[
literal|1
index|]
operator|=
name|pat
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" restore %%g0, %1, %Y0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
block|}
name|PATTERN
argument_list|(
name|delay
argument_list|)
operator|=
name|gen_blockage
argument_list|()
expr_stmt|;
name|INSN_CODE
argument_list|(
name|delay
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"\t restore\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for handling argument passing.     For v8 the first six args are normally in registers and the rest are    pushed.  Any arg that starts within the first 6 words is at least    partially passed in a register unless its data type forbids.     For v9, the argument registers are laid out as an array of 16 elements    and arguments are added sequentially.  The first 6 int args and up to the    first 16 fp args (depending on size) are passed in regs.     Slot    Stack   Integral   Float   Float in structure   Double   Long Double    ----    -----   --------   -----   ------------------   ------   -----------     15   [SP+248]              %f31       %f30,%f31         %d30     14   [SP+240]              %f29       %f28,%f29         %d28       %q28     13   [SP+232]              %f27       %f26,%f27         %d26     12   [SP+224]              %f25       %f24,%f25         %d24       %q24     11   [SP+216]              %f23       %f22,%f23         %d22     10   [SP+208]              %f21       %f20,%f21         %d20       %q20      9   [SP+200]              %f19       %f18,%f19         %d18      8   [SP+192]              %f17       %f16,%f17         %d16       %q16      7   [SP+184]              %f15       %f14,%f15         %d14      6   [SP+176]              %f13       %f12,%f13         %d12       %q12      5   [SP+168]     %o5      %f11       %f10,%f11         %d10      4   [SP+160]     %o4       %f9        %f8,%f9           %d8        %q8      3   [SP+152]     %o3       %f7        %f6,%f7           %d6      2   [SP+144]     %o2       %f5        %f4,%f5           %d4        %q4      1   [SP+136]     %o1       %f3        %f2,%f3           %d2      0   [SP+128]     %o0       %f1        %f0,%f1           %d0        %q0     Here SP = %sp if -mno-stack-bias or %sp+stack_bias otherwise.     Integral arguments are always passed as 64 bit quantities appropriately    extended.     Passing of floating point values is handled as follows.    If a prototype is in scope:      If the value is in a named argument (i.e. not a stdarg function or a      value not part of the `...') then the value is passed in the appropriate      fp reg.      If the value is part of the `...' and is passed in one of the first 6      slots then the value is passed in the appropriate int reg.      If the value is part of the `...' and is not passed in one of the first 6      slots then the value is passed in memory.    If a prototype is not in scope:      If the value is one of the first 6 arguments the value is passed in the      appropriate integer reg and the appropriate fp reg.      If the value is not one of the first 6 arguments the value is passed in      the appropriate fp reg and in memory.    */
end_comment

begin_comment
comment|/* Maximum number of int regs for args.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_INT_ARG_MAX
value|6
end_define

begin_comment
comment|/* Maximum number of fp regs for args.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_FP_ARG_MAX
value|16
end_define

begin_define
define|#
directive|define
name|ROUND_ADVANCE
parameter_list|(
name|SIZE
parameter_list|)
value|(((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
end_define

begin_comment
comment|/* Handle the INIT_CUMULATIVE_ARGS macro.    Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|,
name|indirect
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|indirect
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cum
operator|->
name|words
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|prototype_p
operator|=
name|fntype
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|cum
operator|->
name|libcall_p
operator|=
name|fntype
operator|==
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the slot number to pass an argument in.    Returns the slot number or -1 if passing on the stack.     CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).    INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.    *PREGNO records the register number to use if scalar type.    *PPADDING records the amount of padding needed in words.  */
end_comment

begin_function
specifier|static
name|int
name|function_arg_slotno
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|,
name|incoming_p
parameter_list|,
name|pregno
parameter_list|,
name|ppadding
parameter_list|)
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
name|int
name|incoming_p
decl_stmt|;
name|int
modifier|*
name|pregno
decl_stmt|;
name|int
modifier|*
name|ppadding
decl_stmt|;
block|{
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_INCOMING_INT_ARG_FIRST
else|:
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|slotno
init|=
name|cum
operator|->
name|words
decl_stmt|;
name|int
name|regno
decl_stmt|;
operator|*
name|ppadding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TARGET_ARCH32
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|mode
operator|==
name|BLKmode
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|%
name|PARM_BOUNDARY
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VOIDmode
case|:
comment|/* MODE is VOIDmode when generating the actual call. 	 See emit_call_1.  */
return|return
operator|-
literal|1
return|;
case|case
name|QImode
case|:
case|case
name|CQImode
case|:
case|case
name|HImode
case|:
case|case
name|CHImode
case|:
case|case
name|SImode
case|:
case|case
name|CSImode
case|:
case|case
name|DImode
case|:
case|case
name|CDImode
case|:
case|case
name|TImode
case|:
case|case
name|CTImode
case|:
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
case|case
name|SCmode
case|:
case|case
name|DFmode
case|:
case|case
name|DCmode
case|:
case|case
name|TFmode
case|:
case|case
name|TCmode
case|:
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mode
operator|==
name|TFmode
operator|||
name|mode
operator|==
name|TCmode
operator|)
operator|&&
operator|(
name|slotno
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|slotno
operator|++
operator|,
operator|*
name|ppadding
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_FPU
operator|&&
name|named
condition|)
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_FP_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|SPARC_FP_ARG_FIRST
operator|+
name|slotno
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|regno
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BLKmode
case|:
comment|/* For sparc64, objects requiring 16 byte alignment get it.  */
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
if|if
condition|(
name|type
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|==
literal|128
operator|&&
operator|(
name|slotno
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|slotno
operator|++
operator|,
operator|*
name|ppadding
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ARCH32
operator|||
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
block|}
else|else
block|{
name|tree
name|field
decl_stmt|;
name|int
name|intregs_p
init|=
literal|0
decl_stmt|,
name|fpregs_p
init|=
literal|0
decl_stmt|;
comment|/* The ABI obviously doesn't specify how packed 	     structures are passed.  These are defined to be passed 	     in int regs if possible, otherwise memory.  */
name|int
name|packed_p
init|=
literal|0
decl_stmt|;
comment|/* First see what kinds of registers we need.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TARGET_FPU
condition|)
name|fpregs_p
operator|=
literal|1
expr_stmt|;
else|else
name|intregs_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
name|packed_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|packed_p
operator|||
operator|!
name|named
condition|)
name|fpregs_p
operator|=
literal|0
operator|,
name|intregs_p
operator|=
literal|1
expr_stmt|;
comment|/* If all arg slots are filled, then must pass on stack.  */
if|if
condition|(
name|fpregs_p
operator|&&
name|slotno
operator|>=
name|SPARC_FP_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If there are only int args and all int arg slots are filled, 	     then must pass on stack.  */
if|if
condition|(
operator|!
name|fpregs_p
operator|&&
name|intregs_p
operator|&&
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Note that even if all int arg slots are filled, fp members may 	     still be passed in regs if such regs are available. 	     *PREGNO isn't set because there may be more than one, it's up 	     to the caller to compute them.  */
return|return
name|slotno
return|;
block|}
break|break;
default|default :
name|abort
argument_list|()
expr_stmt|;
block|}
operator|*
name|pregno
operator|=
name|regno
expr_stmt|;
return|return
name|slotno
return|;
block|}
end_function

begin_comment
comment|/* Handle recursive register counting for structure field layout.  */
end_comment

begin_struct
struct|struct
name|function_arg_record_value_parms
block|{
name|rtx
name|ret
decl_stmt|;
name|int
name|slotno
decl_stmt|,
name|named
decl_stmt|,
name|regbase
decl_stmt|;
name|unsigned
name|int
name|nregs
decl_stmt|;
name|int
name|intoffset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|function_arg_record_value_3
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|,
expr|struct
name|function_arg_record_value_parms
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|function_arg_record_value_2
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|HOST_WIDE_INT
operator|,
expr|struct
name|function_arg_record_value_parms
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|function_arg_record_value_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|HOST_WIDE_INT
operator|,
expr|struct
name|function_arg_record_value_parms
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|function_arg_record_value
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A subroutine of function_arg_record_value.  Traverse the structure    recusively and determine how many registers will be required.  */
end_comment

begin_function
specifier|static
name|void
name|function_arg_record_value_1
parameter_list|(
name|type
parameter_list|,
name|startbitpos
parameter_list|,
name|parms
parameter_list|)
name|tree
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|startbitpos
decl_stmt|;
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
comment|/* The ABI obviously doesn't specify how packed structures are      passed.  These are defined to be passed in int regs if possible,      otherwise memory.  */
name|int
name|packed_p
init|=
literal|0
decl_stmt|;
comment|/* We need to compute how many registers are needed so we can      allocate the PARALLEL but before we can do that we need to know      whether there are any packed fields.  If there are, int regs are      used regardless of whether there are fp values present.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|packed_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Compute how many registers we need.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|HOST_WIDE_INT
name|bitpos
init|=
name|startbitpos
decl_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|bitpos
operator|+=
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* ??? FIXME: else assume zero offset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|function_arg_record_value_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|parms
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TARGET_FPU
operator|&&
operator|!
name|packed_p
operator|&&
name|parms
operator|->
name|named
condition|)
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|intslots
decl_stmt|,
name|this_slotno
decl_stmt|;
name|intslots
operator|=
operator|(
name|bitpos
operator|-
name|parms
operator|->
name|intoffset
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|parms
operator|->
name|slotno
operator|+
name|parms
operator|->
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
name|MIN
argument_list|(
name|intslots
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
name|intslots
operator|=
name|MAX
argument_list|(
name|intslots
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
name|intslots
expr_stmt|;
name|parms
operator|->
name|intoffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* There's no need to check this_slotno< SPARC_FP_ARG MAX. 		 If it wasn't true we wouldn't be here.  */
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
name|parms
operator|->
name|intoffset
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of function_arg_record_value.  Assign the bits of the    structure between parms->intoffset and bitpos to integer registers.  */
end_comment

begin_function
specifier|static
name|void
name|function_arg_record_value_3
parameter_list|(
name|bitpos
parameter_list|,
name|parms
parameter_list|)
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|startbit
decl_stmt|,
name|endbit
decl_stmt|;
name|int
name|this_slotno
decl_stmt|,
name|intslots
decl_stmt|,
name|intoffset
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
return|return;
name|intoffset
operator|=
name|parms
operator|->
name|intoffset
expr_stmt|;
name|parms
operator|->
name|intoffset
operator|=
operator|-
literal|1
expr_stmt|;
name|startbit
operator|=
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|endbit
operator|=
operator|(
name|bitpos
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
operator|(
name|endbit
operator|-
name|startbit
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|parms
operator|->
name|slotno
operator|+
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
name|MIN
argument_list|(
name|intslots
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
if|if
condition|(
name|intslots
operator|<=
literal|0
condition|)
return|return;
comment|/* If this is the trailing part of a word, only load that much into      the register.  Otherwise load the whole register.  Note that in      the latter case we may pick up unwanted bits.  It's not a problem      at the moment but may wish to revisit.  */
if|if
condition|(
name|intoffset
operator|%
name|BITS_PER_WORD
operator|!=
literal|0
condition|)
name|mode
operator|=
name|mode_for_size
argument_list|(
name|BITS_PER_WORD
operator|-
name|intoffset
operator|%
name|BITS_PER_WORD
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|word_mode
expr_stmt|;
name|intoffset
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
do|do
block|{
name|regno
operator|=
name|parms
operator|->
name|regbase
operator|+
name|this_slotno
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|parms
operator|->
name|ret
argument_list|,
literal|0
argument_list|,
name|parms
operator|->
name|nregs
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|intoffset
argument_list|)
argument_list|)
expr_stmt|;
name|this_slotno
operator|+=
literal|1
expr_stmt|;
name|intoffset
operator|=
operator|(
name|intoffset
operator||
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
name|intslots
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|intslots
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* A subroutine of function_arg_record_value.  Traverse the structure    recursively and assign bits to floating point registers.  Track which    bits in between need integer registers; invoke function_arg_record_value_3    to make that happen.  */
end_comment

begin_function
specifier|static
name|void
name|function_arg_record_value_2
parameter_list|(
name|type
parameter_list|,
name|startbitpos
parameter_list|,
name|parms
parameter_list|)
name|tree
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|startbitpos
decl_stmt|;
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
name|int
name|packed_p
init|=
literal|0
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|packed_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|HOST_WIDE_INT
name|bitpos
init|=
name|startbitpos
decl_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|bitpos
operator|+=
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* ??? FIXME: else assume zero offset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|function_arg_record_value_2
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|parms
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TARGET_FPU
operator|&&
operator|!
name|packed_p
operator|&&
name|parms
operator|->
name|named
condition|)
block|{
name|int
name|this_slotno
init|=
name|parms
operator|->
name|slotno
operator|+
name|bitpos
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|function_arg_record_value_3
argument_list|(
name|bitpos
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DECL_MODE
argument_list|(
name|field
argument_list|)
argument_list|,
operator|(
name|SPARC_FP_ARG_FIRST
operator|+
name|this_slotno
operator|*
literal|2
operator|+
operator|(
name|DECL_MODE
argument_list|(
name|field
argument_list|)
operator|==
name|SFmode
operator|&&
operator|(
name|bitpos
operator|&
literal|32
operator|)
operator|!=
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|parms
operator|->
name|ret
argument_list|,
literal|0
argument_list|,
name|parms
operator|->
name|nregs
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
name|parms
operator|->
name|intoffset
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Used by function_arg and function_value to implement the complex    Sparc64 structure calling conventions.  */
end_comment

begin_function
specifier|static
name|rtx
name|function_arg_record_value
parameter_list|(
name|type
parameter_list|,
name|mode
parameter_list|,
name|slotno
parameter_list|,
name|named
parameter_list|,
name|regbase
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|slotno
decl_stmt|,
name|named
decl_stmt|,
name|regbase
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|typesize
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|function_arg_record_value_parms
name|parms
decl_stmt|;
name|unsigned
name|int
name|nregs
decl_stmt|;
name|parms
operator|.
name|ret
operator|=
name|NULL_RTX
expr_stmt|;
name|parms
operator|.
name|slotno
operator|=
name|slotno
expr_stmt|;
name|parms
operator|.
name|named
operator|=
name|named
expr_stmt|;
name|parms
operator|.
name|regbase
operator|=
name|regbase
expr_stmt|;
comment|/* Compute how many registers we need.  */
name|parms
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
name|parms
operator|.
name|intoffset
operator|=
literal|0
expr_stmt|;
name|function_arg_record_value_1
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|.
name|intoffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|startbit
decl_stmt|,
name|endbit
decl_stmt|;
name|int
name|intslots
decl_stmt|,
name|this_slotno
decl_stmt|;
name|startbit
operator|=
name|parms
operator|.
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|endbit
operator|=
operator|(
name|typesize
operator|*
name|BITS_PER_UNIT
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
operator|(
name|endbit
operator|-
name|startbit
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|slotno
operator|+
name|parms
operator|.
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
name|MIN
argument_list|(
name|intslots
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
name|intslots
operator|=
name|MAX
argument_list|(
name|intslots
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|.
name|nregs
operator|+=
name|intslots
expr_stmt|;
block|}
name|nregs
operator|=
name|parms
operator|.
name|nregs
expr_stmt|;
comment|/* Allocate the vector and handle some annoying special cases.  */
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
block|{
comment|/* ??? Empty structure has no value?  Duh?  */
if|if
condition|(
name|typesize
operator|<=
literal|0
condition|)
block|{
comment|/* Though there's nothing really to store, return a word register 	     anyway so the rest of gcc doesn't go nuts.  Returning a PARALLEL 	     leads to breakage due to the fact that there are zero bytes to 	     load.  */
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regbase
argument_list|)
return|;
block|}
else|else
block|{
comment|/* ??? C++ has structures with no fields, and yet a size.  Give up 	     for now and pass everything back in integer registers.  */
name|nregs
operator|=
operator|(
name|typesize
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|+
name|slotno
operator|>
name|SPARC_INT_ARG_MAX
condition|)
name|nregs
operator|=
name|SPARC_INT_ARG_MAX
operator|-
name|slotno
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|parms
operator|.
name|ret
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the entries.  */
name|parms
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
name|parms
operator|.
name|intoffset
operator|=
literal|0
expr_stmt|;
name|function_arg_record_value_2
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
name|function_arg_record_value_3
argument_list|(
name|typesize
operator|*
name|BITS_PER_UNIT
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|.
name|nregs
operator|!=
name|nregs
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|parms
operator|.
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG macro.    Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).    INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|,
name|incoming_p
parameter_list|)
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
name|int
name|incoming_p
decl_stmt|;
block|{
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_INCOMING_INT_ARG_FIRST
else|:
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
name|incoming_p
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotno
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* v9 fp args in reg slots beyond the int reg slots get passed in regs      but also have the slot allocated for them.      If no prototype is in scope fp values in register slots get passed      in two places, either fp regs and int regs or fp regs and memory.  */
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|)
operator|&&
name|SPARC_FP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|prototype_p
operator|||
name|cum
operator|->
name|libcall_p
condition|)
block|{
comment|/* "* 2" because fp reg numbers are recorded in 4 byte 	     quantities.  */
if|#
directive|if
literal|0
comment|/* ??? This will cause the value to be passed in the fp reg and 	     in the stack.  When a prototype exists we want to pass the 	     value in the reg but reserve space on the stack.  That's an 	     optimization, and is deferred [for a bit].  */
block|if ((regno - SPARC_FP_ARG_FIRST)>= SPARC_INT_ARG_MAX * 2) 	    return gen_rtx_PARALLEL (mode, 			    gen_rtvec (2, 				       gen_rtx_EXPR_LIST (VOIDmode, 						NULL_RTX, const0_rtx), 				       gen_rtx_EXPR_LIST (VOIDmode, 						reg, const0_rtx))); 	  else
else|#
directive|else
comment|/* ??? It seems that passing back a register even when past 	     the area declared by REG_PARM_STACK_SPACE will allocate 	     space appropriately, and will not copy the data onto the 	     stack, exactly as we desire.  	     This is due to locate_and_pad_parm being called in 	     expand_call whenever reg_parm_stack_space> 0, which 	     while benefical to our example here, would seem to be 	     in error from what had been intended.  Ho hum...  -- r~ */
endif|#
directive|endif
return|return
name|reg
return|;
block|}
else|else
block|{
name|rtx
name|v0
decl_stmt|,
name|v1
decl_stmt|;
if|if
condition|(
operator|(
name|regno
operator|-
name|SPARC_FP_ARG_FIRST
operator|)
operator|<
name|SPARC_INT_ARG_MAX
operator|*
literal|2
condition|)
block|{
name|int
name|intreg
decl_stmt|;
comment|/* On incoming, we don't need to know that the value 		 is passed in %f0 and %i0, and it confuses other parts 		 causing needless spillage even on the simplest cases.  */
if|if
condition|(
name|incoming_p
condition|)
return|return
name|reg
return|;
name|intreg
operator|=
operator|(
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|+
operator|(
name|regno
operator|-
name|SPARC_FP_ARG_FIRST
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|v0
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|v1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|v0
argument_list|,
name|v1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|v0
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|v1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|v0
argument_list|,
name|v1
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
comment|/* Structures up to 16 bytes in size are passed in arg slots on the 	 stack and are promoted to registers where possible.  */
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* shouldn't get here */
return|return
name|function_arg_record_value
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
name|slotno
argument_list|,
name|named
argument_list|,
name|regbase
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Scalar or complex int.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_PARTIAL_NREGS macro.    For an arg passed partly in registers and partly in memory,    this is the number of registers used.    For args passed entirely in registers or entirely in memory, zero.     Any arg that starts in the first 6 regs but won't entirely fit in them    needs partial registers on v8.  On v9, structures with integer    values in arg slots 5,6 will be passed in %o5 and SP+176, and complex fp    values that begin in the last fp reg [where "last fp reg" varies with the    mode] will be split between that reg and memory.  */
end_comment

begin_function
name|int
name|function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
comment|/* We pass 0 for incoming_p here, it doesn't matter.  */
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
literal|0
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotno
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
if|if
condition|(
operator|(
name|slotno
operator|+
operator|(
name|mode
operator|==
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
operator|)
operator|>
name|NPARM_REGS
argument_list|(
name|SImode
argument_list|)
condition|)
return|return
name|NPARM_REGS
argument_list|(
name|SImode
argument_list|)
operator|-
name|slotno
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|16
condition|)
name|slotno
operator|+=
name|slotno
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
operator|&&
name|size
operator|<=
literal|16
operator|&&
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|1
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|&&
operator|!
name|TARGET_FPU
operator|)
condition|)
block|{
if|if
condition|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|128
condition|)
block|{
name|slotno
operator|+=
name|slotno
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|2
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|1
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
if|if
condition|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|128
condition|)
name|slotno
operator|+=
name|slotno
operator|&
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|slotno
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|>
name|SPARC_FP_ARG_MAX
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_PASS_BY_REFERENCE macro.    !v9: The SPARC ABI stipulates passing struct arguments (of any size) and    quad-precision floats by invisible reference.    v9: Aggregates greater than 16 bytes are passed by reference.    For Pascal, also pass arrays by reference.  */
end_comment

begin_function
name|int
name|function_arg_pass_by_reference
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
return|return
operator|(
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|mode
operator|==
name|TFmode
operator|||
name|mode
operator|==
name|TCmode
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
comment|/* Consider complex values as aggregates, so care for TCmode.  */
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|16
operator|||
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|16
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_ADVANCE macro.    Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    TYPE is null for libcalls where that information may not be available.  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
comment|/* We pass 0 for incoming_p here, it doesn't matter.  */
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
literal|0
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
comment|/* If register required leading padding, add it.  */
if|if
condition|(
name|slotno
operator|!=
operator|-
literal|1
condition|)
name|cum
operator|->
name|words
operator|+=
name|padding
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|cum
operator|->
name|words
operator|+=
operator|(
name|mode
operator|!=
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|8
condition|)
operator|++
name|cum
operator|->
name|words
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
literal|16
condition|)
name|cum
operator|->
name|words
operator|+=
literal|2
expr_stmt|;
else|else
comment|/* passed by reference */
operator|++
name|cum
operator|->
name|words
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|cum
operator|->
name|words
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
name|cum
operator|->
name|words
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
block|{
name|cum
operator|->
name|words
operator|+=
operator|(
name|mode
operator|!=
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_PADDING macro.    For the 64 bit ABI structs are always stored left shifted in their    argument slot.  */
end_comment

begin_function
name|enum
name|direction
name|function_arg_padding
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|upward
return|;
comment|/* This is the default definition.  */
return|return
operator|(
operator|!
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
operator|(
operator|(
name|mode
operator|==
name|BLKmode
condition|?
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|PARM_BOUNDARY
operator|)
condition|?
name|downward
else|:
name|upward
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE, and LIBCALL_VALUE macros.    For v9, function return values are subject to the same rules as arguments,    except that up to 32-bytes may be returned in registers.  */
end_comment

begin_function
name|rtx
name|function_value
parameter_list|(
name|type
parameter_list|,
name|mode
parameter_list|,
name|incoming_p
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|incoming_p
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_OUTGOING_INT_ARG_FIRST
else|:
name|SPARC_INCOMING_INT_ARG_FIRST
operator|)
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
comment|/* Structures up to 32 bytes in size are passed in registers, 	     promoted to fp registers where possible.  */
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* shouldn't get here */
return|return
name|function_arg_record_value
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|regbase
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* All other aggregate types are passed in an integer register 	     in a mode corresponding to the size of the type.  */
name|HOST_WIDE_INT
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|&&
name|type
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|mode
operator|=
name|DImode
expr_stmt|;
if|if
condition|(
name|incoming_p
condition|)
name|regno
operator|=
name|BASE_RETURN_VALUE_REG
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|regno
operator|=
name|BASE_OUTGOING_VALUE_REG
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do what is necessary for `va_start'.  We look at the current function    to determine if stdarg or varargs is used and return the address of    the first unnamed parameter.  */
end_comment

begin_function
name|rtx
name|sparc_builtin_saveregs
parameter_list|()
block|{
name|int
name|first_reg
init|=
name|current_function_args_info
operator|.
name|words
decl_stmt|;
name|rtx
name|address
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|first_reg
init|;
name|regno
operator|<
name|NPARM_REGS
argument_list|(
name|word_mode
argument_list|)
condition|;
name|regno
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|STACK_POINTER_OFFSET
operator|+
operator|(
name|UNITS_PER_WORD
operator|*
name|regno
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|BASE_INCOMING_ARG_REG
argument_list|(
name|word_mode
argument_list|)
operator|+
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|STACK_POINTER_OFFSET
operator|+
name|UNITS_PER_WORD
operator|*
name|first_reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|address
return|;
block|}
end_function

begin_comment
comment|/* Implement `va_start' for varargs and stdarg.  */
end_comment

begin_function
name|void
name|sparc_va_start
parameter_list|(
name|stdarg_p
parameter_list|,
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|int
name|stdarg_p
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
decl_stmt|;
block|{
name|nextarg
operator|=
name|expand_builtin_saveregs
argument_list|()
expr_stmt|;
name|std_expand_builtin_va_start
argument_list|(
literal|1
argument_list|,
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement `va_arg'.  */
end_comment

begin_function
name|rtx
name|sparc_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|,
name|type
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|rsize
decl_stmt|,
name|align
decl_stmt|;
name|tree
name|addr
decl_stmt|,
name|incr
decl_stmt|;
name|rtx
name|addr_rtx
decl_stmt|;
name|int
name|indirect
init|=
literal|0
decl_stmt|;
comment|/* Round up sizeof(type) to a word.  */
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rsize
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|UNITS_PER_WORD
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
literal|2
operator|*
operator|(
name|unsigned
operator|)
name|BITS_PER_WORD
condition|)
name|align
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|16
condition|)
block|{
name|indirect
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|rsize
operator|=
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
name|size
operator|=
name|rsize
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TCmode
condition|)
block|{
name|indirect
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|rsize
operator|=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
name|incr
operator|=
name|valist
expr_stmt|;
if|if
condition|(
name|align
condition|)
block|{
name|incr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|incr
argument_list|,
name|build_int_2
argument_list|(
name|align
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|incr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|incr
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|align
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|incr
operator|=
name|save_expr
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|size
operator|<
name|rsize
condition|)
block|{
name|addr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|incr
argument_list|,
name|build_int_2
argument_list|(
name|rsize
operator|-
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|incr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|incr
argument_list|,
name|build_int_2
argument_list|(
name|rsize
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|incr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|valist
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|incr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|incr
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|addr_rtx
operator|=
name|expand_expr
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* If the address isn't aligned properly for the type,      we may need to copy to a temporary.        FIXME: This is inefficient.  Usually we can do this      in registers.  */
if|if
condition|(
name|align
operator|==
literal|0
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|BITS_PER_WORD
operator|&&
operator|!
name|indirect
condition|)
block|{
comment|/* FIXME: We really need to specify that the temporary is live 	 for the whole function because expand_builtin_va_arg wants 	 the alias set to be get_varargs_alias_set (), but in this 	 case the alias set is that for TYPE and if the memory gets 	 reused it will be reused with alias set TYPE.  */
name|rtx
name|tmp
init|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|addr_rtx
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|addr_rtx
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr_rtx
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|addr_rtx
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|shallow_copy_rtx
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|tmp
argument_list|,
name|BLKmode
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|emit_block_move
argument_list|(
name|tmp
argument_list|,
name|addr_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|rsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_addr
operator|!=
name|NULL_RTX
condition|)
name|addr_rtx
operator|=
name|dest_addr
expr_stmt|;
else|else
name|addr_rtx
operator|=
name|XCEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indirect
condition|)
block|{
name|addr_rtx
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|addr_rtx
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr_rtx
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|addr_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, which is    the operand number of the label.  OP is the conditional expression.    XEXP (OP, 0) is assumed to be a condition code register (integer or    floating point) and its mode specifies what kind of comparison we made.     REVERSED is non-zero if we should reverse the sense of the comparison.     ANNUL is non-zero if we should generate an annulling branch.     NOOP is non-zero if we have to follow this branch by a noop.     INSN, if set, is the insn.  */
end_comment

begin_function
name|char
modifier|*
name|output_cbranch
parameter_list|(
name|op
parameter_list|,
name|label
parameter_list|,
name|reversed
parameter_list|,
name|annul
parameter_list|,
name|noop
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|label
decl_stmt|;
name|int
name|reversed
decl_stmt|,
name|annul
decl_stmt|,
name|noop
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|32
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
decl_stmt|;
specifier|static
name|char
name|v8_labelno
index|[]
init|=
literal|"%lX"
decl_stmt|;
specifier|static
name|char
name|v9_icc_labelno
index|[]
init|=
literal|"%%icc, %lX"
decl_stmt|;
specifier|static
name|char
name|v9_xcc_labelno
index|[]
init|=
literal|"%%xcc, %lX"
decl_stmt|;
specifier|static
name|char
name|v9_fcc_labelno
index|[]
init|=
literal|"%%fccX, %lY"
decl_stmt|;
name|char
modifier|*
name|labelno
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch
decl_stmt|;
name|int
name|labeloff
decl_stmt|,
name|spaces
init|=
literal|8
decl_stmt|;
if|if
condition|(
name|reversed
condition|)
block|{
comment|/* Reversal of FP compares takes care -- an ordered compare 	 becomes an unordered compare and vice versa.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Start by writing the branch condition.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
name|branch
operator|=
literal|"fbne"
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|branch
operator|=
literal|"fbe"
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|branch
operator|=
literal|"fbge"
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|branch
operator|=
literal|"fbg"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|branch
operator|=
literal|"fble"
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|branch
operator|=
literal|"fbl"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|branch
operator|=
literal|"fbu"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|branch
operator|=
literal|"fbo"
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
name|branch
operator|=
literal|"fbug"
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|branch
operator|=
literal|"fbul"
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|branch
operator|=
literal|"fbue"
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|branch
operator|=
literal|"fbuge"
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|branch
operator|=
literal|"fbule"
expr_stmt|;
break|break;
case|case
name|LTGT
case|:
name|branch
operator|=
literal|"fblg"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* ??? !v9: FP branches cannot be preceded by another floating point 	 insn.  Because there is currently no concept of pre-delay slots, 	 we can fix this only by always emitting a nop before a floating 	 point branch.  */
name|string
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_V9
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"nop\n\t"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
name|branch
operator|=
literal|"bne"
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|branch
operator|=
literal|"be"
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|mode
operator|==
name|CC_NOOVmode
condition|)
name|branch
operator|=
literal|"bpos"
expr_stmt|;
else|else
name|branch
operator|=
literal|"bge"
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|branch
operator|=
literal|"bg"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|branch
operator|=
literal|"ble"
expr_stmt|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|mode
operator|==
name|CC_NOOVmode
condition|)
name|branch
operator|=
literal|"bneg"
expr_stmt|;
else|else
name|branch
operator|=
literal|"bl"
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|branch
operator|=
literal|"bgeu"
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|branch
operator|=
literal|"bgu"
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|branch
operator|=
literal|"bleu"
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|branch
operator|=
literal|"blu"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|string
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
name|spaces
operator|-=
name|strlen
argument_list|(
name|branch
argument_list|)
expr_stmt|;
comment|/* Now add the annulling, the label, and a possible noop.  */
if|if
condition|(
name|annul
condition|)
block|{
name|strcat
argument_list|(
name|string
argument_list|,
literal|",a"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_V9
condition|)
block|{
name|labeloff
operator|=
literal|2
expr_stmt|;
name|labelno
operator|=
name|v8_labelno
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|insn
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PRED
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|string
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&
name|ATTR_FLAG_likely
condition|?
literal|",pt"
else|:
literal|",pn"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|3
expr_stmt|;
block|}
name|labeloff
operator|=
literal|9
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
name|labeloff
operator|=
literal|10
expr_stmt|;
name|labelno
operator|=
name|v9_fcc_labelno
expr_stmt|;
comment|/* Set the char indicating the number of the fcc reg to use.  */
name|labelno
index|[
literal|5
index|]
operator|=
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
operator|-
name|SPARC_FIRST_V9_FCC_REG
operator|+
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCXmode
operator|||
name|mode
operator|==
name|CCX_NOOVmode
condition|)
name|labelno
operator|=
name|v9_xcc_labelno
expr_stmt|;
else|else
name|labelno
operator|=
name|v9_icc_labelno
expr_stmt|;
block|}
comment|/* Set the char indicating the number of the operand containing the      label_ref.  */
name|labelno
index|[
name|labeloff
index|]
operator|=
name|label
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|spaces
operator|>
literal|0
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
if|if
condition|(
name|noop
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Emit a library call comparison between floating point X and Y.    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).    TARGET_ARCH64 uses _Qp_* functions, which use pointers to TFmode    values as arguments instead of the TFmode registers themselves,    that's why we cannot call emit_float_lib_cmp.  */
end_comment

begin_function
name|void
name|sparc_emit_float_lib_cmp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|comparison
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|rtx_code
name|comparison
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|qpfunc
decl_stmt|;
name|rtx
name|slot0
decl_stmt|,
name|slot1
decl_stmt|,
name|result
decl_stmt|,
name|tem
decl_stmt|,
name|tem2
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_feq"
else|:
literal|"_Q_feq"
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_fne"
else|:
literal|"_Q_fne"
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_fgt"
else|:
literal|"_Q_fgt"
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_fge"
else|:
literal|"_Q_fge"
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_flt"
else|:
literal|"_Q_flt"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_fle"
else|:
literal|"_Q_fle"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
case|case
name|UNGT
case|:
case|case
name|UNLT
case|:
case|case
name|UNEQ
case|:
case|case
name|UNGE
case|:
case|case
name|UNLE
case|:
case|case
name|LTGT
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_cmp"
else|:
literal|"_Q_cmp"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|slot0
operator|=
name|assign_stack_temp
argument_list|(
name|TFmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|TFmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|slot0
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|slot0
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|slot1
operator|=
name|assign_stack_temp
argument_list|(
name|TFmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|TFmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|slot1
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|slot1
operator|=
name|y
expr_stmt|;
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|qpfunc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|DImode
argument_list|,
literal|2
argument_list|,
name|XEXP
argument_list|(
name|slot0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|slot1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
block|}
else|else
block|{
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|qpfunc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|SImode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|TFmode
argument_list|,
name|y
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
block|}
comment|/* Immediately move the result of the libcall into a pseudo      register so reload doesn't clobber the value if it needs      the return register for a spill reg.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|hard_libcall_value
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
default|default:
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|comparison
operator|==
name|UNORDERED
condition|?
name|EQ
else|:
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const1_rtx
argument_list|,
name|comparison
operator|==
name|UNGT
condition|?
name|GT
else|:
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const2_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tem
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|tem
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|tem
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|tem
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|tem
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tem2
argument_list|,
name|tem
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|tem2
argument_list|,
name|tem
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|tem2
argument_list|,
name|const0_rtx
argument_list|,
name|comparison
operator|==
name|UNEQ
condition|?
name|EQ
else|:
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, testing    register REG.  LABEL is the operand number of the label; REG is the    operand number of the reg.  OP is the conditional expression.  The mode    of REG says what kind of comparison we made.     REVERSED is non-zero if we should reverse the sense of the comparison.     ANNUL is non-zero if we should generate an annulling branch.     NOOP is non-zero if we have to follow this branch by a noop.  */
end_comment

begin_function
name|char
modifier|*
name|output_v9branch
parameter_list|(
name|op
parameter_list|,
name|reg
parameter_list|,
name|label
parameter_list|,
name|reversed
parameter_list|,
name|annul
parameter_list|,
name|noop
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|label
decl_stmt|;
name|int
name|reversed
decl_stmt|,
name|annul
decl_stmt|,
name|noop
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|static
name|char
name|labelno
index|[]
init|=
literal|"%X, %lX"
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|spaces
init|=
literal|8
decl_stmt|;
comment|/* If not floating-point or if EQ or NE, we can just reverse the code.  */
if|if
condition|(
name|reversed
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|reversed
operator|=
literal|0
expr_stmt|;
comment|/* Only 64 bit versions of these instructions exist.  */
if|if
condition|(
name|mode
operator|!=
name|DImode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Start by writing the branch condition.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brnz"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brz"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|3
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brgez"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|5
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brlz"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brlez"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|5
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brgz"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|4
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now add the annulling, reg, label, and nop.  */
if|if
condition|(
name|annul
condition|)
block|{
name|strcat
argument_list|(
name|string
argument_list|,
literal|",a"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PRED
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|string
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&
name|ATTR_FLAG_likely
condition|?
literal|",pt"
else|:
literal|",pn"
argument_list|)
expr_stmt|;
name|spaces
operator|-=
literal|3
expr_stmt|;
block|}
name|labelno
index|[
literal|1
index|]
operator|=
name|reg
operator|+
literal|'0'
expr_stmt|;
name|labelno
index|[
literal|6
index|]
operator|=
name|label
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|spaces
operator|>
literal|0
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
if|if
condition|(
name|noop
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return 1, if any of the registers of the instruction are %l[0-7] or %o[0-7].    Such instructions cannot be used in the delay slot of return insn on v9.    If TEST is 0, also rename all %i[0-7] registers to their %o[0-7] counterparts.  */
end_comment

begin_function
specifier|static
name|int
name|epilogue_renumber
parameter_list|(
name|where
parameter_list|,
name|test
parameter_list|)
specifier|register
name|rtx
modifier|*
name|where
decl_stmt|;
name|int
name|test
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
operator|*
name|where
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
operator|*
name|where
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
operator|>=
literal|8
operator|&&
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
operator|<
literal|24
condition|)
comment|/* oX or lX */
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|test
operator|&&
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
operator|<
literal|32
condition|)
operator|*
name|where
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|where
argument_list|)
argument_list|,
name|OUTGOING_REGNO
argument_list|(
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|SCRATCH
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
return|return
literal|0
return|;
comment|/* Do not replace the frame pointer with the stack pointer because 	 it can cause the delayed instruction to load below the stack. 	 This occurs when instructions like:  	 (set (reg/i:SI 24 %i0) 	     (mem/f:SI (plus:SI (reg/f:SI 30 %fp)                        (const_int -20 [0xffffffec])) 0))  	 are in the return delayed slot.  */
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|SPARC_STACK_BIAS
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|MEM
case|:
if|if
condition|(
name|SPARC_STACK_BIAS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
operator|*
name|where
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|epilogue_renumber
argument_list|(
operator|&
operator|(
name|XVECEXP
argument_list|(
operator|*
name|where
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|)
argument_list|,
name|test
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|epilogue_renumber
argument_list|(
operator|&
operator|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
name|i
argument_list|)
operator|)
argument_list|,
name|test
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to return from a function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_return
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|delay
init|=
name|final_sequence
condition|?
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|leaf_label
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|leaf_label
expr_stmt|;
return|return
literal|"b%* %l0%("
return|;
block|}
elseif|else
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
block|{
comment|/* No delay slot in a leaf function.  */
if|if
condition|(
name|delay
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we didn't allocate a frame pointer for the current function, 	 the stack pointer might have been adjusted.  Output code to 	 restore it now.  */
name|operands
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|actual_fsize
argument_list|)
expr_stmt|;
comment|/* Use sub of negated value in first two cases instead of add to 	 allow actual_fsize == 4096.  */
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
block|{
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
return|return
literal|"jmp\t%%o7+12\n\tsub\t%%sp, -%0, %%sp"
return|;
else|else
return|return
literal|"retl\n\tsub\t%%sp, -%0, %%sp"
return|;
block|}
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
return|return
literal|"sub\t%%sp, -4096, %%sp\n\tjmp\t%%o7+12\n\tsub\t%%sp, -%0, %%sp"
return|;
else|else
return|return
literal|"sub\t%%sp, -4096, %%sp\n\tretl\n\tsub\t%%sp, -%0, %%sp"
return|;
block|}
elseif|else
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
block|{
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi\t%%hi(%a0), %%g1\n\tor\t%%g1, %%lo(%a0), %%g1\n\tjmp\t%%o7+12\n\tadd\t%%sp, %%g1, %%sp"
return|;
else|else
return|return
literal|"sethi\t%%hi(%a0), %%g1\n\tjmp\t%%o7+12\n\tadd\t%%sp, %%g1, %%sp"
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi\t%%hi(%a0), %%g1\n\tor\t%%g1, %%lo(%a0), %%g1\n\tretl\n\tadd\t%%sp, %%g1, %%sp"
return|;
else|else
return|return
literal|"sethi\t%%hi(%a0), %%g1\n\tretl\n\tadd\t%%sp, %%g1, %%sp"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_V9
condition|)
block|{
if|if
condition|(
name|delay
condition|)
block|{
name|epilogue_renumber
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|delay
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|epilogue_renumber
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|delay
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
return|return
literal|"return\t%%i7+12%#"
return|;
else|else
return|return
literal|"return\t%%i7+8%#"
return|;
block|}
else|else
block|{
if|if
condition|(
name|delay
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
return|return
literal|"jmp\t%%i7+12\n\trestore"
return|;
else|else
return|return
literal|"ret\n\trestore"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Leaf functions and non-leaf functions have different needs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|reg_leaf_alloc_order
index|[]
init|=
name|REG_LEAF_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|reg_nonleaf_alloc_order
index|[]
init|=
name|REG_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
modifier|*
specifier|const
name|reg_alloc_orders
index|[]
init|=
block|{
name|reg_leaf_alloc_order
block|,
name|reg_nonleaf_alloc_order
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|order_regs_for_local_alloc
parameter_list|()
block|{
specifier|static
name|int
name|last_order_nonleaf
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|15
index|]
operator|!=
name|last_order_nonleaf
condition|)
block|{
name|last_order_nonleaf
operator|=
operator|!
name|last_order_nonleaf
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_alloc_order
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|reg_alloc_orders
index|[
name|last_order_nonleaf
index|]
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if REG and MEM are legitimate enough to allow the various    mem<-->reg splits to be run.  */
end_comment

begin_function
name|int
name|sparc_splitdi_legitimate
parameter_list|(
name|reg
parameter_list|,
name|mem
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
block|{
comment|/* Punt if we are here by mistake.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We must have an offsettable memory reference.  */
if|if
condition|(
operator|!
name|offsettable_memref_p
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we have legitimate args for ldd/std, we do not want      the split to happen.  */
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|%
literal|2
operator|)
operator|==
literal|0
operator|&&
name|mem_min_alignment
argument_list|(
name|mem
argument_list|,
literal|8
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Success.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if x and y are some kind of REG and they refer to    different hard registers.  This test is guarenteed to be    run after reload.  */
end_comment

begin_function
name|int
name|sparc_absnegfloat_split_legitimate
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.    This makes them candidates for using ldd and std insns.      Note reg1 and reg2 *must* be hard registers.  */
end_comment

begin_function
name|int
name|registers_ok_for_ldd_peep
parameter_list|(
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|%
literal|2
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Integer ldd is deprecated in SPARC V9 */
if|if
condition|(
name|TARGET_V9
operator|&&
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg2
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the addresses in mem1 and mem2 are suitable for use in    an ldd or std insn.        This can only happen when addr1 and addr2, the addresses in mem1    and mem2, are consecutive memory locations (addr1 + 4 == addr2).    addr1 must also be aligned on a 64-bit boundary.     Also iff dependent_reg_rtx is not null it should not be used to    compute the address for mem1, i.e. we cannot optimize a sequence    like:    	ld [%o0], %o0 	ld [%o0 + 4], %o1    to    	ldd [%o0], %o0    For stores we don't have a similar problem, so dependent_reg_rtx is    NULL_RTX.  */
end_comment

begin_function
name|int
name|mems_ok_for_ldd_peep
parameter_list|(
name|mem1
parameter_list|,
name|mem2
parameter_list|,
name|dependent_reg_rtx
parameter_list|)
name|rtx
name|mem1
decl_stmt|,
name|mem2
decl_stmt|,
name|dependent_reg_rtx
decl_stmt|;
block|{
name|rtx
name|addr1
decl_stmt|,
name|addr2
decl_stmt|;
name|unsigned
name|int
name|reg1
decl_stmt|;
name|int
name|offset1
decl_stmt|;
comment|/* The mems cannot be volatile.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|mem1
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|mem2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* MEM1 should be aligned on a 64-bit boundary.  */
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|mem1
argument_list|)
operator|<
literal|64
condition|)
return|return
literal|0
return|;
name|addr1
operator|=
name|XEXP
argument_list|(
name|mem1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|XEXP
argument_list|(
name|mem2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Extract a register number and offset (if used) from the first addr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* If not a REG, return zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset must be constant!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
comment|/* This was a simple (mem (reg)) expression.  Offset is 0.  */
name|offset1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure the second address is a (mem (plus (reg) (const_int).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg1
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dependent_reg_rtx
operator|!=
name|NULL_RTX
operator|&&
name|reg1
operator|==
name|REGNO
argument_list|(
name|dependent_reg_rtx
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The first offset must be evenly divisible by 8 to ensure the       address is 64 bit aligned.  */
if|if
condition|(
name|offset1
operator|%
literal|8
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* The offset for the second addr must be 4 more than the first addr.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|offset1
operator|+
literal|4
condition|)
return|return
literal|0
return|;
comment|/* All the tests passed.  addr1 and addr2 are valid for ldd and std      instructions.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if reg is a pseudo, or is the first register in     a hard register pair.  This makes it a candidate for use in    ldd and std insns.  */
end_comment

begin_function
name|int
name|register_ok_for_ldd
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|%
literal|2
operator|==
literal|0
operator|)
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print operand X (an rtx) in assembler syntax to file FILE.    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.    For `%' followed by punctuation, CODE is the punctuation and X is null.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* Output a 'nop' if there's nothing for the delay slot.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t nop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'*'
case|:
comment|/* Output an annul flag if there's nothing for the delay slot and we 	 are optimizing.  This is always used with '(' below.  */
comment|/* Sun OS 4.1.1 dbx can't handle an annulled unconditional branch; 	 this is a dbx bug.  So, we only do this when optimizing.  */
comment|/* On UltraSPARC, a branch in a delay slot causes a pipeline flush. 	 Always emit a nop in case the next instruction is a branch.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|optimize
operator|&&
operator|(
name|int
operator|)
name|sparc_cpu
operator|<
name|PROCESSOR_V9
operator|)
condition|)
name|fputs
argument_list|(
literal|",a"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'('
case|:
comment|/* Output a 'nop' if there's nothing for the delay slot and we are 	 not optimizing.  This is always used with '*' above.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
operator|&&
operator|!
operator|(
name|optimize
operator|&&
operator|(
name|int
operator|)
name|sparc_cpu
operator|<
name|PROCESSOR_V9
operator|)
condition|)
name|fputs
argument_list|(
literal|"\n\t nop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'_'
case|:
comment|/* Output the Embedded Medium/Anywhere code model base register.  */
name|fputs
argument_list|(
name|EMBMEDANY_BASE_REG
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'@'
case|:
comment|/* Print out what we are using as the frame pointer.  This might 	 be %fp, or might be %sp+offset.  */
comment|/* ??? What if offset is too big? Perhaps the caller knows it isn't? */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s+%d"
argument_list|,
name|frame_base_name
argument_list|,
name|frame_base_offset
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Y'
case|:
comment|/* Adjust the operand to take into account a RESTORE operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%Y operand"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
literal|8
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
literal|32
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
literal|16
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%Y operand"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
comment|/* Print out the low order register name of a register pair.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* Print out the high order register name of a register pair.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
comment|/* Print out the second register name of a register pair or quad. 	 I.e., R (%o0) => %o1.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* Print out the third register name of a register quad. 	 I.e., S (%o0) => %o2.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* Print out the fourth register name of a register quad. 	 I.e., T (%o0) => %o3.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'x'
case|:
comment|/* Print a condition code register.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|SPARC_ICC_REG
condition|)
block|{
comment|/* We don't handle CC[X]_NOOVmode because they're not supposed 	     to occur here.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|CCmode
condition|)
name|fputs
argument_list|(
literal|"%icc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|CCXmode
condition|)
name|fputs
argument_list|(
literal|"%xcc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* %fccN register */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
comment|/* Print the operand's address only.  */
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
comment|/* In this case we need a register.  Use %g0 if the 	 operand is const0_rtx.  */
if|if
condition|(
name|x
operator|==
name|const0_rtx
operator|||
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"%g0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
case|case
literal|'A'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"or"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"and"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%A operand"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'B'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"orn"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"andn"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xnor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%B operand"
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* These are used by the conditional move instructions.  */
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
block|{
name|enum
name|rtx_code
name|rc
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|'c'
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|rc
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"g"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"geu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"gu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"leu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"lu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTGT
case|:
name|fputs
argument_list|(
literal|"lg"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|fputs
argument_list|(
literal|"u"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|fputs
argument_list|(
literal|"o"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|fputs
argument_list|(
literal|"ul"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|fputs
argument_list|(
literal|"ule"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
name|fputs
argument_list|(
literal|"ug"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|fputs
argument_list|(
literal|"uge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|fputs
argument_list|(
literal|"ue"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
name|code
operator|==
literal|'c'
condition|?
literal|"invalid %%c operand"
else|:
literal|"invalid %%C operand"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* These are used by the movr instruction pattern.  */
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
block|{
name|enum
name|rtx_code
name|rc
init|=
operator|(
name|code
operator|==
literal|'d'
condition|?
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|)
decl_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"gez"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lz"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"lez"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gz"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
name|code
operator|==
literal|'d'
condition|?
literal|"invalid %%d operand"
else|:
literal|"invalid %%D operand"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
literal|'b'
case|:
block|{
comment|/* Print a sign-extended character.  */
name|int
name|i
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|i
operator|&
literal|0x80
condition|)
name|i
operator||=
literal|0xffffff00
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'f'
case|:
comment|/* Operand must be a MEM; write its address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%f operand"
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
comment|/* Do nothing special.  */
break|break;
default|default:
comment|/* Undocumented flag.  */
name|output_operand_lossage
argument_list|(
literal|"invalid operand output code"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|fputc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Poor Sun assembler doesn't understand absolute addressing.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"%g0+"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
block|{
name|fputs
argument_list|(
literal|"%hi("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
name|print_operand
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CM_MEDMID
condition|)
name|fputs
argument_list|(
literal|"+%l44("
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"+%lo("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"long long constant not a valid immediate operand"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|output_operand_lossage
argument_list|(
literal|"floating point constant not a valid immediate operand"
argument_list|)
expr_stmt|;
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Target hook for assembling integer objects.  The sparc version has    special handling for aligned DI-mode objects.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|aligned_p
decl_stmt|;
block|{
comment|/* ??? We only output .xword's for symbols and only then in environments      where the assembler can handle them.  */
if|if
condition|(
name|aligned_p
operator|&&
name|size
operator|==
literal|8
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|)
condition|)
block|{
if|if
condition|(
name|TARGET_V9
condition|)
block|{
name|assemble_integer_with_op
argument_list|(
literal|"\t.xword\t"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|assemble_aligned_integer
argument_list|(
literal|4
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|assemble_aligned_integer
argument_list|(
literal|4
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of a code used in the .proc pseudo-op that says    what kind of result this function returns.  For non-C types, we pick    the closest C type.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|long
name|sparc_type_code
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|qualifiers
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|shift
decl_stmt|;
comment|/* Only the first 30 bits of the qualifier are valid.  We must refrain from      setting more, since some assemblers will give an error for this.  Also,      we must be careful to avoid shifts of 32 bits or more to avoid getting      unpredictable results.  */
for|for
control|(
name|shift
operator|=
literal|6
init|;
name|shift
operator|<
literal|30
condition|;
name|shift
operator|+=
literal|2
operator|,
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|qualifiers
return|;
case|case
name|ARRAY_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|3
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|2
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|8
operator|)
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|9
operator|)
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|10
operator|)
return|;
case|case
name|VOID_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|16
operator|)
return|;
case|case
name|INTEGER_TYPE
case|:
comment|/* If this is a range type, consider it to be the underlying 	     type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Carefully distinguish all the standard types of C, 	     without messing up if the language is not C.  We do this by 	     testing TYPE_PRECISION and TREE_UNSIGNED.  The old code used to 	     look at both the names and the above fields, but that's redundant. 	     Any type whose size is between two C types will be considered 	     to be the wider of the two types.  Also, we do not have a 	     special code to use for "long long", so anything wider than 	     long is treated the same.  Note that we can't distinguish 	     between "int" and "long" in this code if they are the same 	     size, but that's fine, since neither can the assembler.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|CHAR_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|12
else|:
literal|2
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|SHORT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|13
else|:
literal|3
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|INT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|14
else|:
literal|4
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|15
else|:
literal|5
operator|)
operator|)
return|;
case|case
name|REAL_TYPE
case|:
comment|/* If this is a range type, consider it to be the underlying 	     type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Carefully distinguish all the standard types of C, 	     without messing up if the language is not C.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|FLOAT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|6
operator|)
return|;
else|else
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
case|case
name|COMPLEX_TYPE
case|:
comment|/* GNU Fortran COMPLEX type.  */
comment|/* ??? We need to distinguish between double and float complex types, 	     but I don't know how yet because I can't reach this code from 	     existing front-ends.  */
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
comment|/* Who knows? */
case|case
name|CHAR_TYPE
case|:
comment|/* GNU Pascal CHAR type.  Not used in C.  */
case|case
name|BOOLEAN_TYPE
case|:
comment|/* GNU Fortran BOOLEAN type.  */
case|case
name|FILE_TYPE
case|:
comment|/* GNU Pascal FILE type.  */
case|case
name|SET_TYPE
case|:
comment|/* GNU Pascal SET type.  */
case|case
name|LANG_TYPE
case|:
comment|/* ? */
return|return
name|qualifiers
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Not a type! */
block|}
block|}
return|return
name|qualifiers
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nested function support.  */
end_comment

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.     This takes 16 insns: 2 shifts& 2 ands (to split up addresses), 4 sethi    (to load in opcodes), 4 iors (to merge address and opcodes), and 4 writes    (to store insns).  This is a bit excessive.  Perhaps a different    mechanism would be better here.     Emit enough FLUSH insns to synchronize the data and instruction caches.  */
end_comment

begin_function
name|void
name|sparc_initialize_trampoline
parameter_list|(
name|tramp
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|)
name|rtx
name|tramp
decl_stmt|,
name|fnaddr
decl_stmt|,
name|cxt
decl_stmt|;
block|{
comment|/* SPARC 32 bit trampoline:   	sethi	%hi(fn), %g1  	sethi	%hi(static), %g2  	jmp	%g1+%lo(fn)  	or	%g2, %lo(static), %g2      SETHI i,r  = 00rr rrr1 00ii iiii iiii iiii iiii iiii     JMPL r+i,d = 10dd ddd1 1100 0rrr rr1i iiii iiii iiii    */
ifdef|#
directive|ifdef
name|TRANSFER_FROM_TRAMPOLINE
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|tramp
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|fnaddr
argument_list|,
name|size_int
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x03000000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|cxt
argument_list|,
name|size_int
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x05000000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_and
argument_list|(
name|fnaddr
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3ff
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x81c06000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|12
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_and
argument_list|(
name|cxt
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3ff
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8410a000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_flush
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|tramp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On UltraSPARC a flush flushes an entire cache line.  The trampoline is      aligned on a 16 byte boundary so one flush clears it all.  */
if|if
condition|(
name|sparc_cpu
operator|!=
name|PROCESSOR_ULTRASPARC
condition|)
name|emit_insn
argument_list|(
name|gen_flush
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The 64 bit version is simpler because it makes more sense to load the    values as "immediate" data out of the trampoline.  It's also easier since    we can read the PC without clobbering a register.  */
end_comment

begin_function
name|void
name|sparc64_initialize_trampoline
parameter_list|(
name|tramp
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|)
name|rtx
name|tramp
decl_stmt|,
name|fnaddr
decl_stmt|,
name|cxt
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TRANSFER_FROM_TRAMPOLINE
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|tramp
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	rd	%pc, %g1 	ldx	[%g1+24], %g5 	jmp	%g5 	ldx	[%g1+16], %g5 	+16 bytes data    */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|tramp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x83414000
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0xca586018
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x81c14000
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|12
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0xca586010
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|24
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_flushdi
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|tramp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_cpu
operator|!=
name|PROCESSOR_ULTRASPARC
condition|)
name|emit_insn
argument_list|(
name|gen_flushdi
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines to support a flat (single) register window calling    convention.  */
end_comment

begin_comment
comment|/* Single-register window sparc stack frames look like:               Before call		        After call         +-----------------------+	+-----------------------+    high |		        |	|			|    mem  |  caller's temps.    	|       |  caller's temps.    	| 	|       		|       |       	        |         +-----------------------+	+-----------------------+  	|       		|	|		        |         |  arguments on stack.  |	|  arguments on stack.  | 	|       		|      	|			|         +-----------------------+FP+92->+-----------------------+  	|  6 words to save     	|	|  6 words to save	| 	|  arguments passed	|	|  arguments passed	| 	|  in registers, even	|	|  in registers, even	|        	|  if not passed.       |      	|  if not passed.	|  SP+68->+-----------------------+FP+68->+-----------------------+         | 1 word struct addr	|      	| 1 word struct addr	|         +-----------------------+FP+64->+-----------------------+         |			|	|			|         | 16 word reg save area	|	| 16 word reg save area |        	|                       |      	|			|     SP->+-----------------------+   FP->+-----------------------+ 				        | 4 word area for	| 				       	| fp/alu reg moves	| 				 FP-16->+-----------------------+ 				        |			| 				        |  local variables	| 				        |			| 				        +-----------------------+ 				        |		        |                                         |  fp register save     | 				        |			| 				        +-----------------------+ 				        |		        |                                         |  gp register save     |                                         |       		| 				        +-----------------------+ 				        |			|                                         |  alloca allocations   |         			        |			| 				        +-----------------------+ 				        |			|                                         |  arguments on stack   |         			       	|		        | 				 SP+92->+-----------------------+                                         |  6 words to save      | 				        |  arguments passed     |                                         |  in registers, even   |    low                                 	|  if not passed.       |    memory        		 SP+68->+-----------------------+ 				       	| 1 word struct addr	| 				 SP+64->+-----------------------+ 				        |			| 				        I 16 word reg save area | 				       	|			| 				    SP->+-----------------------+  */
end_comment

begin_comment
comment|/* Structure to be filled in by sparc_flat_compute_frame_size with register    save masks, and offsets for the current function.  */
end_comment

begin_struct
struct|struct
name|sparc_frame_info
block|{
name|unsigned
name|long
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up.  */
name|unsigned
name|long
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up.  */
name|unsigned
name|long
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up.  */
name|unsigned
name|long
name|extra_size
decl_stmt|;
comment|/* # bytes of extra gunk.  */
name|unsigned
name|int
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs.  */
name|unsigned
name|int
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs.  */
name|unsigned
name|long
name|gmask
decl_stmt|;
comment|/* Mask of saved gp registers.  */
name|unsigned
name|long
name|fmask
decl_stmt|;
comment|/* Mask of saved fp registers.  */
name|unsigned
name|long
name|reg_offset
decl_stmt|;
comment|/* Offset from new sp to store regs.  */
name|int
name|initialized
decl_stmt|;
comment|/* Nonzero if frame size already calculated.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Current frame information calculated by sparc_flat_compute_frame_size.  */
end_comment

begin_decl_stmt
name|struct
name|sparc_frame_info
name|current_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero structure to initialize current_frame_info.  */
end_comment

begin_decl_stmt
name|struct
name|sparc_frame_info
name|zero_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tell prologue and epilogue if register REGNO should be saved / restored.  */
end_comment

begin_define
define|#
directive|define
name|RETURN_ADDR_REGNUM
value|15
end_define

begin_define
define|#
directive|define
name|FRAME_POINTER_MASK
value|(1<< (FRAME_POINTER_REGNUM))
end_define

begin_define
define|#
directive|define
name|RETURN_ADDR_MASK
value|(1<< (RETURN_ADDR_REGNUM))
end_define

begin_define
define|#
directive|define
name|MUST_SAVE_REGISTER
parameter_list|(
name|regno
parameter_list|)
define|\
value|((regs_ever_live[regno]&& !call_used_regs[regno])		\   || (regno == FRAME_POINTER_REGNUM&& frame_pointer_needed)	\   || (regno == RETURN_ADDR_REGNUM&& regs_ever_live[RETURN_ADDR_REGNUM]))
end_define

begin_comment
comment|/* Return the bytes needed to compute the frame pointer from the current    stack pointer.  */
end_comment

begin_function
name|unsigned
name|long
name|sparc_flat_compute_frame_size
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
comment|/* # of var. bytes allocated.  */
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up.  */
name|unsigned
name|long
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up.  */
name|unsigned
name|long
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up.  */
name|unsigned
name|long
name|extra_size
decl_stmt|;
comment|/* # extra bytes.  */
name|unsigned
name|int
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs.  */
name|unsigned
name|int
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs.  */
name|unsigned
name|long
name|gmask
decl_stmt|;
comment|/* Mask of saved gp registers.  */
name|unsigned
name|long
name|fmask
decl_stmt|;
comment|/* Mask of saved fp registers.  */
name|unsigned
name|long
name|reg_offset
decl_stmt|;
comment|/* Offset to register save area.  */
name|int
name|need_aligned_p
decl_stmt|;
comment|/* 1 if need the save area 8 byte aligned.  */
comment|/* This is the size of the 16 word reg save area, 1 word struct addr      area, and 4 word fp/alu register copy area.  */
name|extra_size
operator|=
operator|-
name|STARTING_FRAME_OFFSET
operator|+
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|var_size
operator|=
name|size
expr_stmt|;
name|gp_reg_size
operator|=
literal|0
expr_stmt|;
name|fp_reg_size
operator|=
literal|0
expr_stmt|;
name|gmask
operator|=
literal|0
expr_stmt|;
name|fmask
operator|=
literal|0
expr_stmt|;
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|need_aligned_p
operator|=
literal|0
expr_stmt|;
name|args_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|leaf_function_p
argument_list|()
condition|)
block|{
comment|/* Also include the size needed for the 6 parameter registers.  */
name|args_size
operator|=
name|current_function_outgoing_args_size
operator|+
literal|24
expr_stmt|;
block|}
name|total_size
operator|=
name|var_size
operator|+
name|args_size
expr_stmt|;
comment|/* Calculate space needed for gp registers.  */
for|for
control|(
name|regno
operator|=
literal|1
init|;
name|regno
operator|<=
literal|31
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* If we need to save two regs in a row, ensure there's room to bump 	     up the address to align it to a doubleword boundary.  */
if|if
condition|(
operator|(
name|regno
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
operator|+
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|gp_reg_size
operator|%
literal|8
operator|!=
literal|0
condition|)
name|gp_reg_size
operator|+=
literal|4
expr_stmt|;
name|gp_reg_size
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|gmask
operator||=
literal|3
operator|<<
name|regno
expr_stmt|;
name|regno
operator|++
expr_stmt|;
name|need_aligned_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|gmask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
block|}
block|}
comment|/* Calculate space needed for fp registers.  */
for|for
control|(
name|regno
operator|=
literal|32
init|;
name|regno
operator|<=
literal|63
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|fp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|fmask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|-
literal|32
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gmask
operator|||
name|fmask
condition|)
block|{
name|int
name|n
decl_stmt|;
name|reg_offset
operator|=
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
operator|+
name|args_size
expr_stmt|;
comment|/* Ensure save area is 8 byte aligned if we need it.  */
name|n
operator|=
name|reg_offset
operator|%
literal|8
expr_stmt|;
if|if
condition|(
name|need_aligned_p
operator|&&
name|n
operator|!=
literal|0
condition|)
block|{
name|total_size
operator|+=
literal|8
operator|-
name|n
expr_stmt|;
name|reg_offset
operator|+=
literal|8
operator|-
name|n
expr_stmt|;
block|}
name|total_size
operator|+=
name|gp_reg_size
operator|+
name|fp_reg_size
expr_stmt|;
block|}
comment|/* If we must allocate a stack frame at all, we must also allocate       room for register window spillage, so as to be binary compatible      with libraries and operating systems that do not use -mflat.  */
if|if
condition|(
name|total_size
operator|>
literal|0
condition|)
name|total_size
operator|+=
name|extra_size
expr_stmt|;
else|else
name|extra_size
operator|=
literal|0
expr_stmt|;
name|total_size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
comment|/* Save other computed information.  */
name|current_frame_info
operator|.
name|total_size
operator|=
name|total_size
expr_stmt|;
name|current_frame_info
operator|.
name|var_size
operator|=
name|var_size
expr_stmt|;
name|current_frame_info
operator|.
name|args_size
operator|=
name|args_size
expr_stmt|;
name|current_frame_info
operator|.
name|extra_size
operator|=
name|extra_size
expr_stmt|;
name|current_frame_info
operator|.
name|gp_reg_size
operator|=
name|gp_reg_size
expr_stmt|;
name|current_frame_info
operator|.
name|fp_reg_size
operator|=
name|fp_reg_size
expr_stmt|;
name|current_frame_info
operator|.
name|gmask
operator|=
name|gmask
expr_stmt|;
name|current_frame_info
operator|.
name|fmask
operator|=
name|fmask
expr_stmt|;
name|current_frame_info
operator|.
name|reg_offset
operator|=
name|reg_offset
expr_stmt|;
name|current_frame_info
operator|.
name|initialized
operator|=
name|reload_completed
expr_stmt|;
comment|/* Ok, we're done.  */
return|return
name|total_size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save/restore registers in GMASK and FMASK at register BASE_REG plus offset    OFFSET.     BASE_REG must be 8 byte aligned.  This allows us to test OFFSET for    appropriate alignment and use DOUBLEWORD_OP when we can.  We assume    [BASE_REG+OFFSET] will always be a valid address.     WORD_OP is either "st" for save, "ld" for restore.    DOUBLEWORD_OP is either "std" for save, "ldd" for restore.  */
end_comment

begin_function
name|void
name|sparc_flat_save_restore
parameter_list|(
name|file
parameter_list|,
name|base_reg
parameter_list|,
name|offset
parameter_list|,
name|gmask
parameter_list|,
name|fmask
parameter_list|,
name|word_op
parameter_list|,
name|doubleword_op
parameter_list|,
name|base_offset
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_reg
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|long
name|gmask
decl_stmt|;
name|unsigned
name|long
name|fmask
decl_stmt|;
specifier|const
name|char
modifier|*
name|word_op
decl_stmt|;
specifier|const
name|char
modifier|*
name|doubleword_op
decl_stmt|;
name|unsigned
name|long
name|base_offset
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|gmask
operator|==
literal|0
operator|&&
name|fmask
operator|==
literal|0
condition|)
return|return;
comment|/* Save registers starting from high to low.  We've already saved the      previous frame pointer and previous return address for the debugger's      sake.  The debugger allows us to not need a nop in the epilog if at least      one register is reloaded in addition to return address.  */
if|if
condition|(
name|gmask
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|1
init|;
name|regno
operator|<=
literal|31
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|gmask
operator|&
operator|(
literal|1L
operator|<<
name|regno
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|regno
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|gmask
operator|&
operator|(
literal|1L
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* We can save two registers in a row.  If we're not at a 		     double word boundary, move to one. 		     sparc_flat_compute_frame_size ensures there's room to do 		     this.  */
if|if
condition|(
name|offset
operator|%
literal|8
operator|!=
literal|0
condition|)
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%s, [%s+%d]\n"
argument_list|,
name|doubleword_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|regno
argument_list|,
name|offset
operator|+
name|base_offset
argument_list|)
expr_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|offset
operator|+
name|base_offset
operator|+
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t[%s+%d], %s\n"
argument_list|,
name|doubleword_op
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%s, [%s+%d]\n"
argument_list|,
name|word_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|regno
argument_list|,
name|offset
operator|+
name|base_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t[%s+%d], %s\n"
argument_list|,
name|word_op
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fmask
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|32
init|;
name|regno
operator|<=
literal|63
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
operator|(
name|regno
operator|-
literal|32
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%s, [%s+%d]\n"
argument_list|,
name|word_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|regno
argument_list|,
name|offset
operator|+
name|base_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t[%s+%d], %s\n"
argument_list|,
name|word_op
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the stack and frame (if desired) for the function.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_flat_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|sp_str
init|=
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
name|unsigned
name|long
name|gmask
init|=
name|current_frame_info
operator|.
name|gmask
decl_stmt|;
name|sparc_output_scratch_registers
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* This is only for the human reader.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#PROLOGUE# 0\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s# vars= %ld, regs= %d/%d, args= %d, extra= %ld\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|current_frame_info
operator|.
name|var_size
argument_list|,
name|current_frame_info
operator|.
name|gp_reg_size
operator|/
literal|4
argument_list|,
name|current_frame_info
operator|.
name|fp_reg_size
operator|/
literal|4
argument_list|,
name|current_function_outgoing_args_size
argument_list|,
name|current_frame_info
operator|.
name|extra_size
argument_list|)
expr_stmt|;
name|size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|?
name|sparc_flat_compute_frame_size
argument_list|(
name|size
argument_list|)
else|:
name|current_frame_info
operator|.
name|total_size
operator|)
expr_stmt|;
comment|/* These cases shouldn't happen.  Catch them now.  */
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
operator|(
name|gmask
operator|||
name|current_frame_info
operator|.
name|fmask
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Allocate our stack frame by decrementing %sp.      At present, the only algorithm gdb can use to determine if this is a      flat frame is if we always set %i7 if we set %sp.  This can be optimized      in the future by putting in some sort of debugging information that says      this is a `flat' function.  However, there is still the case of debugging      code without such debugging information (including cases where most fns      have such info, but there is one that doesn't).  So, always do this now      so we don't get a lot of code out there that gdb can't handle.      If the frame pointer isn't needn't then that's ok - gdb won't be able to      distinguish us from a non-flat function but there won't (and shouldn't)      be any differences anyway.  The return pc is saved (if necessary) right      after %i7 so gdb won't have to look too far to find it.  */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|reg_offset
init|=
name|current_frame_info
operator|.
name|reg_offset
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fp_str
init|=
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|t1_str
init|=
literal|"%g1"
decl_stmt|;
comment|/* Things get a little tricky if local variables take up more than ~4096 	 bytes and outgoing arguments take up more than ~4096 bytes.  When that 	 happens, the register save area can't be accessed from either end of 	 the frame.  Handle this by decrementing %sp to the start of the gp 	 register save area, save the regs, update %i7, and then set %sp to its 	 final value.  Given that we only have one scratch register to play 	 with it is the cheapest solution, and it helps gdb out as it won't 	 slow down recognition of flat functions. 	 Don't change the order of insns emitted here without checking with 	 the gdb folk first.  */
comment|/* Is the entire register save area offsettable from %sp?  */
if|if
condition|(
name|reg_offset
operator|<
literal|4096
operator|-
literal|64
operator|*
operator|(
name|unsigned
operator|)
name|UNITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|size
operator|<=
literal|4096
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%s, %d, %s\n"
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
operator|-
name|size
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t%s, [%s+%d]\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub\t%s, %d, %s\t%s# set up frame pointer\n"
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
operator|-
name|size
argument_list|,
name|fp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset\t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s\n\tsub\t%s, %s, %s\n"
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t%s, [%s+%d]\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%s, %s, %s\t%s# set up frame pointer\n"
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|fp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
name|reg_offset
operator|-
literal|4
operator|-
name|size
argument_list|)
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gmask
operator|&
name|RETURN_ADDR_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t%s, [%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|RETURN_ADDR_REGNUM
index|]
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_return_save
argument_list|(
literal|""
argument_list|,
name|reg_offset
operator|-
name|size
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
name|sparc_flat_save_restore
argument_list|(
name|file
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|,
name|gmask
operator|&
operator|~
operator|(
name|FRAME_POINTER_MASK
operator||
name|RETURN_ADDR_MASK
operator|)
argument_list|,
name|current_frame_info
operator|.
name|fmask
argument_list|,
literal|"st"
argument_list|,
literal|"std"
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Subtract %sp in two steps, but make sure there is always a 	     64 byte register save area, and %sp is properly aligned.  */
comment|/* Amount to decrement %sp by, the first time.  */
name|unsigned
name|HOST_WIDE_INT
name|size1
init|=
operator|(
operator|(
name|size
operator|-
name|reg_offset
operator|+
literal|64
operator|)
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
decl_stmt|;
comment|/* Offset to register save area from %sp.  */
name|unsigned
name|HOST_WIDE_INT
name|offset
init|=
name|size1
operator|-
operator|(
name|size
operator|-
name|reg_offset
operator|)
decl_stmt|;
if|if
condition|(
name|size1
operator|<=
literal|4096
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%s, %d, %s\n"
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
operator|-
name|size1
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t%s, [%s+%d]\n\tsub\t%s, %d, %s\t%s# set up frame pointer\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
operator|-
name|size1
argument_list|,
name|fp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset\t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|size1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s\n\tsub\t%s, %s, %s\n"
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t%s, [%s+%d]\n\tadd\t%s, %s, %s\t%s# set up frame pointer\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|fp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
name|offset
operator|-
literal|4
operator|-
name|size1
argument_list|)
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|size1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gmask
operator|&
name|RETURN_ADDR_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t%s, [%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|RETURN_ADDR_REGNUM
index|]
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
comment|/* offset - size1 == reg_offset - size 		   if reg_offset were updated above like offset.  */
name|dwarf2out_return_save
argument_list|(
literal|""
argument_list|,
name|offset
operator|-
name|size1
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
name|sparc_flat_save_restore
argument_list|(
name|file
argument_list|,
name|sp_str
argument_list|,
name|offset
argument_list|,
name|gmask
operator|&
operator|~
operator|(
name|FRAME_POINTER_MASK
operator||
name|RETURN_ADDR_MASK
operator|)
argument_list|,
name|current_frame_info
operator|.
name|fmask
argument_list|,
literal|"st"
argument_list|,
literal|"std"
argument_list|,
operator|-
name|size1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset\t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|size
operator|-
name|size1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s\n\tsub\t%s, %s, %s\n"
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
if|if
condition|(
operator|!
operator|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
operator|)
condition|)
name|dwarf2out_def_cfa
argument_list|(
literal|""
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#PROLOGUE# 1\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any necessary cleanup after a function to restore stack, frame,    and regs.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_flat_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
block|{
name|rtx
name|epilogue_delay
init|=
name|current_function_epilogue_delay_list
decl_stmt|;
name|int
name|noepilogue
init|=
name|FALSE
decl_stmt|;
comment|/* This is only for the human reader.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#EPILOGUE#\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
comment|/* The epilogue does not depend on any registers, but the stack      registers, so we assume that if we have 1 pending nop, it can be      ignored, and 2 it must be filled (2 nops occur for integer      multiply and divide).  */
name|size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|?
name|sparc_flat_compute_frame_size
argument_list|(
name|size
argument_list|)
else|:
name|current_frame_info
operator|.
name|total_size
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
name|epilogue_delay
operator|==
literal|0
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write any code 	 because a jump (aka return) was put there.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|noepilogue
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noepilogue
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|reg_offset
init|=
name|current_frame_info
operator|.
name|reg_offset
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|size1
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|sp_str
init|=
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fp_str
init|=
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|t1_str
init|=
literal|"%g1"
decl_stmt|;
comment|/* In the reload sequence, we don't need to fill the load delay 	 slots for most of the loads, also see if we can fill the final 	 delay slot if not otherwise filled by the reload sequence.  */
if|if
condition|(
name|size
operator|>
literal|4095
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset\t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s\n"
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub\t%s, %s, %s\t\t%s# sp not trusted here\n"
argument_list|,
name|fp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub\t%s, %d, %s\t\t%s# sp not trusted here\n"
argument_list|,
name|fp_str
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|sp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
block|}
comment|/* Is the entire register save area offsettable from %sp?  */
if|if
condition|(
name|reg_offset
operator|<
literal|4096
operator|-
literal|64
operator|*
operator|(
name|unsigned
operator|)
name|UNITS_PER_WORD
condition|)
block|{
name|size1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Restore %sp in two steps, but make sure there is always a 	     64 byte register save area, and %sp is properly aligned.  */
comment|/* Amount to increment %sp by, the first time.  */
name|size1
operator|=
operator|(
operator|(
name|reg_offset
operator|-
literal|64
operator|-
literal|16
operator|)
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
expr_stmt|;
comment|/* Offset to register save area from %sp.  */
name|reg_offset
operator|=
name|size1
operator|-
name|reg_offset
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset\t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|size1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s\n\tadd\t%s, %s, %s\n"
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
block|}
comment|/* We must restore the frame pointer and return address reg first 	 because they are treated specially by the prologue output code.  */
if|if
condition|(
name|current_frame_info
operator|.
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld\t[%s+%d], %s\n"
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
name|reg_offset
argument_list|,
name|fp_str
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|gmask
operator|&
name|RETURN_ADDR_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld\t[%s+%d], %s\n"
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
name|reg_offset
argument_list|,
name|reg_names
index|[
name|RETURN_ADDR_REGNUM
index|]
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Restore any remaining saved registers.  */
name|sparc_flat_save_restore
argument_list|(
name|file
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|,
name|current_frame_info
operator|.
name|gmask
operator|&
operator|~
operator|(
name|FRAME_POINTER_MASK
operator||
name|RETURN_ADDR_MASK
operator|)
argument_list|,
name|current_frame_info
operator|.
name|fmask
argument_list|,
literal|"ld"
argument_list|,
literal|"ldd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we had to increment %sp in two steps, record it so the second 	 restoration in the epilogue finishes up.  */
if|if
condition|(
name|size1
operator|>
literal|0
condition|)
block|{
name|size
operator|-=
name|size1
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|4095
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset\t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s\n"
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_function_returns_struct
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp\t%%o7+12\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tretl\n"
argument_list|)
expr_stmt|;
comment|/* If the only register saved is the return address, we need a 	 nop, unless we have an instruction to put into it.  Otherwise 	 we don't since reloading multiple registers doesn't reference 	 the register being loaded.  */
if|if
condition|(
name|epilogue_delay
condition|)
block|{
if|if
condition|(
name|size
condition|)
name|abort
argument_list|()
expr_stmt|;
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|epilogue_delay
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%s, %s, %s\n"
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd\t%s, %d, %s\n"
argument_list|,
name|sp_str
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Reset state info for each function.  */
name|current_frame_info
operator|=
name|zero_frame_info
expr_stmt|;
name|sparc_output_deferred_case_vectors
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the number of delay slots needed for the function epilogue.     On the sparc, we need a slot if either no stack has been allocated,    or the only register saved is the return register.  */
end_comment

begin_function
name|int
name|sparc_flat_epilogue_delay_slots
parameter_list|()
block|{
if|if
condition|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|)
operator|(
name|void
operator|)
name|sparc_flat_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if TRIAL is a valid insn for the epilogue delay slot.    Any single length instruction which doesn't reference the stack or frame    pointer is OK.  */
end_comment

begin_function
name|int
name|sparc_flat_eligible_for_epilogue_delay
parameter_list|(
name|trial
parameter_list|,
name|slot
parameter_list|)
name|rtx
name|trial
decl_stmt|;
name|int
name|slot
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|pat
argument_list|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|supersparc_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|;
if|if
condition|(
operator|!
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Data dependency; DEP_INSN writes a register that INSN reads some 	 cycles later.  */
comment|/* if a load, then the dependence must be on the memory address; 	 add an extra "cycle".  Note that the cost could be two cycles 	 if the reg was written late in an instruction group; we ca not tell 	 here.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_LOAD
operator|||
name|insn_type
operator|==
name|TYPE_FPLOAD
condition|)
return|return
name|cost
operator|+
literal|3
return|;
comment|/* Get the delay only if the address of the store is the dependence.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_STORE
operator|||
name|insn_type
operator|==
name|TYPE_FPSTORE
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dep_pat
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|cost
return|;
comment|/* This should not happen!  */
comment|/* The dependency between the two instructions was on the data that 	     is being stored.  Assume that this implies that the address of the 	     store is not dependent.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|cost
return|;
return|return
name|cost
operator|+
literal|3
return|;
comment|/* An approximation.  */
block|}
comment|/* A shift instruction cannot receive its data from an instruction 	 in the same cycle; add a one cycle penalty.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_SHIFT
condition|)
return|return
name|cost
operator|+
literal|3
return|;
comment|/* Split before cascade into shift.  */
block|}
else|else
block|{
comment|/* Anti- or output- dependency; DEP_INSN reads/writes a register that 	 INSN writes some cycles later.  */
comment|/* These are only significant for the fpu unit; writing a fp reg before          the fpu has finished with it stalls the processor.  */
comment|/* Reusing an integer register causes no problems.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IALU
operator|||
name|insn_type
operator|==
name|TYPE_SHIFT
condition|)
return|return
literal|0
return|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hypersparc_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_type
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dep_pat
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Data dependency; DEP_INSN writes a register that INSN reads some 	 cycles later.  */
switch|switch
condition|(
name|insn_type
condition|)
block|{
case|case
name|TYPE_STORE
case|:
case|case
name|TYPE_FPSTORE
case|:
comment|/* Get the delay iff the address of the store is the dependence.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|cost
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|cost
return|;
return|return
name|cost
operator|+
literal|3
return|;
case|case
name|TYPE_LOAD
case|:
case|case
name|TYPE_SLOAD
case|:
case|case
name|TYPE_FPLOAD
case|:
comment|/* If a load, then the dependence must be on the memory address.  If 	     the addresses aren't equal, then it might be a false dependency */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_STORE
operator|||
name|dep_type
operator|==
name|TYPE_FPSTORE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
return|return
name|cost
operator|+
literal|8
return|;
block|}
break|break;
case|case
name|TYPE_BRANCH
case|:
comment|/* Compare to branch latency is 0.  There is no benefit from 	     separating compare and branch.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_COMPARE
condition|)
return|return
literal|0
return|;
comment|/* Floating point compare to branch latency is less than 	     compare to conditional move.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_FPCMP
condition|)
return|return
name|cost
operator|-
literal|1
return|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|REG_DEP_ANTI
case|:
comment|/* Anti-dependencies only penalize the fpu unit.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IALU
operator|||
name|insn_type
operator|==
name|TYPE_SHIFT
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ultrasparc_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_type
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dep_pat
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* Nothing issues in parallel with integer multiplies, so      mark as zero cost since the scheduler can not do anything      about it.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IMUL
operator|||
name|insn_type
operator|==
name|TYPE_IDIV
condition|)
return|return
literal|0
return|;
define|#
directive|define
name|SLOW_FP
parameter_list|(
name|dep_type
parameter_list|)
define|\
value|(dep_type == TYPE_FPSQRTS || dep_type == TYPE_FPSQRTD || \  dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Data dependency; DEP_INSN writes a register that INSN reads some 	 cycles later.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_CMOVE
condition|)
block|{
comment|/* Instructions that read the result of conditional moves cannot 	     be in the same group or the following group.  */
return|return
name|cost
operator|+
literal|1
return|;
block|}
switch|switch
condition|(
name|insn_type
condition|)
block|{
comment|/* UltraSPARC can dual issue a store and an instruction setting 	     the value stored, except for divide and square root.  */
case|case
name|TYPE_FPSTORE
case|:
if|if
condition|(
operator|!
name|SLOW_FP
argument_list|(
name|dep_type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|cost
return|;
case|case
name|TYPE_STORE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|cost
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
comment|/* The dependency between the two instructions is on the data 	       that is being stored.  Assume that the address of the store 	       is not also dependent.  */
return|return
literal|0
return|;
return|return
name|cost
return|;
case|case
name|TYPE_LOAD
case|:
case|case
name|TYPE_SLOAD
case|:
case|case
name|TYPE_FPLOAD
case|:
comment|/* A load does not return data until at least 11 cycles after 	     a store to the same location.  3 cycles are accounted for 	     in the load latency; add the other 8 here.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_STORE
operator|||
name|dep_type
operator|==
name|TYPE_FPSTORE
condition|)
block|{
comment|/* If the addresses are not equal this may be a false 		 dependency because pointer aliasing could not be 		 determined.  Add only 2 cycles in that case.  2 is 		 an arbitrary compromise between 8, which would cause 		 the scheduler to generate worse code elsewhere to 		 compensate for a dependency which might not really 		 exist, and 0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
return|return
name|cost
operator|+
literal|8
return|;
block|}
return|return
name|cost
return|;
case|case
name|TYPE_BRANCH
case|:
comment|/* Compare to branch latency is 0.  There is no benefit from 	     separating compare and branch.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_COMPARE
condition|)
return|return
literal|0
return|;
comment|/* Floating point compare to branch latency is less than 	     compare to conditional move.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_FPCMP
condition|)
return|return
name|cost
operator|-
literal|1
return|;
return|return
name|cost
return|;
case|case
name|TYPE_FPCMOVE
case|:
comment|/* FMOVR class instructions can not issue in the same cycle 	     or the cycle after an instruction which writes any 	     integer register.  Model this as cost 2 for dependent 	     instructions.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_IALU
operator|&&
name|cost
operator|<
literal|2
condition|)
return|return
literal|2
return|;
comment|/* Otherwise check as for integer conditional moves.  */
case|case
name|TYPE_CMOVE
case|:
comment|/* Conditional moves involving integer registers wait until 	     3 cycles after loads return data.  The interlock applies 	     to all loads, not just dependent loads, but that is hard 	     to model.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_LOAD
operator|||
name|dep_type
operator|==
name|TYPE_SLOAD
condition|)
return|return
name|cost
operator|+
literal|3
return|;
return|return
name|cost
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|REG_DEP_ANTI
case|:
comment|/* Divide and square root lock destination registers for full latency.  */
if|if
condition|(
operator|!
name|SLOW_FP
argument_list|(
name|dep_type
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|REG_DEP_OUTPUT
case|:
comment|/* IEU and FPU instruction that have the same destination 	 register cannot be grouped together.  */
return|return
name|cost
operator|+
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Other costs not accounted for:      - Single precision floating point loads lock the other half of        the even/odd register pair.      - Several hazards associated with ldd/std are ignored because these        instructions are rarely generated for V9.      - The floating point pipeline can not have both a single and double        precision operation active at the same time.  Format conversions        and graphics instructions are given honorary double precision status.      - call and jmpl are always the first instruction in a group.  */
return|return
name|cost
return|;
undef|#
directive|undef
name|SLOW_FP
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
switch|switch
condition|(
name|sparc_cpu
condition|)
block|{
case|case
name|PROCESSOR_SUPERSPARC
case|:
name|cost
operator|=
name|supersparc_adjust_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|dep
argument_list|,
name|cost
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_HYPERSPARC
case|:
case|case
name|PROCESSOR_SPARCLITE86X
case|:
name|cost
operator|=
name|hypersparc_adjust_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|dep
argument_list|,
name|cost
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_ULTRASPARC
case|:
name|cost
operator|=
name|ultrasparc_adjust_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|dep
argument_list|,
name|cost
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* This describes the state of the UltraSPARC pipeline during    instruction scheduling.  */
end_comment

begin_define
define|#
directive|define
name|TMASK
parameter_list|(
name|__x
parameter_list|)
value|((unsigned)1<< ((int)(__x)))
end_define

begin_define
define|#
directive|define
name|UMASK
parameter_list|(
name|__x
parameter_list|)
value|((unsigned)1<< ((int)(__x)))
end_define

begin_enum
enum|enum
name|ultra_code
block|{
name|NONE
init|=
literal|0
block|,
comment|/* no insn at all				*/
name|IEU0
block|,
comment|/* shifts and conditional moves		*/
name|IEU1
block|,
comment|/* condition code setting insns, calls+jumps	*/
name|IEUN
block|,
comment|/* all other single cycle ieu insns		*/
name|LSU
block|,
comment|/* loads and stores				*/
name|CTI
block|,
comment|/* branches					*/
name|FPM
block|,
comment|/* FPU pipeline 1, multiplies and divides	*/
name|FPA
block|,
comment|/* FPU pipeline 2, all other operations	*/
name|SINGLE
block|,
comment|/* single issue instructions			*/
name|NUM_ULTRA_CODES
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|ultra_code
name|ultra_code_from_mask
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ultra_schedule_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
expr|enum
name|ultra_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ultra_code_names
index|[
name|NUM_ULTRA_CODES
index|]
init|=
block|{
literal|"NONE"
block|,
literal|"IEU0"
block|,
literal|"IEU1"
block|,
literal|"IEUN"
block|,
literal|"LSU"
block|,
literal|"CTI"
block|,
literal|"FPM"
block|,
literal|"FPA"
block|,
literal|"SINGLE"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ultrasparc_pipeline_state
block|{
comment|/* The insns in this group.  */
name|rtx
name|group
index|[
literal|4
index|]
decl_stmt|;
comment|/* The code for each insn.  */
name|enum
name|ultra_code
name|codes
index|[
literal|4
index|]
decl_stmt|;
comment|/* Which insns in this group have been committed by the      scheduler.  This is how we determine how many more      can issue this cycle.  */
name|char
name|commit
index|[
literal|4
index|]
decl_stmt|;
comment|/* How many insns in this group.  */
name|char
name|group_size
decl_stmt|;
comment|/* Mask of free slots still in this group.  */
name|char
name|free_slot_mask
decl_stmt|;
comment|/* The slotter uses the following to determine what other      insn types can still make their way into this group.  */
name|char
name|contents
index|[
name|NUM_ULTRA_CODES
index|]
decl_stmt|;
name|char
name|num_ieu_insns
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ULTRA_NUM_HIST
value|8
end_define

begin_decl_stmt
specifier|static
name|struct
name|ultrasparc_pipeline_state
name|ultra_pipe_hist
index|[
name|ULTRA_NUM_HIST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ultra_cur_hist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ultra_cycles_elapsed
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ultra_pipe
value|(ultra_pipe_hist[ultra_cur_hist])
end_define

begin_comment
comment|/* Given TYPE_MASK compute the ultra_code it has.  */
end_comment

begin_function
specifier|static
name|enum
name|ultra_code
name|ultra_code_from_mask
parameter_list|(
name|type_mask
parameter_list|)
name|int
name|type_mask
decl_stmt|;
block|{
if|if
condition|(
name|type_mask
operator|&
operator|(
name|TMASK
argument_list|(
name|TYPE_SHIFT
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_CMOVE
argument_list|)
operator|)
condition|)
return|return
name|IEU0
return|;
elseif|else
if|if
condition|(
name|type_mask
operator|&
operator|(
name|TMASK
argument_list|(
name|TYPE_COMPARE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_CALL
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_SIBCALL
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_UNCOND_BRANCH
argument_list|)
operator|)
condition|)
return|return
name|IEU1
return|;
elseif|else
if|if
condition|(
name|type_mask
operator|&
name|TMASK
argument_list|(
name|TYPE_IALU
argument_list|)
condition|)
return|return
name|IEUN
return|;
elseif|else
if|if
condition|(
name|type_mask
operator|&
operator|(
name|TMASK
argument_list|(
name|TYPE_LOAD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_SLOAD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_STORE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPLOAD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSTORE
argument_list|)
operator|)
condition|)
return|return
name|LSU
return|;
elseif|else
if|if
condition|(
name|type_mask
operator|&
operator|(
name|TMASK
argument_list|(
name|TYPE_FPMUL
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPDIVS
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPDIVD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSQRTS
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSQRTD
argument_list|)
operator|)
condition|)
return|return
name|FPM
return|;
elseif|else
if|if
condition|(
name|type_mask
operator|&
operator|(
name|TMASK
argument_list|(
name|TYPE_FPMOVE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPCMOVE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FP
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPCMP
argument_list|)
operator|)
condition|)
return|return
name|FPA
return|;
elseif|else
if|if
condition|(
name|type_mask
operator|&
name|TMASK
argument_list|(
name|TYPE_BRANCH
argument_list|)
condition|)
return|return
name|CTI
return|;
return|return
name|SINGLE
return|;
block|}
end_function

begin_comment
comment|/* Check INSN (a conditional move) and make sure that it's    results are available at this cycle.  Return 1 if the    results are in fact ready.  */
end_comment

begin_function
specifier|static
name|int
name|ultra_cmove_results_ready_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|ultrasparc_pipeline_state
modifier|*
name|up
decl_stmt|;
name|int
name|entry
decl_stmt|,
name|slot
decl_stmt|;
comment|/* If this got dispatched in the previous      group, the results are not ready.  */
name|entry
operator|=
operator|(
name|ultra_cur_hist
operator|-
literal|1
operator|)
operator|&
operator|(
name|ULTRA_NUM_HIST
operator|-
literal|1
operator|)
expr_stmt|;
name|up
operator|=
operator|&
name|ultra_pipe_hist
index|[
name|entry
index|]
expr_stmt|;
name|slot
operator|=
literal|4
expr_stmt|;
while|while
condition|(
operator|--
name|slot
operator|>=
literal|0
condition|)
if|if
condition|(
name|up
operator|->
name|group
index|[
name|slot
index|]
operator|==
name|insn
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Walk backwards in pipeline history looking for FPU    operations which use a mode different than FPMODE and    will create a stall if an insn using FPMODE were to be    dispatched this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|ultra_fpmode_conflict_exists
parameter_list|(
name|fpmode
parameter_list|)
name|enum
name|machine_mode
name|fpmode
decl_stmt|;
block|{
name|int
name|hist_ent
decl_stmt|;
name|int
name|hist_lim
decl_stmt|;
name|hist_ent
operator|=
operator|(
name|ultra_cur_hist
operator|-
literal|1
operator|)
operator|&
operator|(
name|ULTRA_NUM_HIST
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ultra_cycles_elapsed
operator|<
literal|4
condition|)
name|hist_lim
operator|=
name|ultra_cycles_elapsed
expr_stmt|;
else|else
name|hist_lim
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|hist_lim
operator|>
literal|0
condition|)
block|{
name|struct
name|ultrasparc_pipeline_state
modifier|*
name|up
init|=
operator|&
name|ultra_pipe_hist
index|[
name|hist_ent
index|]
decl_stmt|;
name|int
name|slot
init|=
literal|4
decl_stmt|;
while|while
condition|(
operator|--
name|slot
operator|>=
literal|0
condition|)
block|{
name|rtx
name|insn
init|=
name|up
operator|->
name|group
index|[
name|slot
index|]
decl_stmt|;
name|enum
name|machine_mode
name|this_mode
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
operator|(
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
continue|continue;
name|this_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this_mode
operator|!=
name|SFmode
operator|&&
name|this_mode
operator|!=
name|DFmode
operator|)
operator|||
name|this_mode
operator|==
name|fpmode
condition|)
continue|continue;
comment|/* If it is not FMOV, FABS, FNEG, FDIV, or FSQRT then 	     we will get a stall.  Loads and stores are independent 	     of these rules.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|ABS
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|NEG
operator|&&
operator|(
operator|(
name|TMASK
argument_list|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&
operator|(
name|TMASK
argument_list|(
name|TYPE_FPDIVS
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPDIVD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPMOVE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSQRTS
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSQRTD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_LOAD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_STORE
argument_list|)
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
block|}
name|hist_lim
operator|--
expr_stmt|;
name|hist_ent
operator|=
operator|(
name|hist_ent
operator|-
literal|1
operator|)
operator|&
operator|(
name|ULTRA_NUM_HIST
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* No conflicts, safe to dispatch.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find an instruction in LIST which has one of the    type attributes enumerated in TYPE_MASK.  START    says where to begin the search.     NOTE: This scheme depends upon the fact that we          have less than 32 distinct type attributes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ultra_types_avail
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
modifier|*
name|ultra_find_type
parameter_list|(
name|type_mask
parameter_list|,
name|list
parameter_list|,
name|start
parameter_list|)
name|int
name|type_mask
decl_stmt|;
name|rtx
modifier|*
name|list
decl_stmt|;
name|int
name|start
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Short circuit if no such insn exists in the ready      at the moment.  */
if|if
condition|(
operator|(
name|type_mask
operator|&
name|ultra_types_avail
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|insn
init|=
name|list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|TMASK
argument_list|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&
name|type_mask
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|fpmode
init|=
name|SFmode
decl_stmt|;
name|rtx
name|pat
init|=
literal|0
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|int
name|check_depend
init|=
literal|0
decl_stmt|;
name|int
name|check_fpmode_conflict
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
operator|!
operator|(
name|type_mask
operator|&
operator|(
name|TMASK
argument_list|(
name|TYPE_STORE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSTORE
argument_list|)
operator|)
operator|)
condition|)
block|{
name|check_depend
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|fpmode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|check_fpmode_conflict
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|slot
operator|=
literal|4
expr_stmt|;
while|while
condition|(
operator|--
name|slot
operator|>=
literal|0
condition|)
block|{
name|rtx
name|slot_insn
init|=
name|ultra_pipe
operator|.
name|group
index|[
name|slot
index|]
decl_stmt|;
name|rtx
name|slot_pat
decl_stmt|;
comment|/* Already issued, bad dependency, or FPU 		 mode conflict.  */
if|if
condition|(
name|slot_insn
operator|!=
literal|0
operator|&&
operator|(
name|slot_pat
operator|=
name|PATTERN
argument_list|(
name|slot_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|insn
operator|==
name|slot_insn
operator|)
operator|||
operator|(
name|check_depend
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|slot_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|slot_pat
argument_list|)
operator|==
name|SET
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|SUBREG_BYTE
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|)
operator|==
name|SUBREG_BYTE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|check_fpmode_conflict
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|slot_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|slot_pat
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|)
operator|!=
name|fpmode
operator|)
operator|)
condition|)
goto|goto
name|next
goto|;
block|}
comment|/* Check for peculiar result availability and dispatch 	     interference situations.  */
if|if
condition|(
name|pat
operator|!=
literal|0
operator|&&
name|ultra_cycles_elapsed
operator|>
literal|0
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|link_insn
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|link_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|recog_memoized
argument_list|(
name|link_insn
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|TMASK
argument_list|(
name|get_attr_type
argument_list|(
name|link_insn
argument_list|)
argument_list|)
operator|&
operator|(
name|TMASK
argument_list|(
name|TYPE_CMOVE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPCMOVE
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|ultra_cmove_results_ready_p
argument_list|(
name|link_insn
argument_list|)
condition|)
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|check_fpmode_conflict
operator|&&
name|ultra_fpmode_conflict_exists
argument_list|(
name|fpmode
argument_list|)
condition|)
goto|goto
name|next
goto|;
block|}
return|return
operator|&
name|list
index|[
name|i
index|]
return|;
block|}
name|next
label|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ultra_build_types_avail
parameter_list|(
name|ready
parameter_list|,
name|n_ready
parameter_list|)
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|{
name|int
name|i
init|=
name|n_ready
operator|-
literal|1
decl_stmt|;
name|ultra_types_avail
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|rtx
name|insn
init|=
name|ready
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
name|ultra_types_avail
operator||=
name|TMASK
argument_list|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Place insn pointed to my IP into the pipeline.    Make element THIS of READY be that insn if it    is not already.  TYPE indicates the pipeline class    this insn falls into.  */
end_comment

begin_function
specifier|static
name|void
name|ultra_schedule_insn
parameter_list|(
name|ip
parameter_list|,
name|ready
parameter_list|,
name|this
parameter_list|,
name|type
parameter_list|)
name|rtx
modifier|*
name|ip
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|this
decl_stmt|;
name|enum
name|ultra_code
name|type
decl_stmt|;
block|{
name|int
name|pipe_slot
decl_stmt|;
name|char
name|mask
init|=
name|ultra_pipe
operator|.
name|free_slot_mask
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Obtain free slot.  */
for|for
control|(
name|pipe_slot
operator|=
literal|0
init|;
name|pipe_slot
operator|<
literal|4
condition|;
name|pipe_slot
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|pipe_slot
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|pipe_slot
operator|==
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* In it goes, and it hasn't been committed yet.  */
name|ultra_pipe
operator|.
name|group
index|[
name|pipe_slot
index|]
operator|=
operator|*
name|ip
expr_stmt|;
name|ultra_pipe
operator|.
name|codes
index|[
name|pipe_slot
index|]
operator|=
name|type
expr_stmt|;
name|ultra_pipe
operator|.
name|contents
index|[
name|type
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|UMASK
argument_list|(
name|type
argument_list|)
operator|&
operator|(
name|UMASK
argument_list|(
name|IEUN
argument_list|)
operator||
name|UMASK
argument_list|(
name|IEU0
argument_list|)
operator||
name|UMASK
argument_list|(
name|IEU1
argument_list|)
operator|)
condition|)
name|ultra_pipe
operator|.
name|num_ieu_insns
operator|+=
literal|1
expr_stmt|;
name|ultra_pipe
operator|.
name|free_slot_mask
operator|=
operator|(
name|mask
operator|&
operator|~
operator|(
literal|1
operator|<<
name|pipe_slot
operator|)
operator|)
expr_stmt|;
name|ultra_pipe
operator|.
name|group_size
operator|+=
literal|1
expr_stmt|;
name|ultra_pipe
operator|.
name|commit
index|[
name|pipe_slot
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Update ready list.  */
name|temp
operator|=
operator|*
name|ip
expr_stmt|;
while|while
condition|(
name|ip
operator|!=
operator|&
name|ready
index|[
name|this
index|]
condition|)
block|{
name|ip
index|[
literal|0
index|]
operator|=
name|ip
index|[
literal|1
index|]
expr_stmt|;
operator|++
name|ip
expr_stmt|;
block|}
operator|*
name|ip
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance to the next pipeline group.  */
end_comment

begin_function
specifier|static
name|void
name|ultra_flush_pipeline
parameter_list|()
block|{
name|ultra_cur_hist
operator|=
operator|(
name|ultra_cur_hist
operator|+
literal|1
operator|)
operator|&
operator|(
name|ULTRA_NUM_HIST
operator|-
literal|1
operator|)
expr_stmt|;
name|ultra_cycles_elapsed
operator|+=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ultra_pipe
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ultra_pipe
argument_list|)
expr_stmt|;
name|ultra_pipe
operator|.
name|free_slot_mask
operator|=
literal|0xf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Init our data structures for this current block.  */
end_comment

begin_function
specifier|static
name|void
name|ultrasparc_sched_init
parameter_list|()
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ultra_pipe_hist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ultra_pipe_hist
argument_list|)
expr_stmt|;
name|ultra_cur_hist
operator|=
literal|0
expr_stmt|;
name|ultra_cycles_elapsed
operator|=
literal|0
expr_stmt|;
name|ultra_pipe
operator|.
name|free_slot_mask
operator|=
literal|0xf
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_sched_init
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|max_ready
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|max_ready
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC
condition|)
name|ultrasparc_sched_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* INSN has been scheduled, update pipeline commit state    and return how many instructions are still to be    scheduled in this group.  */
end_comment

begin_function
specifier|static
name|int
name|ultrasparc_variable_issue
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|ultrasparc_pipeline_state
modifier|*
name|up
init|=
operator|&
name|ultra_pipe
decl_stmt|;
name|int
name|i
decl_stmt|,
name|left_to_fire
decl_stmt|;
name|left_to_fire
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|up
operator|->
name|group
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|up
operator|->
name|group
index|[
name|i
index|]
operator|==
name|insn
condition|)
block|{
name|up
operator|->
name|commit
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|up
operator|->
name|commit
index|[
name|i
index|]
condition|)
name|left_to_fire
operator|++
expr_stmt|;
block|}
return|return
name|left_to_fire
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_variable_issue
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|insn
parameter_list|,
name|cim
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|cim
decl_stmt|;
block|{
if|if
condition|(
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC
condition|)
return|return
name|ultrasparc_variable_issue
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|cim
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* In actual_hazard_this_instance, we may have yanked some    instructions from the ready list due to conflict cost    adjustments.  If so, and such an insn was in our pipeline    group, remove it and update state.  */
end_comment

begin_function
specifier|static
name|void
name|ultra_rescan_pipeline_state
parameter_list|(
name|ready
parameter_list|,
name|n_ready
parameter_list|)
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|{
name|struct
name|ultrasparc_pipeline_state
modifier|*
name|up
init|=
operator|&
name|ultra_pipe
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|up
operator|->
name|group
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
continue|continue;
comment|/* If it has been committed, then it was removed from 	 the ready list because it was actually scheduled, 	 and that is not the case we are searching for here.  */
if|if
condition|(
name|up
operator|->
name|commit
index|[
name|i
index|]
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|n_ready
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|ready
index|[
name|j
index|]
operator|==
name|insn
condition|)
break|break;
comment|/* If we didn't find it, toss it.  */
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|enum
name|ultra_code
name|ucode
init|=
name|up
operator|->
name|codes
index|[
name|i
index|]
decl_stmt|;
name|up
operator|->
name|group
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|codes
index|[
name|i
index|]
operator|=
name|NONE
expr_stmt|;
name|up
operator|->
name|contents
index|[
name|ucode
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|UMASK
argument_list|(
name|ucode
argument_list|)
operator|&
operator|(
name|UMASK
argument_list|(
name|IEUN
argument_list|)
operator||
name|UMASK
argument_list|(
name|IEU0
argument_list|)
operator||
name|UMASK
argument_list|(
name|IEU1
argument_list|)
operator|)
condition|)
name|up
operator|->
name|num_ieu_insns
operator|-=
literal|1
expr_stmt|;
name|up
operator|->
name|free_slot_mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|up
operator|->
name|group_size
operator|-=
literal|1
expr_stmt|;
name|up
operator|->
name|commit
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ultrasparc_sched_reorder
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|ready
parameter_list|,
name|n_ready
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|int
name|sched_verbose
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|{
name|struct
name|ultrasparc_pipeline_state
modifier|*
name|up
init|=
operator|&
name|ultra_pipe
decl_stmt|;
name|int
name|i
decl_stmt|,
name|this_insn
decl_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|int
name|n
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n;;\tUltraSPARC Looking at ["
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n_ready
operator|-
literal|1
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|rtx
name|insn
init|=
name|ready
index|[
name|n
index|]
decl_stmt|;
name|enum
name|ultra_code
name|ucode
decl_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|ucode
operator|=
name|ultra_code_from_mask
argument_list|(
name|TMASK
argument_list|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s(%d) "
argument_list|,
name|ultra_code_names
index|[
name|ucode
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s(%d)"
argument_list|,
name|ultra_code_names
index|[
name|ucode
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
name|this_insn
operator|=
name|n_ready
operator|-
literal|1
expr_stmt|;
comment|/* Skip over junk we don't understand.  */
while|while
condition|(
operator|(
name|this_insn
operator|>=
literal|0
operator|)
operator|&&
name|recog_memoized
argument_list|(
name|ready
index|[
name|this_insn
index|]
argument_list|)
operator|<
literal|0
condition|)
name|this_insn
operator|--
expr_stmt|;
name|ultra_build_types_avail
argument_list|(
name|ready
argument_list|,
name|this_insn
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|this_insn
operator|>=
literal|0
condition|)
block|{
name|int
name|old_group_size
init|=
name|up
operator|->
name|group_size
decl_stmt|;
if|if
condition|(
name|up
operator|->
name|group_size
operator|!=
literal|0
condition|)
block|{
name|int
name|num_committed
decl_stmt|;
name|num_committed
operator|=
operator|(
name|up
operator|->
name|commit
index|[
literal|0
index|]
operator|+
name|up
operator|->
name|commit
index|[
literal|1
index|]
operator|+
name|up
operator|->
name|commit
index|[
literal|2
index|]
operator|+
name|up
operator|->
name|commit
index|[
literal|3
index|]
operator|)
expr_stmt|;
comment|/* If nothing has been commited from our group, or all of 	   them have.  Clear out the (current cycle's) pipeline 	   state and start afresh.  */
if|if
condition|(
name|num_committed
operator|==
literal|0
operator|||
name|num_committed
operator|==
name|up
operator|->
name|group_size
condition|)
block|{
name|ultra_flush_pipeline
argument_list|()
expr_stmt|;
name|up
operator|=
operator|&
name|ultra_pipe
expr_stmt|;
name|old_group_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* OK, some ready list insns got requeued and thus removed 	       from the ready list.  Account for this fact.  */
name|ultra_rescan_pipeline_state
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
comment|/* Something "changed", make this look like a newly 	       formed group so the code at the end of the loop 	       knows that progress was in fact made.  */
if|if
condition|(
name|up
operator|->
name|group_size
operator|!=
name|old_group_size
condition|)
name|old_group_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|up
operator|->
name|group_size
operator|==
literal|0
condition|)
block|{
comment|/* If the pipeline is (still) empty and we have any single 	   group insns, get them out now as this is a good time.  */
name|rtx
modifier|*
name|ip
init|=
name|ultra_find_type
argument_list|(
operator|(
name|TMASK
argument_list|(
name|TYPE_RETURN
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_IDIV
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_IMUL
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_CMOVE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_MULTI
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_MISC
argument_list|)
operator|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
name|SINGLE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If we are not in the process of emptying out the pipe, try to 	   obtain an instruction which must be the first in it's group.  */
name|ip
operator|=
name|ultra_find_type
argument_list|(
operator|(
name|TMASK
argument_list|(
name|TYPE_CALL
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_SIBCALL
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_CALL_NO_DELAY_SLOT
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_UNCOND_BRANCH
argument_list|)
operator|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
name|IEU1
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ip
operator|=
name|ultra_find_type
argument_list|(
operator|(
name|TMASK
argument_list|(
name|TYPE_FPDIVS
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPDIVD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSQRTS
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSQRTD
argument_list|)
operator|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
name|FPM
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
block|}
comment|/* Try to fill the integer pipeline.  First, look for an IEU0 specific        operation.  We can't do more IEU operations if the first 3 slots are        all full or we have dispatched two IEU insns already.  */
if|if
condition|(
operator|(
name|up
operator|->
name|free_slot_mask
operator|&
literal|0x7
operator|)
operator|!=
literal|0
operator|&&
name|up
operator|->
name|num_ieu_insns
operator|<
literal|2
operator|&&
name|up
operator|->
name|contents
index|[
name|IEU0
index|]
operator|==
literal|0
operator|&&
name|up
operator|->
name|contents
index|[
name|IEUN
index|]
operator|==
literal|0
condition|)
block|{
name|rtx
modifier|*
name|ip
init|=
name|ultra_find_type
argument_list|(
name|TMASK
argument_list|(
name|TYPE_SHIFT
argument_list|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
name|IEU0
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
block|}
comment|/* If we can, try to find an IEU1 specific or an unnamed        IEU instruction.  */
if|if
condition|(
operator|(
name|up
operator|->
name|free_slot_mask
operator|&
literal|0x7
operator|)
operator|!=
literal|0
operator|&&
name|up
operator|->
name|num_ieu_insns
operator|<
literal|2
condition|)
block|{
name|rtx
modifier|*
name|ip
init|=
name|ultra_find_type
argument_list|(
operator|(
name|TMASK
argument_list|(
name|TYPE_IALU
argument_list|)
operator||
operator|(
name|up
operator|->
name|contents
index|[
name|IEU1
index|]
operator|==
literal|0
condition|?
name|TMASK
argument_list|(
name|TYPE_COMPARE
argument_list|)
else|:
literal|0
operator|)
operator|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|ip
decl_stmt|;
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
operator|(
operator|!
name|up
operator|->
name|contents
index|[
name|IEU1
index|]
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_COMPARE
operator|)
condition|?
name|IEU1
else|:
name|IEUN
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
block|}
comment|/* If only one IEU insn has been found, try to find another unnamed        IEU operation or an IEU1 specific one.  */
if|if
condition|(
operator|(
name|up
operator|->
name|free_slot_mask
operator|&
literal|0x7
operator|)
operator|!=
literal|0
operator|&&
name|up
operator|->
name|num_ieu_insns
operator|<
literal|2
condition|)
block|{
name|rtx
modifier|*
name|ip
decl_stmt|;
name|int
name|tmask
init|=
name|TMASK
argument_list|(
name|TYPE_IALU
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|up
operator|->
name|contents
index|[
name|IEU1
index|]
condition|)
name|tmask
operator||=
name|TMASK
argument_list|(
name|TYPE_COMPARE
argument_list|)
expr_stmt|;
name|ip
operator|=
name|ultra_find_type
argument_list|(
name|tmask
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|ip
decl_stmt|;
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
operator|(
operator|!
name|up
operator|->
name|contents
index|[
name|IEU1
index|]
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_COMPARE
operator|)
condition|?
name|IEU1
else|:
name|IEUN
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
block|}
comment|/* Try for a load or store, but such an insn can only be issued        if it is within' one of the first 3 slots.  */
if|if
condition|(
operator|(
name|up
operator|->
name|free_slot_mask
operator|&
literal|0x7
operator|)
operator|!=
literal|0
operator|&&
name|up
operator|->
name|contents
index|[
name|LSU
index|]
operator|==
literal|0
condition|)
block|{
name|rtx
modifier|*
name|ip
init|=
name|ultra_find_type
argument_list|(
operator|(
name|TMASK
argument_list|(
name|TYPE_LOAD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_SLOAD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_STORE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPLOAD
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPSTORE
argument_list|)
operator|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
name|LSU
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
block|}
comment|/* Now find FPU operations, first FPM class.  But not divisions or        square-roots because those will break the group up.  Unlike all        the previous types, these can go in any slot.  */
if|if
condition|(
name|up
operator|->
name|free_slot_mask
operator|!=
literal|0
operator|&&
name|up
operator|->
name|contents
index|[
name|FPM
index|]
operator|==
literal|0
condition|)
block|{
name|rtx
modifier|*
name|ip
init|=
name|ultra_find_type
argument_list|(
name|TMASK
argument_list|(
name|TYPE_FPMUL
argument_list|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
name|FPM
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
block|}
comment|/* Continue on with FPA class if we have not filled the group already.  */
if|if
condition|(
name|up
operator|->
name|free_slot_mask
operator|!=
literal|0
operator|&&
name|up
operator|->
name|contents
index|[
name|FPA
index|]
operator|==
literal|0
condition|)
block|{
name|rtx
modifier|*
name|ip
init|=
name|ultra_find_type
argument_list|(
operator|(
name|TMASK
argument_list|(
name|TYPE_FPMOVE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPCMOVE
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FP
argument_list|)
operator||
name|TMASK
argument_list|(
name|TYPE_FPCMP
argument_list|)
operator|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
name|FPA
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
block|}
comment|/* Finally, maybe stick a branch in here.  */
if|if
condition|(
name|up
operator|->
name|free_slot_mask
operator|!=
literal|0
operator|&&
name|up
operator|->
name|contents
index|[
name|CTI
index|]
operator|==
literal|0
condition|)
block|{
name|rtx
modifier|*
name|ip
init|=
name|ultra_find_type
argument_list|(
name|TMASK
argument_list|(
name|TYPE_BRANCH
argument_list|)
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|)
decl_stmt|;
comment|/* Try to slip in a branch only if it is one of the 	   next 2 in the ready list.  */
if|if
condition|(
name|ip
operator|&&
operator|(
operator|(
operator|&
name|ready
index|[
name|this_insn
index|]
operator|-
name|ip
operator|)
operator|<
literal|2
operator|)
condition|)
block|{
name|ultra_schedule_insn
argument_list|(
name|ip
argument_list|,
name|ready
argument_list|,
name|this_insn
argument_list|,
name|CTI
argument_list|)
expr_stmt|;
name|this_insn
operator|--
expr_stmt|;
block|}
block|}
name|up
operator|->
name|group_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|up
operator|->
name|free_slot_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|up
operator|->
name|group_size
operator|++
expr_stmt|;
comment|/* See if we made any progress...  */
if|if
condition|(
name|old_group_size
operator|!=
name|up
operator|->
name|group_size
condition|)
break|break;
comment|/* Clean out the (current cycle's) pipeline state        and try once more.  If we placed no instructions        into the pipeline at all, it means a real hard        conflict exists with some earlier issued instruction        so we must advance to the next cycle to clear it up.  */
if|if
condition|(
name|up
operator|->
name|group_size
operator|==
literal|0
condition|)
block|{
name|ultra_flush_pipeline
argument_list|()
expr_stmt|;
name|up
operator|=
operator|&
name|ultra_pipe
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ultra_pipe
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ultra_pipe
argument_list|)
expr_stmt|;
name|ultra_pipe
operator|.
name|free_slot_mask
operator|=
literal|0xf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|int
name|n
decl_stmt|,
name|gsize
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\tUltraSPARC Launched   ["
argument_list|)
expr_stmt|;
name|gsize
operator|=
name|up
operator|->
name|group_size
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|up
operator|->
name|group
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
continue|continue;
name|gsize
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|gsize
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s(%d) "
argument_list|,
name|ultra_code_names
index|[
name|up
operator|->
name|codes
index|[
name|n
index|]
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s(%d)"
argument_list|,
name|ultra_code_names
index|[
name|up
operator|->
name|codes
index|[
name|n
index|]
index|]
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_sched_reorder
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|ready
parameter_list|,
name|n_readyp
parameter_list|,
name|clock
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|int
name|sched_verbose
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
modifier|*
name|n_readyp
decl_stmt|;
name|int
name|clock
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC
condition|)
name|ultrasparc_sched_reorder
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
operator|*
name|n_readyp
argument_list|)
expr_stmt|;
return|return
name|sparc_issue_rate
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_issue_rate
parameter_list|()
block|{
switch|switch
condition|(
name|sparc_cpu
condition|)
block|{
default|default:
return|return
literal|1
return|;
case|case
name|PROCESSOR_V9
case|:
comment|/* Assume V9 processors are capable of at least dual-issue.  */
return|return
literal|2
return|;
case|case
name|PROCESSOR_SUPERSPARC
case|:
return|return
literal|3
return|;
case|case
name|PROCESSOR_HYPERSPARC
case|:
case|case
name|PROCESSOR_SPARCLITE86X
case|:
return|return
literal|2
return|;
case|case
name|PROCESSOR_ULTRASPARC
case|:
return|return
literal|4
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|set_extends
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Load and some shift instructions zero extend.  */
case|case
name|MEM
case|:
case|case
name|ZERO_EXTEND
case|:
comment|/* sethi clears the high bits */
case|case
name|HIGH
case|:
comment|/* LO_SUM is used with sethi.  sethi cleared the high 	 bits and the values used with lo_sum are positive */
case|case
name|LO_SUM
case|:
comment|/* Store flag stores 0 or 1 */
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
literal|1
return|;
case|case
name|AND
case|:
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sparc_check_64
argument_list|(
name|op0
argument_list|,
name|insn
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|sparc_check_64
argument_list|(
name|op1
argument_list|,
name|insn
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
case|case
name|IOR
case|:
case|case
name|XOR
case|:
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
name|sparc_check_64
argument_list|(
name|op0
argument_list|,
name|insn
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|sparc_check_64
argument_list|(
name|op1
argument_list|,
name|insn
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
return|return
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SImode
return|;
comment|/* Positive integers leave the high bits zero.  */
case|case
name|CONST_DOUBLE
case|:
return|return
operator|!
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|&
literal|0x80000000
operator|)
return|;
case|case
name|CONST_INT
case|:
return|return
operator|!
operator|(
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|&
literal|0x80000000
operator|)
return|;
case|case
name|ASHIFTRT
case|:
case|case
name|SIGN_EXTEND
case|:
return|return
operator|-
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SImode
operator|)
return|;
case|case
name|REG
case|:
return|return
name|sparc_check_64
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* We _ought_ to have only one kind per function, but...  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|sparc_addr_diff_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|sparc_addr_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sparc_defer_case_vector
parameter_list|(
name|lab
parameter_list|,
name|vec
parameter_list|,
name|diff
parameter_list|)
name|rtx
name|lab
decl_stmt|,
name|vec
decl_stmt|;
name|int
name|diff
decl_stmt|;
block|{
name|vec
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|,
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
name|sparc_addr_diff_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|,
name|sparc_addr_diff_list
argument_list|)
expr_stmt|;
else|else
name|sparc_addr_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|,
name|sparc_addr_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_output_addr_vec
parameter_list|(
name|vec
parameter_list|)
name|rtx
name|vec
decl_stmt|;
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|body
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|vlen
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_START
name|ASM_OUTPUT_ADDR_VEC_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_LABEL
name|ASM_OUTPUT_CASE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
name|ASM_OUTPUT_ADDR_VEC_ELT
argument_list|(
name|asm_out_file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_END
name|ASM_OUTPUT_ADDR_VEC_END
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_output_addr_diff_vec
parameter_list|(
name|vec
parameter_list|)
name|rtx
name|vec
decl_stmt|;
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|body
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|vlen
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_START
name|ASM_OUTPUT_ADDR_VEC_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_LABEL
name|ASM_OUTPUT_CASE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
name|ASM_OUTPUT_ADDR_DIFF_ELT
argument_list|(
name|asm_out_file
argument_list|,
name|body
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_END
name|ASM_OUTPUT_ADDR_VEC_END
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_output_deferred_case_vectors
parameter_list|()
block|{
name|rtx
name|t
decl_stmt|;
name|int
name|align
decl_stmt|;
if|if
condition|(
name|sparc_addr_list
operator|==
name|NULL_RTX
operator|&&
name|sparc_addr_diff_list
operator|==
name|NULL_RTX
condition|)
return|return;
comment|/* Align to cache line in the function's code section.  */
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|sparc_addr_list
init|;
name|t
condition|;
name|t
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
control|)
name|sparc_output_addr_vec
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|sparc_addr_diff_list
init|;
name|t
condition|;
name|t
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
control|)
name|sparc_output_addr_diff_vec
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sparc_addr_list
operator|=
name|sparc_addr_diff_list
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 0 if the high 32 bits of X (the low word of X, if DImode) are    unknown.  Return 1 if the high bits are zero, -1 if the register is    sign extended.  */
end_comment

begin_function
name|int
name|sparc_check_64
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
comment|/* If a register is set only once it is safe to ignore insns this      code does not know how to handle.  The loop will either recognize      the single set and return the correct value or fail to recognize      it and return 0.  */
name|int
name|set_once
init|=
literal|0
decl_stmt|;
name|rtx
name|y
init|=
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
name|y
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|WORDS_BIG_ENDIAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|set_once
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|set_once
condition|)
name|insn
operator|=
name|get_last_insn_anywhere
argument_list|()
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|JUMP_INSN
case|:
case|case
name|NOTE
case|:
break|break;
case|case
name|CODE_LABEL
case|:
case|case
name|CALL_INSN
case|:
default|default:
if|if
condition|(
operator|!
name|set_once
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|INSN
case|:
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|set_extends
argument_list|(
name|insn
argument_list|)
return|;
if|if
condition|(
name|y
operator|&&
name|rtx_equal_p
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|set_extends
argument_list|(
name|insn
argument_list|)
return|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sparc_v8plus_shift
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|,
name|opcode
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
specifier|const
name|char
modifier|*
name|opcode
decl_stmt|;
block|{
specifier|static
name|char
name|asm_code
index|[
literal|60
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|SCRATCH
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"mov\t%1, %3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"sllx\t%H1, 32, %3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_check_64
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|insn
argument_list|)
operator|<=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"srl\t%L1, 0, %L1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"or\t%L1, %3, %3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|asm_code
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_alternative
operator|!=
literal|2
condition|)
return|return
name|strcat
argument_list|(
name|asm_code
argument_list|,
literal|"\t%0, %2, %L0\n\tsrlx\t%L0, 32, %H0"
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|asm_code
argument_list|,
literal|"\t%3, %2, %3\n\tsrlx\t%3, 32, %H0\n\tmov\t%3, %L0"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if DEST and SRC reference only global and in registers.  */
end_comment

begin_function
name|int
name|sparc_return_peephole_ok
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_V9
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|IN_OR_GLOBAL_P
argument_list|(
name|src
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|IN_OR_GLOBAL_P
argument_list|(
name|dest
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to FILE to increment profiler label # LABELNO    for profiling a function entry.     32 bit sparc uses %g2 as the STATIC_CHAIN_REGNUM which gets clobbered    during profiling so we need to save/restore it around the call to mcount.    We're guaranteed that a save has just been done, and we use the space    allocated for intreg/fpreg value passing.  */
end_comment

begin_function
name|void
name|sparc_function_profiler
parameter_list|(
name|file
parameter_list|,
name|labelno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ARCH64
condition|)
name|fputs
argument_list|(
literal|"\tst\t%g2, [%fp-4]\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tsethi\t%hi("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"), %o0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tcall\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|MCOUNT_FUNCTION
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t or\t%o0, %lo("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"), %o0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ARCH64
condition|)
name|fputs
argument_list|(
literal|"\tld\t[%fp-4], %g2\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark ARG, which is really a struct ultrasparc_pipline_state *, for    GC.  */
end_comment

begin_function
specifier|static
name|void
name|mark_ultrasparc_pipeline_state
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ultrasparc_pipeline_state
modifier|*
name|ups
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ups
operator|=
operator|(
expr|struct
name|ultrasparc_pipeline_state
operator|*
operator|)
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ups
operator|->
name|group
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
condition|;
operator|++
name|i
control|)
name|ggc_mark_rtx
argument_list|(
name|ups
operator|->
name|group
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to register all of our global variables with the garbage    collector.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_add_gc_roots
parameter_list|()
block|{
name|ggc_add_rtx_root
argument_list|(
operator|&
name|sparc_compare_op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|sparc_compare_op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|leaf_label
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|global_offset_table
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|get_pc_symbol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|sparc_addr_diff_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|sparc_addr_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
name|ultra_pipe_hist
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|ultra_pipe_hist
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ultra_pipe_hist
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|&
name|mark_ultrasparc_pipeline_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_function
specifier|static
name|void
name|sparc_elf_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|flags
operator|&
name|SECTION_MERGE
condition|)
block|{
comment|/* entsize cannot be expressed in this section attributes 	 encoding style.  */
name|default_elf_asm_named_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t\"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_DEBUG
operator|)
condition|)
name|fputs
argument_list|(
literal|",#alloc"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
name|fputs
argument_list|(
literal|",#write"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
name|fputs
argument_list|(
literal|",#execinstr"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* ??? Handle SECTION_BSS.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ELF */
end_comment

end_unit

