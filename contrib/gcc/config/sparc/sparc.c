begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Sun SPARC.    Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)    64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,    at Cygnus Support.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* 1 if the caller has placed an "unimp" insn immediately after the call.    This is used in v8 code when calling a function that returns a structure.    v9 doesn't have this.  Be careful to have this test be the same as that    used on the call.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_CALLERS_UNIMP_P
define|\
value|(!TARGET_ARCH64&& current_function_returns_struct			\&& ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl)))	\&& (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))	\      == INTEGER_CST))
end_define

begin_comment
comment|/* Global variables for machine-dependent things.  */
end_comment

begin_comment
comment|/* Size of frame.  Need to know this to emit return insns from leaf procedures.    ACTUAL_FSIZE is set by compute_frame_size() which is called during the    reload pass.  This is important as the value is later used in insn    scheduling (to see what can go in a delay slot).    APPARENT_FSIZE is the size of the stack less the register save area and less    the outgoing argument area.  It is used when saving call preserved regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apparent_fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|actual_fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save the operands last given to a compare for use when we    generate a scc or bcc insn.  */
end_comment

begin_decl_stmt
name|rtx
name|sparc_compare_op0
decl_stmt|,
name|sparc_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We may need an epilogue if we spill too many registers.    If this is non-zero, then we branch here for the epilogue.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|leaf_label
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
end_ifdef

begin_comment
comment|/* Vector to say how input registers are mapped to output    registers.  FRAME_POINTER_REGNUM cannot be remapped by    this function to eliminate it.  You must use -fomit-frame-pointer    to get that.  */
end_comment

begin_decl_stmt
name|char
name|leaf_reg_remap
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|14
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|15
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Name of where we pretend to think the frame pointer points.    Normally, this is "%fp", but if we are in a leaf procedure,    this is "%sp+something".  We record "something" separately as it may be    too big for reg+constant addressing.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|frame_base_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frame_base_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|pic_setup_code
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_addr_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc_init_modes
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|save_regs
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|restore_regs
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_big_number
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|function_arg_slotno
name|PROTO
argument_list|(
operator|(
specifier|const
name|CUMULATIVE_ARGS
operator|*
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|dwarf2out_cfi_label
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Option handling.  */
end_comment

begin_comment
comment|/* Code model option as passed by user.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sparc_cmodel_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsed value.  */
end_comment

begin_decl_stmt
name|enum
name|cmodel
name|sparc_cmodel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record alignment options as passed by user.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sparc_align_loops_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sparc_align_jumps_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sparc_align_funcs_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsed values, as a power of two.  */
end_comment

begin_decl_stmt
name|int
name|sparc_align_loops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sparc_align_jumps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sparc_align_funcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sparc_cpu_select
name|sparc_select
index|[]
init|=
block|{
comment|/* switch	name,		tune	arch */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"default"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mcpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mtune="
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU type.  This is set from TARGET_CPU_DEFAULT and -m{cpu,tune}=xxx.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|sparc_cpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Validate and override various options, and do some machine dependent    initialization.  */
end_comment

begin_function
name|void
name|sparc_override_options
parameter_list|()
block|{
specifier|static
struct|struct
name|code_model
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|cmodels
index|[]
init|=
block|{
block|{
literal|"32"
block|,
name|CM_32
block|}
block|,
block|{
literal|"medlow"
block|,
name|CM_MEDLOW
block|}
block|,
block|{
literal|"medmid"
block|,
name|CM_MEDMID
block|}
block|,
block|{
literal|"medany"
block|,
name|CM_MEDANY
block|}
block|,
block|{
literal|"embmedany"
block|,
name|CM_EMBMEDANY
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
name|struct
name|code_model
modifier|*
name|cmodel
decl_stmt|;
comment|/* Map TARGET_CPU_DEFAULT to value for -m{arch,tune}=.  */
specifier|static
struct|struct
name|cpu_default
block|{
name|int
name|cpu
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|cpu_default
index|[]
init|=
block|{
comment|/* There must be one entry here for each TARGET_CPU value.  */
block|{
name|TARGET_CPU_sparc
block|,
literal|"cypress"
block|}
block|,
block|{
name|TARGET_CPU_sparclet
block|,
literal|"tsc701"
block|}
block|,
block|{
name|TARGET_CPU_sparclite
block|,
literal|"f930"
block|}
block|,
block|{
name|TARGET_CPU_v8
block|,
literal|"v8"
block|}
block|,
block|{
name|TARGET_CPU_supersparc
block|,
literal|"supersparc"
block|}
block|,
block|{
name|TARGET_CPU_v9
block|,
literal|"v9"
block|}
block|,
block|{
name|TARGET_CPU_ultrasparc
block|,
literal|"ultrasparc"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
name|struct
name|cpu_default
modifier|*
name|def
decl_stmt|;
comment|/* Table of values for -m{cpu,tune}=.  */
specifier|static
struct|struct
name|cpu_table
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|processor_type
name|processor
decl_stmt|;
name|int
name|disable
decl_stmt|;
name|int
name|enable
decl_stmt|;
block|}
name|cpu_table
index|[]
init|=
block|{
block|{
literal|"v7"
block|,
name|PROCESSOR_V7
block|,
name|MASK_ISA
block|,
literal|0
block|}
block|,
block|{
literal|"cypress"
block|,
name|PROCESSOR_CYPRESS
block|,
name|MASK_ISA
block|,
literal|0
block|}
block|,
block|{
literal|"v8"
block|,
name|PROCESSOR_V8
block|,
name|MASK_ISA
block|,
name|MASK_V8
block|}
block|,
comment|/* TI TMS390Z55 supersparc */
block|{
literal|"supersparc"
block|,
name|PROCESSOR_SUPERSPARC
block|,
name|MASK_ISA
block|,
name|MASK_V8
block|}
block|,
block|{
literal|"sparclite"
block|,
name|PROCESSOR_SPARCLITE
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLITE
block|}
block|,
comment|/* The Fujitsu MB86930 is the original sparclite chip, with no fpu.        The Fujitsu MB86934 is the recent sparclite chip, with an fpu.  */
block|{
literal|"f930"
block|,
name|PROCESSOR_F930
block|,
name|MASK_ISA
operator||
name|MASK_FPU
block|,
name|MASK_SPARCLITE
block|}
block|,
block|{
literal|"f934"
block|,
name|PROCESSOR_F934
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLITE
operator||
name|MASK_FPU
block|}
block|,
block|{
literal|"sparclet"
block|,
name|PROCESSOR_SPARCLET
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLET
block|}
block|,
comment|/* TEMIC sparclet */
block|{
literal|"tsc701"
block|,
name|PROCESSOR_TSC701
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLET
block|}
block|,
block|{
literal|"v9"
block|,
name|PROCESSOR_V9
block|,
name|MASK_ISA
block|,
name|MASK_V9
block|}
block|,
comment|/* TI ultrasparc */
block|{
literal|"ultrasparc"
block|,
name|PROCESSOR_ULTRASPARC
block|,
name|MASK_ISA
block|,
name|MASK_V9
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
name|struct
name|cpu_table
modifier|*
name|cpu
decl_stmt|;
name|struct
name|sparc_cpu_select
modifier|*
name|sel
decl_stmt|;
name|int
name|fpu
decl_stmt|;
ifndef|#
directive|ifndef
name|SPARC_BI_ARCH
comment|/* Check for unsupported architecture size.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|!=
name|DEFAULT_ARCH32_P
condition|)
block|{
name|error
argument_list|(
literal|"%s is not supported by this configuration"
argument_list|,
name|DEFAULT_ARCH32_P
condition|?
literal|"-m64"
else|:
literal|"-m32"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Code model selection.  */
name|sparc_cmodel
operator|=
name|SPARC_DEFAULT_CMODEL
expr_stmt|;
if|if
condition|(
name|sparc_cmodel_string
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
for|for
control|(
name|cmodel
operator|=
operator|&
name|cmodels
index|[
literal|0
index|]
init|;
name|cmodel
operator|->
name|name
condition|;
name|cmodel
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sparc_cmodel_string
argument_list|,
name|cmodel
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cmodel
operator|->
name|name
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -mcmodel= switch"
argument_list|,
name|sparc_cmodel_string
argument_list|)
expr_stmt|;
else|else
name|sparc_cmodel
operator|=
name|cmodel
operator|->
name|value
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"-mcmodel= is not supported on 32 bit systems"
argument_list|)
expr_stmt|;
block|}
name|fpu
operator|=
name|TARGET_FPU
expr_stmt|;
comment|/* save current -mfpu status */
comment|/* Set the default CPU.  */
for|for
control|(
name|def
operator|=
operator|&
name|cpu_default
index|[
literal|0
index|]
init|;
name|def
operator|->
name|name
condition|;
operator|++
name|def
control|)
if|if
condition|(
name|def
operator|->
name|cpu
operator|==
name|TARGET_CPU_DEFAULT
condition|)
break|break;
if|if
condition|(
operator|!
name|def
operator|->
name|name
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sparc_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|def
operator|->
name|name
expr_stmt|;
for|for
control|(
name|sel
operator|=
operator|&
name|sparc_select
index|[
literal|0
index|]
init|;
name|sel
operator|->
name|name
condition|;
operator|++
name|sel
control|)
block|{
if|if
condition|(
name|sel
operator|->
name|string
condition|)
block|{
for|for
control|(
name|cpu
operator|=
operator|&
name|cpu_table
index|[
literal|0
index|]
init|;
name|cpu
operator|->
name|name
condition|;
operator|++
name|cpu
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sel
operator|->
name|string
argument_list|,
name|cpu
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|sel
operator|->
name|set_tune_p
condition|)
name|sparc_cpu
operator|=
name|cpu
operator|->
name|processor
expr_stmt|;
if|if
condition|(
name|sel
operator|->
name|set_arch_p
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|cpu
operator|->
name|disable
expr_stmt|;
name|target_flags
operator||=
name|cpu
operator|->
name|enable
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|cpu
operator|->
name|name
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|sel
operator|->
name|string
argument_list|,
name|sel
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -mfpu or -mno-fpu was explicitly used, don't override with      the processor default.  */
if|if
condition|(
name|TARGET_FPU_SET
condition|)
name|target_flags
operator|=
operator|(
name|target_flags
operator|&
operator|~
name|MASK_FPU
operator|)
operator||
name|fpu
expr_stmt|;
comment|/* Use the deprecated v8 insns for sparc64 in 32 bit mode.  */
if|if
condition|(
name|TARGET_V9
operator|&&
name|TARGET_ARCH32
condition|)
name|target_flags
operator||=
name|MASK_DEPRECATED_V8_INSNS
expr_stmt|;
comment|/* V8PLUS requires V9 */
if|if
condition|(
operator|!
name|TARGET_V9
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_V8PLUS
expr_stmt|;
comment|/* Don't use stack biasing in 32 bit mode.  */
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_STACK_BIAS
expr_stmt|;
comment|/* Validate -malign-loops= value, or provide default.  */
if|if
condition|(
name|sparc_align_loops_string
condition|)
block|{
name|sparc_align_loops
operator|=
name|exact_log2
argument_list|(
name|atoi
argument_list|(
name|sparc_align_loops_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_align_loops
operator|<
literal|2
operator|||
name|sparc_align_loops
operator|>
literal|7
condition|)
name|fatal
argument_list|(
literal|"-malign-loops=%s is not between 4 and 128 or is not a power of two"
argument_list|,
name|sparc_align_loops_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? This relies on ASM_OUTPUT_ALIGN to not emit the alignment if 	 its 0.  This sounds a bit kludgey.  */
name|sparc_align_loops
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Validate -malign-jumps= value, or provide default.  */
if|if
condition|(
name|sparc_align_jumps_string
condition|)
block|{
name|sparc_align_jumps
operator|=
name|exact_log2
argument_list|(
name|atoi
argument_list|(
name|sparc_align_jumps_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_align_jumps
operator|<
literal|2
operator|||
name|sparc_align_loops
operator|>
literal|7
condition|)
name|fatal
argument_list|(
literal|"-malign-jumps=%s is not between 4 and 128 or is not a power of two"
argument_list|,
name|sparc_align_jumps_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? This relies on ASM_OUTPUT_ALIGN to not emit the alignment if 	 its 0.  This sounds a bit kludgey.  */
name|sparc_align_jumps
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Validate -malign-functions= value, or provide default. */
if|if
condition|(
name|sparc_align_funcs_string
condition|)
block|{
name|sparc_align_funcs
operator|=
name|exact_log2
argument_list|(
name|atoi
argument_list|(
name|sparc_align_funcs_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_align_funcs
operator|<
literal|2
operator|||
name|sparc_align_loops
operator|>
literal|7
condition|)
name|fatal
argument_list|(
literal|"-malign-functions=%s is not between 4 and 128 or is not a power of two"
argument_list|,
name|sparc_align_funcs_string
argument_list|)
expr_stmt|;
block|}
else|else
name|sparc_align_funcs
operator|=
name|DEFAULT_SPARC_ALIGN_FUNCS
expr_stmt|;
comment|/* Validate PCC_STRUCT_RETURN.  */
if|if
condition|(
name|flag_pcc_struct_return
operator|==
name|DEFAULT_PCC_STRUCT_RETURN
condition|)
name|flag_pcc_struct_return
operator|=
operator|(
name|TARGET_ARCH64
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* Do various machine dependent initializations.  */
name|sparc_init_modes
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous utilities.  */
end_comment

begin_comment
comment|/* Nonzero if CODE, a comparison, is suitable for use in v9 conditional move    or branch on register contents instructions.  */
end_comment

begin_function
name|int
name|v9_regcmp_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 32 bit registers are zero extended so only zero/non-zero comparisons    work.  */
end_comment

begin_function
name|int
name|v8plus_regcmp_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Operand constraints.  */
end_comment

begin_comment
comment|/* Return non-zero only if OP is a register of mode MODE,    or const0_rtx.  Don't allow const0_rtx if TARGET_LIVE_G0 because    %g0 may contain anything.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TARGET_LIVE_G0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|op
operator|==
name|const0_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|fp_zero_operand
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point value with value 0.0.  */
end_comment

begin_function
name|int
name|fp_zero_operand
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is an integer register.  */
end_comment

begin_function
name|int
name|intreg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|register_operand
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point condition code register.  */
end_comment

begin_function
name|int
name|fcc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* This can happen when recog is called from combine.  Op may be a MEM.      Fail instead of calling abort in this case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CCFPmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CCFPEmode
operator|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* ??? ==> 1 when %fcc0-3 are pseudos first.  See gen_compare_reg().  */
block|if (reg_renumber == 0)     return REGNO (op)>= FIRST_PSEUDO_REGISTER;   return REGNO_OK_FOR_CCFP_P (REGNO (op));
else|#
directive|else
return|return
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|op
argument_list|)
operator|-
name|SPARC_FIRST_V9_FCC_REG
operator|<
literal|4
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Nonzero if OP is an integer or floating point condition code register.  */
end_comment

begin_function
name|int
name|icc_or_fcc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|SPARC_ICC_REG
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CCmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CCXmode
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
name|fcc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP can appear as the dest of a RESTORE insn.  */
end_comment

begin_function
name|int
name|restore_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
literal|8
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Call insn on SPARC can take a PC-relative constant address, or any regular    memory address.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|call_operand_address
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
comment|/* ??? This clause seems to be irrelevant.  */
case|case
name|CONST_DOUBLE
case|:
return|return
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a symbolic memory    operand of mode MODE.  */
end_comment

begin_function
name|int
name|symbolic_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|HIGH
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a LABEL_REF of mode MODE.  */
end_comment

begin_function
name|int
name|label_ref_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is an argument used in generating pic references    in either the medium/low or medium/anywhere code models of sparc64.  */
end_comment

begin_function
name|int
name|sp64_medium_pic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Check for (const (minus (symbol_ref:GOT)                              (const (minus (label) (pc))))).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MINUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
comment|/* ??? Ensure symbol is GOT.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MINUS
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a data segment reference.  This includes    the readonly data segment, or in other words anything but the text segment.    This is needed in the medium/anywhere code model on v9.  These values    are accessed with EMBMEDANY_BASE_REG.  */
end_comment

begin_function
name|int
name|data_segment_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
operator|!
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* Assume canonical format of symbol + constant. 	 Fall through.  */
case|case
name|CONST
case|:
return|return
name|data_segment_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default :
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a text segment reference.    This is needed in the medium/anywhere code model on v9.  */
end_comment

begin_function
name|int
name|text_segment_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* Assume canonical format of symbol + constant. 	 Fall through.  */
case|case
name|CONST
case|:
return|return
name|text_segment_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default :
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or a memory operand that is    not symbolic.  */
end_comment

begin_function
name|int
name|reg_or_nonsymb_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|symbolic_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sparc_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|SMALL_INT
argument_list|(
name|op
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|move_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|arith_double_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|||
name|SPARC_SETHI_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|splittable_symbolic_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|splittable_immediate_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|immediate_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is EQ or NE.  */
end_comment

begin_function
name|int
name|eq_or_neq
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator, but not an EQ, NE, GEU,    or LTU for non-floating-point.  We handle those specially.  */
end_comment

begin_function
name|int
name|normal_comp_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPEmode
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|code
operator|!=
name|NE
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator.  This allows the use of    MATCH_OPERATOR to recognize all the branch insns.  */
end_comment

begin_function
name|int
name|noov_compare_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CC_NOOVmode
condition|)
comment|/* These are the only branches which work with CC_NOOVmode.  */
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a comparison operator suitable for use in v9    conditional move or branch on register contents instructions.  */
end_comment

begin_function
name|int
name|v9_regcmp_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
return|return
name|v9_regcmp_p
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ??? Same as eq_or_neq.  */
end_comment

begin_function
name|int
name|v8plus_regcmp_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */
end_comment

begin_function
name|int
name|extend_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ZERO_EXTEND
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is an operator of mode MODE which can set    the condition codes explicitly.  We do not include PLUS and MINUS    because these require CC_NOOVmode, which we handle explicitly.  */
end_comment

begin_function
name|int
name|cc_arithop
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|XOR
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is an operator of mode MODE which can bitwise    complement its second operand and set the condition codes explicitly.  */
end_comment

begin_function
name|int
name|cc_arithopn
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* XOR is not here because combine canonicalizes (xor (not ...) ...)      and (xor ... (not ...)) to (not (xor ...)).   */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT that can fit in a    signed 13 bit immediate field.  This is an acceptable SImode operand for    most 3 address instructions.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|SPARC_SIMM13_P
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT that can fit in a    signed 11 bit immediate field.  This is an acceptable SImode operand for    the movcc instructions.  */
end_comment

begin_function
name|int
name|arith11_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SPARC_SIMM11_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT that can fit in a    signed 10 bit immediate field.  This is an acceptable SImode operand for    the movrcc instructions.  */
end_comment

begin_function
name|int
name|arith10_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SPARC_SIMM10_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, is a CONST_INT that fits in a 13 bit    immediate field, or is a CONST_DOUBLE whose both parts fit in a 13 bit    immediate field.    v9: Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that    can fit in a 13 bit immediate field.  This is an acceptable DImode operand    for most 3 address instructions.  */
end_comment

begin_function
name|int
name|arith_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|TARGET_ARCH64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x1000
argument_list|)
operator|<
literal|0x2000
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|+
literal|0x1000
argument_list|)
operator|<
literal|0x2000
operator|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x1000
argument_list|)
operator|<
literal|0x2000
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x1000
operator|)
operator|==
literal|0x1000
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x1000
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that    can fit in an 11 bit immediate field.  This is an acceptable DImode    operand for the movcc instructions.  */
end_comment

begin_comment
comment|/* ??? Replace with arith11_operand?  */
end_comment

begin_function
name|int
name|arith11_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x400
argument_list|)
operator|<
literal|0x800
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x400
operator|)
operator|==
literal|0x400
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x400
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x400
argument_list|)
operator|<
literal|0x800
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that    can fit in an 10 bit immediate field.  This is an acceptable DImode    operand for the movrcc instructions.  */
end_comment

begin_comment
comment|/* ??? Replace with arith10_operand?  */
end_comment

begin_function
name|int
name|arith10_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x200
argument_list|)
operator|<
literal|0x400
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x200
operator|)
operator|==
literal|0x200
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x200
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x200
argument_list|)
operator|<
literal|0x400
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in most three-address insns,    which have a 13 bit immediate field.  */
end_comment

begin_function
name|int
name|small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Recognize operand values for the umul instruction.  That instruction sign    extends immediate values just like all other sparc instructions, but    interprets the extended result as an unsigned number.  */
end_comment

begin_function
name|int
name|uns_small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
comment|/* All allowed constants will fit a CONST_INT.  */
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x1000
operator|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0xFFFFF000
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100000000L
operator|)
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x1000
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|-
literal|0xFFFFF000
operator|<
literal|0x1000
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|uns_arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|uns_small_int
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a call-clobbered register.  */
end_comment

begin_function
name|int
name|clobbered_register
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* X and Y are two things to compare using CODE.  Emit the compare insn and    return the rtx for the cc reg in the proper mode.  */
end_comment

begin_function
name|rtx
name|gen_compare_reg
parameter_list|(
name|code
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
decl_stmt|;
comment|/* ??? We don't have movcc patterns so we cannot generate pseudo regs for the      fcc regs (cse can't tell they're really call clobbered regs and will      remove a duplicate comparison even if there is an intervening function      call - it will then try to reload the cc reg via an int reg which is why      we need the movcc patterns).  It is possible to provide the movcc      patterns by using the ldxfsr/stxfsr v9 insns.  I tried it: you need two      registers (say %g1,%g5) and it takes about 6 insns.  A better fix would be      to tell cse that CCFPE mode registers (even pseudos) are call      clobbered.  */
comment|/* ??? This is an experiment.  Rather than making changes to cse which may      or may not be easy/clean, we do our own cse.  This is possible because      we will generate hard registers.  Cse knows they're call clobbered (it      doesn't know the same thing about pseudos). If we guess wrong, no big      deal, but if we win, great!  */
if|if
condition|(
name|TARGET_V9
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
if|#
directive|if
literal|1
comment|/* experiment */
block|{
name|int
name|reg
decl_stmt|;
comment|/* We cycle through the registers to ensure they're all exercised.  */
specifier|static
name|int
name|next_fcc_reg
init|=
literal|0
decl_stmt|;
comment|/* Previous x,y for each fcc reg.  */
specifier|static
name|rtx
name|prev_args
index|[
literal|4
index|]
index|[
literal|2
index|]
decl_stmt|;
comment|/* Scan prev_args for x,y.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|4
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|prev_args
index|[
name|reg
index|]
index|[
literal|0
index|]
operator|==
name|x
operator|&&
name|prev_args
index|[
name|reg
index|]
index|[
literal|1
index|]
operator|==
name|y
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
literal|4
condition|)
block|{
name|reg
operator|=
name|next_fcc_reg
expr_stmt|;
name|prev_args
index|[
name|reg
index|]
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|prev_args
index|[
name|reg
index|]
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
name|next_fcc_reg
operator|=
operator|(
name|next_fcc_reg
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|reg
operator|+
name|SPARC_FIRST_V9_FCC_REG
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|cc_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! experiment */
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SPARC_FCC_REG
argument_list|)
expr_stmt|;
else|else
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SPARC_ICC_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_V8PLUS
operator|&&
name|mode
operator|==
name|CCXmode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_cmpdi_v8plus
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cc_reg
return|;
block|}
end_function

begin_comment
comment|/* This function is used for v9 only.    CODE is the code for an Scc's comparison.    OPERANDS[0] is the target of the Scc insn.    OPERANDS[1] is the value we compare against const0_rtx (which hasn't    been generated yet).     This function is needed to turn  	   (set (reg:SI 110) 	       (gt (reg:CCX 100 %icc) 	           (const_int 0)))    into 	   (set (reg:SI 110) 	       (gt:DI (reg:CCX 100 %icc) 	           (const_int 0)))     IE: The instruction recognizer needs to see the mode of the comparison to    find the right instruction. We could use "gt:DI" right in the    define_expand, but leaving it out allows us to handle DI, SI, etc.     We refer to the global sparc compare operands sparc_compare_op0 and    sparc_compare_op1.  */
end_comment

begin_function
name|int
name|gen_v9_scc
parameter_list|(
name|compare_code
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|compare_code
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_ARCH64
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|sparc_compare_op0
argument_list|)
operator|==
name|DImode
operator|||
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Handle the case where operands[0] == sparc_compare_op0.      We "early clobber" the result.  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|sparc_compare_op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|sparc_compare_op0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|sparc_compare_op0
argument_list|)
expr_stmt|;
block|}
else|else
name|op0
operator|=
name|sparc_compare_op0
expr_stmt|;
comment|/* For consistency in the following.  */
name|op1
operator|=
name|sparc_compare_op1
expr_stmt|;
comment|/* Try to use the movrCC insns.  */
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|op1
operator|==
name|const0_rtx
operator|&&
name|v9_regcmp_p
argument_list|(
name|compare_code
argument_list|)
condition|)
block|{
comment|/* Special case for op0 != 0.  This can be done with one instruction if 	 operands[0] == sparc_compare_op0.  We don't assume they are equal 	 now though.  */
if|if
condition|(
name|compare_code
operator|==
name|NE
operator|&&
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|DImode
argument_list|,
name|op0
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|DImode
condition|)
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|op0
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|DImode
argument_list|,
name|temp
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_compare_reg
argument_list|(
name|compare_code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|CCmode
case|:
case|case
name|CCXmode
case|:
case|case
name|CCFPEmode
case|:
case|case
name|CCFPmode
case|:
break|break;
default|default :
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a conditional jump insn for the v9 architecture using comparison code    CODE and jump target LABEL.    This function exists to take advantage of the v9 brxx insns.  */
end_comment

begin_function
name|void
name|emit_v9_brxx_insn
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|label
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|label
decl_stmt|;
block|{
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if a return peephole merging return with    setting of output register is ok.  */
end_comment

begin_function
name|int
name|leaf_return_peephole_ok
parameter_list|()
block|{
return|return
operator|(
name|actual_fsize
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL can go into the function epilogue's    delay slot.  SLOT is the slot we are trying to fill.  */
end_comment

begin_function
name|int
name|eligible_for_epilogue_delay
parameter_list|(
name|trial
parameter_list|,
name|slot
parameter_list|)
name|rtx
name|trial
decl_stmt|;
name|int
name|slot
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|,
name|src
decl_stmt|;
if|if
condition|(
name|slot
operator|>=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* If %g0 is live, there are lots of things we can't handle.      Rather than trying to find them all now, let's punt and only      optimize things as necessary.  */
if|if
condition|(
name|TARGET_LIVE_G0
condition|)
return|return
literal|0
return|;
comment|/* In the case of a true leaf function, anything can go into the delay slot.      A delay slot only exists however if the frame size is zero, otherwise      we will put an insn to adjust the stack after the return.  */
if|if
condition|(
name|leaf_function
condition|)
block|{
if|if
condition|(
name|leaf_return_peephole_ok
argument_list|()
condition|)
return|return
operator|(
operator|(
name|get_attr_in_uncond_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_BRANCH_DELAY_TRUE
operator|)
operator|)
return|;
return|return
literal|0
return|;
block|}
comment|/* If only trivial `restore' insns work, nothing can go in the      delay slot.  */
elseif|else
if|if
condition|(
name|TARGET_BROKEN_SAVERESTORE
condition|)
return|return
literal|0
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Otherwise, only operations which can be done in tandem with      a `restore' insn can go into the delay slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|>=
literal|32
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|<
literal|24
condition|)
return|return
literal|0
return|;
comment|/* The set of insns matched here must agree precisely with the set of      patterns paired with a RETURN in sparc.md.  */
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* This matches "*return_[qhs]i".  */
if|if
condition|(
name|arith_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
return|;
comment|/* This matches "*return_di".  */
elseif|else
if|if
condition|(
name|arith_double_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
return|;
comment|/* This matches "*return_sf_no_fpu".  */
elseif|else
if|if
condition|(
operator|!
name|TARGET_FPU
operator|&&
name|restore_operand
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|SFmode
argument_list|)
operator|&&
name|register_operand
argument_list|(
name|src
argument_list|,
name|SFmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* This matches "*return_addsi".  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* This matches "*return_adddi".  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_return_regs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
name|IN_OR_GLOBAL_P
argument_list|(
name|x
argument_list|)
return|;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|SET
case|:
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|check_return_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
case|case
name|NOT
case|:
case|case
name|NEG
case|:
case|case
name|MEM
case|:
return|return
name|check_return_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if TRIAL references only in and global registers.  */
end_comment

begin_function
name|int
name|eligible_for_return_delay
parameter_list|(
name|trial
parameter_list|)
name|rtx
name|trial
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
return|return
name|check_return_regs
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|short_branch
parameter_list|(
name|uid1
parameter_list|,
name|uid2
parameter_list|)
name|int
name|uid1
decl_stmt|,
name|uid2
decl_stmt|;
block|{
name|unsigned
name|int
name|delta
init|=
name|insn_addresses
index|[
name|uid1
index|]
operator|-
name|insn_addresses
index|[
name|uid2
index|]
decl_stmt|;
if|if
condition|(
name|delta
operator|+
literal|1024
operator|<
literal|2048
condition|)
return|return
literal|1
return|;
comment|/* warning ("long branch, distance %d", delta); */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if REG is not used after INSN.    We assume REG is a reload reg, and therefore does    not live past labels or calls or jumps.  */
end_comment

begin_function
name|int
name|reg_unused_after
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|,
name|prev_code
init|=
name|UNKNOWN
decl_stmt|;
while|while
condition|(
operator|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|in_src
init|=
name|set
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|in_src
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|set
operator|==
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The table we use to reference PIC data.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|global_offset_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function we use to get at it.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|get_pc_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|get_pc_symbol_name
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ensure that we are not using patterns that are not OK with PIC.  */
end_comment

begin_function
name|int
name|check_pic
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
switch|switch
condition|(
name|flag_pic
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|global_offset_table
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|)
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
literal|2
case|:
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if X is an address which needs a temporary register when     reloaded while generating PIC code.  */
end_comment

begin_function
name|int
name|pic_address_needs_scratch
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
comment|/* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already position-independent,    we return ORIG.  Newly generated position-independent addresses go into a    reg.  This is REG if non zero, otherwise we allocate register(s) as    necessary.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|pic_ref
decl_stmt|,
name|address
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
comment|/* If not during reload, allocate another temp reg here for loading 	     in the address, so that these instructions can be optimized 	     properly.  */
name|rtx
name|temp_reg
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
comment|/* Must put the SYMBOL_REF inside an UNSPEC here so that cse 	     won't get confused into thinking that these two instructions 	     are loading in the true address of the symbol.  If in the 	     future a PIC rtx exists, that should be used instead.  */
name|emit_insn
argument_list|(
name|gen_pic_sethi_si
argument_list|(
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pic_lo_sum_si
argument_list|(
name|temp_reg
argument_list|,
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|temp_reg
expr_stmt|;
block|}
else|else
name|address
operator|=
name|orig
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
comment|/* Put a REG_EQUAL note on this insn, so that it can be optimized 	 by loop.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|orig
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
comment|/* If we reach here, then something is seriously wrong.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Set up PIC-specific rtl.  This should not cause any insns    to be emitted.  */
end_comment

begin_function
name|void
name|initialize_pic
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Return the RTX for insns to set the PIC register.  */
end_comment

begin_function
specifier|static
name|rtx
name|pic_setup_code
parameter_list|()
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_get_pc
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|global_offset_table
argument_list|,
name|get_pc_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
end_function

begin_comment
comment|/* Emit special PIC prologues and epilogues.  */
end_comment

begin_function
name|void
name|finalize_pic
parameter_list|()
block|{
comment|/* Labels to get the PC in the prologue of this function.  */
name|int
name|orig_flag_pic
init|=
name|flag_pic
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|current_function_uses_pic_offset_table
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we havn't emitted the special get_pc helper function, do so now.  */
if|if
condition|(
name|get_pc_symbol_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|get_pc_symbol_name
argument_list|,
literal|"LGETPC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LGETPC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tretl\n\tadd %o7,%l7,%l7\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize every time through, since we can't easily      know this to be permanent.  */
name|global_offset_table
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|get_pc_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|get_pc_symbol_name
argument_list|)
expr_stmt|;
name|flag_pic
operator|=
literal|0
expr_stmt|;
name|emit_insn_after
argument_list|(
name|pic_setup_code
argument_list|()
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Insert the code in each nonlocal goto receiver.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|4
condition|)
name|emit_insn_after
argument_list|(
name|pic_setup_code
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|flag_pic
operator|=
name|orig_flag_pic
expr_stmt|;
comment|/* Need to emit this whether or not we obey regdecls,      since setjmp/longjmp can cause life info to screw up.      ??? In the case where we don't obey regdecls, this is not sufficient      since we may not fall out the bottom.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].     Return 1 if we have written out everything that needs to be done to    do the move.  Otherwise, return 0 and the caller will emit the move    normally.  */
end_comment

begin_function
name|int
name|emit_move_sequence
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|operand0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|operand1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operand1
argument_list|)
operator|&&
name|flag_pic
operator|&&
name|pic_address_needs_scratch
argument_list|(
name|operand1
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|operand1
operator|=
name|legitimize_pic_address
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle most common case first: storing into a register.  */
if|if
condition|(
name|register_operand
argument_list|(
name|operand0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
comment|/* Integer constant to FP register. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand0
argument_list|)
operator|>=
literal|32
operator|&&
name|REGNO
argument_list|(
name|operand0
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|CONSTANT_P
argument_list|(
name|operand1
argument_list|)
condition|)
block|{
name|operand1
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|operand0
argument_list|)
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|register_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|operand1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|arith_double_operand
argument_list|(
name|operand1
argument_list|,
name|DImode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|HIGH
operator|&&
name|GET_MODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|DImode
operator|)
comment|/* Only `general_operands' can come here, so MEM is ok.  */
operator|||
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Run this case quickly.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand0
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|operand1
operator|==
name|const0_rtx
operator|&&
operator|!
name|TARGET_LIVE_G0
operator|)
condition|)
block|{
comment|/* Run this case quickly.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|reload_in_progress
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|validize_mem
argument_list|(
name|operand0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operand1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* DImode HIGH values in sparc64 need a clobber added.  */
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|HIGH
operator|&&
name|GET_MODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_sethi_di_sp64
argument_list|(
name|operand0
argument_list|,
name|XEXP
argument_list|(
name|operand1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Simplify the source if we need to.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|HIGH
operator|&&
name|immediate_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_pic
operator|&&
name|symbolic_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|temp_reg
init|=
name|reload_in_progress
condition|?
name|operand0
else|:
literal|0
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|,
name|temp_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_INT
condition|?
operator|(
operator|!
name|SMALL_INT
argument_list|(
name|operand1
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|operand1
argument_list|)
operator|!=
operator|-
literal|4096
operator|&&
operator|!
name|SPARC_SETHI_P
argument_list|(
name|INTVAL
argument_list|(
name|operand1
argument_list|)
argument_list|)
operator|)
else|:
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|?
operator|!
name|arith_double_operand
argument_list|(
name|operand1
argument_list|,
name|DImode
argument_list|)
else|:
literal|1
condition|)
block|{
comment|/* For DImode values, temp must be operand0 because of the way 	     HI and LO_SUM work.  The LO_SUM operator only copies half of 	     the LSW from the dest of the HI operator.  If the LO_SUM dest is 	     not the same as the HI dest, then the MSW of the LO_SUM dest will 	     never be set.  	     ??? The real problem here is that the ...(HI:DImode pattern emits 	     multiple instructions, and the ...(LO_SUM:DImode pattern emits 	     one instruction.  This fails, because the compiler assumes that 	     LO_SUM copies all bits of the first operand to its dest.  Better 	     would be to have the HI pattern emit one instruction and the 	     LO_SUM pattern multiple instructions.  Even better would be 	     to use four rtl insns.  */
name|rtx
name|temp
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
name|mode
operator|==
name|DImode
operator|)
condition|?
name|operand0
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|operand1
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|operand1
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|operand1
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|operand1
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|mode
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_sethi_di_sp64
argument_list|(
name|temp
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|mode
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now have insn-emit do whatever it normally does.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a 4 byte quantity.     This isn't intended to be very smart.  It is up to the caller to    choose the best way to do things.     Note that OPERANDS may be modified to suit the returned string.  */
end_comment

begin_function
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|"st %r1,%0"
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"ld %1,%0"
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|i
decl_stmt|;
comment|/* Must be SFmode, otherwise this doesn't make sense.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|SFmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|i
argument_list|,
literal|'I'
argument_list|)
condition|)
return|return
literal|"mov %1,%0"
return|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|&
literal|0x000003FF
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi %%hi(%a1),%0\n\tor %0,%%lo(%a1),%0"
return|;
else|else
return|return
literal|"sethi %%hi(%a1),%0"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Only consider the low 32 bits of the constant. */
name|int
name|i
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0xffffffff
decl_stmt|;
if|if
condition|(
name|SPARC_SIMM13_P
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|"mov %1,%0"
return|;
if|if
condition|(
name|i
operator|==
literal|4096
condition|)
return|return
literal|"sub %%g0,-4096,%0"
return|;
comment|/* If all low order 10 bits are clear, then we only need a single 	 sethi insn to load the constant.  */
comment|/* FIXME: Use SETHI_P.  */
if|if
condition|(
operator|(
name|i
operator|&
literal|0x000003FF
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi %%hi(%a1),%0\n\tor %0,%%lo(%a1),%0"
return|;
else|else
return|return
literal|"sethi %%hi(%a1),%0"
return|;
block|}
comment|/* Operand 1 must be a register, or a 'I' type CONST_INT.  */
return|return
literal|"mov %1,%0"
return|;
block|}
end_function

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as an 8 byte quantity.     This isn't intended to be very smart.  It is up to the caller to    choose the best way to do things.     Note that OPERANDS may be modified to suit the returned string.  */
end_comment

begin_function
name|char
modifier|*
name|doublemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|,
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
literal|"std %1,%0"
return|;
return|return
name|TARGET_ARCH64
condition|?
literal|"stx %1,%0"
else|:
literal|"std %1,%0"
return|;
block|}
if|if
condition|(
name|TARGET_ARCH64
operator|&&
operator|(
name|op1
operator|==
name|const0_rtx
operator|||
operator|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|"stx %r1,%0"
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
literal|"ldd %1,%0"
return|;
return|return
name|TARGET_ARCH64
condition|?
literal|"ldx %1,%0"
else|:
literal|"ldd %1,%0"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* ??? Unfinished, and maybe not needed.  */
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|'I'
argument_list|)
condition|)
block|{
comment|/* ??? Unfinished, and maybe not needed.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Operand 1 must be a register, or a 'I' type CONST_INT.  */
return|return
literal|"mov %1,%0"
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if it is OK to assume that the given memory operand is    aligned at least to a 8-byte boundary.  This should only be called    for memory accesses whose size is 8 bytes or larger.  */
end_comment

begin_function
name|int
name|mem_aligned_8
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|rtx
name|mem
decl_stmt|;
block|{
specifier|register
name|rtx
name|addr
decl_stmt|;
specifier|register
name|rtx
name|base
decl_stmt|;
specifier|register
name|rtx
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* It's gotta be a MEM! */
name|addr
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that all misaligned double parms are copied on function entry,      we can assume any 64-bit object is 64-bit aligned except those which      are at unaligned offsets from the stack or frame pointer.  If the      TARGET_UNALIGNED_DOUBLES switch is given, we do not make this      assumption.  */
comment|/* See what register we use in the address.  */
name|base
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|addr
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* If it's the stack or frame pointer, check offset alignment.      We can have improper alignment in the function entry code.  */
if|if
condition|(
name|base
operator|&&
operator|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|SPARC_STACK_BIAS
operator|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* Anything else we know is properly aligned unless TARGET_UNALIGNED_DOUBLES      is true, in which case we can only assume that an access is aligned if      it is to a constant address, or the address involves a LO_SUM.       We used to assume an address was aligned if MEM_IN_STRUCT_P was true.      That assumption was deleted so that gcc generated code can be used with      memory allocators that only guarantee 4 byte alignment.  */
elseif|else
if|if
condition|(
operator|!
name|TARGET_UNALIGNED_DOUBLES
operator|||
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
literal|1
return|;
comment|/* An obviously unaligned address.  */
return|return
literal|0
return|;
block|}
end_function

begin_enum
enum|enum
name|optype
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
enum|;
end_enum

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  This is very similar to the following    output_move_quad function.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|enum
name|optype
name|optype0
decl_stmt|;
specifier|register
name|enum
name|optype
name|optype1
decl_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|;
name|rtx
name|addreg1
init|=
literal|0
decl_stmt|;
name|int
name|highest_first
init|=
literal|0
decl_stmt|;
name|int
name|no_addreg1_decrement
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op0
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
operator|||
operator|(
name|optype0
operator|==
name|MEM
operator|&&
name|optype1
operator|==
name|MEM
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Set up in LATEHALF the operands to use for the      high-numbered (least significant) word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
if|if
condition|(
name|arith_double_operand
argument_list|(
name|op1
argument_list|,
name|DImode
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"mov %1,%0"
return|;
block|}
else|else
block|{
comment|/* The only way to handle CONST_DOUBLEs or other 64 bit 		 constants here is to use a temporary, such as is done 		 for the V9 DImode sethi insn pattern.  This is not 		 a practical solution, so abort if we reach here. 		 The md file should always force such constants to 		 memory.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|split_double
argument_list|(
name|op1
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
comment|/* Easy case: try moving both words at once.  Check for moving between      an even/odd register pair and a memory location.  */
if|if
condition|(
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|optype1
operator|!=
name|CNSTOP
operator|&&
operator|(
name|TARGET_ARCH64
operator|||
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|optype0
operator|!=
name|REGOP
operator|&&
name|optype0
operator|!=
name|CNSTOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
name|TARGET_ARCH64
operator|||
operator|(
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
specifier|register
name|rtx
name|mem
decl_stmt|,
name|reg
decl_stmt|;
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|mem
operator|=
name|op1
operator|,
name|reg
operator|=
name|op0
expr_stmt|;
else|else
name|mem
operator|=
name|op0
operator|,
name|reg
operator|=
name|op1
expr_stmt|;
comment|/* In v9, ldd can be used for word aligned addresses, so technically 	 some of this logic is unneeded.  We still avoid ldd if the address 	 is obviously unaligned though.  	 Integer ldd/std are deprecated in V9 and are slow on UltraSPARC. 	 Use them only if the access is volatile or not offsettable.  */
if|if
condition|(
operator|(
name|mem_aligned_8
argument_list|(
name|mem
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
literal|32
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|||
operator|!
operator|(
operator|(
name|optype0
operator|==
name|OFFSOP
operator|||
name|optype1
operator|==
name|OFFSOP
operator|)
operator|&&
operator|(
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC
operator|||
name|sparc_cpu
operator|==
name|PROCESSOR_V9
operator|)
operator|)
operator|)
operator|)
comment|/* If this is a floating point register higher than %f31, 	     then we *must* use an aligned load, since `ld' will not accept 	     the register number.  */
operator|||
operator|(
name|TARGET_V9
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
literal|64
operator|)
comment|/* Even if two instructions would otherwise be better than ldd/std, 	     if this insn was put in a delay slot because reorg thought it 	     was only one machine instruction, make sure it is only one 	     instruction.  */
operator|||
name|dbr_sequence_length
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
operator|||
operator|!
name|TARGET_ARCH64
condition|)
return|return
operator|(
name|mem
operator|==
name|op1
condition|?
literal|"ldd %1,%0"
else|:
literal|"std %1,%0"
operator|)
return|;
else|else
return|return
operator|(
name|mem
operator|==
name|op1
condition|?
literal|"ldx %1,%0"
else|:
literal|"stx %1,%0"
operator|)
return|;
block|}
block|}
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
literal|"fmovd %1,%0"
return|;
else|else
return|return
literal|"mov %1,%0"
return|;
block|}
block|}
comment|/* If the first move would clobber the source of the second one,      do them in the other order.  */
comment|/* Overlapping registers.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Loading into a register which overlaps a register used in the address.  */
elseif|else
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
comment|/* If both halves of dest are used in the src memory address, 	 add the two regs and put them in the low reg (op0). 	 Then it works to load latehalf first.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|latehalf
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|latehalf
index|[
literal|0
index|]
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|op0
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add %1,%0,%1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|addreg1
operator|=
literal|0
expr_stmt|;
name|highest_first
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Only one register in the dest is used in the src memory address, 	 and this is the first register of the dest, so we want to do 	 the late half first here also.  */
elseif|else
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|latehalf
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|highest_first
operator|=
literal|1
expr_stmt|;
comment|/* Only one register in the dest is used in the src memory address, 	 and this is the second register of the dest, so we want to do 	 the late half last.  If addreg1 is set, and addreg1 is the same 	 register as latehalf, then we must suppress the trailing decrement, 	 because it would clobber the value just loaded.  */
elseif|else
if|if
condition|(
name|addreg1
operator|&&
name|reg_mentioned_p
argument_list|(
name|addreg1
argument_list|,
name|latehalf
index|[
literal|0
index|]
argument_list|)
condition|)
name|no_addreg1_decrement
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Normal case: do the two words, low-numbered first.      Overlap case (highest_first set): do high-numbered word first.  */
if|if
condition|(
operator|!
name|highest_first
condition|)
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
operator|&&
operator|!
name|no_addreg1_decrement
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|highest_first
condition|)
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to perform a quadword move insn    with operands OPERANDS.  This is very similar to the preceding    output_move_double function.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_quad
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|enum
name|optype
name|optype0
decl_stmt|;
specifier|register
name|enum
name|optype
name|optype1
decl_stmt|;
name|rtx
name|wordpart
index|[
literal|4
index|]
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|load_late
index|[
literal|4
index|]
decl_stmt|;
name|int
name|load_late_half
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|;
name|rtx
name|addreg1
init|=
literal|0
decl_stmt|;
name|load_late_half
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|load_late_half
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|load_late
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|load_late
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|load_late
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|load_late
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|wordpart
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op0
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
operator|||
operator|(
name|optype0
operator|==
name|MEM
operator|&&
name|optype1
operator|==
name|MEM
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|FP_REG_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|<
name|SPARC_FIRST_V9_FP_REG
condition|)
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|wordpart
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Loading into a register which overlaps a register used in the 	 address.  */
if|if
condition|(
name|optype1
operator|!=
name|REGOP
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|wordpart
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|wordpart
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|load_late
index|[
name|i
index|]
operator|=
name|wordpart
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|load_late_half
index|[
name|TARGET_ARCH64
condition|?
name|i
else|:
name|i
operator|/
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|>
literal|2
condition|)
block|{
comment|/* Not sure what to do here. Multiple adds? Can't happen. */
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|2
condition|)
block|{
comment|/* We have a two-address source operand, and both registers 		 overlap with the dest quad. Add them together and 		 store the result into the last register of the quad being 		 loaded, then generate an appropriate MEM insn. */
name|rtx
name|temp
index|[
literal|3
index|]
decl_stmt|;
name|int
name|place
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|load_late
index|[
name|i
index|]
condition|)
block|{
name|temp
index|[
name|place
operator|++
index|]
operator|=
name|load_late
index|[
name|i
index|]
expr_stmt|;
name|load_late
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|temp
index|[
literal|2
index|]
operator|=
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add %0, %1, %2"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|load_late_half
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|load_late_half
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|op1
operator|=
name|gen_rtx_MEM
argument_list|(
name|TFmode
argument_list|,
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
block|}
block|}
block|}
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the later words.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Set up in wordpart the operands to use for each word of the arguments.  */
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
else|else
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype0
operator|!=
name|REGOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
block|}
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|FP_REG_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|<
name|SPARC_FIRST_V9_FP_REG
condition|)
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|wordpart
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
else|else
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|4
index|]
decl_stmt|;
comment|/* This only works for TFmode floating point constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|TFmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
block|}
comment|/* Easy case: try moving the quad as two pairs.  Check for moving between      an even/odd register pair and a memory location.      Also handle new v9 fp regs here.  */
comment|/* ??? Should also handle the case of non-offsettable addresses here.      We can at least do the first pair as a ldd/std, and then do the third      and fourth words individually.  */
if|if
condition|(
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|OFFSOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|optype0
operator|==
name|OFFSOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|mem
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|use_ldx
decl_stmt|;
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|mem
operator|=
name|op1
operator|,
name|reg
operator|=
name|op0
expr_stmt|;
else|else
name|mem
operator|=
name|op0
operator|,
name|reg
operator|=
name|op1
expr_stmt|;
if|if
condition|(
name|mem_aligned_8
argument_list|(
name|mem
argument_list|)
comment|/* If this is a floating point register higher than %f31, 	     then we *must* use an aligned load, since `ld' will not accept 	     the register number.  */
operator|||
operator|(
name|TARGET_V9
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|SPARC_FIRST_V9_FP_REG
operator|)
condition|)
block|{
specifier|static
name|char
modifier|*
specifier|const
name|mov_by_64
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
block|{
literal|"std %S1,%2;std %1,%0"
block|,
literal|"stx %R1,%2;stx %1,%0"
block|}
block|,
block|{
literal|"ldd %2,%S0;ldd %1,%0"
block|,
literal|"ldx %2,%R0;ldx %1,%0"
block|}
block|}
block|,
block|{
block|{
literal|"std %1,%0;std %S1,%2"
block|,
literal|"stx %1,%0;stx %R1,%2"
block|}
block|,
block|{
literal|"ldd %1,%0;ldd %2,%S0"
block|,
literal|"ldx %1,%0;ldx %2,%R0"
block|}
block|}
block|}
decl_stmt|;
if|if
condition|(
name|TARGET_V9
operator|&&
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
name|TARGET_HARD_QUAD
condition|)
block|{
comment|/* Only abort if the register # requires that we use ldq. */
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* ??? Can `mem' have an inappropriate alignment here?  */
return|return
operator|(
name|mem
operator|==
name|op1
condition|?
literal|"ldq %1,%0"
else|:
literal|"stq %1,%0"
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|SPARC_FIRST_V9_FP_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|operands
index|[
literal|2
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|mem
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Do the loads in the right order; can't overwrite our address 	     register. */
name|use_ldx
operator|=
name|TARGET_ARCH64
operator|&&
operator|!
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|mov_by_64
index|[
operator|!
name|load_late_half
index|[
literal|0
index|]
index|]
index|[
name|mem
operator|==
name|op1
index|]
index|[
name|use_ldx
index|]
return|;
block|}
block|}
comment|/* If the first move would clobber the source of the second one,      do them in the other order.  */
comment|/* Overlapping registers?  */
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|3
index|]
argument_list|)
operator|||
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|||
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Do fourth word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Do the third word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Do the second word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Do lowest-numbered word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
else|else
comment|/* TARGET_ARCH64 */
block|{
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"mov %1,%0"
argument_list|,
name|wordpart
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov %1,%0"
argument_list|,
name|wordpart
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
comment|/* Normal case: move the words in lowest to highest address order.      There may have an overlapping register; in that case, skip and go      back. */
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|offset
init|=
literal|0xc
decl_stmt|;
name|rtx
name|temp
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|load_late
index|[
name|i
index|]
condition|)
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
name|i
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|3
condition|)
block|{
comment|/* Make any unoffsettable addresses point at the next word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|load_late
index|[
name|i
index|]
condition|)
block|{
name|int
name|fix
init|=
name|offset
operator|-
name|i
operator|*
literal|4
decl_stmt|;
comment|/* Back up to the appropriate place. */
name|temp
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|fix
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg0
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
name|addreg0
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add %0,%1,%0"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addreg1
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
name|addreg1
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add %0,%1,%0"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
name|i
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Don't modify the register that's the destination of the 		 move. */
name|temp
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
operator|(
name|offset
operator|-
name|fix
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg0
operator|&&
name|REGNO
argument_list|(
name|addreg0
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|wordpart
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|temp
index|[
literal|1
index|]
operator|=
name|addreg0
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add %0,%1,%0"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addreg1
operator|&&
name|REGNO
argument_list|(
name|addreg1
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|wordpart
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|temp
index|[
literal|1
index|]
operator|=
name|addreg1
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add %0,%1,%0"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|offset
condition|)
block|{
name|temp
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|offset
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
name|addreg0
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add %0,%1,%0"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addreg1
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
name|addreg1
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add %0,%1,%0"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* TARGET_ARCH64 */
block|{
if|if
condition|(
name|load_late_half
index|[
literal|0
index|]
condition|)
block|{
comment|/* Load the second half first. */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x8,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x8,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|doublemove_string
argument_list|(
name|wordpart
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x8,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x8,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|doublemove_string
argument_list|(
name|wordpart
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
name|doublemove_string
argument_list|(
name|wordpart
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x8,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x8,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do the second word.  */
name|output_asm_insn
argument_list|(
name|doublemove_string
argument_list|(
name|wordpart
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  But don't modify the dest of 	     the move. */
if|if
condition|(
name|addreg0
operator|&&
name|REGNO
argument_list|(
name|addreg0
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x8,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
operator|&&
name|REGNO
argument_list|(
name|addreg1
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x8,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to perform a doubleword move insn with operands    OPERANDS, one of which must be a floating point register.  */
end_comment

begin_function
name|char
modifier|*
name|output_fp_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_V9
condition|)
return|return
literal|"fmovd %1,%0"
return|;
else|else
return|return
literal|"fmovs %1,%0\n\tfmovs %R1,%R0"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When doing a quad-register move, determine the drection in which    the move needs to be performed. SRC and DST are the source and    destination registers.     A value of -1 indicates that the move needs to be done from the    highest register to the lowest. */
end_comment

begin_function
specifier|static
name|int
name|move_quad_direction
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|>
name|REGNO
argument_list|(
name|src
argument_list|)
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|<
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|+
literal|4
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to perform a quadword move insn with operands    OPERANDS, one of which must be a floating point register.  */
end_comment

begin_function
name|char
modifier|*
name|output_fp_move_quad
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_V9
operator|&&
name|TARGET_HARD_QUAD
condition|)
return|return
literal|"fmovq %1,%0"
return|;
elseif|else
if|if
condition|(
name|TARGET_V9
condition|)
block|{
name|int
name|dir
init|=
name|move_quad_direction
argument_list|(
name|op1
argument_list|,
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
return|return
literal|"fmovd %1,%0\n\tfmovd %S1,%S0"
return|;
else|else
return|return
literal|"fmovd %S1,%S0\n\tfmovd %1,%0"
return|;
block|}
else|else
block|{
name|int
name|dir
init|=
name|move_quad_direction
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
return|return
literal|"fmovs %1,%0\n\tfmovs %R1,%R0\n\tfmovs %S1,%S0\n\tfmovs %T1,%T0"
return|;
else|else
return|return
literal|"fmovs %T1,%T0\n\tfmovs %S1,%S0\n\tfmovs %R1,%R0\n\tfmovs %1,%0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
name|output_move_quad
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
name|output_move_quad
argument_list|(
name|operands
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* We absolutely can not fudge the frame pointer here, because the 	 frame pointer must always be 8 byte aligned.  It also confuses 	 debuggers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output reasonable peephole for set-on-condition-code insns.    Note that these insns assume a particular way of defining    labels.  Therefore, *both* sparc.h and this function must    be changed if a new syntax is needed.    */
end_comment

begin_function
name|char
modifier|*
name|output_scc_insn
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|100
index|]
decl_stmt|;
name|rtx
name|label
init|=
literal|0
decl_stmt|,
name|next
init|=
name|insn
decl_stmt|;
name|int
name|need_label
init|=
literal|0
decl_stmt|;
comment|/* This code used to be called with final_sequence nonzero (for fpcc      delay slots), but that is no longer allowed.  */
if|if
condition|(
name|final_sequence
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* On UltraSPARC a conditional moves blocks until 3 cycles after prior loads      complete.  It might be beneficial here to use branches if any recent      instructions were loads.  */
if|if
condition|(
name|TARGET_V9
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SPARC_ICC_REG
condition|)
return|return
literal|"mov 0,%0\n\tmov%C2 %x1,1,%0"
return|;
comment|/* Try doing a jump optimization which jump.c can't do for us      because we did not expose that setcc works by using branches.       If this scc insn is followed by an unconditional branch, then have      the jump insn emitted here jump to that location, instead of to      the end of the scc sequence as usual.  */
do|do
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|label
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
operator|)
condition|)
do|;
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|next
argument_list|)
condition|)
name|label
operator|=
name|JUMP_LABEL
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* If not optimizing, jump label fields are not set.  To be safe, always      check here to whether label is still zero.  */
if|if
condition|(
name|label
operator|==
literal|0
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|need_label
operator|=
literal|1
expr_stmt|;
block|}
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|+=
literal|1
expr_stmt|;
comment|/* operands[3] is an unused slot.  */
name|operands
index|[
literal|3
index|]
operator|=
name|label
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|output_cbranch
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n\tmov 1,%0\n\tmov 0,%0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_label
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n%l3:"
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Vectors to keep interesting information about registers where it can easily    be got.  We use to use the actual mode value as the bit number, but there    are more than 32 modes now.  Instead we use two tables: one indexed by    hard register number, and one indexed by mode.  */
end_comment

begin_comment
comment|/* The purpose of sparc_mode_class is to shrink the range of modes so that    they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is    mapped into one sparc_mode_class mode.  */
end_comment

begin_enum
enum|enum
name|sparc_mode_class
block|{
name|S_MODE
block|,
name|D_MODE
block|,
name|T_MODE
block|,
name|O_MODE
block|,
name|SF_MODE
block|,
name|DF_MODE
block|,
name|TF_MODE
block|,
name|OF_MODE
block|,
name|CC_MODE
block|,
name|CCFP_MODE
block|}
enum|;
end_enum

begin_comment
comment|/* Modes for single-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|S_MODES
value|((1<< (int) S_MODE) | (1<< (int) SF_MODE))
end_define

begin_comment
comment|/* Modes for double-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|D_MODES
value|(S_MODES | (1<< (int) D_MODE) | (1<< DF_MODE))
end_define

begin_comment
comment|/* Modes for quad-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|T_MODES
value|(D_MODES | (1<< (int) T_MODE) | (1<< (int) TF_MODE))
end_define

begin_comment
comment|/* Modes for single-float quantities.  We must allow any single word or    smaller quantity.  This is because the fix/float conversion instructions    take integer inputs/outputs from the float registers.  */
end_comment

begin_define
define|#
directive|define
name|SF_MODES
value|(S_MODES)
end_define

begin_comment
comment|/* Modes for double-float and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_MODES
value|(S_MODES | D_MODES)
end_define

begin_define
define|#
directive|define
name|DF_MODES64
value|DF_MODES
end_define

begin_comment
comment|/* Modes for double-float only quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_ONLY_MODES
value|((1<< (int) DF_MODE) | (1<< (int) D_MODE))
end_define

begin_comment
comment|/* Modes for double-float and larger quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_UP_MODES
value|(DF_ONLY_MODES | TF_ONLY_MODES)
end_define

begin_comment
comment|/* Modes for quad-float only quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_ONLY_MODES
value|(1<< (int) TF_MODE)
end_define

begin_comment
comment|/* Modes for quad-float and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_MODES
value|(DF_MODES | TF_ONLY_MODES)
end_define

begin_define
define|#
directive|define
name|TF_MODES64
value|(DF_MODES64 | TF_ONLY_MODES)
end_define

begin_comment
comment|/* Modes for condition codes.  */
end_comment

begin_define
define|#
directive|define
name|CC_MODES
value|(1<< (int) CC_MODE)
end_define

begin_define
define|#
directive|define
name|CCFP_MODES
value|(1<< (int) CCFP_MODE)
end_define

begin_comment
comment|/* Value is 1 if register/mode pair is acceptable on sparc.    The funny mixture of D and T modes is because integer operations    do not specially operate on tetra quantities, so non-quad-aligned    registers can hold quadword quantities (except %o4 and %i4 because    they cross fixed registers).  */
end_comment

begin_comment
comment|/* This points to either the 32 bit or the 64 bit version.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|hard_regno_mode_classes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hard_32bit_mode_classes
index|[]
init|=
block|{
name|S_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
comment|/* FP regs f32 to f63.  Only the even numbered registers actually exist,      and none can hold SFmode/SImode values.  */
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
comment|/* %fcc[0123] */
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
comment|/* %icc */
name|CC_MODES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hard_64bit_mode_classes
index|[]
init|=
block|{
name|D_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|TF_MODES64
block|,
name|SF_MODES
block|,
name|DF_MODES64
block|,
name|SF_MODES
block|,
name|TF_MODES64
block|,
name|SF_MODES
block|,
name|DF_MODES64
block|,
name|SF_MODES
block|,
name|TF_MODES64
block|,
name|SF_MODES
block|,
name|DF_MODES64
block|,
name|SF_MODES
block|,
name|TF_MODES64
block|,
name|SF_MODES
block|,
name|DF_MODES64
block|,
name|SF_MODES
block|,
name|TF_MODES64
block|,
name|SF_MODES
block|,
name|DF_MODES64
block|,
name|SF_MODES
block|,
name|TF_MODES64
block|,
name|SF_MODES
block|,
name|DF_MODES64
block|,
name|SF_MODES
block|,
name|TF_MODES64
block|,
name|SF_MODES
block|,
name|DF_MODES64
block|,
name|SF_MODES
block|,
name|TF_MODES64
block|,
name|SF_MODES
block|,
name|DF_MODES64
block|,
name|SF_MODES
block|,
comment|/* FP regs f32 to f63.  Only the even numbered registers actually exist,      and none can hold SFmode/SImode values.  */
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
name|DF_UP_MODES
block|,
literal|0
block|,
name|DF_ONLY_MODES
block|,
literal|0
block|,
comment|/* %fcc[0123] */
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
comment|/* %icc */
name|CC_MODES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sparc_mode_class
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reg_class
name|sparc_regno_reg_class
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sparc_init_modes
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
case|case
name|MODE_COMPLEX_INT
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|<=
literal|4
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|S_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|8
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|D_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|16
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|T_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|32
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|O_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|<=
literal|4
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|SF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|8
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|DF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|16
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|TF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|32
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|OF_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_CC
case|:
default|default:
comment|/* mode_class hasn't been initialized yet for EXTRA_CC_MODES, so 	     we must explicitly check for them here.  */
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|CCFPmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CCFPEmode
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|CCFP_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|CCmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CC_NOOVmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CCXmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CCX_NOOVmode
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|CC_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|TARGET_ARCH64
condition|)
name|hard_regno_mode_classes
operator|=
name|hard_64bit_mode_classes
expr_stmt|;
else|else
name|hard_regno_mode_classes
operator|=
name|hard_32bit_mode_classes
expr_stmt|;
comment|/* Initialize the array used by REGNO_REG_CLASS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|16
operator|&&
name|TARGET_V8PLUS
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|I64_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|32
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|GENERAL_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|64
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|FP_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|96
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|EXTRA_FP_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|100
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|FPCC_REGS
expr_stmt|;
else|else
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save non call used registers from LOW to HIGH at BASE+OFFSET.    N_REGS is the number of 4-byte regs saved thus far.  This applies even to    v9 int regs as it simplifies the code.  */
end_comment

begin_function
specifier|static
name|int
name|save_regs
parameter_list|(
name|file
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|,
name|n_regs
parameter_list|,
name|real_offset
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|n_regs
decl_stmt|;
name|int
name|real_offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|high
operator|<=
literal|32
condition|)
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstx %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|i
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstd %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|i
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|i
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|)
expr_stmt|;
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|real_offset
operator|+
literal|4
operator|*
name|n_regs
operator|+
literal|4
argument_list|)
expr_stmt|;
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|n_regs
return|;
block|}
end_function

begin_comment
comment|/* Restore non call used registers from LOW to HIGH at BASE+OFFSET.     N_REGS is the number of 4-byte regs saved thus far.  This applies even to    v9 int regs as it simplifies the code.  */
end_comment

begin_function
specifier|static
name|int
name|restore_regs
parameter_list|(
name|file
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|,
name|n_regs
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|n_regs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|high
operator|<=
literal|32
condition|)
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldx [%s+%d], %s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
operator|,
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldd [%s+%d], %s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
operator|,
name|n_regs
operator|+=
literal|2
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld [%s+%d],%s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
operator|,
name|n_regs
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld [%s+%d],%s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_regs
operator|+
literal|4
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|,
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|n_regs
return|;
block|}
end_function

begin_comment
comment|/* Static variables we want to share between prologue and epilogue.  */
end_comment

begin_comment
comment|/* Number of live general or floating point registers needed to be saved    (as 4-byte quantities).  This is only done if TARGET_EPILOGUE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_gfregs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute the frame size required by the function.  This function is called    during the reload pass and also by output_function_prologue().  */
end_comment

begin_function
name|int
name|compute_frame_size
parameter_list|(
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
name|int
name|n_regs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|int
name|outgoing_args_size
init|=
operator|(
name|current_function_outgoing_args_size
operator|+
name|REG_PARM_STACK_SPACE
argument_list|(
name|current_function_decl
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
condition|)
block|{
comment|/* N_REGS is the number of 4-byte regs saved thus far.  This applies 	 even to v9 int regs to be consistent with save_regs/restore_regs.  */
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
operator|(
name|TARGET_V9
condition|?
literal|96
else|:
literal|64
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Set up values for use in `function_epilogue'.  */
name|num_gfregs
operator|=
name|n_regs
expr_stmt|;
if|if
condition|(
name|leaf_function
operator|&&
name|n_regs
operator|==
literal|0
operator|&&
name|size
operator|==
literal|0
operator|&&
name|current_function_outgoing_args_size
operator|==
literal|0
condition|)
block|{
name|actual_fsize
operator|=
name|apparent_fsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We subtract STARTING_FRAME_OFFSET, remember it's negative.          The stack bias (if any) is taken out to undo its effects.  */
name|apparent_fsize
operator|=
operator|(
name|size
operator|-
name|STARTING_FRAME_OFFSET
operator|+
name|SPARC_STACK_BIAS
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
expr_stmt|;
name|apparent_fsize
operator|+=
name|n_regs
operator|*
literal|4
expr_stmt|;
name|actual_fsize
operator|=
name|apparent_fsize
operator|+
operator|(
operator|(
name|outgoing_args_size
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
operator|)
expr_stmt|;
block|}
comment|/* Make sure nothing can clobber our register windows.      If a SAVE must be done, or there is a stack-local variable,      the register window area must be allocated.      ??? For v8 we apparently need an additional 8 bytes of reserved space.  */
if|if
condition|(
name|leaf_function
operator|==
literal|0
operator|||
name|size
operator|>
literal|0
condition|)
name|actual_fsize
operator|+=
operator|(
literal|16
operator|*
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|TARGET_ARCH64
condition|?
literal|0
else|:
literal|8
operator|)
expr_stmt|;
return|return
name|SPARC_STACK_ALIGN
argument_list|(
name|actual_fsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a (32 bit) big number in a register.  */
end_comment

begin_comment
comment|/* ??? We may be able to use the set macro here too.  */
end_comment

begin_function
specifier|static
name|void
name|build_big_number
parameter_list|(
name|file
parameter_list|,
name|num
parameter_list|,
name|reg
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|>=
literal|0
operator|||
operator|!
name|TARGET_ARCH64
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi %%hi(%d),%s\n"
argument_list|,
name|num
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor %s,%%lo(%d),%s\n"
argument_list|,
name|reg
argument_list|,
name|num
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* num< 0&& TARGET_ARCH64 */
block|{
comment|/* Sethi does not sign extend, so we must use a little trickery 	 to use it for negative numbers.  Invert the constant before 	 loading it in, then use xor immediate to invert the loaded bits 	 (along with the upper 32 bits) to the desired constant.  This 	 works because the sethi and immediate fields overlap.  */
name|int
name|asize
init|=
name|num
decl_stmt|;
name|int
name|inv
init|=
operator|~
name|asize
decl_stmt|;
name|int
name|low
init|=
operator|-
literal|0x400
operator|+
operator|(
name|asize
operator|&
literal|0x3FF
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi %%hi(%d),%s\n\txor %s,%d,%s\n"
argument_list|,
name|inv
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|low
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output code for the function prologue.  */
end_comment

begin_function
name|void
name|output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
comment|/* Need to use actual_fsize, since we are also allocating      space for our callee (and our own register save area).  */
name|actual_fsize
operator|=
name|compute_frame_size
argument_list|(
name|size
argument_list|,
name|leaf_function
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaf_function
condition|)
block|{
name|frame_base_name
operator|=
literal|"%sp"
expr_stmt|;
name|frame_base_offset
operator|=
name|actual_fsize
operator|+
name|SPARC_STACK_BIAS
expr_stmt|;
block|}
else|else
block|{
name|frame_base_name
operator|=
literal|"%fp"
expr_stmt|;
name|frame_base_offset
operator|=
name|SPARC_STACK_BIAS
expr_stmt|;
block|}
comment|/* This is only for the human reader.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#PROLOGUE# 0\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_fsize
operator|==
literal|0
condition|)
comment|/* do nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|leaf_function
operator|&&
operator|!
name|TARGET_BROKEN_SAVERESTORE
condition|)
block|{
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave %%sp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave %%sp,-4096,%%sp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|build_big_number
argument_list|(
name|file
argument_list|,
operator|-
name|actual_fsize
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave %%sp,%%g1,%%sp\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|leaf_function
operator|&&
name|TARGET_BROKEN_SAVERESTORE
condition|)
block|{
comment|/* We assume the environment will properly handle or otherwise avoid 	 trouble associated with an interrupt occurring after the `save' or 	 trap occurring during it.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%fp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%fp,-4096,%%sp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%fp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|build_big_number
argument_list|(
name|file
argument_list|,
operator|-
name|actual_fsize
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%fp,%%g1,%%sp\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* leaf function */
block|{
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,-4096,%%sp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|build_big_number
argument_list|(
name|file
argument_list|,
operator|-
name|actual_fsize
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,%%g1,%%sp\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
operator|&&
name|actual_fsize
condition|)
block|{
name|char
modifier|*
name|label
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
comment|/* The canonical frame address refers to the top of the frame.  */
name|dwarf2out_def_cfa
argument_list|(
name|label
argument_list|,
operator|(
name|leaf_function
condition|?
name|STACK_POINTER_REGNUM
else|:
name|FRAME_POINTER_REGNUM
operator|)
argument_list|,
name|frame_base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaf_function
condition|)
block|{
comment|/* Note the register window save.  This tells the unwinder that 	     it needs to restore the window registers from the previous 	     frame's window save area at 0(cfa).  */
name|dwarf2out_window_save
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* The return address (-8) is now in %i7.  */
name|dwarf2out_return_reg
argument_list|(
name|label
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If doing anything with PIC, do it now.  */
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#PROLOGUE# 1\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
comment|/* Call saved registers are saved just above the outgoing argument area.  */
if|if
condition|(
name|num_gfregs
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|real_offset
decl_stmt|,
name|n_regs
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|real_offset
operator|=
operator|-
name|apparent_fsize
expr_stmt|;
name|offset
operator|=
operator|-
name|apparent_fsize
operator|+
name|frame_base_offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
operator|-
literal|4096
operator|||
name|offset
operator|+
name|num_gfregs
operator|*
literal|4
operator|>
literal|4096
condition|)
block|{
comment|/* ??? This might be optimized a little as %g1 might already have a 	     value close enough that a single add insn will do.  */
comment|/* ??? Although, all of this is probably only a temporary fix 	     because if %g1 can hold a function result, then 	     output_function_epilogue will lose (the result will get 	     clobbered).  */
name|build_big_number
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%%g1,%%g1\n"
argument_list|,
name|frame_base_name
argument_list|)
expr_stmt|;
name|base
operator|=
literal|"%g1"
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|frame_base_name
expr_stmt|;
block|}
name|n_regs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|&&
operator|!
name|leaf_function
condition|)
comment|/* ??? Originally saved regs 0-15 here.  */
name|n_regs
operator|=
name|save_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|real_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|leaf_function
condition|)
comment|/* ??? Originally saved regs 0-31 here.  */
name|n_regs
operator|=
name|save_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|real_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
condition|)
name|save_regs
argument_list|(
name|file
argument_list|,
literal|32
argument_list|,
name|TARGET_V9
condition|?
literal|96
else|:
literal|64
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|n_regs
argument_list|,
name|real_offset
argument_list|)
expr_stmt|;
block|}
name|leaf_label
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|leaf_function
operator|&&
name|actual_fsize
operator|!=
literal|0
condition|)
block|{
comment|/* warning ("leaf procedure with frame size %d", actual_fsize); */
if|if
condition|(
operator|!
name|TARGET_EPILOGUE
condition|)
name|leaf_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output code for the function epilogue.  */
end_comment

begin_function
name|void
name|output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|leaf_label
condition|)
block|{
name|emit_label_after
argument_list|(
name|leaf_label
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_BLOCK_PROFILER_EXIT
elseif|else
if|if
condition|(
name|profile_block_flag
operator|==
literal|2
condition|)
block|{
name|FUNCTION_BLOCK_PROFILER_EXIT
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|current_function_epilogue_delay_list
operator|==
literal|0
condition|)
block|{
comment|/* If code does not drop into the epilogue, do nothing.  */
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
return|return;
block|}
comment|/* Restore any call saved registers.  */
if|if
condition|(
name|num_gfregs
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|n_regs
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|offset
operator|=
operator|-
name|apparent_fsize
operator|+
name|frame_base_offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
operator|-
literal|4096
operator|||
name|offset
operator|+
name|num_gfregs
operator|*
literal|4
operator|>
literal|4096
operator|-
literal|8
comment|/*double*/
condition|)
block|{
name|build_big_number
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
literal|"%g1"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%%g1,%%g1\n"
argument_list|,
name|frame_base_name
argument_list|)
expr_stmt|;
name|base
operator|=
literal|"%g1"
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|frame_base_name
expr_stmt|;
block|}
name|n_regs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|&&
operator|!
name|leaf_function
condition|)
comment|/* ??? Originally saved regs 0-15 here.  */
name|n_regs
operator|=
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|leaf_function
condition|)
comment|/* ??? Originally saved regs 0-31 here.  */
name|n_regs
operator|=
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
condition|)
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|32
argument_list|,
name|TARGET_V9
condition|?
literal|96
else|:
literal|64
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|n_regs
argument_list|)
expr_stmt|;
block|}
comment|/* Work out how to skip the caller's unimp instruction if required.  */
if|if
condition|(
name|leaf_function
condition|)
name|ret
operator|=
operator|(
name|SKIP_CALLERS_UNIMP_P
condition|?
literal|"jmp %o7+12"
else|:
literal|"retl"
operator|)
expr_stmt|;
else|else
name|ret
operator|=
operator|(
name|SKIP_CALLERS_UNIMP_P
condition|?
literal|"jmp %i7+12"
else|:
literal|"ret"
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|||
name|leaf_label
condition|)
block|{
name|int
name|old_target_epilogue
init|=
name|TARGET_EPILOGUE
decl_stmt|;
name|target_flags
operator|&=
operator|~
name|old_target_epilogue
expr_stmt|;
if|if
condition|(
operator|!
name|leaf_function
condition|)
block|{
comment|/* If we wound up with things in our delay slot, flush them here.  */
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
block|{
name|rtx
name|insn
init|=
name|emit_jump_insn_after
argument_list|(
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
decl_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_V9
operator|&&
operator|!
name|SKIP_CALLERS_UNIMP_P
condition|)
name|fputs
argument_list|(
literal|"\treturn %i7+8\n\tnop\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n\trestore\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* All of the following cases are for leaf functions.  */
elseif|else
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
block|{
comment|/* eligible_for_epilogue_delay_slot ensures that if this is a 	     leaf function, then we will only have insn in the delay slot 	     if the frame size is zero, thus no adjust for the stack is 	     needed here.  */
if|if
condition|(
name|actual_fsize
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Output 'nop' instead of 'sub %sp,-0,%sp' when no frame, so as to 	 avoid generating confusing assembly language output.  */
elseif|else
if|if
condition|(
name|actual_fsize
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n\tnop\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n\tsub %%sp,-%d,%%sp\n"
argument_list|,
name|ret
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %%sp,-4096,%%sp\n\t%s\n\tsub %%sp,-%d,%%sp\n"
argument_list|,
name|ret
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi %%hi(%d),%%g1\n\t%s\n\tadd %%sp,%%g1,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi %%hi(%d),%%g1\n\tor %%g1,%%lo(%d),%%g1\n\t%s\n\tadd %%sp,%%g1,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|,
name|actual_fsize
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|old_target_epilogue
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for handling argument passing.     For v8 the first six args are normally in registers and the rest are    pushed.  Any arg that starts within the first 6 words is at least    partially passed in a register unless its data type forbids.     For v9, the argument registers are laid out as an array of 16 elements    and arguments are added sequentially.  The first 6 int args and up to the    first 16 fp args (depending on size) are passed in regs.     Slot    Stack   Integral   Float   Float in structure   Double   Long Double    ----    -----   --------   -----   ------------------   ------   -----------     15   [SP+248]              %f31       %f30,%f31         %d30     14   [SP+240]              %f29       %f28,%f29         %d28       %q28     13   [SP+232]              %f27       %f26,%f27         %d26     12   [SP+224]              %f25       %f24,%f25         %d24       %q24     11   [SP+216]              %f23       %f22,%f23         %d22     10   [SP+208]              %f21       %f20,%f21         %d20       %q20      9   [SP+200]              %f19       %f18,%f19         %d18      8   [SP+192]              %f17       %f16,%f17         %d16       %q16      7   [SP+184]              %f15       %f14,%f15         %d14      6   [SP+176]              %f13       %f12,%f13         %d12       %q12      5   [SP+168]     %o5      %f11       %f10,%f11         %d10      4   [SP+160]     %o4       %f9        %f8,%f9           %d8        %q8      3   [SP+152]     %o3       %f7        %f6,%f7           %d6      2   [SP+144]     %o2       %f5        %f4,%f5           %d4        %q4      1   [SP+136]     %o1       %f3        %f2,%f3           %d2      0   [SP+128]     %o0       %f1        %f0,%f1           %d0        %q0     Here SP = %sp if -mno-stack-bias or %sp+stack_bias otherwise.     Integral arguments are always passed as 64 bit quantities appropriately    extended.     Passing of floating point values is handled as follows.    If a prototype is in scope:      If the value is in a named argument (i.e. not a stdarg function or a      value not part of the `...') then the value is passed in the appropriate      fp reg.      If the value is part of the `...' and is passed in one of the first 6      slots then the value is passed in the appropriate int reg.      If the value is part of the `...' and is not passed in one of the first 6      slots then the value is passed in memory.    If a prototype is not in scope:      If the value is one of the first 6 arguments the value is passed in the      appropriate integer reg and the appropriate fp reg.      If the value is not one of the first 6 arguments the value is passed in      the appropriate fp reg and in memory.    */
end_comment

begin_comment
comment|/* Maximum number of int regs for args.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_INT_ARG_MAX
value|6
end_define

begin_comment
comment|/* Maximum number of fp regs for args.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_FP_ARG_MAX
value|16
end_define

begin_define
define|#
directive|define
name|ROUND_ADVANCE
parameter_list|(
name|SIZE
parameter_list|)
value|(((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
end_define

begin_comment
comment|/* Handle the INIT_CUMULATIVE_ARGS macro.    Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|,
name|indirect
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|libname
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|indirect
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cum
operator|->
name|words
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|prototype_p
operator|=
name|fntype
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|cum
operator|->
name|libcall_p
operator|=
name|fntype
operator|==
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the slot number to pass an argument in.    Returns the slot number or -1 if passing on the stack.     CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).    INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.    *PREGNO records the register number to use if scalar type.    *PPADDING records the amount of padding needed in words.  */
end_comment

begin_function
specifier|static
name|int
name|function_arg_slotno
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|,
name|incoming_p
parameter_list|,
name|pregno
parameter_list|,
name|ppadding
parameter_list|)
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
name|int
name|incoming_p
decl_stmt|;
name|int
modifier|*
name|pregno
decl_stmt|;
name|int
modifier|*
name|ppadding
decl_stmt|;
block|{
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_INCOMING_INT_ARG_FIRST
else|:
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|slotno
init|=
name|cum
operator|->
name|words
decl_stmt|;
name|int
name|regno
decl_stmt|;
operator|*
name|ppadding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TARGET_ARCH32
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|mode
operator|==
name|BLKmode
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|%
name|PARM_BOUNDARY
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VOIDmode
case|:
comment|/* MODE is VOIDmode when generating the actual call. 	 See emit_call_1.  */
return|return
operator|-
literal|1
return|;
case|case
name|QImode
case|:
case|case
name|CQImode
case|:
case|case
name|HImode
case|:
case|case
name|CHImode
case|:
case|case
name|SImode
case|:
case|case
name|CSImode
case|:
case|case
name|DImode
case|:
case|case
name|CDImode
case|:
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
case|case
name|SCmode
case|:
case|case
name|DFmode
case|:
case|case
name|DCmode
case|:
case|case
name|TFmode
case|:
case|case
name|TCmode
case|:
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mode
operator|==
name|TFmode
operator|||
name|mode
operator|==
name|TCmode
operator|)
operator|&&
operator|(
name|slotno
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|slotno
operator|++
operator|,
operator|*
name|ppadding
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_FPU
operator|&&
name|named
condition|)
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_FP_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|SPARC_FP_ARG_FIRST
operator|+
name|slotno
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|regno
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BLKmode
case|:
comment|/* For sparc64, objects requiring 16 byte alignment get it.  */
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
if|if
condition|(
name|type
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|==
literal|128
operator|&&
operator|(
name|slotno
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|slotno
operator|++
operator|,
operator|*
name|ppadding
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ARCH32
operator|||
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
block|}
else|else
block|{
name|tree
name|field
decl_stmt|;
name|int
name|intregs_p
init|=
literal|0
decl_stmt|,
name|fpregs_p
init|=
literal|0
decl_stmt|;
comment|/* The ABI obviously doesn't specify how packed 	     structures are passed.  These are defined to be passed 	     in int regs if possible, otherwise memory.  */
name|int
name|packed_p
init|=
literal|0
decl_stmt|;
comment|/* First see what kinds of registers we need.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TARGET_FPU
condition|)
name|fpregs_p
operator|=
literal|1
expr_stmt|;
else|else
name|intregs_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
name|packed_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|packed_p
operator|||
operator|!
name|named
condition|)
name|fpregs_p
operator|=
literal|0
operator|,
name|intregs_p
operator|=
literal|1
expr_stmt|;
comment|/* If all arg slots are filled, then must pass on stack.  */
if|if
condition|(
name|fpregs_p
operator|&&
name|slotno
operator|>=
name|SPARC_FP_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If there are only int args and all int arg slots are filled, 	     then must pass on stack.  */
if|if
condition|(
operator|!
name|fpregs_p
operator|&&
name|intregs_p
operator|&&
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Note that even if all int arg slots are filled, fp members may 	     still be passed in regs if such regs are available. 	     *PREGNO isn't set because there may be more than one, it's up 	     to the caller to compute them.  */
return|return
name|slotno
return|;
block|}
break|break;
default|default :
name|abort
argument_list|()
expr_stmt|;
block|}
operator|*
name|pregno
operator|=
name|regno
expr_stmt|;
return|return
name|slotno
return|;
block|}
end_function

begin_comment
comment|/* Handle recursive register counting for structure field layout.  */
end_comment

begin_struct
struct|struct
name|function_arg_record_value_parms
block|{
name|rtx
name|ret
decl_stmt|;
name|int
name|slotno
decl_stmt|,
name|named
decl_stmt|,
name|regbase
decl_stmt|;
name|int
name|nregs
decl_stmt|,
name|intoffset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|function_arg_record_value_1
parameter_list|(
name|type
parameter_list|,
name|startbitpos
parameter_list|,
name|parms
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|startbitpos
decl_stmt|;
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
comment|/* The ABI obviously doesn't specify how packed structures are      passed.  These are defined to be passed in int regs if possible,      otherwise memory.  */
name|int
name|packed_p
init|=
literal|0
decl_stmt|;
comment|/* We need to compute how many registers are needed so we can      allocate the PARALLEL but before we can do that we need to know      whether there are any packed fields.  If there are, int regs are      used regardless of whether there are fp values present.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|packed_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Compute how many registers we need.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|int
name|bitpos
init|=
name|startbitpos
decl_stmt|;
if|if
condition|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
condition|)
name|bitpos
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? FIXME: else assume zero offset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|function_arg_record_value_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TARGET_FPU
operator|&&
operator|!
name|packed_p
operator|&&
name|parms
operator|->
name|named
condition|)
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|intslots
decl_stmt|,
name|this_slotno
decl_stmt|;
name|intslots
operator|=
operator|(
name|bitpos
operator|-
name|parms
operator|->
name|intoffset
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|parms
operator|->
name|slotno
operator|+
name|parms
operator|->
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
name|MIN
argument_list|(
name|intslots
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
name|intslots
operator|=
name|MAX
argument_list|(
name|intslots
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
name|intslots
expr_stmt|;
name|parms
operator|->
name|intoffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* There's no need to check this_slotno< SPARC_FP_ARG MAX. 		 If it wasn't true we wouldn't be here.  */
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
name|parms
operator|->
name|intoffset
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle recursive structure field register assignment.  */
end_comment

begin_function
specifier|static
name|void
name|function_arg_record_value_3
parameter_list|(
name|bitpos
parameter_list|,
name|parms
parameter_list|)
name|int
name|bitpos
decl_stmt|;
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|this_slotno
decl_stmt|,
name|intslots
decl_stmt|,
name|intoffset
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
return|return;
name|intoffset
operator|=
name|parms
operator|->
name|intoffset
expr_stmt|;
name|parms
operator|->
name|intoffset
operator|=
operator|-
literal|1
expr_stmt|;
name|intslots
operator|=
operator|(
name|bitpos
operator|-
name|intoffset
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|parms
operator|->
name|slotno
operator|+
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
name|MIN
argument_list|(
name|intslots
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
if|if
condition|(
name|intslots
operator|<=
literal|0
condition|)
return|return;
comment|/* If this is the trailing part of a word, only load that much into      the register.  Otherwise load the whole register.  Note that in      the latter case we may pick up unwanted bits.  It's not a problem      at the moment but may wish to revisit.  */
if|if
condition|(
name|intoffset
operator|%
name|BITS_PER_WORD
operator|!=
literal|0
condition|)
block|{
name|mode
operator|=
name|mode_for_size
argument_list|(
name|BITS_PER_WORD
operator|-
name|intoffset
operator|%
name|BITS_PER_WORD
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mode
operator|=
name|word_mode
expr_stmt|;
name|intoffset
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
do|do
block|{
name|regno
operator|=
name|parms
operator|->
name|regbase
operator|+
name|this_slotno
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|parms
operator|->
name|ret
argument_list|,
literal|0
argument_list|,
name|parms
operator|->
name|nregs
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|intoffset
argument_list|)
argument_list|)
expr_stmt|;
name|this_slotno
operator|+=
literal|1
expr_stmt|;
name|intoffset
operator|=
operator|(
name|intoffset
operator||
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
name|intslots
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|intslots
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|function_arg_record_value_2
parameter_list|(
name|type
parameter_list|,
name|startbitpos
parameter_list|,
name|parms
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|startbitpos
decl_stmt|;
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
name|int
name|packed_p
init|=
literal|0
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|packed_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|int
name|bitpos
init|=
name|startbitpos
decl_stmt|;
if|if
condition|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
condition|)
name|bitpos
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? FIXME: else assume zero offset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|function_arg_record_value_2
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TARGET_FPU
operator|&&
operator|!
name|packed_p
operator|&&
name|parms
operator|->
name|named
condition|)
block|{
name|int
name|this_slotno
init|=
name|parms
operator|->
name|slotno
operator|+
name|bitpos
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|function_arg_record_value_3
argument_list|(
name|bitpos
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DECL_MODE
argument_list|(
name|field
argument_list|)
argument_list|,
operator|(
name|SPARC_FP_ARG_FIRST
operator|+
name|this_slotno
operator|*
literal|2
operator|+
operator|(
name|DECL_MODE
argument_list|(
name|field
argument_list|)
operator|==
name|SFmode
operator|&&
operator|(
name|bitpos
operator|&
literal|32
operator|)
operator|!=
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|parms
operator|->
name|ret
argument_list|,
literal|0
argument_list|,
name|parms
operator|->
name|nregs
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
name|parms
operator|->
name|intoffset
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|rtx
name|function_arg_record_value
parameter_list|(
name|type
parameter_list|,
name|mode
parameter_list|,
name|slotno
parameter_list|,
name|named
parameter_list|,
name|regbase
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|slotno
decl_stmt|,
name|named
decl_stmt|,
name|regbase
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|typesize
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|function_arg_record_value_parms
name|parms
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|parms
operator|.
name|ret
operator|=
name|NULL_RTX
expr_stmt|;
name|parms
operator|.
name|slotno
operator|=
name|slotno
expr_stmt|;
name|parms
operator|.
name|named
operator|=
name|named
expr_stmt|;
name|parms
operator|.
name|regbase
operator|=
name|regbase
expr_stmt|;
comment|/* Compute how many registers we need.  */
name|parms
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
name|parms
operator|.
name|intoffset
operator|=
literal|0
expr_stmt|;
name|function_arg_record_value_1
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|.
name|intoffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|intslots
decl_stmt|,
name|this_slotno
decl_stmt|;
name|intslots
operator|=
operator|(
name|typesize
operator|*
name|BITS_PER_UNIT
operator|-
name|parms
operator|.
name|intoffset
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|slotno
operator|+
name|parms
operator|.
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
name|MIN
argument_list|(
name|intslots
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
name|intslots
operator|=
name|MAX
argument_list|(
name|intslots
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|.
name|nregs
operator|+=
name|intslots
expr_stmt|;
block|}
name|nregs
operator|=
name|parms
operator|.
name|nregs
expr_stmt|;
comment|/* Allocate the vector and handle some annoying special cases.  */
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
block|{
comment|/* ??? Empty structure has no value?  Duh?  */
if|if
condition|(
name|typesize
operator|<=
literal|0
condition|)
block|{
comment|/* Though there's nothing really to store, return a word register 	     anyway so the rest of gcc doesn't go nuts.  Returning a PARALLEL 	     leads to breakage due to the fact that there are zero bytes to 	     load.  */
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regbase
argument_list|)
return|;
block|}
else|else
block|{
comment|/* ??? C++ has structures with no fields, and yet a size.  Give up 	     for now and pass everything back in integer registers.  */
name|nregs
operator|=
operator|(
name|typesize
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|+
name|slotno
operator|>
name|SPARC_INT_ARG_MAX
condition|)
name|nregs
operator|=
name|SPARC_INT_ARG_MAX
operator|-
name|slotno
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|parms
operator|.
name|ret
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the entries.  */
name|parms
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
name|parms
operator|.
name|intoffset
operator|=
literal|0
expr_stmt|;
name|function_arg_record_value_2
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
name|function_arg_record_value_3
argument_list|(
name|typesize
operator|*
name|BITS_PER_UNIT
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|.
name|nregs
operator|!=
name|nregs
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|parms
operator|.
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG macro.    Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).    INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|,
name|incoming_p
parameter_list|)
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
name|int
name|incoming_p
decl_stmt|;
block|{
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_INCOMING_INT_ARG_FIRST
else|:
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
name|incoming_p
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotno
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* v9 fp args in reg slots beyond the int reg slots get passed in regs      but also have the slot allocated for them.      If no prototype is in scope fp values in register slots get passed      in two places, either fp regs and int regs or fp regs and memory.  */
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|)
operator|&&
name|SPARC_FP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|prototype_p
operator|||
name|cum
operator|->
name|libcall_p
condition|)
block|{
comment|/* "* 2" because fp reg numbers are recorded in 4 byte 	     quantities.  */
if|#
directive|if
literal|0
comment|/* ??? This will cause the value to be passed in the fp reg and 	     in the stack.  When a prototype exists we want to pass the 	     value in the reg but reserve space on the stack.  That's an 	     optimization, and is deferred [for a bit].  */
block|if ((regno - SPARC_FP_ARG_FIRST)>= SPARC_INT_ARG_MAX * 2) 	    return gen_rtx_PARALLEL (mode, 			    gen_rtvec (2, 				       gen_rtx_EXPR_LIST (VOIDmode, 						NULL_RTX, const0_rtx), 				       gen_rtx_EXPR_LIST (VOIDmode, 						reg, const0_rtx))); 	  else
else|#
directive|else
comment|/* ??? It seems that passing back a register even when past 	     the area declared by REG_PARM_STACK_SPACE will allocate 	     space appropriately, and will not copy the data onto the 	     stack, exactly as we desire.  	     This is due to locate_and_pad_parm being called in 	     expand_call whenever reg_parm_stack_space> 0, which 	     while benefical to our example here, would seem to be 	     in error from what had been intended.  Ho hum...  -- r~ */
endif|#
directive|endif
return|return
name|reg
return|;
block|}
else|else
block|{
name|rtx
name|v0
decl_stmt|,
name|v1
decl_stmt|;
if|if
condition|(
operator|(
name|regno
operator|-
name|SPARC_FP_ARG_FIRST
operator|)
operator|<
name|SPARC_INT_ARG_MAX
operator|*
literal|2
condition|)
block|{
name|int
name|intreg
decl_stmt|;
comment|/* On incoming, we don't need to know that the value 		 is passed in %f0 and %i0, and it confuses other parts 		 causing needless spillage even on the simplest cases.  */
if|if
condition|(
name|incoming_p
condition|)
return|return
name|reg
return|;
name|intreg
operator|=
operator|(
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|+
operator|(
name|regno
operator|-
name|SPARC_FP_ARG_FIRST
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|v0
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|v1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|v0
argument_list|,
name|v1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|v0
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|v1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|v0
argument_list|,
name|v1
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
comment|/* Structures up to 16 bytes in size are passed in arg slots on the 	 stack and are promoted to registers where possible.  */
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* shouldn't get here */
return|return
name|function_arg_record_value
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
name|slotno
argument_list|,
name|named
argument_list|,
name|regbase
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Scalar or complex int.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_PARTIAL_NREGS macro.    For an arg passed partly in registers and partly in memory,    this is the number of registers used.    For args passed entirely in registers or entirely in memory, zero.     Any arg that starts in the first 6 regs but won't entirely fit in them    needs partial registers on v8.  On v9, structures with integer    values in arg slots 5,6 will be passed in %o5 and SP+176, and complex fp    values that begin in the last fp reg [where "last fp reg" varies with the    mode] will be split between that reg and memory.  */
end_comment

begin_function
name|int
name|function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
comment|/* We pass 0 for incoming_p here, it doesn't matter.  */
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
literal|0
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotno
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
if|if
condition|(
operator|(
name|slotno
operator|+
operator|(
name|mode
operator|==
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
operator|)
operator|>
name|NPARM_REGS
argument_list|(
name|SImode
argument_list|)
condition|)
return|return
name|NPARM_REGS
argument_list|(
name|SImode
argument_list|)
operator|-
name|slotno
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|16
condition|)
name|slotno
operator|+=
name|slotno
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
operator|&&
name|size
operator|<=
literal|16
operator|&&
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|1
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|&&
operator|!
name|TARGET_FPU
operator|)
condition|)
block|{
if|if
condition|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|128
condition|)
block|{
name|slotno
operator|+=
name|slotno
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|2
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|1
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
if|if
condition|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|==
literal|128
condition|)
name|slotno
operator|+=
name|slotno
operator|&
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|slotno
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|>
name|SPARC_FP_ARG_MAX
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_PASS_BY_REFERENCE macro.    !v9: The SPARC ABI stipulates passing struct arguments (of any size) and    quad-precision floats by invisible reference.    v9: Aggregates greater than 16 bytes are passed by reference.    For Pascal, also pass arrays by reference.  */
end_comment

begin_function
name|int
name|function_arg_pass_by_reference
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
return|return
operator|(
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|mode
operator|==
name|TFmode
operator|||
name|mode
operator|==
name|TCmode
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
comment|/* Consider complex values as aggregates, so care for TCmode. */
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|16
operator|||
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|16
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_ADVANCE macro.    Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    TYPE is null for libcalls where that information may not be available.  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
comment|/* We pass 0 for incoming_p here, it doesn't matter.  */
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
literal|0
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
comment|/* If register required leading padding, add it.  */
if|if
condition|(
name|slotno
operator|!=
operator|-
literal|1
condition|)
name|cum
operator|->
name|words
operator|+=
name|padding
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|cum
operator|->
name|words
operator|+=
operator|(
name|mode
operator|!=
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|8
condition|)
operator|++
name|cum
operator|->
name|words
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
literal|16
condition|)
name|cum
operator|->
name|words
operator|+=
literal|2
expr_stmt|;
else|else
comment|/* passed by reference */
operator|++
name|cum
operator|->
name|words
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
block|{
name|cum
operator|->
name|words
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
name|cum
operator|->
name|words
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
block|{
name|cum
operator|->
name|words
operator|+=
operator|(
name|mode
operator|!=
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_PADDING macro.    For the 64 bit ABI structs are always stored left shifted in their    argument slot.  */
end_comment

begin_function
name|enum
name|direction
name|function_arg_padding
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|upward
return|;
comment|/* This is the default definition.  */
return|return
operator|(
operator|!
name|BYTES_BIG_ENDIAN
condition|?
name|upward
else|:
operator|(
operator|(
name|mode
operator|==
name|BLKmode
condition|?
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|PARM_BOUNDARY
operator|)
condition|?
name|downward
else|:
name|upward
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE, and LIBCALL_VALUE macros.    For v9, function return values are subject to the same rules as arguments,    except that up to 32-bytes may be returned in registers.  */
end_comment

begin_function
name|rtx
name|function_value
parameter_list|(
name|type
parameter_list|,
name|mode
parameter_list|,
name|incoming_p
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|incoming_p
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_OUTGOING_INT_ARG_FIRST
else|:
name|SPARC_INCOMING_INT_ARG_FIRST
operator|)
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
comment|/* Structures up to 32 bytes in size are passed in registers, 	     promoted to fp registers where possible.  */
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* shouldn't get here */
return|return
name|function_arg_record_value
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|regbase
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|int
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bytes
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|incoming_p
condition|)
name|regno
operator|=
name|BASE_RETURN_VALUE_REG
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|regno
operator|=
name|BASE_OUTGOING_VALUE_REG
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do what is necessary for `va_start'.  The argument is ignored.     We look at the current function to determine if stdarg or varargs    is used and return the address of the first unnamed parameter.  */
end_comment

begin_function
name|rtx
name|sparc_builtin_saveregs
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|first_reg
init|=
name|current_function_args_info
operator|.
name|words
decl_stmt|;
name|rtx
name|address
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|first_reg
init|;
name|regno
operator|<
name|NPARM_REGS
argument_list|(
name|word_mode
argument_list|)
condition|;
name|regno
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|STACK_POINTER_OFFSET
operator|+
name|UNITS_PER_WORD
operator|*
name|regno
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|BASE_INCOMING_ARG_REG
argument_list|(
name|word_mode
argument_list|)
operator|+
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|STACK_POINTER_OFFSET
operator|+
name|UNITS_PER_WORD
operator|*
name|first_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_check_memory_usage
operator|&&
name|first_reg
operator|<
name|NPARM_REGS
argument_list|(
name|word_mode
argument_list|)
condition|)
name|emit_library_call
argument_list|(
name|chkr_set_right_libfunc
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|address
argument_list|,
name|ptr_mode
argument_list|,
name|GEN_INT
argument_list|(
name|UNITS_PER_WORD
operator|*
operator|(
name|NPARM_REGS
argument_list|(
name|word_mode
argument_list|)
operator|-
name|first_reg
operator|)
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|MEMORY_USE_RW
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|address
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, which is    the operand number of the label.  OP is the conditional expression.    XEXP (OP, 0) is assumed to be a condition code register (integer or    floating point) and its mode specifies what kind of comparison we made.     REVERSED is non-zero if we should reverse the sense of the comparison.     ANNUL is non-zero if we should generate an annulling branch.     NOOP is non-zero if we have to follow this branch by a noop.     INSN, if set, is the insn.  */
end_comment

begin_function
name|char
modifier|*
name|output_cbranch
parameter_list|(
name|op
parameter_list|,
name|label
parameter_list|,
name|reversed
parameter_list|,
name|annul
parameter_list|,
name|noop
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|label
decl_stmt|;
name|int
name|reversed
decl_stmt|,
name|annul
decl_stmt|,
name|noop
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
decl_stmt|;
specifier|static
name|char
name|v8_labelno
index|[]
init|=
literal|" %lX"
decl_stmt|;
specifier|static
name|char
name|v9_icc_labelno
index|[]
init|=
literal|" %%icc,%lX"
decl_stmt|;
specifier|static
name|char
name|v9_xcc_labelno
index|[]
init|=
literal|" %%xcc,%lX"
decl_stmt|;
specifier|static
name|char
name|v9_fcc_labelno
index|[]
init|=
literal|" %%fccX,%lY"
decl_stmt|;
name|char
modifier|*
name|labelno
decl_stmt|;
name|int
name|labeloff
decl_stmt|;
comment|/* ??? !v9: FP branches cannot be preceded by another floating point insn.      Because there is currently no concept of pre-delay slots, we can fix      this only by always emitting a nop before a floating point branch.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
operator|)
operator|&&
operator|!
name|TARGET_V9
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"nop\n\t"
argument_list|)
expr_stmt|;
else|else
name|string
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If not floating-point or if EQ or NE, we can just reverse the code.  */
if|if
condition|(
name|reversed
operator|&&
operator|(
operator|(
name|mode
operator|!=
name|CCFPmode
operator|&&
name|mode
operator|!=
name|CCFPEmode
operator|)
operator|||
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|reversed
operator|=
literal|0
expr_stmt|;
comment|/* Start by writing the branch condition.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbne"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bne"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbe"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"be"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbul"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbge"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CC_NOOVmode
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bpos"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bge"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbule"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbg"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bg"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbug"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fble"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"ble"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbuge"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbl"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CC_NOOVmode
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bneg"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bl"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bgeu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bgu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bleu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"blu"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Now add the annulling, the label, and a possible noop.  */
if|if
condition|(
name|annul
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|",a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_V9
condition|)
block|{
name|labeloff
operator|=
literal|3
expr_stmt|;
name|labelno
operator|=
name|v8_labelno
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|insn
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PRED
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&
name|ATTR_FLAG_likely
condition|?
literal|",pt"
else|:
literal|",pn"
argument_list|)
expr_stmt|;
name|labeloff
operator|=
literal|9
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
name|labeloff
operator|=
literal|10
expr_stmt|;
name|labelno
operator|=
name|v9_fcc_labelno
expr_stmt|;
comment|/* Set the char indicating the number of the fcc reg to use.  */
name|labelno
index|[
literal|6
index|]
operator|=
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
operator|-
name|SPARC_FIRST_V9_FCC_REG
operator|+
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCXmode
operator|||
name|mode
operator|==
name|CCX_NOOVmode
condition|)
name|labelno
operator|=
name|v9_xcc_labelno
expr_stmt|;
else|else
name|labelno
operator|=
name|v9_icc_labelno
expr_stmt|;
block|}
comment|/* Set the char indicating the number of the operand containing the      label_ref.  */
name|labelno
index|[
name|labeloff
index|]
operator|=
name|label
operator|+
literal|'0'
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
if|if
condition|(
name|noop
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, testing    register REG.  LABEL is the operand number of the label; REG is the    operand number of the reg.  OP is the conditional expression.  The mode    of REG says what kind of comparison we made.     REVERSED is non-zero if we should reverse the sense of the comparison.     ANNUL is non-zero if we should generate an annulling branch.     NOOP is non-zero if we have to follow this branch by a noop.  */
end_comment

begin_function
name|char
modifier|*
name|output_v9branch
parameter_list|(
name|op
parameter_list|,
name|reg
parameter_list|,
name|label
parameter_list|,
name|reversed
parameter_list|,
name|annul
parameter_list|,
name|noop
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|label
decl_stmt|;
name|int
name|reversed
decl_stmt|,
name|annul
decl_stmt|,
name|noop
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|static
name|char
name|labelno
index|[]
init|=
literal|" %X,%lX"
decl_stmt|;
comment|/* If not floating-point or if EQ or NE, we can just reverse the code.  */
if|if
condition|(
name|reversed
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|reversed
operator|=
literal|0
expr_stmt|;
comment|/* Only 64 bit versions of these instructions exist.  */
if|if
condition|(
name|mode
operator|!=
name|DImode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Start by writing the branch condition.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brnz"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brz"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brgez"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brlz"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brlez"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brgz"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now add the annulling, reg, label, and nop.  */
if|if
condition|(
name|annul
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|",a"
argument_list|)
expr_stmt|;
comment|/* ??? Optional prediction bit ",pt" or ",pf" goes here.  */
name|labelno
index|[
literal|2
index|]
operator|=
name|reg
operator|+
literal|'0'
expr_stmt|;
name|labelno
index|[
literal|6
index|]
operator|=
name|label
operator|+
literal|'0'
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
if|if
condition|(
name|noop
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Renumber registers in delay slot.  Replace registers instead of    renumbering because they may be shared.     This does not handle instructions other than move.  */
end_comment

begin_function
specifier|static
name|void
name|epilogue_renumber
parameter_list|(
name|where
parameter_list|)
name|rtx
modifier|*
name|where
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|where
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
operator|*
name|where
operator|=
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|epilogue_renumber
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>
literal|8
operator|&&
name|regno
operator|<
literal|24
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|24
operator|&&
name|regno
operator|<
literal|32
condition|)
operator|*
name|where
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|regno
operator|-
literal|16
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|IOR
case|:
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
name|epilogue_renumber
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
name|epilogue_renumber
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|debug_rtx
argument_list|(
operator|*
name|where
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output assembler code to return from a function.  */
end_comment

begin_function
name|char
modifier|*
name|output_return
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|delay
init|=
name|final_sequence
condition|?
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|leaf_label
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|leaf_label
expr_stmt|;
return|return
literal|"b%* %l0%("
return|;
block|}
elseif|else
if|if
condition|(
name|leaf_function
condition|)
block|{
comment|/* No delay slot in a leaf function.  */
if|if
condition|(
name|delay
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we didn't allocate a frame pointer for the current function, 	 the stack pointer might have been adjusted.  Output code to 	 restore it now.  */
name|operands
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|actual_fsize
argument_list|)
expr_stmt|;
comment|/* Use sub of negated value in first two cases instead of add to 	 allow actual_fsize == 4096.  */
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
block|{
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
return|return
literal|"jmp %%o7+12\n\tsub %%sp,-%0,%%sp"
return|;
else|else
return|return
literal|"retl\n\tsub %%sp,-%0,%%sp"
return|;
block|}
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
return|return
literal|"sub %%sp,-4096,%%sp\n\tjmp %%o7+12\n\tsub %%sp,-%0,%%sp"
return|;
else|else
return|return
literal|"sub %%sp,-4096,%%sp\n\tretl\n\tsub %%sp,-%0,%%sp"
return|;
block|}
elseif|else
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
block|{
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi %%hi(%a0),%%g1\n\tor %%g1,%%lo(%a0),%%g1\n\tjmp %%o7+12\n\tadd %%sp,%%g1,%%sp"
return|;
else|else
return|return
literal|"sethi %%hi(%a0),%%g1\n\tjmp %%o7+12\n\tadd %%sp,%%g1,%%sp"
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi %%hi(%a0),%%g1\n\tor %%g1,%%lo(%a0),%%g1\n\tretl\n\tadd %%sp,%%g1,%%sp"
return|;
else|else
return|return
literal|"sethi %%hi(%a0),%%g1\n\tretl\n\tadd %%sp,%%g1,%%sp"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_V9
condition|)
block|{
if|if
condition|(
name|delay
condition|)
block|{
name|epilogue_renumber
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|delay
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|epilogue_renumber
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|delay
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
return|return
literal|"return %%i7+12%#"
return|;
else|else
return|return
literal|"return %%i7+8%#"
return|;
block|}
else|else
block|{
if|if
condition|(
name|delay
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|SKIP_CALLERS_UNIMP_P
condition|)
return|return
literal|"jmp %%i7+12\n\trestore"
return|;
else|else
return|return
literal|"ret\n\trestore"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Leaf functions and non-leaf functions have different needs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_leaf_alloc_order
index|[]
init|=
name|REG_LEAF_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_nonleaf_alloc_order
index|[]
init|=
name|REG_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_alloc_orders
index|[]
init|=
block|{
name|reg_leaf_alloc_order
block|,
name|reg_nonleaf_alloc_order
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|order_regs_for_local_alloc
parameter_list|()
block|{
specifier|static
name|int
name|last_order_nonleaf
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|15
index|]
operator|!=
name|last_order_nonleaf
condition|)
block|{
name|last_order_nonleaf
operator|=
operator|!
name|last_order_nonleaf
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_alloc_orders
index|[
name|last_order_nonleaf
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|reg_alloc_order
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.    This makes them candidates for using ldd and std insns.      Note reg1 and reg2 *must* be hard registers.  */
end_comment

begin_function
name|int
name|registers_ok_for_ldd_peep
parameter_list|(
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|%
literal|2
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Integer ldd is deprecated in SPARC V9 */
if|if
condition|(
name|TARGET_V9
operator|&&
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg2
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if addr1 and addr2 are suitable for use in an ldd or     std insn.     This can only happen when addr1 and addr2 are consecutive memory    locations (addr1 + 4 == addr2).  addr1 must also be aligned on a     64 bit boundary (addr1 % 8 == 0).       We know %sp and %fp are kept aligned on a 64 bit boundary.  Other    registers are assumed to *never* be properly aligned and are     rejected.     Knowing %sp and %fp are kept aligned on a 64 bit boundary, we     need only check that the offset for addr1 % 8 == 0.  */
end_comment

begin_function
name|int
name|addrs_ok_for_ldd_peep
parameter_list|(
name|addr1
parameter_list|,
name|addr2
parameter_list|)
name|rtx
name|addr1
decl_stmt|,
name|addr2
decl_stmt|;
block|{
name|int
name|reg1
decl_stmt|,
name|offset1
decl_stmt|;
comment|/* Extract a register number and offset (if used) from the first addr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* If not a REG, return zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset must be constant!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
comment|/* This was a simple (mem (reg)) expression.  Offset is 0.  */
name|offset1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure the second address is a (mem (plus (reg) (const_int).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* Only %fp and %sp are allowed.  Additionally both addresses must      use the same register.  */
if|if
condition|(
name|reg1
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|reg1
operator|!=
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg1
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The first offset must be evenly divisible by 8 to ensure the       address is 64 bit aligned.  */
if|if
condition|(
name|offset1
operator|%
literal|8
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* The offset for the second addr must be 4 more than the first addr.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|offset1
operator|+
literal|4
condition|)
return|return
literal|0
return|;
comment|/* All the tests passed.  addr1 and addr2 are valid for ldd and std      instructions.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if reg is a pseudo, or is the first register in     a hard register pair.  This makes it a candidate for use in    ldd and std insns.  */
end_comment

begin_function
name|int
name|register_ok_for_ldd
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|%
literal|2
operator|==
literal|0
operator|)
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print operand X (an rtx) in assembler syntax to file FILE.    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.    For `%' followed by punctuation, CODE is the punctuation and X is null.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* Output a 'nop' if there's nothing for the delay slot.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\tnop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'*'
case|:
comment|/* Output an annul flag if there's nothing for the delay slot and we 	 are optimizing.  This is always used with '(' below.  */
comment|/* Sun OS 4.1.1 dbx can't handle an annulled unconditional branch; 	 this is a dbx bug.  So, we only do this when optimizing.  */
comment|/* On UltraSPARC, a branch in a delay slot causes a pipeline flush. 	 Always emit a nop in case the next instruction is a branch.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|optimize
operator|&&
operator|(
name|int
operator|)
name|sparc_cpu
operator|<
name|PROCESSOR_V9
operator|)
condition|)
name|fputs
argument_list|(
literal|",a"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'('
case|:
comment|/* Output a 'nop' if there's nothing for the delay slot and we are 	 not optimizing.  This is always used with '*' above.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
operator|&&
operator|!
operator|(
name|optimize
operator|&&
operator|(
name|int
operator|)
name|sparc_cpu
operator|<
name|PROCESSOR_V9
operator|)
condition|)
name|fputs
argument_list|(
literal|"\n\tnop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'_'
case|:
comment|/* Output the Embedded Medium/Anywhere code model base register.  */
name|fputs
argument_list|(
name|EMBMEDANY_BASE_REG
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'@'
case|:
comment|/* Print out what we are using as the frame pointer.  This might 	 be %fp, or might be %sp+offset.  */
comment|/* ??? What if offset is too big? Perhaps the caller knows it isn't? */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s+%d"
argument_list|,
name|frame_base_name
argument_list|,
name|frame_base_offset
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Y'
case|:
comment|/* Adjust the operand to take into account a RESTORE operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|output_operand_lossage
argument_list|(
literal|"Invalid %%Y operand"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
literal|8
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
literal|32
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
literal|16
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"Invalid %%Y operand"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
comment|/* Print out the low order register name of a register pair.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* Print out the high order register name of a register pair.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
comment|/* Print out the second register name of a register pair or quad. 	 I.e., R (%o0) => %o1.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* Print out the third register name of a register quad. 	 I.e., S (%o0) => %o2.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* Print out the fourth register name of a register quad. 	 I.e., T (%o0) => %o3.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'x'
case|:
comment|/* Print a condition code register.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|SPARC_ICC_REG
condition|)
block|{
comment|/* We don't handle CC[X]_NOOVmode because they're not supposed 	     to occur here.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|CCmode
condition|)
name|fputs
argument_list|(
literal|"%icc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|CCXmode
condition|)
name|fputs
argument_list|(
literal|"%xcc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* %fccN register */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
comment|/* Print the operand's address only.  */
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
comment|/* In this case we need a register.  Use %g0 if the 	 operand is const0_rtx.  */
if|if
condition|(
name|x
operator|==
name|const0_rtx
operator|||
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"%g0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
case|case
literal|'A'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"or"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"and"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"Invalid %%A operand"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'B'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"orn"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"andn"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xnor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"Invalid %%B operand"
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* These are used by the conditional move instructions.  */
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
block|{
name|enum
name|rtx_code
name|rc
init|=
operator|(
name|code
operator|==
literal|'c'
condition|?
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|)
decl_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"g"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"geu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"gu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"leu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"lu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
name|code
operator|==
literal|'c'
condition|?
literal|"Invalid %%c operand"
else|:
literal|"Invalid %%C operand"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* These are used by the movr instruction pattern.  */
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
block|{
name|enum
name|rtx_code
name|rc
init|=
operator|(
name|code
operator|==
literal|'d'
condition|?
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|)
decl_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"gez"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lz"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"lez"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gz"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
name|code
operator|==
literal|'d'
condition|?
literal|"Invalid %%d operand"
else|:
literal|"Invalid %%D operand"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
literal|'b'
case|:
block|{
comment|/* Print a sign-extended character.  */
name|int
name|i
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|i
operator|&
literal|0x80
condition|)
name|i
operator||=
literal|0xffffff00
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'f'
case|:
comment|/* Operand must be a MEM; write its address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|output_operand_lossage
argument_list|(
literal|"Invalid %%f operand"
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
comment|/* Do nothing special.  */
break|break;
default|default:
comment|/* Undocumented flag.  */
name|output_operand_lossage
argument_list|(
literal|"invalid operand output code"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|fputc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Poor Sun assembler doesn't understand absolute addressing.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|TARGET_LIVE_G0
condition|)
name|fputs
argument_list|(
literal|"%g0+"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
block|{
name|fputs
argument_list|(
literal|"%hi("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
name|print_operand
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"+%lo("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%u"
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"long long constant not a valid immediate operand"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|output_operand_lossage
argument_list|(
literal|"floating point constant not a valid immediate operand"
argument_list|)
expr_stmt|;
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function outputs assembler code for VALUE to FILE, where VALUE is    a 64 bit (DImode) value.  */
end_comment

begin_comment
comment|/* ??? If there is a 64 bit counterpart to .word that the assembler    understands, then using that would simply this code greatly.  */
end_comment

begin_comment
comment|/* ??? We only output .xword's for symbols and only then in environments    where the assembler can handle them.  */
end_comment

begin_function
name|void
name|output_double_int
parameter_list|(
name|file
parameter_list|,
name|value
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|value
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* ??? This has endianness issues.  */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
name|HOST_WIDE_INT
name|xword
init|=
name|INTVAL
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|high
operator|=
operator|(
name|xword
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
name|low
operator|=
name|xword
operator|&
literal|0xffffffff
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|GEN_INT
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|)
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MINUS
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_V9
operator|||
name|TARGET_CM_MEDLOW
condition|)
block|{
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t"
argument_list|,
name|ASM_LONGLONG
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of a code used in the .proc pseudo-op that says    what kind of result this function returns.  For non-C types, we pick    the closest C type.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|long
name|sparc_type_code
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|qualifiers
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|shift
decl_stmt|;
comment|/* Only the first 30 bits of the qualifier are valid.  We must refrain from      setting more, since some assemblers will give an error for this.  Also,      we must be careful to avoid shifts of 32 bits or more to avoid getting      unpredictable results.  */
for|for
control|(
name|shift
operator|=
literal|6
init|;
name|shift
operator|<
literal|30
condition|;
name|shift
operator|+=
literal|2
operator|,
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|qualifiers
return|;
case|case
name|ARRAY_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|3
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|2
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|8
operator|)
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|9
operator|)
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|10
operator|)
return|;
case|case
name|VOID_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|16
operator|)
return|;
case|case
name|INTEGER_TYPE
case|:
comment|/* If this is a range type, consider it to be the underlying 	     type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Carefully distinguish all the standard types of C, 	     without messing up if the language is not C.  We do this by 	     testing TYPE_PRECISION and TREE_UNSIGNED.  The old code used to 	     look at both the names and the above fields, but that's redundant. 	     Any type whose size is between two C types will be considered 	     to be the wider of the two types.  Also, we do not have a 	     special code to use for "long long", so anything wider than 	     long is treated the same.  Note that we can't distinguish 	     between "int" and "long" in this code if they are the same 	     size, but that's fine, since neither can the assembler.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|CHAR_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|12
else|:
literal|2
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|SHORT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|13
else|:
literal|3
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|INT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|14
else|:
literal|4
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|15
else|:
literal|5
operator|)
operator|)
return|;
case|case
name|REAL_TYPE
case|:
comment|/* If this is a range type, consider it to be the underlying 	     type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Carefully distinguish all the standard types of C, 	     without messing up if the language is not C.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|FLOAT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|6
operator|)
return|;
else|else
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
case|case
name|COMPLEX_TYPE
case|:
comment|/* GNU Fortran COMPLEX type.  */
comment|/* ??? We need to distinguish between double and float complex types, 	     but I don't know how yet because I can't reach this code from 	     existing front-ends.  */
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
comment|/* Who knows? */
case|case
name|CHAR_TYPE
case|:
comment|/* GNU Pascal CHAR type.  Not used in C.  */
case|case
name|BOOLEAN_TYPE
case|:
comment|/* GNU Fortran BOOLEAN type.  */
case|case
name|FILE_TYPE
case|:
comment|/* GNU Pascal FILE type.  */
case|case
name|SET_TYPE
case|:
comment|/* GNU Pascal SET type.  */
case|case
name|LANG_TYPE
case|:
comment|/* ? */
return|return
name|qualifiers
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Not a type! */
block|}
block|}
return|return
name|qualifiers
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nested function support.  */
end_comment

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.     This takes 16 insns: 2 shifts& 2 ands (to split up addresses), 4 sethi    (to load in opcodes), 4 iors (to merge address and opcodes), and 4 writes    (to store insns).  This is a bit excessive.  Perhaps a different    mechanism would be better here.     Emit enough FLUSH insns to synchronize the data and instruction caches.  */
end_comment

begin_function
name|void
name|sparc_initialize_trampoline
parameter_list|(
name|tramp
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|)
name|rtx
name|tramp
decl_stmt|,
name|fnaddr
decl_stmt|,
name|cxt
decl_stmt|;
block|{
comment|/* SPARC 32 bit trampoline:   	sethi %hi(fn),%g1  	sethi %hi(static),%g2  	jmp %g1+%lo(fn)  	or %g2,%lo(static),%g2      SETHI i,r  = 00rr rrr1 00ii iiii iiii iiii iiii iiii     JMPL r+i,d = 10dd ddd1 1100 0rrr rr1i iiii iiii iiii    */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|fnaddr
argument_list|,
name|size_int
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x03000000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|cxt
argument_list|,
name|size_int
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x05000000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_and
argument_list|(
name|fnaddr
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3ff
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x81c06000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|12
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_and
argument_list|(
name|cxt
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3ff
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8410a000
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_flush
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|tramp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On UltraSPARC a flush flushes an entire cache line.  The trampoline is      aligned on a 16 byte boundary so one flush clears it all.  */
if|if
condition|(
name|sparc_cpu
operator|!=
name|PROCESSOR_ULTRASPARC
condition|)
name|emit_insn
argument_list|(
name|gen_flush
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The 64 bit version is simpler because it makes more sense to load the    values as "immediate" data out of the trampoline.  It's also easier since    we can read the PC without clobbering a register.  */
end_comment

begin_function
name|void
name|sparc64_initialize_trampoline
parameter_list|(
name|tramp
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|)
name|rtx
name|tramp
decl_stmt|,
name|fnaddr
decl_stmt|,
name|cxt
decl_stmt|;
block|{
comment|/* 	rd %pc,%g1 	ldx [%g1+24],%g5 	jmp %g5 	ldx [%g1+16],%g5 	+16 bytes data    */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|tramp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x83414000
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0xca586018
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0x81c04000
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|12
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0xca586010
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|20
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_flush
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|tramp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_cpu
operator|!=
name|PROCESSOR_ULTRASPARC
condition|)
name|emit_insn
argument_list|(
name|gen_flush
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines to support a flat (single) register window calling    convention.  */
end_comment

begin_comment
comment|/* Single-register window sparc stack frames look like:               Before call		        After call         +-----------------------+	+-----------------------+    high |		        |	|			|    mem  |  caller's temps.    	|       |  caller's temps.    	| 	|       		|       |       	        |         +-----------------------+	+-----------------------+  	|       		|	|		        |         |  arguments on stack.  |	|  arguments on stack.  | 	|       		|      	|			|         +-----------------------+FP+92->+-----------------------+  	|  6 words to save     	|	|  6 words to save	| 	|  arguments passed	|	|  arguments passed	| 	|  in registers, even	|	|  in registers, even	|        	|  if not passed.       |      	|  if not passed.	|  SP+68->+-----------------------+FP+68->+-----------------------+         | 1 word struct addr	|      	| 1 word struct addr	|         +-----------------------+FP+64->+-----------------------+         |			|	|			|         | 16 word reg save area	|	| 16 word reg save area |        	|                       |      	|			|     SP->+-----------------------+   FP->+-----------------------+ 				        | 4 word area for	| 				       	| fp/alu reg moves	| 				 FP-16->+-----------------------+ 				        |			| 				        |  local variables	| 				        |			| 				        +-----------------------+ 				        |		        |                                         |  fp register save     | 				        |			| 				        +-----------------------+ 				        |		        |                                         |  gp register save     |                                         |       		| 				        +-----------------------+ 				        |			|                                         |  alloca allocations   |         			        |			| 				        +-----------------------+ 				        |			|                                         |  arguments on stack   |         			       	|		        | 				 SP+92->+-----------------------+                                         |  6 words to save      | 				        |  arguments passed     |                                         |  in registers, even   |    low                                 	|  if not passed.       |    memory        		 SP+68->+-----------------------+ 				       	| 1 word struct addr	| 				 SP+64->+-----------------------+ 				        |			| 				        I 16 word reg save area | 				       	|			| 				    SP->+-----------------------+  */
end_comment

begin_comment
comment|/* Structure to be filled in by sparc_flat_compute_frame_size with register    save masks, and offsets for the current function.  */
end_comment

begin_struct
struct|struct
name|sparc_frame_info
block|{
name|unsigned
name|long
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up.  */
name|unsigned
name|long
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up.  */
name|unsigned
name|long
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up.  */
name|unsigned
name|long
name|extra_size
decl_stmt|;
comment|/* # bytes of extra gunk.  */
name|unsigned
name|int
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs.  */
name|unsigned
name|int
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs.  */
name|unsigned
name|long
name|gmask
decl_stmt|;
comment|/* Mask of saved gp registers.  */
name|unsigned
name|long
name|fmask
decl_stmt|;
comment|/* Mask of saved fp registers.  */
name|unsigned
name|long
name|reg_offset
decl_stmt|;
comment|/* Offset from new sp to store regs.  */
name|int
name|initialized
decl_stmt|;
comment|/* Nonzero if frame size already calculated.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Current frame information calculated by sparc_flat_compute_frame_size.  */
end_comment

begin_decl_stmt
name|struct
name|sparc_frame_info
name|current_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero structure to initialize current_frame_info.  */
end_comment

begin_decl_stmt
name|struct
name|sparc_frame_info
name|zero_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tell prologue and epilogue if register REGNO should be saved / restored.  */
end_comment

begin_define
define|#
directive|define
name|RETURN_ADDR_REGNUM
value|15
end_define

begin_define
define|#
directive|define
name|FRAME_POINTER_MASK
value|(1<< (FRAME_POINTER_REGNUM))
end_define

begin_define
define|#
directive|define
name|RETURN_ADDR_MASK
value|(1<< (RETURN_ADDR_REGNUM))
end_define

begin_define
define|#
directive|define
name|MUST_SAVE_REGISTER
parameter_list|(
name|regno
parameter_list|)
define|\
value|((regs_ever_live[regno]&& !call_used_regs[regno])		\   || (regno == FRAME_POINTER_REGNUM&& frame_pointer_needed)	\   || (regno == RETURN_ADDR_REGNUM&& regs_ever_live[RETURN_ADDR_REGNUM]))
end_define

begin_comment
comment|/* Return the bytes needed to compute the frame pointer from the current    stack pointer.  */
end_comment

begin_function
name|unsigned
name|long
name|sparc_flat_compute_frame_size
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
comment|/* # of var. bytes allocated.  */
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up.  */
name|unsigned
name|long
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up.  */
name|unsigned
name|long
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up.  */
name|unsigned
name|long
name|extra_size
decl_stmt|;
comment|/* # extra bytes.  */
name|unsigned
name|int
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs.  */
name|unsigned
name|int
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs.  */
name|unsigned
name|long
name|gmask
decl_stmt|;
comment|/* Mask of saved gp registers.  */
name|unsigned
name|long
name|fmask
decl_stmt|;
comment|/* Mask of saved fp registers.  */
name|unsigned
name|long
name|reg_offset
decl_stmt|;
comment|/* Offset to register save area.  */
name|int
name|need_aligned_p
decl_stmt|;
comment|/* 1 if need the save area 8 byte aligned.  */
comment|/* This is the size of the 16 word reg save area, 1 word struct addr      area, and 4 word fp/alu register copy area.  */
name|extra_size
operator|=
operator|-
name|STARTING_FRAME_OFFSET
operator|+
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|var_size
operator|=
name|size
expr_stmt|;
comment|/* Also include the size needed for the 6 parameter registers.  */
name|args_size
operator|=
name|current_function_outgoing_args_size
operator|+
literal|24
expr_stmt|;
name|total_size
operator|=
name|var_size
operator|+
name|args_size
operator|+
name|extra_size
expr_stmt|;
name|gp_reg_size
operator|=
literal|0
expr_stmt|;
name|fp_reg_size
operator|=
literal|0
expr_stmt|;
name|gmask
operator|=
literal|0
expr_stmt|;
name|fmask
operator|=
literal|0
expr_stmt|;
name|reg_offset
operator|=
literal|0
expr_stmt|;
name|need_aligned_p
operator|=
literal|0
expr_stmt|;
comment|/* Calculate space needed for gp registers.  */
for|for
control|(
name|regno
operator|=
literal|1
init|;
name|regno
operator|<=
literal|31
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* If we need to save two regs in a row, ensure there's room to bump 	     up the address to align it to a doubleword boundary.  */
if|if
condition|(
operator|(
name|regno
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
operator|+
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|gp_reg_size
operator|%
literal|8
operator|!=
literal|0
condition|)
name|gp_reg_size
operator|+=
literal|4
expr_stmt|;
name|gp_reg_size
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|gmask
operator||=
literal|3
operator|<<
name|regno
expr_stmt|;
name|regno
operator|++
expr_stmt|;
name|need_aligned_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|gmask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
block|}
block|}
comment|/* Calculate space needed for fp registers.  */
for|for
control|(
name|regno
operator|=
literal|32
init|;
name|regno
operator|<=
literal|63
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|fp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|fmask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|-
literal|32
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gmask
operator|||
name|fmask
condition|)
block|{
name|int
name|n
decl_stmt|;
name|reg_offset
operator|=
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
operator|+
name|args_size
expr_stmt|;
comment|/* Ensure save area is 8 byte aligned if we need it.  */
name|n
operator|=
name|reg_offset
operator|%
literal|8
expr_stmt|;
if|if
condition|(
name|need_aligned_p
operator|&&
name|n
operator|!=
literal|0
condition|)
block|{
name|total_size
operator|+=
literal|8
operator|-
name|n
expr_stmt|;
name|reg_offset
operator|+=
literal|8
operator|-
name|n
expr_stmt|;
block|}
name|total_size
operator|+=
name|gp_reg_size
operator|+
name|fp_reg_size
expr_stmt|;
block|}
comment|/* ??? This looks a little suspicious.  Clarify.  */
if|if
condition|(
name|total_size
operator|==
name|extra_size
condition|)
name|total_size
operator|=
name|extra_size
operator|=
literal|0
expr_stmt|;
name|total_size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
comment|/* Save other computed information.  */
name|current_frame_info
operator|.
name|total_size
operator|=
name|total_size
expr_stmt|;
name|current_frame_info
operator|.
name|var_size
operator|=
name|var_size
expr_stmt|;
name|current_frame_info
operator|.
name|args_size
operator|=
name|args_size
expr_stmt|;
name|current_frame_info
operator|.
name|extra_size
operator|=
name|extra_size
expr_stmt|;
name|current_frame_info
operator|.
name|gp_reg_size
operator|=
name|gp_reg_size
expr_stmt|;
name|current_frame_info
operator|.
name|fp_reg_size
operator|=
name|fp_reg_size
expr_stmt|;
name|current_frame_info
operator|.
name|gmask
operator|=
name|gmask
expr_stmt|;
name|current_frame_info
operator|.
name|fmask
operator|=
name|fmask
expr_stmt|;
name|current_frame_info
operator|.
name|reg_offset
operator|=
name|reg_offset
expr_stmt|;
name|current_frame_info
operator|.
name|initialized
operator|=
name|reload_completed
expr_stmt|;
comment|/* Ok, we're done.  */
return|return
name|total_size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save/restore registers in GMASK and FMASK at register BASE_REG plus offset    OFFSET.     BASE_REG must be 8 byte aligned.  This allows us to test OFFSET for    appropriate alignment and use DOUBLEWORD_OP when we can.  We assume    [BASE_REG+OFFSET] will always be a valid address.     WORD_OP is either "st" for save, "ld" for restore.    DOUBLEWORD_OP is either "std" for save, "ldd" for restore.  */
end_comment

begin_function
name|void
name|sparc_flat_save_restore
parameter_list|(
name|file
parameter_list|,
name|base_reg
parameter_list|,
name|offset
parameter_list|,
name|gmask
parameter_list|,
name|fmask
parameter_list|,
name|word_op
parameter_list|,
name|doubleword_op
parameter_list|,
name|base_offset
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|base_reg
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|long
name|gmask
decl_stmt|;
name|unsigned
name|long
name|fmask
decl_stmt|;
name|char
modifier|*
name|word_op
decl_stmt|;
name|char
modifier|*
name|doubleword_op
decl_stmt|;
name|unsigned
name|long
name|base_offset
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|gmask
operator|==
literal|0
operator|&&
name|fmask
operator|==
literal|0
condition|)
return|return;
comment|/* Save registers starting from high to low.  We've already saved the      previous frame pointer and previous return address for the debugger's      sake.  The debugger allows us to not need a nop in the epilog if at least      one register is reloaded in addition to return address.  */
if|if
condition|(
name|gmask
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|1
init|;
name|regno
operator|<=
literal|31
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|gmask
operator|&
operator|(
literal|1L
operator|<<
name|regno
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|regno
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|gmask
operator|&
operator|(
literal|1L
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* We can save two registers in a row.  If we're not at a 		     double word boundary, move to one. 		     sparc_flat_compute_frame_size ensures there's room to do 		     this.  */
if|if
condition|(
name|offset
operator|%
literal|8
operator|!=
literal|0
condition|)
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s %s,[%s+%d]\n"
argument_list|,
name|doubleword_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|regno
argument_list|,
name|offset
operator|+
name|base_offset
argument_list|)
expr_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|offset
operator|+
name|base_offset
operator|+
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s [%s+%d],%s\n"
argument_list|,
name|doubleword_op
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s %s,[%s+%d]\n"
argument_list|,
name|word_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|regno
argument_list|,
name|offset
operator|+
name|base_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s [%s+%d],%s\n"
argument_list|,
name|word_op
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fmask
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|32
init|;
name|regno
operator|<=
literal|63
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
operator|(
name|regno
operator|-
literal|32
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s %s,[%s+%d]\n"
argument_list|,
name|word_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_reg_save
argument_list|(
literal|""
argument_list|,
name|regno
argument_list|,
name|offset
operator|+
name|base_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s [%s+%d],%s\n"
argument_list|,
name|word_op
argument_list|,
name|base_reg
argument_list|,
name|offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the stack and frame (if desired) for the function.  */
end_comment

begin_function
name|void
name|sparc_flat_output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|sp_str
init|=
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
name|unsigned
name|long
name|gmask
init|=
name|current_frame_info
operator|.
name|gmask
decl_stmt|;
comment|/* This is only for the human reader.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#PROLOGUE# 0\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s# vars= %ld, regs= %d/%d, args= %d, extra= %ld\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|current_frame_info
operator|.
name|var_size
argument_list|,
name|current_frame_info
operator|.
name|gp_reg_size
operator|/
literal|4
argument_list|,
name|current_frame_info
operator|.
name|fp_reg_size
operator|/
literal|4
argument_list|,
name|current_function_outgoing_args_size
argument_list|,
name|current_frame_info
operator|.
name|extra_size
argument_list|)
expr_stmt|;
name|size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|?
name|sparc_flat_compute_frame_size
argument_list|(
name|size
argument_list|)
else|:
name|current_frame_info
operator|.
name|total_size
operator|)
expr_stmt|;
comment|/* These cases shouldn't happen.  Catch them now.  */
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
operator|(
name|gmask
operator|||
name|current_frame_info
operator|.
name|fmask
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Allocate our stack frame by decrementing %sp.      At present, the only algorithm gdb can use to determine if this is a      flat frame is if we always set %i7 if we set %sp.  This can be optimized      in the future by putting in some sort of debugging information that says      this is a `flat' function.  However, there is still the case of debugging      code without such debugging information (including cases where most fns      have such info, but there is one that doesn't).  So, always do this now      so we don't get a lot of code out there that gdb can't handle.      If the frame pointer isn't needn't then that's ok - gdb won't be able to      distinguish us from a non-flat function but there won't (and shouldn't)      be any differences anyway.  The return pc is saved (if necessary) right      after %i7 so gdb won't have to look too far to find it.  */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|reg_offset
init|=
name|current_frame_info
operator|.
name|reg_offset
decl_stmt|;
name|char
modifier|*
name|fp_str
init|=
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|char
modifier|*
name|t1_str
init|=
literal|"%g1"
decl_stmt|;
comment|/* Things get a little tricky if local variables take up more than ~4096 	 bytes and outgoing arguments take up more than ~4096 bytes.  When that 	 happens, the register save area can't be accessed from either end of 	 the frame.  Handle this by decrementing %sp to the start of the gp 	 register save area, save the regs, update %i7, and then set %sp to its 	 final value.  Given that we only have one scratch register to play 	 with it is the cheapest solution, and it helps gdb out as it won't 	 slow down recognition of flat functions. 	 Don't change the order of insns emitted here without checking with 	 the gdb folk first.  */
comment|/* Is the entire register save area offsettable from %sp?  */
if|if
condition|(
name|reg_offset
operator|<
literal|4096
operator|-
literal|64
operator|*
name|UNITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|size
operator|<=
literal|4096
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%d,%s\n"
argument_list|,
name|sp_str
argument_list|,
operator|-
name|size
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%d,%s\t%s# set up frame pointer\n"
argument_list|,
name|sp_str
argument_list|,
operator|-
name|size
argument_list|,
name|fp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %d,%s\n\tsub %s,%s,%s\n"
argument_list|,
name|size
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%s\t%s# set up frame pointer\n"
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|fp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
name|reg_offset
operator|-
literal|4
operator|-
name|size
argument_list|)
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gmask
operator|&
name|RETURN_ADDR_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|RETURN_ADDR_REGNUM
index|]
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_return_save
argument_list|(
literal|""
argument_list|,
name|reg_offset
operator|-
name|size
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
name|sparc_flat_save_restore
argument_list|(
name|file
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|,
name|gmask
operator|&
operator|~
operator|(
name|FRAME_POINTER_MASK
operator||
name|RETURN_ADDR_MASK
operator|)
argument_list|,
name|current_frame_info
operator|.
name|fmask
argument_list|,
literal|"st"
argument_list|,
literal|"std"
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Subtract %sp in two steps, but make sure there is always a 	     64 byte register save area, and %sp is properly aligned.  */
comment|/* Amount to decrement %sp by, the first time.  */
name|unsigned
name|int
name|size1
init|=
operator|(
operator|(
name|size
operator|-
name|reg_offset
operator|+
literal|64
operator|)
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
decl_stmt|;
comment|/* Offset to register save area from %sp.  */
name|unsigned
name|int
name|offset
init|=
name|size1
operator|-
operator|(
name|size
operator|-
name|reg_offset
operator|)
decl_stmt|;
if|if
condition|(
name|size1
operator|<=
literal|4096
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%d,%s\n"
argument_list|,
name|sp_str
argument_list|,
operator|-
name|size1
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n\tsub %s,%d,%s\t%s# set up frame pointer\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
name|offset
argument_list|,
name|sp_str
argument_list|,
operator|-
name|size1
argument_list|,
name|fp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %d,%s\n\tsub %s,%s,%s\n"
argument_list|,
name|size1
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n\tadd %s,%s,%s\t%s# set up frame pointer\n"
argument_list|,
name|fp_str
argument_list|,
name|sp_str
argument_list|,
name|offset
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|fp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
if|if
condition|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
name|offset
operator|-
literal|4
operator|-
name|size1
argument_list|)
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|size1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gmask
operator|&
name|RETURN_ADDR_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|RETURN_ADDR_REGNUM
index|]
argument_list|,
name|sp_str
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
comment|/* offset - size1 == reg_offset - size 		   if reg_offset were updated above like offset.  */
name|dwarf2out_return_save
argument_list|(
literal|""
argument_list|,
name|offset
operator|-
name|size1
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
name|sparc_flat_save_restore
argument_list|(
name|file
argument_list|,
name|sp_str
argument_list|,
name|offset
argument_list|,
name|gmask
operator|&
operator|~
operator|(
name|FRAME_POINTER_MASK
operator||
name|RETURN_ADDR_MASK
operator|)
argument_list|,
name|current_frame_info
operator|.
name|fmask
argument_list|,
literal|"st"
argument_list|,
literal|"std"
argument_list|,
operator|-
name|size1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %d,%s\n\tsub %s,%s,%s\n"
argument_list|,
name|size
operator|-
name|size1
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
if|if
condition|(
operator|!
operator|(
name|gmask
operator|&
name|FRAME_POINTER_MASK
operator|)
condition|)
name|dwarf2out_def_cfa
argument_list|(
literal|""
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#PROLOGUE# 1\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any necessary cleanup after a function to restore stack, frame,    and regs. */
end_comment

begin_function
name|void
name|sparc_flat_output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|rtx
name|epilogue_delay
init|=
name|current_function_epilogue_delay_list
decl_stmt|;
name|int
name|noepilogue
init|=
name|FALSE
decl_stmt|;
comment|/* This is only for the human reader.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s#EPILOGUE#\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
comment|/* The epilogue does not depend on any registers, but the stack      registers, so we assume that if we have 1 pending nop, it can be      ignored, and 2 it must be filled (2 nops occur for integer      multiply and divide).  */
name|size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|?
name|sparc_flat_compute_frame_size
argument_list|(
name|size
argument_list|)
else|:
name|current_frame_info
operator|.
name|total_size
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
name|epilogue_delay
operator|==
literal|0
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write any code 	 because a jump (aka return) was put there.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|noepilogue
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noepilogue
condition|)
block|{
name|unsigned
name|int
name|reg_offset
init|=
name|current_frame_info
operator|.
name|reg_offset
decl_stmt|;
name|unsigned
name|int
name|size1
decl_stmt|;
name|char
modifier|*
name|sp_str
init|=
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
name|char
modifier|*
name|fp_str
init|=
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|char
modifier|*
name|t1_str
init|=
literal|"%g1"
decl_stmt|;
comment|/* In the reload sequence, we don't need to fill the load delay 	 slots for most of the loads, also see if we can fill the final 	 delay slot if not otherwise filled by the reload sequence.  */
if|if
condition|(
name|size
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %d,%s\n"
argument_list|,
name|size
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%s,%s\t\t%s# sp not trusted here\n"
argument_list|,
name|fp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%d,%s\t\t%s# sp not trusted here\n"
argument_list|,
name|fp_str
argument_list|,
name|size
argument_list|,
name|sp_str
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
block|}
comment|/* Is the entire register save area offsettable from %sp?  */
if|if
condition|(
name|reg_offset
operator|<
literal|4096
operator|-
literal|64
operator|*
name|UNITS_PER_WORD
condition|)
block|{
name|size1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Restore %sp in two steps, but make sure there is always a 	     64 byte register save area, and %sp is properly aligned.  */
comment|/* Amount to increment %sp by, the first time.  */
name|size1
operator|=
operator|(
operator|(
name|reg_offset
operator|-
literal|64
operator|-
literal|16
operator|)
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
expr_stmt|;
comment|/* Offset to register save area from %sp.  */
name|reg_offset
operator|=
name|size1
operator|-
name|reg_offset
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %d,%s\n\tadd %s,%s,%s\n"
argument_list|,
name|size1
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
block|}
comment|/* We must restore the frame pointer and return address reg first 	 because they are treated specially by the prologue output code.  */
if|if
condition|(
name|current_frame_info
operator|.
name|gmask
operator|&
name|FRAME_POINTER_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld [%s+%d],%s\n"
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|,
name|fp_str
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|gmask
operator|&
name|RETURN_ADDR_MASK
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld [%s+%d],%s\n"
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|,
name|reg_names
index|[
name|RETURN_ADDR_REGNUM
index|]
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Restore any remaining saved registers.  */
name|sparc_flat_save_restore
argument_list|(
name|file
argument_list|,
name|sp_str
argument_list|,
name|reg_offset
argument_list|,
name|current_frame_info
operator|.
name|gmask
operator|&
operator|~
operator|(
name|FRAME_POINTER_MASK
operator||
name|RETURN_ADDR_MASK
operator|)
argument_list|,
name|current_frame_info
operator|.
name|fmask
argument_list|,
literal|"ld"
argument_list|,
literal|"ldd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we had to increment %sp in two steps, record it so the second 	 restoration in the epilogue finishes up.  */
if|if
condition|(
name|size1
operator|>
literal|0
condition|)
block|{
name|size
operator|-=
name|size1
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %d,%s\n"
argument_list|,
name|size
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_returns_struct
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp %%o7+12\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tretl\n"
argument_list|)
expr_stmt|;
comment|/* If the only register saved is the return address, we need a 	 nop, unless we have an instruction to put into it.  Otherwise 	 we don't since reloading multiple registers doesn't reference 	 the register being loaded.  */
if|if
condition|(
name|epilogue_delay
condition|)
block|{
if|if
condition|(
name|size
condition|)
name|abort
argument_list|()
expr_stmt|;
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|epilogue_delay
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%s\n"
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%d,%s\n"
argument_list|,
name|sp_str
argument_list|,
name|size
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Reset state info for each function.  */
name|current_frame_info
operator|=
name|zero_frame_info
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the number of delay slots needed for the function epilogue.     On the sparc, we need a slot if either no stack has been allocated,    or the only register saved is the return register.  */
end_comment

begin_function
name|int
name|sparc_flat_epilogue_delay_slots
parameter_list|()
block|{
if|if
condition|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|)
operator|(
name|void
operator|)
name|sparc_flat_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true is TRIAL is a valid insn for the epilogue delay slot.    Any single length instruction which doesn't reference the stack or frame    pointer is OK.  */
end_comment

begin_function
name|int
name|sparc_flat_eligible_for_epilogue_delay
parameter_list|(
name|trial
parameter_list|,
name|slot
parameter_list|)
name|rtx
name|trial
decl_stmt|;
name|int
name|slot
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* If %g0 is live, there are lots of things we can't handle.      Rather than trying to find them all now, let's punt and only      optimize things as necessary.  */
if|if
condition|(
name|TARGET_LIVE_G0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|pat
argument_list|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
name|int
name|supersparc_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|;
if|if
condition|(
operator|!
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Data dependency; DEP_INSN writes a register that INSN reads some 	 cycles later.  */
comment|/* if a load, then the dependence must be on the memory address; 	 add an extra 'cycle'.  Note that the cost could be two cycles 	 if the reg was written late in an instruction group; we can't tell 	 here.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_LOAD
operator|||
name|insn_type
operator|==
name|TYPE_FPLOAD
condition|)
return|return
name|cost
operator|+
literal|3
return|;
comment|/* Get the delay only if the address of the store is the dependence.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_STORE
operator|||
name|insn_type
operator|==
name|TYPE_FPSTORE
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dep_pat
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|cost
return|;
comment|/* This shouldn't happen!  */
comment|/* The dependency between the two instructions was on the data that 	     is being stored.  Assume that this implies that the address of the 	     store is not dependent.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|cost
return|;
return|return
name|cost
operator|+
literal|3
return|;
comment|/* An approximation.  */
block|}
comment|/* A shift instruction cannot receive its data from an instruction 	 in the same cycle; add a one cycle penalty.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_SHIFT
condition|)
return|return
name|cost
operator|+
literal|3
return|;
comment|/* Split before cascade into shift.  */
block|}
else|else
block|{
comment|/* Anti- or output- dependency; DEP_INSN reads/writes a register that 	 INSN writes some cycles later.  */
comment|/* These are only significant for the fpu unit; writing a fp reg before          the fpu has finished with it stalls the processor.  */
comment|/* Reusing an integer register causes no problems.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IALU
operator|||
name|insn_type
operator|==
name|TYPE_SHIFT
condition|)
return|return
literal|0
return|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_function
name|int
name|ultrasparc_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_type
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dep_pat
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
define|#
directive|define
name|SLOW_FP
parameter_list|(
name|dep_type
parameter_list|)
define|\
value|(dep_type == TYPE_FPSQRT || dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Data dependency; DEP_INSN writes a register that INSN reads some 	 cycles later.  */
switch|switch
condition|(
name|insn_type
condition|)
block|{
comment|/* UltraSPARC can dual issue a store and an instruction setting        	     the value stored, except for divide and square root.  */
case|case
name|TYPE_FPSTORE
case|:
if|if
condition|(
operator|!
name|SLOW_FP
argument_list|(
name|dep_type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|cost
return|;
case|case
name|TYPE_STORE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|cost
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
comment|/* The dependency between the two instructions is on the data 	     that is being stored.  Assume that the address of the store 	     is not also dependent.  */
return|return
literal|0
return|;
return|return
name|cost
return|;
case|case
name|TYPE_LOAD
case|:
case|case
name|TYPE_SLOAD
case|:
case|case
name|TYPE_FPLOAD
case|:
comment|/* A load does not return data until at least 11 cycles after          	     a store to the same location.  3 cycles are accounted for 	     in the load latency; add the other 8 here.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_STORE
operator|||
name|dep_type
operator|==
name|TYPE_FPSTORE
condition|)
block|{
comment|/* If the addresses are not equal this may be a false 		 dependency because pointer aliasing could not be 		 determined.  Add only 2 cycles in that case.  2 is 		 an arbitrary compromise between 8, which would cause 		 the scheduler to generate worse code elsewhere to 		 compensate for a dependency which might not really     		 exist, and 0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
return|return
name|cost
operator|+
literal|8
return|;
block|}
return|return
name|cost
return|;
case|case
name|TYPE_BRANCH
case|:
comment|/* Compare to branch latency is 0.  There is no benefit from 	     separating compare and branch.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_COMPARE
condition|)
return|return
literal|0
return|;
comment|/* Floating point compare to branch latency is less than  	     compare to conditional move.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_FPCMP
condition|)
return|return
name|cost
operator|-
literal|1
return|;
return|return
name|cost
return|;
case|case
name|TYPE_FPCMOVE
case|:
comment|/* FMOVR class instructions can not issue in the same cycle 	     or the cycle after an instruction which writes any 	     integer register.  Model this as cost 2 for dependent 	     instructions.  */
if|if
condition|(
operator|(
name|dep_type
operator|==
name|TYPE_IALU
operator|||
name|dep_type
operator|==
name|TYPE_UNARY
operator|||
name|dep_type
operator|==
name|TYPE_BINARY
operator|)
operator|&&
name|cost
operator|<
literal|2
condition|)
return|return
literal|2
return|;
comment|/* Otherwise check as for integer conditional moves. */
case|case
name|TYPE_CMOVE
case|:
comment|/* Conditional moves involving integer registers wait until 	     3 cycles after loads return data.  The interlock applies 	     to all loads, not just dependent loads, but that is hard 	     to model.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_LOAD
operator|||
name|dep_type
operator|==
name|TYPE_SLOAD
condition|)
return|return
name|cost
operator|+
literal|3
return|;
return|return
name|cost
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|REG_DEP_ANTI
case|:
comment|/* Divide and square root lock destination registers for full latency. */
if|if
condition|(
operator|!
name|SLOW_FP
argument_list|(
name|dep_type
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
comment|/* Other costs not accounted for:                                  - Multiply should be modeled as having no latency because there is        nothing the scheduler can do about it.        - Single precision floating point loads lock the other half of          the even/odd register pair.                                         - Several hazards associated with ldd/std are ignored because these        instructions are rarely generated for V9.        - A shift following an integer instruction which does not set the        condition codes can not issue in the same cycle.      - The floating point pipeline can not have both a single and double        precision operation active at the same time.  Format conversions        and graphics instructions are given honorary double precision status.      - call and jmpl are always the first instruction in a group.  */
return|return
name|cost
return|;
block|}
end_function

begin_function
name|int
name|sparc_issue_rate
parameter_list|()
block|{
switch|switch
condition|(
name|sparc_cpu
condition|)
block|{
default|default:
return|return
literal|1
return|;
case|case
name|PROCESSOR_V9
case|:
comment|/* Assume V9 processors are capable of at least dual-issue.  */
return|return
literal|2
return|;
case|case
name|PROCESSOR_SUPERSPARC
case|:
return|return
literal|3
return|;
case|case
name|PROCESSOR_ULTRASPARC
case|:
return|return
literal|4
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|set_extends
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Load and some shift instructions zero extend. */
case|case
name|MEM
case|:
case|case
name|ZERO_EXTEND
case|:
comment|/* sethi clears the high bits */
case|case
name|HIGH
case|:
comment|/* LO_SUM is used with sethi.  sethi cleared the high 	 bits and the values used with lo_sum are positive */
case|case
name|LO_SUM
case|:
comment|/* UNSPEC is v8plus_clear_high */
case|case
name|UNSPEC
case|:
comment|/* Store flag stores 0 or 1 */
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
literal|1
return|;
case|case
name|AND
case|:
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|sparc_check_64
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|sparc_check_64
argument_list|(
operator|(
name|op1
operator|)
argument_list|,
name|insn
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
block|}
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
return|return
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SImode
return|;
comment|/* Positive integers leave the high bits zero. */
case|case
name|CONST_DOUBLE
case|:
return|return
operator|!
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0x80000000
operator|)
return|;
case|case
name|CONST_INT
case|:
return|return
operator|!
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x80000000
operator|)
return|;
case|case
name|ASHIFTRT
case|:
case|case
name|SIGN_EXTEND
case|:
return|return
operator|-
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SImode
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 0 if the high 32 bits of X (the low word of X, if DImode) are    unknown.  Return 1 if the high bits are zero, -1 if the register is    sign extended.  */
end_comment

begin_function
name|int
name|sparc_check_64
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
comment|/* If a register is set only once it is safe to ignore insns this      code does not know how to handle.  The loop will either recognize      the single set and return the correct value or fail to recognize      it and return 0.  */
name|int
name|set_once
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|flag_expensive_optimizations
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|set_once
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|set_once
condition|)
name|insn
operator|=
name|get_last_insn_anywhere
argument_list|()
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|JUMP_INSN
case|:
case|case
name|NOTE
case|:
break|break;
case|case
name|CODE_LABEL
case|:
case|case
name|CALL_INSN
case|:
default|default:
if|if
condition|(
operator|!
name|set_once
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|INSN
case|:
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|set_extends
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
return|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sparc_v8plus_shift
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|,
name|opcode
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|;
block|{
specifier|static
name|char
name|asm_code
index|[
literal|60
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|SCRATCH
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"mov %1,%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"sllx %H1,32,%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_check_64
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|insn
argument_list|)
operator|<=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"srl %L1,0,%L1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"or %L1,%3,%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|asm_code
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_alternative
operator|!=
literal|2
condition|)
return|return
name|strcat
argument_list|(
name|asm_code
argument_list|,
literal|" %0,%2,%L0\n\tsrlx %L0,32,%H0"
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|asm_code
argument_list|,
literal|" %3,%2,%3\n\tsrlx %3,32,%H0\n\tmov %3,%L0"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if DEST and SRC reference only global and in registers. */
end_comment

begin_function
name|int
name|sparc_return_peephole_ok
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_V9
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|leaf_function
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|IN_OR_GLOBAL_P
argument_list|(
name|src
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|IN_OR_GLOBAL_P
argument_list|(
name|dest
argument_list|)
return|;
block|}
end_function

end_unit

