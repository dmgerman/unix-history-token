begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for SPARC.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)    64-bit SPARC-V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,    at Cygnus Support.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Processor costs */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|cypress_costs
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int load */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int signed load */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int zeroed load */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* float load */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fmov, fneg, fabs */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fadd, fsub */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fcmp */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmov, fmovr */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* fmul */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* fdivs */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* fdivd */
name|COSTS_N_INSNS
argument_list|(
literal|63
argument_list|)
block|,
comment|/* fsqrts */
name|COSTS_N_INSNS
argument_list|(
literal|63
argument_list|)
block|,
comment|/* fsqrtd */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* imul */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* imulX */
literal|0
block|,
comment|/* imul bit factor */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* idiv */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* idivX */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* movcc/movr */
literal|0
block|,
comment|/* shift penalty */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|supersparc_costs
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int signed load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int zeroed load */
name|COSTS_N_INSNS
argument_list|(
literal|0
argument_list|)
block|,
comment|/* float load */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fmov, fneg, fabs */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fadd, fsub */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fcmp */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmov, fmovr */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fmul */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fdivs */
name|COSTS_N_INSNS
argument_list|(
literal|9
argument_list|)
block|,
comment|/* fdivd */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* fsqrts */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* fsqrtd */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* imul */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* imulX */
literal|0
block|,
comment|/* imul bit factor */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* idiv */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* idivX */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* movcc/movr */
literal|1
block|,
comment|/* shift penalty */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|hypersparc_costs
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int signed load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int zeroed load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* float load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmov, fneg, fabs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fadd, fsub */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fcmp */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmov, fmovr */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmul */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fdivs */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* fdivd */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* fsqrts */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* fsqrtd */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* imul */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* imulX */
literal|0
block|,
comment|/* imul bit factor */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* idiv */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* idivX */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* movcc/movr */
literal|0
block|,
comment|/* shift penalty */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|sparclet_costs
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int load */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int signed load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* int zeroed load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* float load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmov, fneg, fabs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fadd, fsub */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fcmp */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmov, fmovr */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmul */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fdivs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fdivd */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fsqrts */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fsqrtd */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* imul */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* imulX */
literal|0
block|,
comment|/* imul bit factor */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* idiv */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* idivX */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* movcc/movr */
literal|0
block|,
comment|/* shift penalty */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ultrasparc_costs
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int load */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int signed load */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int zeroed load */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* float load */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fmov, fneg, fabs */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fadd, fsub */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* fcmp */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* fmov, fmovr */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fmul */
name|COSTS_N_INSNS
argument_list|(
literal|13
argument_list|)
block|,
comment|/* fdivs */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* fdivd */
name|COSTS_N_INSNS
argument_list|(
literal|13
argument_list|)
block|,
comment|/* fsqrts */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* fsqrtd */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* imul */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* imulX */
literal|2
block|,
comment|/* imul bit factor */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* idiv */
name|COSTS_N_INSNS
argument_list|(
literal|68
argument_list|)
block|,
comment|/* idivX */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* movcc/movr */
literal|2
block|,
comment|/* shift penalty */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|ultrasparc3_costs
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int load */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int signed load */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int zeroed load */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* float load */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fmov, fneg, fabs */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fadd, fsub */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fcmp */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fmov, fmovr */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fmul */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* fdivs */
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* fdivd */
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* fsqrts */
name|COSTS_N_INSNS
argument_list|(
literal|29
argument_list|)
block|,
comment|/* fsqrtd */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* imul */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* imulX */
literal|0
block|,
comment|/* imul bit factor */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/* idiv */
name|COSTS_N_INSNS
argument_list|(
literal|71
argument_list|)
block|,
comment|/* idivX */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* movcc/movr */
literal|0
block|,
comment|/* shift penalty */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|niagara_costs
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int load */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int signed load */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int zeroed load */
name|COSTS_N_INSNS
argument_list|(
literal|9
argument_list|)
block|,
comment|/* float load */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fmov, fneg, fabs */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fadd, fsub */
name|COSTS_N_INSNS
argument_list|(
literal|26
argument_list|)
block|,
comment|/* fcmp */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fmov, fmovr */
name|COSTS_N_INSNS
argument_list|(
literal|29
argument_list|)
block|,
comment|/* fmul */
name|COSTS_N_INSNS
argument_list|(
literal|54
argument_list|)
block|,
comment|/* fdivs */
name|COSTS_N_INSNS
argument_list|(
literal|83
argument_list|)
block|,
comment|/* fdivd */
name|COSTS_N_INSNS
argument_list|(
literal|100
argument_list|)
block|,
comment|/* fsqrts - not implemented in hardware */
name|COSTS_N_INSNS
argument_list|(
literal|100
argument_list|)
block|,
comment|/* fsqrtd - not implemented in hardware */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* imul */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* imulX */
literal|0
block|,
comment|/* imul bit factor */
name|COSTS_N_INSNS
argument_list|(
literal|72
argument_list|)
block|,
comment|/* idiv */
name|COSTS_N_INSNS
argument_list|(
literal|72
argument_list|)
block|,
comment|/* idivX */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* movcc/movr */
literal|0
block|,
comment|/* shift penalty */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|processor_costs
modifier|*
name|sparc_costs
init|=
operator|&
name|cypress_costs
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_RELAX_OPTION
end_ifdef

begin_comment
comment|/* If 'as' and 'ld' are relaxing tail call insns into branch always, use    "or %o7,%g0,X; call Y; or X,%g0,%o7" always, so that it can be optimized.    With sethi/jmp, neither 'as' nor 'ld' has an easy way how to find out if    somebody does not branch between the sethi and jmp.  */
end_comment

begin_define
define|#
directive|define
name|LEAF_SIBCALL_SLOT_RESERVED_P
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LEAF_SIBCALL_SLOT_RESERVED_P
define|\
value|((TARGET_ARCH64&& !TARGET_CM_MEDLOW) || flag_pic)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Global variables for machine-dependent things.  */
end_comment

begin_comment
comment|/* Size of frame.  Need to know this to emit return insns from leaf procedures.    ACTUAL_FSIZE is set by sparc_compute_frame_size() which is called during the    reload pass.  This is important as the value is later used for scheduling    (to see what can go in a delay slot).    APPARENT_FSIZE is the size of the stack less the register save area and less    the outgoing argument area.  It is used when saving call preserved regs.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|apparent_fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|actual_fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of live general or floating point registers needed to be    saved (as 4-byte quantities).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_gfregs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The alias set for prologue/epilogue register save/restore.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|sparc_sr_alias_set
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The alias set for the structure return value.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|struct_value_alias_set
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Save the operands last given to a compare for use when we    generate a scc or bcc insn.  */
end_comment

begin_decl_stmt
name|rtx
name|sparc_compare_op0
decl_stmt|,
name|sparc_compare_op1
decl_stmt|,
name|sparc_compare_emitted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector to say how input registers are mapped to output registers.    HARD_FRAME_POINTER_REGNUM cannot be remapped by this function to    eliminate it.  You must use -fomit-frame-pointer to get that.  */
end_comment

begin_decl_stmt
name|char
name|leaf_reg_remap
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|14
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|15
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector, indexed by hard register number, which contains 1    for a register that is allowable in a candidate for leaf    function treatment.  */
end_comment

begin_decl_stmt
name|char
name|sparc_leaf_regs
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|machine_function
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Some local-dynamic TLS symbol name.  */
specifier|const
name|char
modifier|*
name|some_ld_name
decl_stmt|;
comment|/* True if the current function is leaf and uses only leaf regs,      so that the SPARC leaf function optimization can be applied.      Private version of current_function_uses_only_leaf_regs, see      sparc_expand_prologue for the rationale.  */
name|int
name|leaf_function_p
decl_stmt|;
comment|/* True if the data calculated by sparc_expand_prologue are valid.  */
name|bool
name|prologue_data_valid_p
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|sparc_leaf_function_p
value|cfun->machine->leaf_function_p
end_define

begin_define
define|#
directive|define
name|sparc_prologue_data_valid_p
value|cfun->machine->prologue_data_valid_p
end_define

begin_comment
comment|/* Register we pretend to think the frame pointer is allocated to.    Normally, this is %fp, but if we are in a leaf procedure, this    is %sp+"something".  We record "something" separately as it may    be too big for reg+constant addressing.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|frame_base_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|frame_base_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if the next opcode is to be specially indented.  */
end_comment

begin_decl_stmt
name|int
name|sparc_indent_opcode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|sparc_handle_option
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_init_modes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_record_type
parameter_list|(
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|function_arg_slotno
parameter_list|(
specifier|const
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|supersparc_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hypersparc_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_output_addr_vec
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_output_addr_diff_vec
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_output_deferred_case_vectors
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|sparc_builtin_saveregs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|epilogue_renumber
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_assemble_integer
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_extends
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_pic_helper
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_pic_register
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|save_or_restore_regs
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_save_or_restore_regs
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_asm_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_asm_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_function_decl
specifier|static
name|void
name|sparc_elf_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|sparc_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparc_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_sched_init
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparc_use_sched_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_soft_tfmode_libcall
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_soft_tfmode_binop
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_soft_tfmode_unop
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_soft_tfmode_cvt
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_hard_tfmode_operation
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_init_libfuncs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_vis_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|sparc_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|sparc_fold_builtin
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparc_vis_mul8x16
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|sparc_handle_vis_mul8x16
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_can_output_mi_thunk
parameter_list|(
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|sparc_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_cannot_force_const_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|sparc_tls_get_addr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|sparc_tls_got
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_promote_prototypes
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|sparc_struct_value_rtx
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_return_in_memory
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_strict_argument_naming
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|sparc_gimplify_va_arg
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|sparc_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparc_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_dwarf_handle_frame_unspec
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|sparc_output_dwarf_dtprel
argument_list|(
name|FILE
operator|*
argument_list|,
name|int
argument_list|,
name|rtx
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sparc_file_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_ALTERNATE_LONG_DOUBLE_MANGLING
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|sparc_mangle_fundamental_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUBTARGET_ATTRIBUTE_TABLE
end_ifdef

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|sparc_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Option handling.  */
end_comment

begin_comment
comment|/* Parsed value.  */
end_comment

begin_decl_stmt
name|enum
name|cmodel
name|sparc_cmodel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|sparc_hard_reg_printed
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sparc_cpu_select
name|sparc_select
index|[]
init|=
block|{
comment|/* switch	name,		tune	arch */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"default"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mcpu="
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|"-mtune="
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU type.  This is set from TARGET_CPU_DEFAULT and -m{cpu,tune}=xxx.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|sparc_cpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether
comment|an FPU option was specified.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|fpu_option_set
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_comment
comment|/* The sparc default is to use .half rather than .short for aligned    HI objects.  Use .word instead of .long on non-ELF systems.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.half\t"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
end_ifndef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\t.word\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\t.uahalf\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\t.uaword\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\t.uaxword\t"
end_define

begin_comment
comment|/* The target hook has to handle DI-mode values.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|sparc_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|sparc_asm_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|sparc_asm_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|sparc_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|sparc_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT
value|sparc_sched_init
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
value|sparc_use_sched_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|sparc_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_LIBFUNCS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_LIBFUNCS
value|sparc_init_libfuncs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|sparc_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|sparc_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FOLD_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_FOLD_BUILTIN
value|sparc_fold_builtin
end_define

begin_if
if|#
directive|if
name|TARGET_TLS
end_if

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|sparc_cannot_force_const_mem
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|sparc_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|sparc_can_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|sparc_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|hook_int_rtx_0
end_define

begin_comment
comment|/* This is only needed for TARGET_ARCH64, but since PROMOTE_FUNCTION_MODE is a    no-op for TARGET_ARCH32 this is ok.  Otherwise we'd need to add a runtime    test for this value.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_ARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_ARGS
value|hook_bool_tree_true
end_define

begin_comment
comment|/* This is only needed for TARGET_ARCH64, but since PROMOTE_FUNCTION_MODE is a    no-op for TARGET_ARCH32 this is ok.  Otherwise we'd need to add a runtime    test for this value.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_RETURN
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_RETURN
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_PROTOTYPES
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_PROTOTYPES
value|sparc_promote_prototypes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRUCT_VALUE_RTX
end_undef

begin_define
define|#
directive|define
name|TARGET_STRUCT_VALUE_RTX
value|sparc_struct_value_rtx
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MEMORY
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MEMORY
value|sparc_return_in_memory
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MUST_PASS_IN_STACK
end_undef

begin_define
define|#
directive|define
name|TARGET_MUST_PASS_IN_STACK
value|must_pass_in_stack_var_size
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PASS_BY_REFERENCE
end_undef

begin_define
define|#
directive|define
name|TARGET_PASS_BY_REFERENCE
value|sparc_pass_by_reference
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ARG_PARTIAL_BYTES
end_undef

begin_define
define|#
directive|define
name|TARGET_ARG_PARTIAL_BYTES
value|sparc_arg_partial_bytes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN_SAVEREGS
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN_SAVEREGS
value|sparc_builtin_saveregs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRICT_ARGUMENT_NAMING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRICT_ARGUMENT_NAMING
value|sparc_strict_argument_naming
end_define

begin_undef
undef|#
directive|undef
name|TARGET_GIMPLIFY_VA_ARG_EXPR
end_undef

begin_define
define|#
directive|define
name|TARGET_GIMPLIFY_VA_ARG_EXPR
value|sparc_gimplify_va_arg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_MODE_SUPPORTED_P
value|sparc_vector_mode_supported_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DWARF_HANDLE_FRAME_UNSPEC
end_undef

begin_define
define|#
directive|define
name|TARGET_DWARF_HANDLE_FRAME_UNSPEC
value|sparc_dwarf_handle_frame_unspec
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SUBTARGET_INSERT_ATTRIBUTES
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_INSERT_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_INSERT_ATTRIBUTES
value|SUBTARGET_INSERT_ATTRIBUTES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUBTARGET_ATTRIBUTE_TABLE
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|sparc_attribute_table
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_RELAXED_ORDERING
end_undef

begin_define
define|#
directive|define
name|TARGET_RELAXED_ORDERING
value|SPARC_RELAXED_ORDERING
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DEFAULT_TARGET_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_DEFAULT_TARGET_FLAGS
value|TARGET_DEFAULT
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HANDLE_OPTION
end_undef

begin_define
define|#
directive|define
name|TARGET_HANDLE_OPTION
value|sparc_handle_option
end_define

begin_if
if|#
directive|if
name|TARGET_GNU_TLS
end_if

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
value|sparc_output_dwarf_dtprel
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_END
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_END
value|sparc_file_end
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_ALTERNATE_LONG_DOUBLE_MANGLING
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
end_undef

begin_define
define|#
directive|define
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
value|sparc_mangle_fundamental_type
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implement TARGET_HANDLE_OPTION.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_handle_option
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPT_mfpu
case|:
case|case
name|OPT_mhard_float
case|:
case|case
name|OPT_msoft_float
case|:
name|fpu_option_set
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_mcpu_
case|:
name|sparc_select
index|[
literal|1
index|]
operator|.
name|string
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_mtune_
case|:
name|sparc_select
index|[
literal|2
index|]
operator|.
name|string
operator|=
name|arg
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Validate and override various options, and do some machine dependent    initialization.  */
end_comment

begin_function
name|void
name|sparc_override_options
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
struct|struct
name|code_model
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|value
decl_stmt|;
block|}
decl|const
name|cmodels
index|[]
init|=
block|{
block|{
literal|"32"
block|,
name|CM_32
block|}
block|,
block|{
literal|"medlow"
block|,
name|CM_MEDLOW
block|}
block|,
block|{
literal|"medmid"
block|,
name|CM_MEDMID
block|}
block|,
block|{
literal|"medany"
block|,
name|CM_MEDANY
block|}
block|,
block|{
literal|"embmedany"
block|,
name|CM_EMBMEDANY
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|code_model
modifier|*
name|cmodel
decl_stmt|;
comment|/* Map TARGET_CPU_DEFAULT to value for -m{arch,tune}=.  */
specifier|static
struct|struct
name|cpu_default
block|{
specifier|const
name|int
name|cpu
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|}
decl|const
name|cpu_default
index|[]
init|=
block|{
comment|/* There must be one entry here for each TARGET_CPU value.  */
block|{
name|TARGET_CPU_sparc
block|,
literal|"cypress"
block|}
block|,
block|{
name|TARGET_CPU_sparclet
block|,
literal|"tsc701"
block|}
block|,
block|{
name|TARGET_CPU_sparclite
block|,
literal|"f930"
block|}
block|,
block|{
name|TARGET_CPU_v8
block|,
literal|"v8"
block|}
block|,
block|{
name|TARGET_CPU_hypersparc
block|,
literal|"hypersparc"
block|}
block|,
block|{
name|TARGET_CPU_sparclite86x
block|,
literal|"sparclite86x"
block|}
block|,
block|{
name|TARGET_CPU_supersparc
block|,
literal|"supersparc"
block|}
block|,
block|{
name|TARGET_CPU_v9
block|,
literal|"v9"
block|}
block|,
block|{
name|TARGET_CPU_ultrasparc
block|,
literal|"ultrasparc"
block|}
block|,
block|{
name|TARGET_CPU_ultrasparc3
block|,
literal|"ultrasparc3"
block|}
block|,
block|{
name|TARGET_CPU_niagara
block|,
literal|"niagara"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|cpu_default
modifier|*
name|def
decl_stmt|;
comment|/* Table of values for -m{cpu,tune}=.  */
specifier|static
struct|struct
name|cpu_table
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
name|int
name|disable
decl_stmt|;
specifier|const
name|int
name|enable
decl_stmt|;
block|}
decl|const
name|cpu_table
index|[]
init|=
block|{
block|{
literal|"v7"
block|,
name|PROCESSOR_V7
block|,
name|MASK_ISA
block|,
literal|0
block|}
block|,
block|{
literal|"cypress"
block|,
name|PROCESSOR_CYPRESS
block|,
name|MASK_ISA
block|,
literal|0
block|}
block|,
block|{
literal|"v8"
block|,
name|PROCESSOR_V8
block|,
name|MASK_ISA
block|,
name|MASK_V8
block|}
block|,
comment|/* TI TMS390Z55 supersparc */
block|{
literal|"supersparc"
block|,
name|PROCESSOR_SUPERSPARC
block|,
name|MASK_ISA
block|,
name|MASK_V8
block|}
block|,
block|{
literal|"sparclite"
block|,
name|PROCESSOR_SPARCLITE
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLITE
block|}
block|,
comment|/* The Fujitsu MB86930 is the original sparclite chip, with no fpu.        The Fujitsu MB86934 is the recent sparclite chip, with an fpu.  */
block|{
literal|"f930"
block|,
name|PROCESSOR_F930
block|,
name|MASK_ISA
operator||
name|MASK_FPU
block|,
name|MASK_SPARCLITE
block|}
block|,
block|{
literal|"f934"
block|,
name|PROCESSOR_F934
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLITE
operator||
name|MASK_FPU
block|}
block|,
block|{
literal|"hypersparc"
block|,
name|PROCESSOR_HYPERSPARC
block|,
name|MASK_ISA
block|,
name|MASK_V8
operator||
name|MASK_FPU
block|}
block|,
block|{
literal|"sparclite86x"
block|,
name|PROCESSOR_SPARCLITE86X
block|,
name|MASK_ISA
operator||
name|MASK_FPU
block|,
name|MASK_SPARCLITE
block|}
block|,
block|{
literal|"sparclet"
block|,
name|PROCESSOR_SPARCLET
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLET
block|}
block|,
comment|/* TEMIC sparclet */
block|{
literal|"tsc701"
block|,
name|PROCESSOR_TSC701
block|,
name|MASK_ISA
block|,
name|MASK_SPARCLET
block|}
block|,
block|{
literal|"v9"
block|,
name|PROCESSOR_V9
block|,
name|MASK_ISA
block|,
name|MASK_V9
block|}
block|,
comment|/* TI ultrasparc I, II, IIi */
block|{
literal|"ultrasparc"
block|,
name|PROCESSOR_ULTRASPARC
block|,
name|MASK_ISA
block|,
name|MASK_V9
comment|/* Although insns using %y are deprecated, it is a clear win on current        ultrasparcs.  */
operator||
name|MASK_DEPRECATED_V8_INSNS
block|}
block|,
comment|/* TI ultrasparc III */
comment|/* ??? Check if %y issue still holds true in ultra3.  */
block|{
literal|"ultrasparc3"
block|,
name|PROCESSOR_ULTRASPARC3
block|,
name|MASK_ISA
block|,
name|MASK_V9
operator||
name|MASK_DEPRECATED_V8_INSNS
block|}
block|,
comment|/* UltraSPARC T1 */
block|{
literal|"niagara"
block|,
name|PROCESSOR_NIAGARA
block|,
name|MASK_ISA
block|,
name|MASK_V9
operator||
name|MASK_DEPRECATED_V8_INSNS
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|cpu_table
modifier|*
name|cpu
decl_stmt|;
specifier|const
name|struct
name|sparc_cpu_select
modifier|*
name|sel
decl_stmt|;
name|int
name|fpu
decl_stmt|;
ifndef|#
directive|ifndef
name|SPARC_BI_ARCH
comment|/* Check for unsupported architecture size.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|!=
name|DEFAULT_ARCH32_P
condition|)
name|error
argument_list|(
literal|"%s is not supported by this configuration"
argument_list|,
name|DEFAULT_ARCH32_P
condition|?
literal|"-m64"
else|:
literal|"-m32"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We force all 64bit archs to use 128 bit long double */
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|TARGET_LONG_DOUBLE_128
condition|)
block|{
name|error
argument_list|(
literal|"-mlong-double-64 not allowed with -m64"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|MASK_LONG_DOUBLE_128
expr_stmt|;
block|}
comment|/* Code model selection.  */
name|sparc_cmodel
operator|=
name|SPARC_DEFAULT_CMODEL
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARC_BI_ARCH
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|sparc_cmodel
operator|=
name|CM_32
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sparc_cmodel_string
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
for|for
control|(
name|cmodel
operator|=
operator|&
name|cmodels
index|[
literal|0
index|]
init|;
name|cmodel
operator|->
name|name
condition|;
name|cmodel
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sparc_cmodel_string
argument_list|,
name|cmodel
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cmodel
operator|->
name|name
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -mcmodel= switch"
argument_list|,
name|sparc_cmodel_string
argument_list|)
expr_stmt|;
else|else
name|sparc_cmodel
operator|=
name|cmodel
operator|->
name|value
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"-mcmodel= is not supported on 32 bit systems"
argument_list|)
expr_stmt|;
block|}
name|fpu
operator|=
name|target_flags
operator|&
name|MASK_FPU
expr_stmt|;
comment|/* save current -mfpu status */
comment|/* Set the default CPU.  */
for|for
control|(
name|def
operator|=
operator|&
name|cpu_default
index|[
literal|0
index|]
init|;
name|def
operator|->
name|name
condition|;
operator|++
name|def
control|)
if|if
condition|(
name|def
operator|->
name|cpu
operator|==
name|TARGET_CPU_DEFAULT
condition|)
break|break;
name|gcc_assert
argument_list|(
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
name|sparc_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|def
operator|->
name|name
expr_stmt|;
for|for
control|(
name|sel
operator|=
operator|&
name|sparc_select
index|[
literal|0
index|]
init|;
name|sel
operator|->
name|name
condition|;
operator|++
name|sel
control|)
block|{
if|if
condition|(
name|sel
operator|->
name|string
condition|)
block|{
for|for
control|(
name|cpu
operator|=
operator|&
name|cpu_table
index|[
literal|0
index|]
init|;
name|cpu
operator|->
name|name
condition|;
operator|++
name|cpu
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sel
operator|->
name|string
argument_list|,
name|cpu
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|sel
operator|->
name|set_tune_p
condition|)
name|sparc_cpu
operator|=
name|cpu
operator|->
name|processor
expr_stmt|;
if|if
condition|(
name|sel
operator|->
name|set_arch_p
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|cpu
operator|->
name|disable
expr_stmt|;
name|target_flags
operator||=
name|cpu
operator|->
name|enable
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|cpu
operator|->
name|name
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|sel
operator|->
name|string
argument_list|,
name|sel
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -mfpu or -mno-fpu was explicitly used, don't override with      the processor default.  */
if|if
condition|(
name|fpu_option_set
condition|)
name|target_flags
operator|=
operator|(
name|target_flags
operator|&
operator|~
name|MASK_FPU
operator|)
operator||
name|fpu
expr_stmt|;
comment|/* Don't allow -mvis if FPU is disabled.  */
if|if
condition|(
operator|!
name|TARGET_FPU
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_VIS
expr_stmt|;
comment|/* -mvis assumes UltraSPARC+, so we are sure v9 instructions      are available.      -m64 also implies v9.  */
if|if
condition|(
name|TARGET_VIS
operator|||
name|TARGET_ARCH64
condition|)
block|{
name|target_flags
operator||=
name|MASK_V9
expr_stmt|;
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_V8
operator||
name|MASK_SPARCLET
operator||
name|MASK_SPARCLITE
operator|)
expr_stmt|;
block|}
comment|/* Use the deprecated v8 insns for sparc64 in 32 bit mode.  */
if|if
condition|(
name|TARGET_V9
operator|&&
name|TARGET_ARCH32
condition|)
name|target_flags
operator||=
name|MASK_DEPRECATED_V8_INSNS
expr_stmt|;
comment|/* V8PLUS requires V9, makes no sense in 64 bit mode.  */
if|if
condition|(
operator|!
name|TARGET_V9
operator|||
name|TARGET_ARCH64
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_V8PLUS
expr_stmt|;
comment|/* Don't use stack biasing in 32 bit mode.  */
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_STACK_BIAS
expr_stmt|;
comment|/* Supply a default value for align_functions.  */
if|if
condition|(
name|align_functions
operator|==
literal|0
operator|&&
operator|(
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC
operator|||
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC3
operator|||
name|sparc_cpu
operator|==
name|PROCESSOR_NIAGARA
operator|)
condition|)
name|align_functions
operator|=
literal|32
expr_stmt|;
comment|/* Validate PCC_STRUCT_RETURN.  */
if|if
condition|(
name|flag_pcc_struct_return
operator|==
name|DEFAULT_PCC_STRUCT_RETURN
condition|)
name|flag_pcc_struct_return
operator|=
operator|(
name|TARGET_ARCH64
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* Only use .uaxword when compiling for a 64-bit target.  */
if|if
condition|(
operator|!
name|TARGET_ARCH64
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|unaligned_op
operator|.
name|di
operator|=
name|NULL
expr_stmt|;
comment|/* Do various machine dependent initializations.  */
name|sparc_init_modes
argument_list|()
expr_stmt|;
comment|/* Acquire unique alias sets for our private stuff.  */
name|sparc_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
name|struct_value_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
comment|/* Set up function hooks.  */
name|init_machine_status
operator|=
name|sparc_init_machine_status
expr_stmt|;
switch|switch
condition|(
name|sparc_cpu
condition|)
block|{
case|case
name|PROCESSOR_V7
case|:
case|case
name|PROCESSOR_CYPRESS
case|:
name|sparc_costs
operator|=
operator|&
name|cypress_costs
expr_stmt|;
break|break;
case|case
name|PROCESSOR_V8
case|:
case|case
name|PROCESSOR_SPARCLITE
case|:
case|case
name|PROCESSOR_SUPERSPARC
case|:
name|sparc_costs
operator|=
operator|&
name|supersparc_costs
expr_stmt|;
break|break;
case|case
name|PROCESSOR_F930
case|:
case|case
name|PROCESSOR_F934
case|:
case|case
name|PROCESSOR_HYPERSPARC
case|:
case|case
name|PROCESSOR_SPARCLITE86X
case|:
name|sparc_costs
operator|=
operator|&
name|hypersparc_costs
expr_stmt|;
break|break;
case|case
name|PROCESSOR_SPARCLET
case|:
case|case
name|PROCESSOR_TSC701
case|:
name|sparc_costs
operator|=
operator|&
name|sparclet_costs
expr_stmt|;
break|break;
case|case
name|PROCESSOR_V9
case|:
case|case
name|PROCESSOR_ULTRASPARC
case|:
name|sparc_costs
operator|=
operator|&
name|ultrasparc_costs
expr_stmt|;
break|break;
case|case
name|PROCESSOR_ULTRASPARC3
case|:
name|sparc_costs
operator|=
operator|&
name|ultrasparc3_costs
expr_stmt|;
break|break;
case|case
name|PROCESSOR_NIAGARA
case|:
name|sparc_costs
operator|=
operator|&
name|niagara_costs
expr_stmt|;
break|break;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|TARGET_DEFAULT_LONG_DOUBLE_128
if|if
condition|(
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_LONG_DOUBLE_128
operator|)
condition|)
name|target_flags
operator||=
name|MASK_LONG_DOUBLE_128
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SUBTARGET_ATTRIBUTE_TABLE
end_ifdef

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|sparc_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
name|SUBTARGET_ATTRIBUTE_TABLE
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous utilities.  */
end_comment

begin_comment
comment|/* Nonzero if CODE, a comparison, is suitable for use in v9 conditional move    or branch on register contents instructions.  */
end_comment

begin_function
name|int
name|v9_regcmp_p
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point constant which can    be loaded into an integer register using a single    sethi instruction.  */
end_comment

begin_function
name|int
name|fp_sethi_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|i
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|!
name|SPARC_SIMM13_P
argument_list|(
name|i
argument_list|)
operator|&&
name|SPARC_SETHI_P
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point constant which can    be loaded into an integer register using a single    mov instruction.  */
end_comment

begin_function
name|int
name|fp_mov_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|i
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|SPARC_SIMM13_P
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a floating point constant which can    be loaded into an integer register using a high/losum    instruction sequence.  */
end_comment

begin_function
name|int
name|fp_high_losum_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
comment|/* The constraints calling this should only be in      SFmode move insns, so any constant which cannot      be moved using a single insn will do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|i
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|!
name|SPARC_SIMM13_P
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|SPARC_SETHI_P
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a move instruction.  Return true if all work is done.  */
end_comment

begin_function
name|bool
name|sparc_expand_move
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
comment|/* Handle sets of MEM first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* 0 is a register (or a pair of registers) on SPARC.  */
if|if
condition|(
name|register_or_zero_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|reload_in_progress
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|validize_mem
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fixup TLS cases.  */
if|if
condition|(
name|TARGET_HAVE_TLS
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|HIGH
operator|&&
name|sparc_tls_referenced_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|sym
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|addend
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sym
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|addend
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|legitimize_tls_address
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|addend
condition|)
block|{
name|sym
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|sym
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|sym
operator|=
name|force_operand
argument_list|(
name|sym
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|sym
expr_stmt|;
block|}
comment|/* Fixup PIC cases.  */
if|if
condition|(
name|flag_pic
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|pic_address_needs_scratch
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|mode
operator|==
name|SImode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi_pic_label_ref
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|mode
operator|==
name|DImode
condition|)
block|{
name|gcc_assert
argument_list|(
name|TARGET_ARCH64
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movdi_pic_label_ref
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|symbolic_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|,
operator|(
name|reload_in_progress
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|NULL_RTX
operator|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* If we are trying to toss an integer constant into FP registers,      or loading a FP or vector constant, force it into memory.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|SPARC_FP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
comment|/* emit_group_store will send such bogosity to us when it is          not storing directly into memory.  So fix this up to avoid          crashes in output_constant_pool.  */
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|const0_rtx
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* We can clear FP registers if TARGET_VIS, and always other regs.  */
if|if
condition|(
operator|(
name|TARGET_VIS
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|<
name|SPARC_FIRST_FP_REG
operator|)
operator|&&
name|const_zero_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|<
name|SPARC_FIRST_FP_REG
comment|/* We are able to build any SF constant in integer registers 	     with at most 2 instructions.  */
operator|&&
operator|(
name|mode
operator|==
name|SFmode
comment|/* And any DF constant in integer registers.  */
operator|||
operator|(
name|mode
operator|==
name|DFmode
operator|&&
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
name|operands
index|[
literal|1
index|]
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|validize_mem
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Accept non-constants and valid constants unmodified.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|HIGH
operator|||
name|input_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
comment|/* All QImode constants require only one insn, so proceed.  */
break|break;
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|sparc_emit_set_const32
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|DImode
case|:
comment|/* input_operand should have filtered out 32-bit mode.  */
name|sparc_emit_set_const64
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Load OP1, a 32-bit constant, into OP0, a register.    We know it can't be done in one insn when we get    here, the move expander guarantees this.  */
end_comment

begin_function
name|void
name|sparc_emit_set_const32
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|temp
operator|=
name|op0
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|small_int_operand
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|const_high_operand
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit them as real moves instead of a HIGH/LO_SUM, 	 this way CSE can see everything and reuse intermediate 	 values if it wants.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x3ff
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|0x3ff
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A symbol, emit in the traditional way.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Load OP1, a symbolic 64-bit constant, into OP0, a DImode register.    If TEMP is nonzero, we are forbidden to use any other scratch    registers.  Otherwise, we are allowed to generate them as needed.     Note that TEMP may have TImode if the code model is TARGET_CM_MEDANY    or TARGET_CM_EMBMEDANY (see the reload_indi and reload_outdi patterns).  */
end_comment

begin_function
name|void
name|sparc_emit_set_symbolic_const64
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|temp
parameter_list|)
block|{
name|rtx
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|temp3
decl_stmt|,
name|temp4
decl_stmt|,
name|temp5
decl_stmt|;
name|rtx
name|ti_temp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|==
name|TImode
condition|)
block|{
name|ti_temp
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* SPARC-V9 code-model support.  */
switch|switch
condition|(
name|sparc_cmodel
condition|)
block|{
case|case
name|CM_MEDLOW
case|:
comment|/* The range spanned by all instructions in the object is less 	 than 2^31 bytes (2GB) and the distance from any instruction 	 to the location of the label _GLOBAL_OFFSET_TABLE_ is less 	 than 2^31 bytes (2GB).  	 The executable must be in the low 4TB of the virtual address 	 space.  	 sethi	%hi(symbol), %temp1 	 or	%temp1, %lo(symbol), %reg  */
if|if
condition|(
name|temp
condition|)
name|temp1
operator|=
name|temp
expr_stmt|;
comment|/* op0 is allowed.  */
else|else
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp1
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|DImode
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|DImode
argument_list|,
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CM_MEDMID
case|:
comment|/* The range spanned by all instructions in the object is less 	 than 2^31 bytes (2GB) and the distance from any instruction 	 to the location of the label _GLOBAL_OFFSET_TABLE_ is less 	 than 2^31 bytes (2GB).  	 The executable must be in the low 16TB of the virtual address 	 space.  	 sethi	%h44(symbol), %temp1 	 or	%temp1, %m44(symbol), %temp2 	 sllx	%temp2, 12, %temp3 	 or	%temp3, %l44(symbol), %reg  */
if|if
condition|(
name|temp
condition|)
block|{
name|temp1
operator|=
name|op0
expr_stmt|;
name|temp2
operator|=
name|op0
expr_stmt|;
name|temp3
operator|=
name|temp
expr_stmt|;
comment|/* op0 is allowed.  */
block|}
else|else
block|{
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp3
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_seth44
argument_list|(
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setm44
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp3
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp2
argument_list|,
name|GEN_INT
argument_list|(
literal|12
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setl44
argument_list|(
name|op0
argument_list|,
name|temp3
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CM_MEDANY
case|:
comment|/* The range spanned by all instructions in the object is less 	 than 2^31 bytes (2GB) and the distance from any instruction 	 to the location of the label _GLOBAL_OFFSET_TABLE_ is less 	 than 2^31 bytes (2GB).  	 The executable can be placed anywhere in the virtual address 	 space.  	 sethi	%hh(symbol), %temp1 	 sethi	%lm(symbol), %temp2 	 or	%temp1, %hm(symbol), %temp3 	 sllx	%temp3, 32, %temp4 	 or	%temp4, %temp2, %temp5 	 or	%temp5, %lo(symbol), %reg  */
if|if
condition|(
name|temp
condition|)
block|{
comment|/* It is possible that one of the registers we got for operands[2] 	     might coincide with that of operands[0] (which is why we made 	     it TImode).  Pick the other one to use as our scratch.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|ti_temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|temp1
operator|=
name|op0
expr_stmt|;
name|temp2
operator|=
name|temp
expr_stmt|;
comment|/* op0 is _not_ allowed, see above.  */
name|temp3
operator|=
name|op0
expr_stmt|;
name|temp4
operator|=
name|op0
expr_stmt|;
name|temp5
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp3
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp4
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp5
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_sethh
argument_list|(
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setlm
argument_list|(
name|temp2
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sethm
argument_list|(
name|temp3
argument_list|,
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp4
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp3
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp5
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|temp4
argument_list|,
name|temp2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setlo
argument_list|(
name|op0
argument_list|,
name|temp5
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CM_EMBMEDANY
case|:
comment|/* Old old old backwards compatibility kruft here. 	 Essentially it is MEDLOW with a fixed 64-bit 	 virtual base added to all data segment addresses. 	 Text-segment stuff is computed like MEDANY, we can't 	 reuse the code above because the relocation knobs 	 look different.  	 Data segment:	sethi	%hi(symbol), %temp1 			add	%temp1, EMBMEDANY_BASE_REG, %temp2 			or	%temp2, %lo(symbol), %reg  */
if|if
condition|(
name|data_segment_operand
argument_list|(
name|op1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|temp
condition|)
block|{
name|temp1
operator|=
name|temp
expr_stmt|;
comment|/* op0 is allowed.  */
name|temp2
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_embmedany_sethi
argument_list|(
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_brsum
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_losum
argument_list|(
name|op0
argument_list|,
name|temp2
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Text segment:	sethi	%uhi(symbol), %temp1 			sethi	%hi(symbol), %temp2 			or	%temp1, %ulo(symbol), %temp3 			sllx	%temp3, 32, %temp4 			or	%temp4, %temp2, %temp5 			or	%temp5, %lo(symbol), %reg  */
else|else
block|{
if|if
condition|(
name|temp
condition|)
block|{
comment|/* It is possible that one of the registers we got for operands[2] 		 might coincide with that of operands[0] (which is why we made 		 it TImode).  Pick the other one to use as our scratch.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|ti_temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|temp1
operator|=
name|op0
expr_stmt|;
name|temp2
operator|=
name|temp
expr_stmt|;
comment|/* op0 is _not_ allowed, see above.  */
name|temp3
operator|=
name|op0
expr_stmt|;
name|temp4
operator|=
name|op0
expr_stmt|;
name|temp5
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp3
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp4
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|temp5
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_embmedany_textuhi
argument_list|(
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_texthi
argument_list|(
name|temp2
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_textulo
argument_list|(
name|temp3
argument_list|,
name|temp1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp4
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp3
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp5
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|temp4
argument_list|,
name|temp2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_embmedany_textlo
argument_list|(
name|op0
argument_list|,
name|temp5
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
end_if

begin_function
name|void
name|sparc_emit_set_const64
parameter_list|(
name|rtx
name|op0
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|op1
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* These avoid problems when cross compiling.  If we do not    go through all this hair then the optimizer will see    invalid REG_EQUAL notes or in some cases none at all.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|gen_safe_HIGH64
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_safe_SET64
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_safe_OR64
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_safe_XOR64
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The optimizer is not to assume anything about exactly    which bits are set for a HIGH, they are unspecified.    Unfortunately this leads to many missed optimizations    during CSE.  We mask out the non-HIGH bits, and matches    a plain movdi, to alleviate this problem.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_safe_HIGH64
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|)
block|{
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|val
operator|&
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x3ff
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_safe_SET64
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|)
block|{
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_safe_OR64
parameter_list|(
name|rtx
name|src
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|)
block|{
return|return
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_safe_XOR64
parameter_list|(
name|rtx
name|src
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|)
block|{
return|return
name|gen_rtx_XOR
argument_list|(
name|DImode
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Worker routines for 64-bit constant formation on arch64.    One of the key things to be doing in these emissions is    to create as many temp REGs as possible.  This makes it    possible for half-built constants to be used later when    such values are similar to something required later on.    Without doing this, the optimizer cannot see such    opportunities.  */
end_comment

begin_function_decl
specifier|static
name|void
name|sparc_emit_set_const64_quick1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|sparc_emit_set_const64_quick1
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|temp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low_bits
parameter_list|,
name|int
name|is_neg
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|;
if|if
condition|(
name|is_neg
condition|)
name|high_bits
operator|=
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
else|else
name|high_bits
operator|=
name|low_bits
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_safe_HIGH64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_neg
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_OR64
argument_list|(
name|temp
argument_list|,
operator|(
name|high_bits
operator|&
literal|0x3ff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we are XOR'ing with -1, then we should emit a one's complement 	 instead.  This way the combiner will notice logical operations 	 such as ANDN later on and substitute.  */
if|if
condition|(
operator|(
name|low_bits
operator|&
literal|0x3ff
operator|)
operator|==
literal|0x3ff
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_XOR64
argument_list|(
name|temp
argument_list|,
operator|(
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x400
operator||
operator|(
name|low_bits
operator|&
literal|0x3ff
operator|)
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|sparc_emit_set_const64_quick2
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|sparc_emit_set_const64_quick2
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|temp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|high_bits
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low_immediate
parameter_list|,
name|int
name|shift_count
parameter_list|)
block|{
name|rtx
name|temp2
init|=
name|op0
decl_stmt|;
if|if
condition|(
operator|(
name|high_bits
operator|&
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_safe_HIGH64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|high_bits
operator|&
operator|~
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_OR64
argument_list|(
name|temp
argument_list|,
operator|(
name|high_bits
operator|&
literal|0x3ff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|temp2
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_safe_SET64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Now shift it up into place.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp2
argument_list|,
name|GEN_INT
argument_list|(
name|shift_count
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is a low immediate part piece, finish up by      putting that in as well.  */
if|if
condition|(
name|low_immediate
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_OR64
argument_list|(
name|op0
argument_list|,
name|low_immediate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|sparc_emit_set_const64_longway
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Full 64-bit constant decomposition.  Even though this is the    'worst' case, we still optimize a few things away.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_emit_set_const64_longway
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|temp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|high_bits
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low_bits
parameter_list|)
block|{
name|rtx
name|sub_temp
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|sub_temp
operator|=
name|op0
expr_stmt|;
else|else
name|sub_temp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|high_bits
operator|&
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_safe_HIGH64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|high_bits
operator|&
operator|~
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub_temp
argument_list|,
name|gen_safe_OR64
argument_list|(
name|temp
argument_list|,
operator|(
name|high_bits
operator|&
literal|0x3ff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sub_temp
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_safe_SET64
argument_list|(
name|temp
argument_list|,
name|high_bits
argument_list|)
argument_list|)
expr_stmt|;
name|sub_temp
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
block|{
name|rtx
name|temp2
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp3
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|temp4
init|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp4
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|sub_temp
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_safe_HIGH64
argument_list|(
name|temp2
argument_list|,
name|low_bits
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|low_bits
operator|&
operator|~
literal|0xfffffc00
operator|)
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp3
argument_list|,
name|gen_safe_OR64
argument_list|(
name|temp2
argument_list|,
operator|(
name|low_bits
operator|&
literal|0x3ff
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|temp4
argument_list|,
name|temp3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|temp4
argument_list|,
name|temp2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|low1
init|=
name|GEN_INT
argument_list|(
operator|(
name|low_bits
operator|>>
operator|(
literal|32
operator|-
literal|12
operator|)
operator|)
operator|&
literal|0xfff
argument_list|)
decl_stmt|;
name|rtx
name|low2
init|=
name|GEN_INT
argument_list|(
operator|(
name|low_bits
operator|>>
operator|(
literal|32
operator|-
literal|12
operator|-
literal|12
operator|)
operator|)
operator|&
literal|0xfff
argument_list|)
decl_stmt|;
name|rtx
name|low3
init|=
name|GEN_INT
argument_list|(
operator|(
name|low_bits
operator|>>
operator|(
literal|32
operator|-
literal|12
operator|-
literal|12
operator|-
literal|8
operator|)
operator|)
operator|&
literal|0x0ff
argument_list|)
decl_stmt|;
name|int
name|to_shift
init|=
literal|12
decl_stmt|;
comment|/* We are in the middle of reload, so this is really 	 painful.  However we do still make an attempt to 	 avoid emitting truly stupid code.  */
if|if
condition|(
name|low1
operator|!=
name|const0_rtx
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|sub_temp
argument_list|,
name|GEN_INT
argument_list|(
name|to_shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|low1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sub_temp
operator|=
name|op0
expr_stmt|;
name|to_shift
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|to_shift
operator|+=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|low2
operator|!=
name|const0_rtx
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|sub_temp
argument_list|,
name|GEN_INT
argument_list|(
name|to_shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|low2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sub_temp
operator|=
name|op0
expr_stmt|;
name|to_shift
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|to_shift
operator|+=
literal|8
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|sub_temp
argument_list|,
name|GEN_INT
argument_list|(
name|to_shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|low3
operator|!=
name|const0_rtx
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|DImode
argument_list|,
name|op0
argument_list|,
name|low3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* phew...  */
block|}
block|}
end_function

begin_comment
comment|/* Analyze a 64-bit constant for certain properties.  */
end_comment

begin_function_decl
specifier|static
name|void
name|analyze_64bit_constant
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|analyze_64bit_constant
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|high_bits
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low_bits
parameter_list|,
name|int
modifier|*
name|hbsp
parameter_list|,
name|int
modifier|*
name|lbsp
parameter_list|,
name|int
modifier|*
name|abbasp
parameter_list|)
block|{
name|int
name|lowest_bit_set
decl_stmt|,
name|highest_bit_set
decl_stmt|,
name|all_bits_between_are_set
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lowest_bit_set
operator|=
name|highest_bit_set
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|low_bits
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
condition|)
name|lowest_bit_set
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|high_bits
operator|>>
operator|(
literal|32
operator|-
name|i
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
condition|)
name|highest_bit_set
operator|=
operator|(
literal|64
operator|-
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
literal|32
operator|&&
operator|(
operator|(
name|highest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|i
operator|==
literal|32
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|high_bits
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
condition|)
name|lowest_bit_set
operator|=
name|i
operator|+
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|low_bits
operator|>>
operator|(
literal|32
operator|-
name|i
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
condition|)
name|highest_bit_set
operator|=
literal|32
operator|-
name|i
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
literal|32
operator|&&
operator|(
operator|(
name|highest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|lowest_bit_set
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
do|;
block|}
comment|/* If there are no bits set this should have gone out      as one instruction!  */
name|gcc_assert
argument_list|(
name|lowest_bit_set
operator|!=
operator|-
literal|1
operator|&&
name|highest_bit_set
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|all_bits_between_are_set
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowest_bit_set
init|;
name|i
operator|<=
name|highest_bit_set
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|32
condition|)
block|{
if|if
condition|(
operator|(
name|low_bits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|high_bits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|32
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
name|all_bits_between_are_set
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|hbsp
operator|=
name|highest_bit_set
expr_stmt|;
operator|*
name|lbsp
operator|=
name|lowest_bit_set
expr_stmt|;
operator|*
name|abbasp
operator|=
name|all_bits_between_are_set
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|const64_is_2insns
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|const64_is_2insns
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|high_bits
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low_bits
parameter_list|)
block|{
name|int
name|highest_bit_set
decl_stmt|,
name|lowest_bit_set
decl_stmt|,
name|all_bits_between_are_set
decl_stmt|;
if|if
condition|(
name|high_bits
operator|==
literal|0
operator|||
name|high_bits
operator|==
literal|0xffffffff
condition|)
return|return
literal|1
return|;
name|analyze_64bit_constant
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
operator|&
name|highest_bit_set
argument_list|,
operator|&
name|lowest_bit_set
argument_list|,
operator|&
name|all_bits_between_are_set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|==
literal|63
operator|||
name|lowest_bit_set
operator|==
literal|0
operator|)
operator|&&
name|all_bits_between_are_set
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|-
name|lowest_bit_set
operator|)
operator|<
literal|21
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|create_simple_focus_bits
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|create_simple_focus_bits
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|high_bits
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|low_bits
parameter_list|,
name|int
name|lowest_bit_set
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
if|if
condition|(
name|lowest_bit_set
operator|<
literal|32
condition|)
block|{
name|lo
operator|=
operator|(
name|low_bits
operator|>>
name|lowest_bit_set
operator|)
operator|<<
name|shift
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
name|high_bits
operator|<<
operator|(
literal|32
operator|-
name|lowest_bit_set
operator|)
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
name|high_bits
operator|>>
operator|(
name|lowest_bit_set
operator|-
literal|32
operator|)
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|!
operator|(
name|hi
operator|&
name|lo
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hi
operator||
name|lo
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Here we are sure to be arch64 and this is an integer constant    being loaded into a register.  Emit the most efficient    insn sequence possible.  Detection of all the 1-insn cases    has been done already.  */
end_comment

begin_function
name|void
name|sparc_emit_set_const64
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|high_bits
decl_stmt|,
name|low_bits
decl_stmt|;
name|int
name|lowest_bit_set
decl_stmt|,
name|highest_bit_set
decl_stmt|;
name|int
name|all_bits_between_are_set
decl_stmt|;
name|rtx
name|temp
init|=
literal|0
decl_stmt|;
comment|/* Sanity check that we know what we are working with.  */
name|gcc_assert
argument_list|(
name|TARGET_ARCH64
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|SPARC_FP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|temp
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|sparc_emit_set_symbolic_const64
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|temp
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|high_bits
operator|=
operator|(
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|low_bits
operator|=
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
comment|/* low_bits	bits 0  --> 31      high_bits	bits 32 --> 63  */
name|analyze_64bit_constant
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
operator|&
name|highest_bit_set
argument_list|,
operator|&
name|lowest_bit_set
argument_list|,
operator|&
name|all_bits_between_are_set
argument_list|)
expr_stmt|;
comment|/* First try for a 2-insn sequence.  */
comment|/* These situations are preferred because the optimizer can    * do more things with them:    * 1) mov	-1, %reg    *    sllx	%reg, shift, %reg    * 2) mov	-1, %reg    *    srlx	%reg, shift, %reg    * 3) mov	some_small_const, %reg    *    sllx	%reg, shift, %reg    */
if|if
condition|(
operator|(
operator|(
name|highest_bit_set
operator|==
literal|63
operator|||
name|lowest_bit_set
operator|==
literal|0
operator|)
operator|&&
name|all_bits_between_are_set
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|highest_bit_set
operator|-
name|lowest_bit_set
operator|)
operator|<
literal|12
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|the_const
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|shift
init|=
name|lowest_bit_set
decl_stmt|;
if|if
condition|(
operator|(
name|highest_bit_set
operator|!=
literal|63
operator|&&
name|lowest_bit_set
operator|!=
literal|0
operator|)
operator|||
name|all_bits_between_are_set
operator|==
literal|0
condition|)
block|{
name|the_const
operator|=
name|create_simple_focus_bits
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
name|lowest_bit_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowest_bit_set
operator|==
literal|0
condition|)
name|shift
operator|=
operator|-
operator|(
literal|63
operator|-
name|highest_bit_set
operator|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|SPARC_SIMM13_P
argument_list|(
name|the_const
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|shift
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_safe_SET64
argument_list|(
name|temp
argument_list|,
name|the_const
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now a range of 22 or less bits set somewhere.    * 1) sethi	%hi(focus_bits), %reg    *    sllx	%reg, shift, %reg    * 2) sethi	%hi(focus_bits), %reg    *    srlx	%reg, shift, %reg    */
if|if
condition|(
operator|(
name|highest_bit_set
operator|-
name|lowest_bit_set
operator|)
operator|<
literal|21
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|focus_bits
init|=
name|create_simple_focus_bits
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
name|lowest_bit_set
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|SPARC_SETHI_P
argument_list|(
name|focus_bits
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|lowest_bit_set
operator|!=
literal|10
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_safe_HIGH64
argument_list|(
name|temp
argument_list|,
name|focus_bits
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If lowest_bit_set == 10 then a sethi alone could have done it.  */
if|if
condition|(
name|lowest_bit_set
operator|<
literal|10
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
literal|10
operator|-
name|lowest_bit_set
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lowest_bit_set
operator|>
literal|10
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|lowest_bit_set
operator|-
literal|10
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 1) sethi	%hi(low_bits), %reg    *    or	%reg, %lo(low_bits), %reg    * 2) sethi	%hi(~low_bits), %reg    *	xor	%reg, %lo(-0x400 | (low_bits& 0x3ff)), %reg    */
if|if
condition|(
name|high_bits
operator|==
literal|0
operator|||
name|high_bits
operator|==
literal|0xffffffff
condition|)
block|{
name|sparc_emit_set_const64_quick1
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|low_bits
argument_list|,
operator|(
name|high_bits
operator|==
literal|0xffffffff
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now, try 3-insn sequences.  */
comment|/* 1) sethi	%hi(high_bits), %reg    *    or	%reg, %lo(high_bits), %reg    *    sllx	%reg, 32, %reg    */
if|if
condition|(
name|low_bits
operator|==
literal|0
condition|)
block|{
name|sparc_emit_set_const64_quick2
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|high_bits
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We may be able to do something quick      when the constant is negated, so try that.  */
if|if
condition|(
name|const64_is_2insns
argument_list|(
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
argument_list|,
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0xfffffc00
argument_list|)
condition|)
block|{
comment|/* NOTE: The trailing bits get XOR'd so we need the 	 non-negated bits, not the negated ones.  */
name|unsigned
name|HOST_WIDE_INT
name|trailing_bits
init|=
name|low_bits
operator|&
literal|0x3ff
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0xffffffff
operator|&&
operator|(
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|fast_int
init|=
operator|(
operator|~
name|low_bits
operator|&
literal|0xffffffff
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|SPARC_SETHI_P
argument_list|(
name|fast_int
argument_list|)
operator|&&
operator|(
operator|~
name|high_bits
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0
operator|)
operator|||
name|SPARC_SIMM13_P
argument_list|(
name|fast_int
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_safe_SET64
argument_list|(
name|temp
argument_list|,
name|fast_int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sparc_emit_set_const64
argument_list|(
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|fast_int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|negated_const
decl_stmt|;
name|negated_const
operator|=
name|GEN_INT
argument_list|(
operator|(
operator|(
operator|~
name|low_bits
operator|)
operator|&
literal|0xfffffc00
operator|)
operator||
operator|(
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|(
operator|~
name|high_bits
operator|)
operator|&
literal|0xffffffff
argument_list|)
operator|)
operator|<<
literal|32
operator|)
argument_list|)
expr_stmt|;
name|sparc_emit_set_const64
argument_list|(
name|temp
argument_list|,
name|negated_const
argument_list|)
expr_stmt|;
block|}
comment|/* If we are XOR'ing with -1, then we should emit a one's complement 	 instead.  This way the combiner will notice logical operations 	 such as ANDN later on and substitute.  */
if|if
condition|(
name|trailing_bits
operator|==
literal|0x3ff
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|DImode
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|gen_safe_XOR64
argument_list|(
name|temp
argument_list|,
operator|(
operator|-
literal|0x400
operator||
name|trailing_bits
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 1) sethi	%hi(xxx), %reg    *    or	%reg, %lo(xxx), %reg    *	sllx	%reg, yyy, %reg    *    * ??? This is just a generalized version of the low_bits==0    * thing above, FIXME...    */
if|if
condition|(
operator|(
name|highest_bit_set
operator|-
name|lowest_bit_set
operator|)
operator|<
literal|32
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|focus_bits
init|=
name|create_simple_focus_bits
argument_list|(
name|high_bits
argument_list|,
name|low_bits
argument_list|,
name|lowest_bit_set
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We can't get here in this state.  */
name|gcc_assert
argument_list|(
name|highest_bit_set
operator|>=
literal|32
operator|&&
name|lowest_bit_set
operator|<
literal|32
argument_list|)
expr_stmt|;
comment|/* So what we know is that the set bits straddle the 	 middle of the 64-bit word.  */
name|sparc_emit_set_const64_quick2
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|focus_bits
argument_list|,
literal|0
argument_list|,
name|lowest_bit_set
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 1) sethi	%hi(high_bits), %reg    *    or	%reg, %lo(high_bits), %reg    *    sllx	%reg, 32, %reg    *	or	%reg, low_bits, %reg    */
if|if
condition|(
name|SPARC_SIMM13_P
argument_list|(
name|low_bits
argument_list|)
operator|&&
operator|(
operator|(
name|int
operator|)
name|low_bits
operator|>
literal|0
operator|)
condition|)
block|{
name|sparc_emit_set_const64_quick2
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|high_bits
argument_list|,
name|low_bits
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The easiest way when all else fails, is full decomposition.  */
if|#
directive|if
literal|0
block|printf ("sparc_emit_set_const64: Hard constant [%08lx%08lx] neg[%08lx%08lx]\n", 	  high_bits, low_bits, ~high_bits, ~low_bits);
endif|#
directive|endif
name|sparc_emit_set_const64_longway
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|,
name|high_bits
argument_list|,
name|low_bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HOST_BITS_PER_WIDE_INT == 32 */
end_comment

begin_comment
comment|/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,    return the mode to be used for the comparison.  For floating-point,    CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand    is a PLUS, MINUS, NEG, or ASHIFT.  CCmode should be used when no special    processing is needed.  */
end_comment

begin_function
name|enum
name|machine_mode
name|select_cc_mode
parameter_list|(
name|enum
name|rtx_code
name|op
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|CCFPmode
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
return|return
name|CCFPEmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
return|return
name|CCX_NOOVmode
return|;
else|else
return|return
name|CC_NOOVmode
return|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
return|return
name|CCXmode
return|;
else|else
return|return
name|CCmode
return|;
block|}
block|}
end_function

begin_comment
comment|/* X and Y are two things to compare using CODE.  Emit the compare insn and    return the rtx for the cc reg in the proper mode.  */
end_comment

begin_function
name|rtx
name|gen_compare_reg
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|rtx
name|x
init|=
name|sparc_compare_op0
decl_stmt|;
name|rtx
name|y
init|=
name|sparc_compare_op1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
decl_stmt|;
if|if
condition|(
name|sparc_compare_emitted
operator|!=
name|NULL_RTX
condition|)
block|{
name|cc_reg
operator|=
name|sparc_compare_emitted
expr_stmt|;
name|sparc_compare_emitted
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
comment|/* ??? We don't have movcc patterns so we cannot generate pseudo regs for the      fcc regs (cse can't tell they're really call clobbered regs and will      remove a duplicate comparison even if there is an intervening function      call - it will then try to reload the cc reg via an int reg which is why      we need the movcc patterns).  It is possible to provide the movcc      patterns by using the ldxfsr/stxfsr v9 insns.  I tried it: you need two      registers (say %g1,%g5) and it takes about 6 insns.  A better fix would be      to tell cse that CCFPE mode registers (even pseudos) are call      clobbered.  */
comment|/* ??? This is an experiment.  Rather than making changes to cse which may      or may not be easy/clean, we do our own cse.  This is possible because      we will generate hard registers.  Cse knows they're call clobbered (it      doesn't know the same thing about pseudos). If we guess wrong, no big      deal, but if we win, great!  */
if|if
condition|(
name|TARGET_V9
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
if|#
directive|if
literal|1
comment|/* experiment */
block|{
name|int
name|reg
decl_stmt|;
comment|/* We cycle through the registers to ensure they're all exercised.  */
specifier|static
name|int
name|next_fcc_reg
init|=
literal|0
decl_stmt|;
comment|/* Previous x,y for each fcc reg.  */
specifier|static
name|rtx
name|prev_args
index|[
literal|4
index|]
index|[
literal|2
index|]
decl_stmt|;
comment|/* Scan prev_args for x,y.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|4
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|prev_args
index|[
name|reg
index|]
index|[
literal|0
index|]
operator|==
name|x
operator|&&
name|prev_args
index|[
name|reg
index|]
index|[
literal|1
index|]
operator|==
name|y
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
literal|4
condition|)
block|{
name|reg
operator|=
name|next_fcc_reg
expr_stmt|;
name|prev_args
index|[
name|reg
index|]
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|prev_args
index|[
name|reg
index|]
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
name|next_fcc_reg
operator|=
operator|(
name|next_fcc_reg
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|reg
operator|+
name|SPARC_FIRST_V9_FCC_REG
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|cc_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! experiment */
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SPARC_FCC_REG
argument_list|)
expr_stmt|;
else|else
name|cc_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SPARC_ICC_REG
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_comment
comment|/* This function is used for v9 only.    CODE is the code for an Scc's comparison.    OPERANDS[0] is the target of the Scc insn.    OPERANDS[1] is the value we compare against const0_rtx (which hasn't    been generated yet).     This function is needed to turn  	   (set (reg:SI 110) 	       (gt (reg:CCX 100 %icc) 	           (const_int 0)))    into 	   (set (reg:SI 110) 	       (gt:DI (reg:CCX 100 %icc) 	           (const_int 0)))     IE: The instruction recognizer needs to see the mode of the comparison to    find the right instruction. We could use "gt:DI" right in the    define_expand, but leaving it out allows us to handle DI, SI, etc.     We refer to the global sparc compare operands sparc_compare_op0 and    sparc_compare_op1.  */
end_comment

begin_function
name|int
name|gen_v9_scc
parameter_list|(
name|enum
name|rtx_code
name|compare_code
parameter_list|,
specifier|register
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_ARCH64
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|sparc_compare_op0
argument_list|)
operator|==
name|DImode
operator|||
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Try to use the movrCC insns.  */
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|sparc_compare_op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|sparc_compare_op1
operator|==
name|const0_rtx
operator|&&
name|v9_regcmp_p
argument_list|(
name|compare_code
argument_list|)
condition|)
block|{
name|rtx
name|op0
init|=
name|sparc_compare_op0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Special case for op0 != 0.  This can be done with one instruction if 	 operands[0] == sparc_compare_op0.  */
if|if
condition|(
name|compare_code
operator|==
name|NE
operator|&&
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
operator|&&
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|DImode
argument_list|,
name|op0
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|)
condition|)
block|{
comment|/* Handle the case where operands[0] == sparc_compare_op0. 	     We "early clobber" the result.  */
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|sparc_compare_op0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|sparc_compare_op0
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|DImode
condition|)
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|op0
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|DImode
argument_list|,
name|temp
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_compare_reg
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|CCmode
case|:
case|case
name|CCXmode
case|:
case|case
name|CCFPEmode
case|:
case|case
name|CCFPmode
case|:
break|break;
default|default :
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|compare_code
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const1_rtx
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a conditional jump insn for the v9 architecture using comparison code    CODE and jump target LABEL.    This function exists to take advantage of the v9 brxx insns.  */
end_comment

begin_function
name|void
name|emit_v9_brxx_insn
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|label
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|sparc_compare_emitted
operator|==
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DFmode part of a hard TFmode register.    REG is the TFmode hard register, LOW is 1 for the    low 64bit of the register and 0 otherwise.  */
end_comment

begin_function
name|rtx
name|gen_df_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|int
name|low
parameter_list|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|WORDS_BIG_ENDIAN
operator|==
literal|0
operator|)
operator|^
operator|(
name|low
operator|!=
literal|0
operator|)
condition|)
name|regno
operator|+=
operator|(
name|TARGET_ARCH64
operator|&&
name|regno
operator|<
literal|32
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a call to FUNC with OPERANDS.  Operand 0 is the return value.    Unlike normal calls, TFmode operands are passed by reference.  It is    assumed that no more than 3 operands are required.  */
end_comment

begin_function
specifier|static
name|void
name|emit_soft_tfmode_libcall
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|,
name|int
name|nargs
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|ret_slot
init|=
name|NULL
decl_stmt|,
name|arg
index|[
literal|3
index|]
decl_stmt|,
name|func_sym
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We only expect to be called for conversions, unary, and binary ops.  */
name|gcc_assert
argument_list|(
name|nargs
operator|==
literal|2
operator|||
name|nargs
operator|==
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|this_arg
init|=
name|operands
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|this_slot
decl_stmt|;
comment|/* TFmode arguments and return values are passed by reference.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|this_arg
argument_list|)
operator|==
name|TFmode
condition|)
block|{
name|int
name|force_stack_temp
decl_stmt|;
name|force_stack_temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_BUGGY_QP_LIB
operator|&&
name|i
operator|==
literal|0
condition|)
name|force_stack_temp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_arg
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|force_stack_temp
condition|)
name|this_arg
operator|=
name|XEXP
argument_list|(
name|this_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|this_arg
argument_list|)
operator|&&
operator|!
name|force_stack_temp
condition|)
block|{
name|this_slot
operator|=
name|force_const_mem
argument_list|(
name|TFmode
argument_list|,
name|this_arg
argument_list|)
expr_stmt|;
name|this_arg
operator|=
name|XEXP
argument_list|(
name|this_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this_slot
operator|=
name|assign_stack_temp
argument_list|(
name|TFmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|TFmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Operand 0 is the return value.  We'll copy it out later.  */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|this_slot
argument_list|,
name|this_arg
argument_list|)
expr_stmt|;
else|else
name|ret_slot
operator|=
name|this_slot
expr_stmt|;
name|this_arg
operator|=
name|XEXP
argument_list|(
name|this_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|arg
index|[
name|i
index|]
operator|=
name|this_arg
expr_stmt|;
block|}
name|func_sym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|nargs
operator|==
literal|2
condition|)
name|emit_library_call
argument_list|(
name|func_sym
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|2
argument_list|,
name|arg
index|[
literal|0
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_library_call
argument_list|(
name|func_sym
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|arg
index|[
literal|0
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|arg
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_slot
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|ret_slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|ret
decl_stmt|;
name|gcc_assert
argument_list|(
name|nargs
operator|==
literal|2
argument_list|)
expr_stmt|;
name|ret
operator|=
name|emit_library_call_value
argument_list|(
name|func_sym
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|LCT_NORMAL
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand soft-float TFmode calls to sparc abi routines.  */
end_comment

begin_function
specifier|static
name|void
name|emit_soft_tfmode_binop
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|func
operator|=
literal|"_Qp_add"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|func
operator|=
literal|"_Qp_sub"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|func
operator|=
literal|"_Qp_mul"
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|func
operator|=
literal|"_Qp_div"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|emit_soft_tfmode_libcall
argument_list|(
name|func
argument_list|,
literal|3
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_soft_tfmode_unop
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|gcc_assert
argument_list|(
name|code
operator|==
name|SQRT
argument_list|)
expr_stmt|;
name|func
operator|=
literal|"_Qp_sqrt"
expr_stmt|;
name|emit_soft_tfmode_libcall
argument_list|(
name|func
argument_list|,
literal|2
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_soft_tfmode_cvt
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FLOAT_EXTEND
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|SFmode
case|:
name|func
operator|=
literal|"_Qp_stoq"
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|func
operator|=
literal|"_Qp_dtoq"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|SFmode
case|:
name|func
operator|=
literal|"_Qp_qtos"
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|func
operator|=
literal|"_Qp_qtod"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
name|func
operator|=
literal|"_Qp_itoq"
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|func
operator|=
literal|"_Qp_xtoq"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|UNSIGNED_FLOAT
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
name|func
operator|=
literal|"_Qp_uitoq"
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|func
operator|=
literal|"_Qp_uxtoq"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FIX
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
name|func
operator|=
literal|"_Qp_qtoi"
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|func
operator|=
literal|"_Qp_qtox"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|UNSIGNED_FIX
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
name|func
operator|=
literal|"_Qp_qtoui"
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|func
operator|=
literal|"_Qp_qtoux"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|emit_soft_tfmode_libcall
argument_list|(
name|func
argument_list|,
literal|2
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a hard-float tfmode operation.  All arguments must be in    registers.  */
end_comment

begin_function
specifier|static
name|void
name|emit_hard_tfmode_operation
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|op
decl_stmt|,
name|dest
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_UNARY
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|op
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|op
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|dest
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
else|else
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emit_tfmode_binop
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
if|if
condition|(
name|TARGET_HARD_QUAD
condition|)
name|emit_hard_tfmode_operation
argument_list|(
name|code
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|emit_soft_tfmode_binop
argument_list|(
name|code
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emit_tfmode_unop
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
if|if
condition|(
name|TARGET_HARD_QUAD
condition|)
name|emit_hard_tfmode_operation
argument_list|(
name|code
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|emit_soft_tfmode_unop
argument_list|(
name|code
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emit_tfmode_cvt
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
if|if
condition|(
name|TARGET_HARD_QUAD
condition|)
name|emit_hard_tfmode_operation
argument_list|(
name|code
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|emit_soft_tfmode_cvt
argument_list|(
name|code
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if a branch/jump/call instruction will be emitting    nop into its delay slot.  */
end_comment

begin_function
name|int
name|empty_delay_slot
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|seq
decl_stmt|;
comment|/* If no previous instruction (should not happen), return true.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|seq
operator|=
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|seq
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL can go into the call delay slot.  */
end_comment

begin_function
name|int
name|tls_call_delay
parameter_list|(
name|rtx
name|trial
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
comment|/* Binutils allows        call __tls_get_addr, %tgd_call (foo)         add %l7, %o0, %o0, %tgd_add (foo)      while Sun as/ld does not.  */
if|if
condition|(
name|TARGET_GNU_TLS
operator|||
operator|!
name|TARGET_TLS
condition|)
return|return
literal|1
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* We must reject tgd_add{32|64}, i.e.        (set (reg) (plus (reg) (unspec [(reg) (symbol_ref)] UNSPEC_TLSGD)))      and tldm_add{32|64}, i.e.        (set (reg) (plus (reg) (unspec [(reg) (symbol_ref)] UNSPEC_TLSLDM)))      for Sun as/ld.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|unspec
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|unspec
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|unspec
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSGD
operator|||
name|XINT
argument_list|(
name|unspec
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSLDM
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL, an insn, can be combined with a 'restore'    instruction.  RETURN_P is true if the v9 variant 'return' is to be    considered in the test too.     TRIAL must be a SET whose destination is a REG appropriate for the    'restore' instruction or, if RETURN_P is true, for the 'return'    instruction.  */
end_comment

begin_function
specifier|static
name|int
name|eligible_for_restore_insn
parameter_list|(
name|rtx
name|trial
parameter_list|,
name|bool
name|return_p
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
comment|/* The 'restore src,%g0,dest' pattern for word mode and below.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|arith_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
return|;
else|else
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
return|;
block|}
comment|/* The 'restore src,%g0,dest' pattern for double-word mode.  */
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|arith_double_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
return|;
comment|/* The 'restore src,%g0,dest' pattern for float if no FPU.  */
elseif|else
if|if
condition|(
operator|!
name|TARGET_FPU
operator|&&
name|register_operand
argument_list|(
name|src
argument_list|,
name|SFmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The 'restore src,%g0,dest' pattern for double if no FPU.  */
elseif|else
if|if
condition|(
operator|!
name|TARGET_FPU
operator|&&
name|TARGET_ARCH64
operator|&&
name|register_operand
argument_list|(
name|src
argument_list|,
name|DFmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If we have the 'return' instruction, anything that does not use      local or output registers and can go into a delay slot wins.  */
elseif|else
if|if
condition|(
name|return_p
operator|&&
name|TARGET_V9
operator|&&
operator|!
name|epilogue_renumber
argument_list|(
operator|&
name|pat
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|get_attr_in_uncond_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_UNCOND_BRANCH_DELAY_TRUE
operator|)
condition|)
return|return
literal|1
return|;
comment|/* The 'restore src1,src2,dest' pattern for SImode.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The 'restore src1,src2,dest' pattern for DImode.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The 'restore src1,%lo(src2),dest' pattern.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LO_SUM
operator|&&
operator|!
name|TARGET_CM_MEDMID
operator|&&
operator|(
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|immediate_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|immediate_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* The 'restore src,src,dest' pattern.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ASHIFT
operator|&&
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL can go into the function return's    delay slot.  */
end_comment

begin_function
name|int
name|eligible_for_return_delay
parameter_list|(
name|rtx
name|trial
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* If there are any call-saved registers, we should scan TRIAL if it      does not reference them.  For now just make it easy.  */
if|if
condition|(
name|num_gfregs
condition|)
return|return
literal|0
return|;
comment|/* If the function uses __builtin_eh_return, the eh_return machinery      occupies the delay slot.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
return|return
literal|0
return|;
comment|/* In the case of a true leaf function, anything can go into the slot.  */
if|if
condition|(
name|sparc_leaf_function_p
condition|)
return|return
name|get_attr_in_uncond_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_UNCOND_BRANCH_DELAY_TRUE
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Otherwise, only operations which can be done in tandem with      a `restore' or `return' insn can go into the delay slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|>=
literal|8
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|<
literal|24
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If this instruction sets up floating point register and we have a return      instruction, it can probably go in.  But restore will not work      with FP_REGS.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|>=
literal|32
condition|)
return|return
operator|(
name|TARGET_V9
operator|&&
operator|!
name|epilogue_renumber
argument_list|(
operator|&
name|pat
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|get_attr_in_uncond_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_UNCOND_BRANCH_DELAY_TRUE
operator|)
operator|)
return|;
return|return
name|eligible_for_restore_insn
argument_list|(
name|trial
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL can go into the sibling call's    delay slot.  */
end_comment

begin_function
name|int
name|eligible_for_sibcall_delay
parameter_list|(
name|rtx
name|trial
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_leaf_function_p
condition|)
block|{
comment|/* If the tail call is done using the call instruction, 	 we have to restore %o7 in the delay slot.  */
if|if
condition|(
name|LEAF_SIBCALL_SLOT_RESERVED_P
condition|)
return|return
literal|0
return|;
comment|/* %g1 is used to build the function address */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pat
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/* Otherwise, only operations which can be done in tandem with      a `restore' insn can go into the delay slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|>=
literal|8
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|<
literal|24
operator|)
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|>=
literal|32
condition|)
return|return
literal|0
return|;
comment|/* If it mentions %o7, it can't go in, because sibcall will clobber it      in most cases.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|15
argument_list|)
argument_list|,
name|pat
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|eligible_for_restore_insn
argument_list|(
name|trial
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|short_branch
parameter_list|(
name|int
name|uid1
parameter_list|,
name|int
name|uid2
parameter_list|)
block|{
name|int
name|delta
init|=
name|INSN_ADDRESSES
argument_list|(
name|uid1
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|uid2
argument_list|)
decl_stmt|;
comment|/* Leave a few words of "slop".  */
if|if
condition|(
name|delta
operator|>=
operator|-
literal|1023
operator|&&
name|delta
operator|<=
literal|1022
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REG is not used after INSN.    We assume REG is a reload reg, and therefore does    not live past labels or calls or jumps.  */
end_comment

begin_function
name|int
name|reg_unused_after
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|,
name|prev_code
init|=
name|UNKNOWN
decl_stmt|;
while|while
condition|(
operator|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|in_src
init|=
name|set
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|in_src
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|set
operator|==
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine if it's legal to put X into the constant pool.  This    is not possible if X contains the address of a symbol that is    not constant (TLS) or not known at final link time (PIC).  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_cannot_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
comment|/* Accept all non-symbolic constants.  */
return|return
name|false
return|;
case|case
name|LABEL_REF
case|:
comment|/* Labels are OK iff we are non-PIC.  */
return|return
name|flag_pic
operator|!=
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* 'Naked' TLS symbol references are never OK, 	 non-TLS symbols are OK iff we are non-PIC.  */
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|flag_pic
operator|!=
literal|0
return|;
case|case
name|CONST
case|:
return|return
name|sparc_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
name|sparc_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|sparc_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
return|return
name|true
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PIC support.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|char
name|pic_helper_symbol_name
index|[
literal|256
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|pic_helper_symbol
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|bool
name|pic_helper_emitted_p
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|global_offset_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Ensure that we are not using patterns that are not OK with PIC.  */
end_comment

begin_function
name|int
name|check_pic
parameter_list|(
name|int
name|i
parameter_list|)
block|{
switch|switch
condition|(
name|flag_pic
condition|)
block|{
case|case
literal|1
case|:
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|!=
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|global_offset_table
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if X is an address which needs a temporary register when     reloaded while generating PIC code.  */
end_comment

begin_function
name|int
name|pic_address_needs_scratch
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
comment|/* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine if a given RTX is a valid constant.  We already know this    satisfies CONSTANT_P.  */
end_comment

begin_function
name|bool
name|legitimate_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|inner
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
comment|/* TLS symbols are not constant.  */
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|CONST
case|:
name|inner
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Offsets of TLS symbols are never valid. 	 Discourage CSE from creating them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLUS
operator|&&
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|true
return|;
comment|/* Floating point constants are generally not ok. 	 The only exception is 0.0 in VIS.  */
if|if
condition|(
name|TARGET_VIS
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|const_zero_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|CONST_VECTOR
case|:
comment|/* Vector constants are generally not ok. 	 The only exception is 0 in VIS.  */
if|if
condition|(
name|TARGET_VIS
operator|&&
name|const_zero_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
default|default:
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine if a given RTX is a valid constant address.  */
end_comment

begin_function
name|bool
name|constant_address_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|HIGH
case|:
return|return
name|true
return|;
case|case
name|CONST
case|:
if|if
condition|(
name|flag_pic
operator|&&
name|pic_address_needs_scratch
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|legitimate_constant_p
argument_list|(
name|x
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
operator|!
name|flag_pic
operator|&&
name|legitimate_constant_p
argument_list|(
name|x
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if the constant value X is a legitimate general operand    when generating PIC code.  It is given that flag_pic is on and    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|bool
name|legitimate_pic_operand_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|pic_address_needs_scratch
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ADDR is a valid memory address.    STRICT specifies whether strict register checking applies.  */
end_comment

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|rtx
name|rs1
init|=
name|NULL
decl_stmt|,
name|rs2
init|=
name|NULL
decl_stmt|,
name|imm1
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
condition|)
name|rs1
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rs1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rs2
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Canonicalize.  REG comes first, if there are no regs, 	 LO_SUM comes first.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|rs1
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|rs1
argument_list|)
operator|!=
name|SUBREG
operator|&&
operator|(
name|REG_P
argument_list|(
name|rs2
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|rs2
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rs2
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|rs1
argument_list|)
operator|!=
name|LO_SUM
operator|)
operator|)
condition|)
block|{
name|rs1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rs2
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag_pic
operator|==
literal|1
operator|&&
name|rs1
operator|==
name|pic_offset_table_rtx
operator|&&
operator|!
name|REG_P
argument_list|(
name|rs2
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|rs2
argument_list|)
operator|!=
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|rs2
argument_list|)
operator|!=
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|rs2
argument_list|)
operator|!=
name|MEM
operator|&&
operator|!
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
name|rs2
argument_list|)
operator|&&
operator|(
operator|!
name|symbolic_operand
argument_list|(
name|rs2
argument_list|,
name|VOIDmode
argument_list|)
operator|||
name|mode
operator|==
name|Pmode
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|rs2
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|SMALL_INT
argument_list|(
name|rs2
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|REG_P
argument_list|(
name|rs1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|rs1
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
name|RTX_OK_FOR_OFFSET_P
argument_list|(
name|rs2
argument_list|)
operator|)
condition|)
block|{
name|imm1
operator|=
name|rs2
expr_stmt|;
name|rs2
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|rs1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|rs1
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|rs2
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|rs2
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
comment|/* We prohibit REG + REG for TFmode when there are no quad move insns 	     and we consequently need to split.  We do this because REG+REG 	     is not an offsettable address.  If we get the situation in reload 	     where source and destination of a movtf pattern are both MEMs with 	     REG+REG address, then only one of them gets converted to an 	     offsettable address.  */
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|&&
operator|!
operator|(
name|TARGET_FPU
operator|&&
name|TARGET_ARCH64
operator|&&
name|TARGET_HARD_QUAD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* We prohibit REG + REG on ARCH32 if not optimizing for 	     DFmode/DImode because then mem_min_alignment is likely to be zero 	     after reload and the  forced split would lack a matching splitter 	     pattern.  */
if|if
condition|(
name|TARGET_ARCH32
operator|&&
operator|!
name|optimize
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DImode
operator|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|USE_AS_OFFSETABLE_LO10
operator|&&
name|GET_CODE
argument_list|(
name|rs1
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|TARGET_ARCH64
operator|&&
operator|!
name|TARGET_CM_MEDMID
operator|&&
name|RTX_OK_FOR_OLO10_P
argument_list|(
name|rs2
argument_list|)
condition|)
block|{
name|rs2
operator|=
name|NULL
expr_stmt|;
name|imm1
operator|=
name|XEXP
argument_list|(
name|rs1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rs1
operator|=
name|XEXP
argument_list|(
name|rs1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|imm1
argument_list|)
operator|||
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
name|rs1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
name|rs1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imm1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|imm1
argument_list|)
operator|||
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
name|rs1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We can't allow TFmode in 32-bit mode, because an offset greater 	 than the alignment (8) may cause the LO_SUM to overflow.  */
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|&&
name|TARGET_ARCH32
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|addr
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rs1
argument_list|)
operator|==
name|SUBREG
condition|)
name|rs1
operator|=
name|SUBREG_REG
argument_list|(
name|rs1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|rs1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rs2
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|rs2
argument_list|)
operator|==
name|SUBREG
condition|)
name|rs2
operator|=
name|SUBREG_REG
argument_list|(
name|rs2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|rs2
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strict
condition|)
block|{
if|if
condition|(
operator|!
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|rs1
argument_list|)
argument_list|)
operator|||
operator|(
name|rs2
operator|&&
operator|!
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|rs2
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|rs1
argument_list|)
operator|>=
literal|32
operator|&&
name|REGNO
argument_list|(
name|rs1
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|rs1
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|rs2
operator|&&
operator|(
name|REGNO
argument_list|(
name|rs2
argument_list|)
operator|>=
literal|32
operator|&&
name|REGNO
argument_list|(
name|rs2
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|rs2
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for the tls_get_offset function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|sparc_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|sparc_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sparc_tls_symbol
condition|)
name|sparc_tls_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
return|return
name|sparc_tls_symbol
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|sparc_tls_got
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|pic_offset_table_rtx
return|;
block|}
if|if
condition|(
operator|!
name|global_offset_table
condition|)
name|global_offset_table
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|global_offset_table
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if *X is a thread-local symbol.  */
end_comment

begin_function
specifier|static
name|int
name|sparc_tls_symbol_ref_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
operator|*
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X contains a thread-local symbol.  */
end_comment

begin_function
name|bool
name|sparc_tls_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAVE_TLS
condition|)
return|return
name|false
return|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|sparc_tls_symbol_ref_1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute    this (thread-local) address.  */
end_comment

begin_function
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|temp3
decl_stmt|,
name|ret
decl_stmt|,
name|o0
decl_stmt|,
name|got
decl_stmt|,
name|insn
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|no_new_pseudos
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
switch|switch
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|o0
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|got
operator|=
name|sparc_tls_got
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tgd_hi22
argument_list|(
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tgd_lo10
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_tgd_add32
argument_list|(
name|o0
argument_list|,
name|got
argument_list|,
name|temp2
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_tgd_call32
argument_list|(
name|o0
argument_list|,
name|sparc_tls_get_addr
argument_list|()
argument_list|,
name|addr
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_tgd_add64
argument_list|(
name|o0
argument_list|,
name|got
argument_list|,
name|temp2
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_tgd_call64
argument_list|(
name|o0
argument_list|,
name|sparc_tls_get_addr
argument_list|()
argument_list|,
name|addr
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|o0
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|ret
argument_list|,
name|o0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|temp3
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|o0
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|got
operator|=
name|sparc_tls_got
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tldm_hi22
argument_list|(
name|temp1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tldm_lo10
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_tldm_add32
argument_list|(
name|o0
argument_list|,
name|got
argument_list|,
name|temp2
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_tldm_call32
argument_list|(
name|o0
argument_list|,
name|sparc_tls_get_addr
argument_list|()
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_tldm_add64
argument_list|(
name|o0
argument_list|,
name|got
argument_list|,
name|temp2
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_tldm_call64
argument_list|(
name|o0
argument_list|,
name|sparc_tls_get_addr
argument_list|()
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|o0
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|temp3
argument_list|,
name|o0
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLD_BASE
argument_list|)
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tldo_hix22
argument_list|(
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tldo_lox10
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_tldo_add32
argument_list|(
name|ret
argument_list|,
name|temp3
argument_list|,
name|temp2
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_tldo_add64
argument_list|(
name|ret
argument_list|,
name|temp3
argument_list|,
name|temp2
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|temp3
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|got
operator|=
name|sparc_tls_got
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tie_hi22
argument_list|(
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tie_lo10
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_tie_ld32
argument_list|(
name|temp3
argument_list|,
name|got
argument_list|,
name|temp2
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_tie_ld64
argument_list|(
name|temp3
argument_list|,
name|got
argument_list|,
name|temp2
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SUN_TLS
condition|)
block|{
name|ret
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_tie_add32
argument_list|(
name|ret
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|7
argument_list|)
argument_list|,
name|temp3
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_tie_add64
argument_list|(
name|ret
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|7
argument_list|)
argument_list|,
name|temp3
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|7
argument_list|)
argument_list|,
name|temp3
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
name|temp1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_tle_hix22_sp32
argument_list|(
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tle_lox10_sp32
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_tle_hix22_sp64
argument_list|(
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_tle_lox10_sp64
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|7
argument_list|)
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* for now ... */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already position-independent,    we return ORIG.  Newly generated position-independent addresses go into a    reg.  This is REG if nonzero, otherwise we allocate register(s) as    necessary.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|rtx
name|pic_ref
decl_stmt|,
name|address
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
comment|/* If not during reload, allocate another temp reg here for loading 	     in the address, so that these instructions can be optimized 	     properly.  */
name|rtx
name|temp_reg
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
comment|/* Must put the SYMBOL_REF inside an UNSPEC here so that cse 	     won't get confused into thinking that these two instructions 	     are loading in the true address of the symbol.  If in the 	     future a PIC rtx exists, that should be used instead.  */
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movdi_high_pic
argument_list|(
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movdi_lo_sum_pic
argument_list|(
name|temp_reg
argument_list|,
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_movsi_high_pic
argument_list|(
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi_lo_sum_pic
argument_list|(
name|temp_reg
argument_list|,
name|temp_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|address
operator|=
name|temp_reg
expr_stmt|;
block|}
else|else
name|address
operator|=
name|orig
expr_stmt|;
name|pic_ref
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
comment|/* Put a REG_EQUAL note on this insn, so that it can be optimized 	 by loop.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|orig
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
argument_list|)
expr_stmt|;
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
comment|/* If we reach here, then something is seriously wrong.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
comment|/* ??? Why do we do this?  */
comment|/* Now movsi_pic_label_ref uses it, but we ought to be checking that        the register is live instead, in case it is eliminated.  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address X    to be legitimate.  If we find one, return the new, valid address.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE is the mode of the operand pointed to by X.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|orig_x
init|=
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|orig_x
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|SPARC_SYMBOL_REF_TLS_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|legitimize_tls_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|x
operator|=
name|copy_to_suggested_reg
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Emit the special PIC helper function.  */
end_comment

begin_function
specifier|static
name|void
name|emit_pic_helper
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pic_name
init|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
index|]
decl_stmt|;
name|int
name|align
decl_stmt|;
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|pic_helper_symbol_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_delayed_branch
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tjmp\t%%o7+8\n\t add\t%%o7, %s, %s\n"
argument_list|,
name|pic_name
argument_list|,
name|pic_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tadd\t%%o7, %s, %s\n\tjmp\t%%o7+8\n\t nop\n"
argument_list|,
name|pic_name
argument_list|,
name|pic_name
argument_list|)
expr_stmt|;
name|pic_helper_emitted_p
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to load the PIC register.  */
end_comment

begin_function
specifier|static
name|void
name|load_pic_register
parameter_list|(
name|bool
name|delay_pic_helper
parameter_list|)
block|{
name|int
name|orig_flag_pic
init|=
name|flag_pic
decl_stmt|;
comment|/* If we haven't initialized the special PIC symbols, do so now.  */
if|if
condition|(
operator|!
name|pic_helper_symbol_name
index|[
literal|0
index|]
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|pic_helper_symbol_name
argument_list|,
literal|"LADDPC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pic_helper_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|pic_helper_symbol_name
argument_list|)
expr_stmt|;
name|global_offset_table
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
block|}
comment|/* If we haven't emitted the special PIC helper function, do so now unless      we are requested to delay it.  */
if|if
condition|(
operator|!
name|delay_pic_helper
operator|&&
operator|!
name|pic_helper_emitted_p
condition|)
name|emit_pic_helper
argument_list|()
expr_stmt|;
name|flag_pic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH64
condition|)
name|emit_insn
argument_list|(
name|gen_load_pcrel_symdi
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|global_offset_table
argument_list|,
name|pic_helper_symbol
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_load_pcrel_symsi
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|global_offset_table
argument_list|,
name|pic_helper_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|flag_pic
operator|=
name|orig_flag_pic
expr_stmt|;
comment|/* Need to emit this whether or not we obey regdecls,      since setjmp/longjmp can cause life info to screw up.      ??? In the case where we don't obey regdecls, this is not sufficient      since we may not fall out the bottom.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if RTX is a MEM which is known to be aligned to at    least a DESIRED byte boundary.  */
end_comment

begin_function
name|int
name|mem_min_alignment
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|int
name|desired
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|base
decl_stmt|,
name|offset
decl_stmt|;
comment|/* If it's not a MEM we can't accept it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* Obviously...  */
if|if
condition|(
operator|!
name|TARGET_UNALIGNED_DOUBLES
operator|&&
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|>=
operator|(
name|unsigned
operator|)
name|desired
condition|)
return|return
literal|1
return|;
comment|/* ??? The rest of the function predates MEM_ALIGN so      there is probably a bit of redundancy.  */
name|addr
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|offset
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* What we are saying here is that if the base 	     REG is aligned properly, the compiler will make 	     sure any REG based index upon it will be so 	     as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|addr
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|!=
name|NULL_RTX
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
comment|/* Check if the compiler has recorded some information 	     about the alignment of the base REG.  If reload has 	     completed, we already matched with proper alignments. 	     If not running global_alloc, reload might give us 	     unaligned pointer to local stack though.  */
if|if
condition|(
operator|(
operator|(
name|cfun
operator|!=
literal|0
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|regno
argument_list|)
operator|>=
name|desired
operator|*
name|BITS_PER_UNIT
operator|)
operator|||
operator|(
name|optimize
operator|&&
name|reload_completed
operator|)
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|&
operator|(
name|desired
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|SPARC_STACK_BIAS
operator|)
operator|&
operator|(
name|desired
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_UNALIGNED_DOUBLES
operator|||
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
comment|/* Anything else we know is properly aligned unless TARGET_UNALIGNED_DOUBLES 	 is true, in which case we can only assume that an access is aligned if 	 it is to a constant address, or the address involves a LO_SUM.  */
return|return
literal|1
return|;
block|}
comment|/* An obviously unaligned address.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Vectors to keep interesting information about registers where it can easily    be got.  We used to use the actual mode value as the bit number, but there    are more than 32 modes now.  Instead we use two tables: one indexed by    hard register number, and one indexed by mode.  */
end_comment

begin_comment
comment|/* The purpose of sparc_mode_class is to shrink the range of modes so that    they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is    mapped into one sparc_mode_class mode.  */
end_comment

begin_enum
enum|enum
name|sparc_mode_class
block|{
name|S_MODE
block|,
name|D_MODE
block|,
name|T_MODE
block|,
name|O_MODE
block|,
name|SF_MODE
block|,
name|DF_MODE
block|,
name|TF_MODE
block|,
name|OF_MODE
block|,
name|CC_MODE
block|,
name|CCFP_MODE
block|}
enum|;
end_enum

begin_comment
comment|/* Modes for single-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|S_MODES
value|((1<< (int) S_MODE) | (1<< (int) SF_MODE))
end_define

begin_comment
comment|/* Modes for double-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|D_MODES
value|(S_MODES | (1<< (int) D_MODE) | (1<< DF_MODE))
end_define

begin_comment
comment|/* Modes for quad-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|T_MODES
value|(D_MODES | (1<< (int) T_MODE) | (1<< (int) TF_MODE))
end_define

begin_comment
comment|/* Modes for 8-word and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|O_MODES
value|(T_MODES | (1<< (int) O_MODE) | (1<< (int) OF_MODE))
end_define

begin_comment
comment|/* Modes for single-float quantities.  We must allow any single word or    smaller quantity.  This is because the fix/float conversion instructions    take integer inputs/outputs from the float registers.  */
end_comment

begin_define
define|#
directive|define
name|SF_MODES
value|(S_MODES)
end_define

begin_comment
comment|/* Modes for double-float and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_MODES
value|(S_MODES | D_MODES)
end_define

begin_comment
comment|/* Modes for double-float only quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_MODES_NO_S
value|((1<< (int) D_MODE) | (1<< (int) DF_MODE))
end_define

begin_comment
comment|/* Modes for quad-float only quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_ONLY_MODES
value|(1<< (int) TF_MODE)
end_define

begin_comment
comment|/* Modes for quad-float and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_MODES
value|(DF_MODES | TF_ONLY_MODES)
end_define

begin_comment
comment|/* Modes for quad-float and double-float quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_MODES_NO_S
value|(DF_MODES_NO_S | TF_ONLY_MODES)
end_define

begin_comment
comment|/* Modes for quad-float pair only quantities.  */
end_comment

begin_define
define|#
directive|define
name|OF_ONLY_MODES
value|(1<< (int) OF_MODE)
end_define

begin_comment
comment|/* Modes for quad-float pairs and smaller quantities.  */
end_comment

begin_define
define|#
directive|define
name|OF_MODES
value|(TF_MODES | OF_ONLY_MODES)
end_define

begin_define
define|#
directive|define
name|OF_MODES_NO_S
value|(TF_MODES_NO_S | OF_ONLY_MODES)
end_define

begin_comment
comment|/* Modes for condition codes.  */
end_comment

begin_define
define|#
directive|define
name|CC_MODES
value|(1<< (int) CC_MODE)
end_define

begin_define
define|#
directive|define
name|CCFP_MODES
value|(1<< (int) CCFP_MODE)
end_define

begin_comment
comment|/* Value is 1 if register/mode pair is acceptable on sparc.    The funny mixture of D and T modes is because integer operations    do not specially operate on tetra quantities, so non-quad-aligned    registers can hold quadword quantities (except %o4 and %i4 because    they cross fixed registers).  */
end_comment

begin_comment
comment|/* This points to either the 32 bit or the 64 bit version.  */
end_comment

begin_decl_stmt
specifier|const
name|int
modifier|*
name|hard_regno_mode_classes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|hard_32bit_mode_classes
index|[]
init|=
block|{
name|S_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
comment|/* FP regs f32 to f63.  Only the even numbered registers actually exist,      and none can hold SFmode/SImode values.  */
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|TF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
comment|/* %fcc[0123] */
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
comment|/* %icc */
name|CC_MODES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|hard_64bit_mode_classes
index|[]
init|=
block|{
name|D_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|O_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|O_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|T_MODES
block|,
name|D_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|OF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
comment|/* FP regs f32 to f63.  Only the even numbered registers actually exist,      and none can hold SFmode/SImode values.  */
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|OF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
name|TF_MODES_NO_S
block|,
literal|0
block|,
name|DF_MODES_NO_S
block|,
literal|0
block|,
comment|/* %fcc[0123] */
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
name|CCFP_MODES
block|,
comment|/* %icc */
name|CC_MODES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sparc_mode_class
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reg_class
name|sparc_regno_reg_class
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sparc_init_modes
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
case|case
name|MODE_COMPLEX_INT
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|<=
literal|4
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|S_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|8
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|D_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|16
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|T_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|32
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|O_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_VECTOR_INT
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|<=
literal|4
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|SF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|8
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|DF_MODE
expr_stmt|;
break|break;
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|<=
literal|4
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|SF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|8
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|DF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|16
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|TF_MODE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|i
argument_list|)
operator|==
literal|32
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|OF_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_CC
case|:
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|CCFPmode
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|CCFPEmode
condition|)
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|CCFP_MODE
expr_stmt|;
else|else
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|int
operator|)
name|CC_MODE
expr_stmt|;
break|break;
default|default:
name|sparc_mode_class
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|TARGET_ARCH64
condition|)
name|hard_regno_mode_classes
operator|=
name|hard_64bit_mode_classes
expr_stmt|;
else|else
name|hard_regno_mode_classes
operator|=
name|hard_32bit_mode_classes
expr_stmt|;
comment|/* Initialize the array used by REGNO_REG_CLASS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|16
operator|&&
name|TARGET_V8PLUS
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|I64_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|32
operator|||
name|i
operator|==
name|FRAME_POINTER_REGNUM
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|GENERAL_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|64
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|FP_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|96
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|EXTRA_FP_REGS
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|100
condition|)
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|FPCC_REGS
expr_stmt|;
else|else
name|sparc_regno_reg_class
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the frame size required by the function.  This function is called    during the reload pass and also by sparc_expand_prologue.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|sparc_compute_frame_size
parameter_list|(
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|leaf_function_p
parameter_list|)
block|{
name|int
name|outgoing_args_size
init|=
operator|(
name|current_function_outgoing_args_size
operator|+
name|REG_PARM_STACK_SPACE
argument_list|(
name|current_function_decl
argument_list|)
operator|)
decl_stmt|;
name|int
name|n_regs
init|=
literal|0
decl_stmt|;
comment|/* N_REGS is the number of 4-byte regs saved thus far.  */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
operator|(
name|TARGET_V9
condition|?
literal|96
else|:
literal|64
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
name|n_regs
operator|+=
literal|2
expr_stmt|;
comment|/* Set up values for use in prologue and epilogue.  */
name|num_gfregs
operator|=
name|n_regs
expr_stmt|;
if|if
condition|(
name|leaf_function_p
operator|&&
name|n_regs
operator|==
literal|0
operator|&&
name|size
operator|==
literal|0
operator|&&
name|current_function_outgoing_args_size
operator|==
literal|0
condition|)
name|actual_fsize
operator|=
name|apparent_fsize
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* We subtract STARTING_FRAME_OFFSET, remember it's negative.  */
name|apparent_fsize
operator|=
operator|(
name|size
operator|-
name|STARTING_FRAME_OFFSET
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
expr_stmt|;
name|apparent_fsize
operator|+=
name|n_regs
operator|*
literal|4
expr_stmt|;
name|actual_fsize
operator|=
name|apparent_fsize
operator|+
operator|(
operator|(
name|outgoing_args_size
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
operator|)
expr_stmt|;
block|}
comment|/* Make sure nothing can clobber our register windows.      If a SAVE must be done, or there is a stack-local variable,      the register window area must be allocated.  */
if|if
condition|(
operator|!
name|leaf_function_p
operator|||
name|size
operator|>
literal|0
condition|)
name|actual_fsize
operator|+=
name|FIRST_PARM_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
return|return
name|SPARC_STACK_ALIGN
argument_list|(
name|actual_fsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output any necessary .register pseudo-ops.  */
end_comment

begin_function
name|void
name|sparc_output_scratch_registers
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_AS_REGISTER_PSEUDO_OP
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
return|return;
comment|/* Check if %g[2367] were used without      .register being printed for them already.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|sparc_hard_reg_printed
index|[
name|i
index|]
condition|)
block|{
name|sparc_hard_reg_printed
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* %g7 is used as TLS base register, use #ignore 	     for it instead of #scratch.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.register\t%%g%d, #%s\n"
argument_list|,
name|i
argument_list|,
name|i
operator|==
literal|7
condition|?
literal|"ignore"
else|:
literal|"scratch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|i
operator|=
literal|5
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Save/restore call-saved registers from LOW to HIGH at BASE+OFFSET    as needed.  LOW should be double-word aligned for 32-bit registers.    Return the new OFFSET.  */
end_comment

begin_define
define|#
directive|define
name|SORR_SAVE
value|0
end_define

begin_define
define|#
directive|define
name|SORR_RESTORE
value|1
end_define

begin_function
specifier|static
name|int
name|save_or_restore_regs
parameter_list|(
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|,
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|rtx
name|mem
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|high
operator|<=
literal|32
condition|)
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|sparc_sr_alias_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SORR_SAVE
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* action == SORR_RESTORE */
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|bool
name|reg0
init|=
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
decl_stmt|;
name|bool
name|reg1
init|=
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|reg0
operator|&&
name|reg1
condition|)
block|{
name|mode
operator|=
name|i
operator|<
literal|32
condition|?
name|DImode
else|:
name|DFmode
expr_stmt|;
name|regno
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg0
condition|)
block|{
name|mode
operator|=
name|i
operator|<
literal|32
condition|?
name|SImode
else|:
name|SFmode
expr_stmt|;
name|regno
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
condition|)
block|{
name|mode
operator|=
name|i
operator|<
literal|32
condition|?
name|SImode
else|:
name|SFmode
expr_stmt|;
name|regno
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
else|else
continue|continue;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|sparc_sr_alias_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SORR_SAVE
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* action == SORR_RESTORE */
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
comment|/* Always preserve double-word alignment.  */
name|offset
operator|=
operator|(
name|offset
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Emit code to save call-saved registers.  */
end_comment

begin_function
specifier|static
name|void
name|emit_save_or_restore_regs
parameter_list|(
name|int
name|action
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|offset
operator|=
name|frame_base_offset
operator|-
name|apparent_fsize
expr_stmt|;
if|if
condition|(
name|offset
operator|<
operator|-
literal|4096
operator|||
name|offset
operator|+
name|num_gfregs
operator|*
literal|4
operator|>
literal|4095
condition|)
block|{
comment|/* ??? This might be optimized a little as %g1 might already have a 	 value close enough that a single add insn will do.  */
comment|/* ??? Although, all of this is probably only a temporary fix 	 because if %g1 can hold a function result, then 	 sparc_expand_epilogue will lose (the result will be 	 clobbered).  */
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|base
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_base_reg
argument_list|,
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|base
operator|=
name|frame_base_reg
expr_stmt|;
name|offset
operator|=
name|save_or_restore_regs
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|save_or_restore_regs
argument_list|(
literal|32
argument_list|,
name|TARGET_V9
condition|?
literal|96
else|:
literal|64
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a save_register_window insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_save_register_window
parameter_list|(
name|rtx
name|increment
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
return|return
name|gen_save_register_windowdi
argument_list|(
name|increment
argument_list|)
return|;
else|else
return|return
name|gen_save_register_windowsi
argument_list|(
name|increment
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate an increment for the stack pointer.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_stack_pointer_inc
parameter_list|(
name|rtx
name|increment
parameter_list|)
block|{
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|increment
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a decrement for the stack pointer.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_stack_pointer_dec
parameter_list|(
name|rtx
name|decrement
parameter_list|)
block|{
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|decrement
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand the function prologue.  The prologue is responsible for reserving    storage for the frame, saving the call-saved registers and loading the    PIC register if needed.  */
end_comment

begin_function
name|void
name|sparc_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Compute a snapshot of current_function_uses_only_leaf_regs.  Relying      on the final value of the flag means deferring the prologue/epilogue      expansion until just before the second scheduling pass, which is too      late to emit multiple epilogues or return insns.       Of course we are making the assumption that the value of the flag      will not change between now and its final value.  Of the three parts      of the formula, only the last one can reasonably vary.  Let's take a      closer look, after assuming that the first two ones are set to true      (otherwise the last value is effectively silenced).       If only_leaf_regs_used returns false, the global predicate will also      be false so the actual frame size calculated below will be positive.      As a consequence, the save_register_window insn will be emitted in      the instruction stream; now this insn explicitly references %fp      which is not a leaf register so only_leaf_regs_used will always      return false subsequently.       If only_leaf_regs_used returns true, we hope that the subsequent      optimization passes won't cause non-leaf registers to pop up.  For      example, the regrename pass has special provisions to not rename to      non-leaf registers in a leaf function.  */
name|sparc_leaf_function_p
operator|=
name|optimize
operator|>
literal|0
operator|&&
name|leaf_function_p
argument_list|()
operator|&&
name|only_leaf_regs_used
argument_list|()
expr_stmt|;
comment|/* Need to use actual_fsize, since we are also allocating      space for our callee (and our own register save area).  */
name|actual_fsize
operator|=
name|sparc_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|,
name|sparc_leaf_function_p
argument_list|)
expr_stmt|;
comment|/* Advertise that the data calculated just above are now valid.  */
name|sparc_prologue_data_valid_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sparc_leaf_function_p
condition|)
block|{
name|frame_base_reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|frame_base_offset
operator|=
name|actual_fsize
operator|+
name|SPARC_STACK_BIAS
expr_stmt|;
block|}
else|else
block|{
name|frame_base_reg
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
name|frame_base_offset
operator|=
name|SPARC_STACK_BIAS
expr_stmt|;
block|}
if|if
condition|(
name|actual_fsize
operator|==
literal|0
condition|)
comment|/* do nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|sparc_leaf_function_p
condition|)
block|{
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_stack_pointer_inc
argument_list|(
name|GEN_INT
argument_list|(
operator|-
name|actual_fsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_stack_pointer_inc
argument_list|(
name|GEN_INT
argument_list|(
operator|-
literal|4096
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* %sp is still the CFA register.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_stack_pointer_inc
argument_list|(
name|GEN_INT
argument_list|(
literal|4096
operator|-
name|actual_fsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|actual_fsize
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_stack_pointer_inc
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_stack_pointer_inc
argument_list|(
name|GEN_INT
argument_list|(
operator|-
name|actual_fsize
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_save_register_window
argument_list|(
name|GEN_INT
argument_list|(
operator|-
name|actual_fsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_save_register_window
argument_list|(
name|GEN_INT
argument_list|(
operator|-
literal|4096
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* %sp is not the CFA register anymore.  */
name|emit_insn
argument_list|(
name|gen_stack_pointer_inc
argument_list|(
name|GEN_INT
argument_list|(
literal|4096
operator|-
name|actual_fsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|actual_fsize
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_save_register_window
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|num_gfregs
condition|)
name|emit_save_or_restore_regs
argument_list|(
name|SORR_SAVE
argument_list|)
expr_stmt|;
comment|/* Load the PIC register if needed.  */
if|if
condition|(
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
condition|)
name|load_pic_register
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function generates the assembly code for function entry, which boils    down to emitting the necessary .register directives.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_asm_function_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Check that the assumption we made in sparc_expand_prologue is valid.  */
name|gcc_assert
argument_list|(
name|sparc_leaf_function_p
operator|==
name|current_function_uses_only_leaf_regs
argument_list|)
expr_stmt|;
name|sparc_output_scratch_registers
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the function epilogue, either normal or part of a sibcall.    We emit all the instructions except the return or the call.  */
end_comment

begin_function
name|void
name|sparc_expand_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|num_gfregs
condition|)
name|emit_save_or_restore_regs
argument_list|(
name|SORR_RESTORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_fsize
operator|==
literal|0
condition|)
comment|/* do nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|sparc_leaf_function_p
condition|)
block|{
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|emit_insn
argument_list|(
name|gen_stack_pointer_dec
argument_list|(
name|GEN_INT
argument_list|(
operator|-
name|actual_fsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_stack_pointer_dec
argument_list|(
name|GEN_INT
argument_list|(
operator|-
literal|4096
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_stack_pointer_dec
argument_list|(
name|GEN_INT
argument_list|(
literal|4096
operator|-
name|actual_fsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|actual_fsize
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_stack_pointer_dec
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true if it is appropriate to emit `return' instructions in the    body of a function.  */
end_comment

begin_function
name|bool
name|sparc_can_use_return_insn_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|sparc_prologue_data_valid_p
operator|&&
operator|(
name|actual_fsize
operator|==
literal|0
operator|||
operator|!
name|sparc_leaf_function_p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This function generates the assembly code for function exit.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_asm_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If code does not drop into the epilogue, we have to still output      a dummy nop for the sake of sane backtraces.  Otherwise, if the      last two instructions of a function were "call foo; dslot;" this      can make the return PC of foo (i.e. address of call instruction      plus 8) point to the first instruction in the next function.  */
name|rtx
name|insn
decl_stmt|,
name|last_real_insn
decl_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_real_insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_real_insn
operator|&&
name|GET_CODE
argument_list|(
name|last_real_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last_real_insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|last_real_insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|last_real_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_real_insn
operator|&&
name|GET_CODE
argument_list|(
name|last_real_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|fputs
argument_list|(
literal|"\tnop\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|sparc_output_deferred_case_vectors
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a 'restore' instruction.  */
end_comment

begin_function
specifier|static
name|void
name|output_restore
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
block|{
name|fputs
argument_list|(
literal|"\t restore\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|pat
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" restore %r1, %2, %Y0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_SUM
case|:
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" restore %r1, %%lo(%a2), %Y0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" restore %r1, %r1, %Y0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|operands
index|[
literal|1
index|]
operator|=
name|pat
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|" restore %%g0, %1, %Y0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output a return.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_return
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|sparc_leaf_function_p
condition|)
block|{
comment|/* This is a leaf function so we don't have to bother restoring the 	 register window, which frees us from dealing with the convoluted 	 semantics of restore/return.  We simply output the jump to the 	 return address and the insn in the delay slot (if any).  */
name|gcc_assert
argument_list|(
operator|!
name|current_function_calls_eh_return
argument_list|)
expr_stmt|;
return|return
literal|"jmp\t%%o7+%)%#"
return|;
block|}
else|else
block|{
comment|/* This is a regular function so we have to restore the register window. 	 We may have a pending insn for the delay slot, which will be either 	 combined with the 'restore' instruction or put in the delay slot of 	 the 'return' instruction.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
comment|/* If the function uses __builtin_eh_return, the eh_return 	     machinery occupies the delay slot.  */
name|gcc_assert
argument_list|(
operator|!
name|final_sequence
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_delayed_branch
condition|)
name|fputs
argument_list|(
literal|"\tadd\t%fp, %g1, %fp\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_V9
condition|)
name|fputs
argument_list|(
literal|"\treturn\t%i7+8\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\trestore\n\tjmp\t%o7+8\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_delayed_branch
condition|)
name|fputs
argument_list|(
literal|"\t add\t%sp, %g1, %sp\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\t nop\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|final_sequence
condition|)
block|{
name|rtx
name|delay
decl_stmt|,
name|pat
decl_stmt|;
name|delay
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_V9
operator|&&
operator|!
name|epilogue_renumber
argument_list|(
operator|&
name|pat
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|epilogue_renumber
argument_list|(
operator|&
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"return\t%%i7+%)%#"
return|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"jmp\t%%i7+%)"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|output_restore
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|delay
argument_list|)
operator|=
name|gen_blockage
argument_list|()
expr_stmt|;
name|INSN_CODE
argument_list|(
name|delay
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The delay slot is empty.  */
if|if
condition|(
name|TARGET_V9
condition|)
return|return
literal|"return\t%%i7+%)\n\t nop"
return|;
elseif|else
if|if
condition|(
name|flag_delayed_branch
condition|)
return|return
literal|"jmp\t%%i7+%)\n\t restore"
return|;
else|else
return|return
literal|"restore\n\tjmp\t%%o7+%)\n\t nop"
return|;
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a sibling call.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_sibcall
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|call_operand
parameter_list|)
block|{
name|rtx
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|flag_delayed_branch
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|call_operand
expr_stmt|;
if|if
condition|(
name|sparc_leaf_function_p
condition|)
block|{
comment|/* This is a leaf function so we don't have to bother restoring the 	 register window.  We simply output the jump to the function and 	 the insn in the delay slot (if any).  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|LEAF_SIBCALL_SLOT_RESERVED_P
operator|&&
name|final_sequence
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_sequence
condition|)
name|output_asm_insn
argument_list|(
literal|"sethi\t%%hi(%a0), %%g1\n\tjmp\t%%g1 + %%lo(%a0)%#"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
comment|/* Use or with rs2 %%g0 instead of mov, so that as/ld can optimize 	   it into branch if possible.  */
name|output_asm_insn
argument_list|(
literal|"or\t%%o7, %%g0, %%g1\n\tcall\t%a0, 0\n\t or\t%%g1, %%g0, %%o7"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a regular function so we have to restore the register window. 	 We may have a pending insn for the delay slot, which will be combined 	 with the 'restore' instruction.  */
name|output_asm_insn
argument_list|(
literal|"call\t%a0, 0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_sequence
condition|)
block|{
name|rtx
name|delay
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|output_restore
argument_list|(
name|PATTERN
argument_list|(
name|delay
argument_list|)
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|delay
argument_list|)
operator|=
name|gen_blockage
argument_list|()
expr_stmt|;
name|INSN_CODE
argument_list|(
name|delay
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|output_restore
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for handling argument passing.     For 32-bit, the first 6 args are normally in registers and the rest are    pushed.  Any arg that starts within the first 6 words is at least    partially passed in a register unless its data type forbids.     For 64-bit, the argument registers are laid out as an array of 16 elements    and arguments are added sequentially.  The first 6 int args and up to the    first 16 fp args (depending on size) are passed in regs.     Slot    Stack   Integral   Float   Float in structure   Double   Long Double    ----    -----   --------   -----   ------------------   ------   -----------     15   [SP+248]              %f31       %f30,%f31         %d30     14   [SP+240]              %f29       %f28,%f29         %d28       %q28     13   [SP+232]              %f27       %f26,%f27         %d26     12   [SP+224]              %f25       %f24,%f25         %d24       %q24     11   [SP+216]              %f23       %f22,%f23         %d22     10   [SP+208]              %f21       %f20,%f21         %d20       %q20      9   [SP+200]              %f19       %f18,%f19         %d18      8   [SP+192]              %f17       %f16,%f17         %d16       %q16      7   [SP+184]              %f15       %f14,%f15         %d14      6   [SP+176]              %f13       %f12,%f13         %d12       %q12      5   [SP+168]     %o5      %f11       %f10,%f11         %d10      4   [SP+160]     %o4       %f9        %f8,%f9           %d8        %q8      3   [SP+152]     %o3       %f7        %f6,%f7           %d6      2   [SP+144]     %o2       %f5        %f4,%f5           %d4        %q4      1   [SP+136]     %o1       %f3        %f2,%f3           %d2      0   [SP+128]     %o0       %f1        %f0,%f1           %d0        %q0     Here SP = %sp if -mno-stack-bias or %sp+stack_bias otherwise.     Integral arguments are always passed as 64-bit quantities appropriately    extended.     Passing of floating point values is handled as follows.    If a prototype is in scope:      If the value is in a named argument (i.e. not a stdarg function or a      value not part of the `...') then the value is passed in the appropriate      fp reg.      If the value is part of the `...' and is passed in one of the first 6      slots then the value is passed in the appropriate int reg.      If the value is part of the `...' and is not passed in one of the first 6      slots then the value is passed in memory.    If a prototype is not in scope:      If the value is one of the first 6 arguments the value is passed in the      appropriate integer reg and the appropriate fp reg.      If the value is not one of the first 6 arguments the value is passed in      the appropriate fp reg and in memory.      Summary of the calling conventions implemented by GCC on SPARC:     32-bit ABI:                                 size      argument     return value        small integer<4       int. reg.      int. reg.       word                        4       int. reg.      int. reg.       double word                 8       int. reg.      int. reg.        _Complex small integer<8       int. reg.      int. reg.       _Complex word               8       int. reg.      int. reg.       _Complex double word       16        memory        int. reg.        vector integer<=8       int. reg.       FP reg.       vector integer>8        memory         memory        float                       4       int. reg.       FP reg.       double                      8       int. reg.       FP reg.       long double                16        memory         memory        _Complex float              8        memory         FP reg.       _Complex double            16        memory         FP reg.       _Complex long double       32        memory         FP reg.        vector float              any        memory         memory        aggregate                 any        memory         memory        64-bit ABI:                                 size      argument     return value        small integer<8       int. reg.      int. reg.       word                        8       int. reg.      int. reg.       double word                16       int. reg.      int. reg.        _Complex small integer<16       int. reg.      int. reg.       _Complex word              16       int. reg.      int. reg.       _Complex double word       32        memory        int. reg.        vector integer<=16        FP reg.        FP reg.       vector integer       16<s<=32        memory         FP reg.       vector integer>32        memory         memory        float                       4        FP reg.        FP reg.       double                      8        FP reg.        FP reg.       long double                16        FP reg.        FP reg.        _Complex float              8        FP reg.        FP reg.       _Complex double            16        FP reg.        FP reg.       _Complex long double       32        memory         FP reg.        vector float<=16        FP reg.        FP reg.       vector float         16<s<=32        memory         FP reg.       vector float>32        memory         memory        aggregate<=16         reg.           reg.       aggregate            16<s<=32        memory          reg.       aggregate>32        memory         memory    Note #1: complex floating-point types follow the extended SPARC ABIs as implemented by the Sun compiler.  Note #2: integral vector types follow the scalar floating-point types conventions to match what is implemented by the Sun VIS SDK.  Note #3: floating-point vector types follow the aggregate types  conventions.  */
end_comment

begin_comment
comment|/* Maximum number of int regs for args.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_INT_ARG_MAX
value|6
end_define

begin_comment
comment|/* Maximum number of fp regs for args.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_FP_ARG_MAX
value|16
end_define

begin_define
define|#
directive|define
name|ROUND_ADVANCE
parameter_list|(
name|SIZE
parameter_list|)
value|(((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
end_define

begin_comment
comment|/* Handle the INIT_CUMULATIVE_ARGS macro.    Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|struct
name|sparc_args
modifier|*
name|cum
parameter_list|,
name|tree
name|fntype
parameter_list|,
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|cum
operator|->
name|words
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|prototype_p
operator|=
name|fntype
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|cum
operator|->
name|libcall_p
operator|=
name|fntype
operator|==
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the TARGET_PROMOTE_PROTOTYPES target hook.    When a prototype says `char' or `short', really pass an `int'.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_promote_prototypes
parameter_list|(
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TARGET_ARCH32
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_comment
comment|/* Handle the TARGET_STRICT_ARGUMENT_NAMING target hook.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_strict_argument_naming
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TARGET_ARCH64
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_comment
comment|/* Scan the record type TYPE and return the following predicates:     - INTREGS_P: the record contains at least one field or sub-field       that is eligible for promotion in integer registers.     - FP_REGS_P: the record contains at least one field or sub-field       that is eligible for promotion in floating-point registers.     - PACKED_P: the record contains at least one field that is packed.     Sub-fields are not taken into account for the PACKED_P predicate.  */
end_comment

begin_function
specifier|static
name|void
name|scan_record_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|intregs_p
parameter_list|,
name|int
modifier|*
name|fpregs_p
parameter_list|,
name|int
modifier|*
name|packed_p
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|scan_record_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|intregs_p
argument_list|,
name|fpregs_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
name|TARGET_FPU
condition|)
operator|*
name|fpregs_p
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|intregs_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|packed_p
operator|&&
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
operator|*
name|packed_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the slot number to pass an argument in.    Return the slot number or -1 if passing on the stack.     CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).    INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.    *PREGNO records the register number to use if scalar type.    *PPADDING records the amount of padding needed in words.  */
end_comment

begin_function
specifier|static
name|int
name|function_arg_slotno
parameter_list|(
specifier|const
name|struct
name|sparc_args
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|,
name|int
name|incoming_p
parameter_list|,
name|int
modifier|*
name|pregno
parameter_list|,
name|int
modifier|*
name|ppadding
parameter_list|)
block|{
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_INCOMING_INT_ARG_FIRST
else|:
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|slotno
init|=
name|cum
operator|->
name|words
decl_stmt|;
name|enum
name|mode_class
name|mclass
decl_stmt|;
name|int
name|regno
decl_stmt|;
operator|*
name|ppadding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TARGET_ARCH32
operator|&&
name|mode
operator|==
name|BLKmode
operator|&&
name|type
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|%
name|PARM_BOUNDARY
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* For SPARC64, objects requiring 16-byte alignment get it.  */
if|if
condition|(
name|TARGET_ARCH64
operator|&&
operator|(
name|type
condition|?
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|>=
literal|128
operator|&&
operator|(
name|slotno
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|slotno
operator|++
operator|,
operator|*
name|ppadding
operator|=
literal|1
expr_stmt|;
name|mclass
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* Vector types deserve special treatment because they are 	 polymorphic wrt their mode, depending upon whether VIS 	 instructions are enabled.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* The SPARC port defines no floating-point vector modes.  */
name|gcc_assert
argument_list|(
name|mode
operator|==
name|BLKmode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Integral vector types should either have a vector 	     mode or an integral mode, because we are guaranteed 	     by pass_by_reference that their size is not greater 	     than 16 bytes and TImode is 16-byte wide.  */
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
comment|/* Vector integers are handled like floats according to 	     the Sun VIS SDK.  */
name|mclass
operator|=
name|MODE_FLOAT
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|mclass
condition|)
block|{
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|TARGET_FPU
operator|&&
name|named
condition|)
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_FP_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|SPARC_FP_ARG_FIRST
operator|+
name|slotno
operator|*
literal|2
expr_stmt|;
comment|/* Arguments filling only one single FP register are 	     right-justified in the outer double FP register.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
condition|)
name|regno
operator|++
expr_stmt|;
break|break;
block|}
comment|/* fallthrough */
case|case
name|MODE_INT
case|:
case|case
name|MODE_COMPLEX_INT
case|:
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
break|break;
case|case
name|MODE_RANDOM
case|:
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
comment|/* MODE is VOIDmode when generating the actual call.  */
return|return
operator|-
literal|1
return|;
name|gcc_assert
argument_list|(
name|mode
operator|==
name|BLKmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
operator|||
operator|!
name|type
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VECTOR_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|regno
operator|=
name|regbase
operator|+
name|slotno
expr_stmt|;
block|}
else|else
comment|/* TARGET_ARCH64&& type */
block|{
name|int
name|intregs_p
init|=
literal|0
decl_stmt|,
name|fpregs_p
init|=
literal|0
decl_stmt|,
name|packed_p
init|=
literal|0
decl_stmt|;
comment|/* First see what kinds of registers we would need.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
name|fpregs_p
operator|=
literal|1
expr_stmt|;
else|else
name|scan_record_type
argument_list|(
name|type
argument_list|,
operator|&
name|intregs_p
argument_list|,
operator|&
name|fpregs_p
argument_list|,
operator|&
name|packed_p
argument_list|)
expr_stmt|;
comment|/* The ABI obviously doesn't specify how packed structures 	     are passed.  These are defined to be passed in int regs 	     if possible, otherwise memory.  */
if|if
condition|(
name|packed_p
operator|||
operator|!
name|named
condition|)
name|fpregs_p
operator|=
literal|0
operator|,
name|intregs_p
operator|=
literal|1
expr_stmt|;
comment|/* If all arg slots are filled, then must pass on stack.  */
if|if
condition|(
name|fpregs_p
operator|&&
name|slotno
operator|>=
name|SPARC_FP_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If there are only int args and all int arg slots are filled, 	     then must pass on stack.  */
if|if
condition|(
operator|!
name|fpregs_p
operator|&&
name|intregs_p
operator|&&
name|slotno
operator|>=
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Note that even if all int arg slots are filled, fp members may 	     still be passed in regs if such regs are available. 	     *PREGNO isn't set because there may be more than one, it's up 	     to the caller to compute them.  */
return|return
name|slotno
return|;
block|}
break|break;
default|default :
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
operator|*
name|pregno
operator|=
name|regno
expr_stmt|;
return|return
name|slotno
return|;
block|}
end_function

begin_comment
comment|/* Handle recursive register counting for structure field layout.  */
end_comment

begin_struct
struct|struct
name|function_arg_record_value_parms
block|{
name|rtx
name|ret
decl_stmt|;
comment|/* return expression being built.  */
name|int
name|slotno
decl_stmt|;
comment|/* slot number of the argument.  */
name|int
name|named
decl_stmt|;
comment|/* whether the argument is named.  */
name|int
name|regbase
decl_stmt|;
comment|/* regno of the base register.  */
name|int
name|stack
decl_stmt|;
comment|/* 1 if part of the argument is on the stack.  */
name|int
name|intoffset
decl_stmt|;
comment|/* offset of the first pending integer field.  */
name|unsigned
name|int
name|nregs
decl_stmt|;
comment|/* number of words passed in registers.  */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|function_arg_record_value_3
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|struct
name|function_arg_record_value_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|function_arg_record_value_2
parameter_list|(
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|struct
name|function_arg_record_value_parms
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|function_arg_record_value_1
parameter_list|(
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|struct
name|function_arg_record_value_parms
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|function_arg_record_value
parameter_list|(
name|tree
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|function_arg_union_value
parameter_list|(
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A subroutine of function_arg_record_value.  Traverse the structure    recursively and determine how many registers will be required.  */
end_comment

begin_function
specifier|static
name|void
name|function_arg_record_value_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|HOST_WIDE_INT
name|startbitpos
parameter_list|,
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
parameter_list|,
name|bool
name|packed_p
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* We need to compute how many registers are needed so we can      allocate the PARALLEL but before we can do that we need to know      whether there are any packed fields.  The ABI obviously doesn't      specify how structures are passed in this case, so they are      defined to be passed in int regs if possible, otherwise memory,      regardless of whether there are fp values present.  */
if|if
condition|(
operator|!
name|packed_p
condition|)
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|packed_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* Compute how many registers we need.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|HOST_WIDE_INT
name|bitpos
init|=
name|startbitpos
decl_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|bitpos
operator|+=
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* ??? FIXME: else assume zero offset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|function_arg_record_value_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|parms
argument_list|,
name|packed_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
name|TARGET_FPU
operator|&&
name|parms
operator|->
name|named
operator|&&
operator|!
name|packed_p
condition|)
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|startbit
decl_stmt|,
name|endbit
decl_stmt|;
name|int
name|intslots
decl_stmt|,
name|this_slotno
decl_stmt|;
name|startbit
operator|=
name|parms
operator|->
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|endbit
operator|=
operator|(
name|bitpos
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
operator|(
name|endbit
operator|-
name|startbit
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|parms
operator|->
name|slotno
operator|+
name|parms
operator|->
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|intslots
operator|>
literal|0
operator|&&
name|intslots
operator|>
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
condition|)
block|{
name|intslots
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
comment|/* We need to pass this field on the stack.  */
name|parms
operator|->
name|stack
operator|=
literal|1
expr_stmt|;
block|}
name|parms
operator|->
name|nregs
operator|+=
name|intslots
expr_stmt|;
name|parms
operator|->
name|intoffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* There's no need to check this_slotno< SPARC_FP_ARG MAX. 		 If it wasn't true we wouldn't be here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|DECL_MODE
argument_list|(
name|field
argument_list|)
operator|==
name|BLKmode
condition|)
name|parms
operator|->
name|nregs
operator|+=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|parms
operator|->
name|nregs
operator|+=
literal|2
expr_stmt|;
else|else
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
name|parms
operator|->
name|intoffset
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of function_arg_record_value.  Assign the bits of the    structure between parms->intoffset and bitpos to integer registers.  */
end_comment

begin_function
specifier|static
name|void
name|function_arg_record_value_3
parameter_list|(
name|HOST_WIDE_INT
name|bitpos
parameter_list|,
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|startbit
decl_stmt|,
name|endbit
decl_stmt|;
name|int
name|this_slotno
decl_stmt|,
name|intslots
decl_stmt|,
name|intoffset
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
return|return;
name|intoffset
operator|=
name|parms
operator|->
name|intoffset
expr_stmt|;
name|parms
operator|->
name|intoffset
operator|=
operator|-
literal|1
expr_stmt|;
name|startbit
operator|=
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|endbit
operator|=
operator|(
name|bitpos
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
operator|(
name|endbit
operator|-
name|startbit
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|parms
operator|->
name|slotno
operator|+
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
name|MIN
argument_list|(
name|intslots
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
if|if
condition|(
name|intslots
operator|<=
literal|0
condition|)
return|return;
comment|/* If this is the trailing part of a word, only load that much into      the register.  Otherwise load the whole register.  Note that in      the latter case we may pick up unwanted bits.  It's not a problem      at the moment but may wish to revisit.  */
if|if
condition|(
name|intoffset
operator|%
name|BITS_PER_WORD
operator|!=
literal|0
condition|)
name|mode
operator|=
name|smallest_mode_for_size
argument_list|(
name|BITS_PER_WORD
operator|-
name|intoffset
operator|%
name|BITS_PER_WORD
argument_list|,
name|MODE_INT
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|word_mode
expr_stmt|;
name|intoffset
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
do|do
block|{
name|regno
operator|=
name|parms
operator|->
name|regbase
operator|+
name|this_slotno
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|parms
operator|->
name|ret
argument_list|,
literal|0
argument_list|,
name|parms
operator|->
name|stack
operator|+
name|parms
operator|->
name|nregs
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|intoffset
argument_list|)
argument_list|)
expr_stmt|;
name|this_slotno
operator|+=
literal|1
expr_stmt|;
name|intoffset
operator|=
operator|(
name|intoffset
operator||
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|mode
operator|=
name|word_mode
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
name|intslots
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|intslots
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* A subroutine of function_arg_record_value.  Traverse the structure    recursively and assign bits to floating point registers.  Track which    bits in between need integer registers; invoke function_arg_record_value_3    to make that happen.  */
end_comment

begin_function
specifier|static
name|void
name|function_arg_record_value_2
parameter_list|(
name|tree
name|type
parameter_list|,
name|HOST_WIDE_INT
name|startbitpos
parameter_list|,
name|struct
name|function_arg_record_value_parms
modifier|*
name|parms
parameter_list|,
name|bool
name|packed_p
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
operator|!
name|packed_p
condition|)
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|packed_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|HOST_WIDE_INT
name|bitpos
init|=
name|startbitpos
decl_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|bitpos
operator|+=
name|int_bit_position
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* ??? FIXME: else assume zero offset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|function_arg_record_value_2
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|parms
argument_list|,
name|packed_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
name|TARGET_FPU
operator|&&
name|parms
operator|->
name|named
operator|&&
operator|!
name|packed_p
condition|)
block|{
name|int
name|this_slotno
init|=
name|parms
operator|->
name|slotno
operator|+
name|bitpos
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|nregs
decl_stmt|,
name|pos
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|DECL_MODE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|function_arg_record_value_3
argument_list|(
name|bitpos
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|nregs
operator|=
literal|1
expr_stmt|;
name|regno
operator|=
name|SPARC_FP_ARG_FIRST
operator|+
name|this_slotno
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|&&
operator|(
name|bitpos
operator|&
literal|32
operator|)
operator|!=
literal|0
condition|)
name|regno
operator|++
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|pos
operator|=
name|bitpos
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|XVECEXP
argument_list|(
name|parms
operator|->
name|ret
argument_list|,
literal|0
argument_list|,
name|parms
operator|->
name|stack
operator|+
name|parms
operator|->
name|nregs
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|nregs
operator|>
literal|0
condition|)
block|{
name|regno
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|4
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|parms
operator|->
name|ret
argument_list|,
literal|0
argument_list|,
name|parms
operator|->
name|stack
operator|+
name|parms
operator|->
name|nregs
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|parms
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parms
operator|->
name|intoffset
operator|==
operator|-
literal|1
condition|)
name|parms
operator|->
name|intoffset
operator|=
name|bitpos
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Used by function_arg and function_value to implement the complex    conventions of the 64-bit ABI for passing and returning structures.    Return an expression valid as a return value for the two macros    FUNCTION_ARG and FUNCTION_VALUE.     TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    MODE is the argument's machine mode.    SLOTNO is the index number of the argument's slot in the parameter array.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).    REGBASE is the regno of the base register for the parameter array.  */
end_comment

begin_function
specifier|static
name|rtx
name|function_arg_record_value
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|slotno
parameter_list|,
name|int
name|named
parameter_list|,
name|int
name|regbase
parameter_list|)
block|{
name|HOST_WIDE_INT
name|typesize
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|function_arg_record_value_parms
name|parms
decl_stmt|;
name|unsigned
name|int
name|nregs
decl_stmt|;
name|parms
operator|.
name|ret
operator|=
name|NULL_RTX
expr_stmt|;
name|parms
operator|.
name|slotno
operator|=
name|slotno
expr_stmt|;
name|parms
operator|.
name|named
operator|=
name|named
expr_stmt|;
name|parms
operator|.
name|regbase
operator|=
name|regbase
expr_stmt|;
name|parms
operator|.
name|stack
operator|=
literal|0
expr_stmt|;
comment|/* Compute how many registers we need.  */
name|parms
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
name|parms
operator|.
name|intoffset
operator|=
literal|0
expr_stmt|;
name|function_arg_record_value_1
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|parms
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Take into account pending integer fields.  */
if|if
condition|(
name|parms
operator|.
name|intoffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|startbit
decl_stmt|,
name|endbit
decl_stmt|;
name|int
name|intslots
decl_stmt|,
name|this_slotno
decl_stmt|;
name|startbit
operator|=
name|parms
operator|.
name|intoffset
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|endbit
operator|=
operator|(
name|typesize
operator|*
name|BITS_PER_UNIT
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|BITS_PER_WORD
expr_stmt|;
name|intslots
operator|=
operator|(
name|endbit
operator|-
name|startbit
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|this_slotno
operator|=
name|slotno
operator|+
name|parms
operator|.
name|intoffset
operator|/
name|BITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|intslots
operator|>
literal|0
operator|&&
name|intslots
operator|>
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
condition|)
block|{
name|intslots
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|SPARC_INT_ARG_MAX
operator|-
name|this_slotno
argument_list|)
expr_stmt|;
comment|/* We need to pass this field on the stack.  */
name|parms
operator|.
name|stack
operator|=
literal|1
expr_stmt|;
block|}
name|parms
operator|.
name|nregs
operator|+=
name|intslots
expr_stmt|;
block|}
name|nregs
operator|=
name|parms
operator|.
name|nregs
expr_stmt|;
comment|/* Allocate the vector and handle some annoying special cases.  */
if|if
condition|(
name|nregs
operator|==
literal|0
condition|)
block|{
comment|/* ??? Empty structure has no value?  Duh?  */
if|if
condition|(
name|typesize
operator|<=
literal|0
condition|)
block|{
comment|/* Though there's nothing really to store, return a word register 	     anyway so the rest of gcc doesn't go nuts.  Returning a PARALLEL 	     leads to breakage due to the fact that there are zero bytes to 	     load.  */
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regbase
argument_list|)
return|;
block|}
else|else
block|{
comment|/* ??? C++ has structures with no fields, and yet a size.  Give up 	     for now and pass everything back in integer registers.  */
name|nregs
operator|=
operator|(
name|typesize
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|+
name|slotno
operator|>
name|SPARC_INT_ARG_MAX
condition|)
name|nregs
operator|=
name|SPARC_INT_ARG_MAX
operator|-
name|slotno
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|nregs
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|.
name|ret
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|rtvec_alloc
argument_list|(
name|parms
operator|.
name|stack
operator|+
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If at least one field must be passed on the stack, generate      (parallel [(expr_list (nil) ...) ...]) so that all fields will      also be passed on the stack.  We can't do much better because the      semantics of TARGET_ARG_PARTIAL_BYTES doesn't handle the case      of structures for which the fields passed exclusively in registers      are not at the beginning of the structure.  */
if|if
condition|(
name|parms
operator|.
name|stack
condition|)
name|XVECEXP
argument_list|(
name|parms
operator|.
name|ret
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* Fill in the entries.  */
name|parms
operator|.
name|nregs
operator|=
literal|0
expr_stmt|;
name|parms
operator|.
name|intoffset
operator|=
literal|0
expr_stmt|;
name|function_arg_record_value_2
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|parms
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|function_arg_record_value_3
argument_list|(
name|typesize
operator|*
name|BITS_PER_UNIT
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parms
operator|.
name|nregs
operator|==
name|nregs
argument_list|)
expr_stmt|;
return|return
name|parms
operator|.
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Used by function_arg and function_value to implement the conventions    of the 64-bit ABI for passing and returning unions.    Return an expression valid as a return value for the two macros    FUNCTION_ARG and FUNCTION_VALUE.     SIZE is the size in bytes of the union.    MODE is the argument's machine mode.    REGNO is the hard register the union will be passed in.  */
end_comment

begin_function
specifier|static
name|rtx
name|function_arg_union_value
parameter_list|(
name|int
name|size
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|slotno
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|nwords
init|=
name|ROUND_ADVANCE
argument_list|(
name|size
argument_list|)
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|regs
decl_stmt|;
comment|/* See comment in previous function for empty structures.  */
if|if
condition|(
name|nwords
operator|==
literal|0
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
if|if
condition|(
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|1
condition|)
name|nwords
operator|=
literal|1
expr_stmt|;
name|regs
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nwords
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
comment|/* Unions are passed left-justified.  */
name|XVECEXP
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|UNITS_PER_WORD
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
return|return
name|regs
return|;
block|}
end_function

begin_comment
comment|/* Used by function_arg and function_value to implement the conventions    for passing and returning large (BLKmode) vectors.    Return an expression valid as a return value for the two macros    FUNCTION_ARG and FUNCTION_VALUE.     SIZE is the size in bytes of the vector.    BASE_MODE is the argument's base machine mode.    REGNO is the FP hard register the vector will be passed in.  */
end_comment

begin_function
specifier|static
name|rtx
name|function_arg_vector_value
parameter_list|(
name|int
name|size
parameter_list|,
name|enum
name|machine_mode
name|base_mode
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|unsigned
name|short
name|base_mode_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|base_mode
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|size
operator|/
name|base_mode_size
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|regs
decl_stmt|;
name|regs
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|BLKmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nregs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
name|XVECEXP
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|base_mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|base_mode_size
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|+=
name|base_mode_size
operator|/
literal|4
expr_stmt|;
block|}
return|return
name|regs
return|;
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG macro.    Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).    INCOMING_P is zero for FUNCTION_ARG, nonzero for FUNCTION_INCOMING_ARG.  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
specifier|const
name|struct
name|sparc_args
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|,
name|int
name|incoming_p
parameter_list|)
block|{
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_INCOMING_INT_ARG_FIRST
else|:
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
name|enum
name|mode_class
name|mclass
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
name|incoming_p
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotno
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Vector types deserve special treatment because they are polymorphic wrt      their mode, depending upon whether VIS instructions are enabled.  */
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|TARGET_ARCH32
operator|&&
name|size
operator|<=
literal|8
operator|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|size
operator|<=
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
return|return
name|function_arg_vector_value
argument_list|(
name|size
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|SPARC_FP_ARG_FIRST
operator|+
literal|2
operator|*
name|slotno
argument_list|)
return|;
else|else
name|mclass
operator|=
name|MODE_FLOAT
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ARCH32
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
comment|/* Structures up to 16 bytes in size are passed in arg slots on the stack      and are promoted to registers if possible.  */
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|16
argument_list|)
expr_stmt|;
return|return
name|function_arg_record_value
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
name|slotno
argument_list|,
name|named
argument_list|,
name|regbase
argument_list|)
return|;
block|}
comment|/* Unions up to 16 bytes in size are passed in integer registers.  */
elseif|else
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|16
argument_list|)
expr_stmt|;
return|return
name|function_arg_union_value
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|slotno
argument_list|,
name|regno
argument_list|)
return|;
block|}
comment|/* v9 fp args in reg slots beyond the int reg slots get passed in regs      but also have the slot allocated for them.      If no prototype is in scope fp values in register slots get passed      in two places, either fp regs and int regs or fp regs and memory.  */
elseif|else
if|if
condition|(
operator|(
name|mclass
operator|==
name|MODE_FLOAT
operator|||
name|mclass
operator|==
name|MODE_COMPLEX_FLOAT
operator|)
operator|&&
name|SPARC_FP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|prototype_p
operator|||
name|cum
operator|->
name|libcall_p
condition|)
block|{
comment|/* "* 2" because fp reg numbers are recorded in 4 byte 	     quantities.  */
if|#
directive|if
literal|0
comment|/* ??? This will cause the value to be passed in the fp reg and 	     in the stack.  When a prototype exists we want to pass the 	     value in the reg but reserve space on the stack.  That's an 	     optimization, and is deferred [for a bit].  */
block|if ((regno - SPARC_FP_ARG_FIRST)>= SPARC_INT_ARG_MAX * 2) 	    return gen_rtx_PARALLEL (mode, 			    gen_rtvec (2, 				       gen_rtx_EXPR_LIST (VOIDmode, 						NULL_RTX, const0_rtx), 				       gen_rtx_EXPR_LIST (VOIDmode, 						reg, const0_rtx))); 	  else
else|#
directive|else
comment|/* ??? It seems that passing back a register even when past 	     the area declared by REG_PARM_STACK_SPACE will allocate 	     space appropriately, and will not copy the data onto the 	     stack, exactly as we desire.  	     This is due to locate_and_pad_parm being called in 	     expand_call whenever reg_parm_stack_space> 0, which 	     while beneficial to our example here, would seem to be 	     in error from what had been intended.  Ho hum...  -- r~ */
endif|#
directive|endif
return|return
name|reg
return|;
block|}
else|else
block|{
name|rtx
name|v0
decl_stmt|,
name|v1
decl_stmt|;
if|if
condition|(
operator|(
name|regno
operator|-
name|SPARC_FP_ARG_FIRST
operator|)
operator|<
name|SPARC_INT_ARG_MAX
operator|*
literal|2
condition|)
block|{
name|int
name|intreg
decl_stmt|;
comment|/* On incoming, we don't need to know that the value 		 is passed in %f0 and %i0, and it confuses other parts 		 causing needless spillage even on the simplest cases.  */
if|if
condition|(
name|incoming_p
condition|)
return|return
name|reg
return|;
name|intreg
operator|=
operator|(
name|SPARC_OUTGOING_INT_ARG_FIRST
operator|+
operator|(
name|regno
operator|-
name|SPARC_FP_ARG_FIRST
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|v0
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|v1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|v0
argument_list|,
name|v1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|v0
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|v1
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|v0
argument_list|,
name|v1
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/* All other aggregate types are passed in an integer register in a mode      corresponding to the size of the type.  */
elseif|else
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|16
argument_list|)
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For an arg passed partly in registers and partly in memory,    this is the number of bytes of registers used.    For args passed entirely in registers or entirely in memory, zero.     Any arg that starts in the first 6 regs but won't entirely fit in them    needs partial registers on v8.  On v9, structures with integer    values in arg slots 5,6 will be passed in %o5 and SP+176, and complex fp    values that begin in the last fp reg [where "last fp reg" varies with the    mode] will be split between that reg and memory.  */
end_comment

begin_function
specifier|static
name|int
name|sparc_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
parameter_list|)
block|{
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
comment|/* We pass 0 for incoming_p here, it doesn't matter.  */
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
literal|0
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotno
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
if|if
condition|(
operator|(
name|slotno
operator|+
operator|(
name|mode
operator|==
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
operator|)
operator|>
name|SPARC_INT_ARG_MAX
condition|)
return|return
operator|(
name|SPARC_INT_ARG_MAX
operator|-
name|slotno
operator|)
operator|*
name|UNITS_PER_WORD
return|;
block|}
else|else
block|{
comment|/* We are guaranteed by pass_by_reference that the size of the 	 argument is not greater than 16 bytes, so we only need to return 	 one word if the argument is partially passed in registers.  */
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|UNITS_PER_WORD
operator|&&
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|1
condition|)
return|return
name|UNITS_PER_WORD
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|&&
operator|!
operator|(
name|TARGET_FPU
operator|&&
name|named
operator|)
operator|)
condition|)
block|{
comment|/* The complex types are passed as packed types.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|slotno
operator|==
name|SPARC_INT_ARG_MAX
operator|-
literal|1
condition|)
return|return
name|UNITS_PER_WORD
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
if|if
condition|(
operator|(
name|slotno
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|>
name|SPARC_FP_ARG_MAX
condition|)
return|return
name|UNITS_PER_WORD
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle the TARGET_PASS_BY_REFERENCE target hook.    Specify whether to pass the argument by reference.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ARCH32
condition|)
comment|/* Original SPARC 32-bit ABI says that structures and unions,        and quad-precision floats are passed by reference.  For Pascal,        also pass arrays by reference.  All other base types are passed        in registers.         Extended ABI (as implemented by the Sun compiler) says that all        complex floats are passed by reference.  Pass complex integers        in registers up to 8 bytes.  More generally, enforce the 2-word        cap for passing arguments in registers.         Vector ABI (as implemented by the Sun VIS SDK) says that vector        integers are passed like floats of the same size, that is in        registers up to 8 bytes.  Pass all vector floats by reference        like structure and unions.  */
return|return
operator|(
operator|(
name|type
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|VECTOR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|||
name|mode
operator|==
name|SCmode
comment|/* Catch CDImode, TFmode, DCmode and TCmode.  */
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|8
operator|||
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|)
operator|)
return|;
else|else
comment|/* Original SPARC 64-bit ABI says that structures and unions        smaller than 16 bytes are passed in registers, as well as        all other base types.                Extended ABI (as implemented by the Sun compiler) says that        complex floats are passed in registers up to 16 bytes.  Pass        all complex integers in registers up to 16 bytes.  More generally,        enforce the 2-word cap for passing arguments in registers.         Vector ABI (as implemented by the Sun VIS SDK) says that vector        integers are passed like floats of the same size, that is in        registers (up to 16 bytes).  Pass all vector floats like structure        and unions.  */
return|return
operator|(
operator|(
name|type
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|16
operator|)
comment|/* Catch CTImode and TCmode.  */
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_ADVANCE macro.    Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    TYPE is null for libcalls where that information may not be available.  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|struct
name|sparc_args
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|int
name|slotno
decl_stmt|,
name|regno
decl_stmt|,
name|padding
decl_stmt|;
comment|/* We pass 0 for incoming_p here, it doesn't matter.  */
name|slotno
operator|=
name|function_arg_slotno
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
literal|0
argument_list|,
operator|&
name|regno
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
comment|/* If register required leading padding, add it.  */
if|if
condition|(
name|slotno
operator|!=
operator|-
literal|1
condition|)
name|cum
operator|->
name|words
operator|+=
name|padding
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|cum
operator|->
name|words
operator|+=
operator|(
name|mode
operator|!=
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|8
condition|)
operator|++
name|cum
operator|->
name|words
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
literal|16
condition|)
name|cum
operator|->
name|words
operator|+=
literal|2
expr_stmt|;
else|else
comment|/* passed by reference */
operator|++
name|cum
operator|->
name|words
expr_stmt|;
block|}
else|else
block|{
name|cum
operator|->
name|words
operator|+=
operator|(
name|mode
operator|!=
name|BLKmode
condition|?
name|ROUND_ADVANCE
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
else|:
name|ROUND_ADVANCE
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle the FUNCTION_ARG_PADDING macro.    For the 64 bit ABI structs are always stored left shifted in their    argument slot.  */
end_comment

begin_function
name|enum
name|direction
name|function_arg_padding
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|type
operator|!=
literal|0
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|upward
return|;
comment|/* Fall back to the default.  */
return|return
name|DEFAULT_FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle the TARGET_RETURN_IN_MEMORY target hook.    Specify whether to return the return value in memory.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ARCH32
condition|)
comment|/* Original SPARC 32-bit ABI says that structures and unions,        and quad-precision floats are returned in memory.  All other        base types are returned in registers.         Extended ABI (as implemented by the Sun compiler) says that        all complex floats are returned in registers (8 FP registers        at most for '_Complex long double').  Return all complex integers        in registers (4 at most for '_Complex long long').         Vector ABI (as implemented by the Sun VIS SDK) says that vector        integers are returned like floats of the same size, that is in        registers up to 8 bytes and in memory otherwise.  Return all        vector floats in memory like structure and unions; note that        they always have BLKmode like the latter.  */
return|return
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|)
operator|)
return|;
else|else
comment|/* Original SPARC 64-bit ABI says that structures and unions        smaller than 32 bytes are returned in registers, as well as        all other base types.                Extended ABI (as implemented by the Sun compiler) says that all        complex floats are returned in registers (8 FP registers at most        for '_Complex long double').  Return all complex integers in        registers (4 at most for '_Complex TItype').         Vector ABI (as implemented by the Sun VIS SDK) says that vector        integers are returned like floats of the same size, that is in        registers.  Return all vector floats like structure and unions;        note that they always have BLKmode like the latter.  */
return|return
operator|(
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|32
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle the TARGET_STRUCT_VALUE target hook.    Return where to find the structure return value address.  */
end_comment

begin_function
specifier|static
name|rtx
name|sparc_struct_value_rtx
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|int
name|incoming
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ARCH64
condition|)
return|return
literal|0
return|;
else|else
block|{
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|incoming
condition|)
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|STRUCT_VALUE_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STRUCT_VALUE_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only follow the SPARC ABI for fixed-size structure returns.           Variable size structure returns are handled per the normal           procedures in GCC. This is enabled by -mstd-struct-return */
if|if
condition|(
name|incoming
operator|==
literal|2
operator|&&
name|sparc_std_struct_return
operator|&&
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* We must check and adjust the return address, as it is 	     optional as to whether the return object is really 	     provided.  */
name|rtx
name|ret_rtx
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|31
argument_list|)
decl_stmt|;
name|rtx
name|scratch
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|endlab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Calculate the return object size */
name|tree
name|size
init|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|size_rtx
init|=
name|GEN_INT
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|&
literal|0xfff
argument_list|)
decl_stmt|;
comment|/* Construct a temporary return value */
name|rtx
name|temp_val
init|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Implement SPARC 32-bit psABI callee returns struck checking 	     requirements:  	     	      Fetch the instruction where we will return to and see if 	     it's an unimp instruction (the most significant 10 bits 	     will be zero).  */
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|ret_rtx
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assume the size is valid and pre-adjust */
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|ret_rtx
argument_list|,
name|ret_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|scratch
argument_list|,
name|size_rtx
argument_list|,
name|EQ
argument_list|,
name|const0_rtx
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|,
name|endlab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sub3_insn
argument_list|(
name|ret_rtx
argument_list|,
name|ret_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assign stack temp:  	     Write the address of the memory pointed to by temp_val into 	     the memory pointed to by mem */
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|XEXP
argument_list|(
name|temp_val
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|endlab
argument_list|)
expr_stmt|;
block|}
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|struct_value_alias_set
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
block|}
end_function

begin_comment
comment|/* Handle FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE, and LIBCALL_VALUE macros.    For v9, function return values are subject to the same rules as arguments,    except that up to 32 bytes may be returned in registers.  */
end_comment

begin_function
name|rtx
name|function_value
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|incoming_p
parameter_list|)
block|{
comment|/* Beware that the two values are swapped here wrt function_arg.  */
name|int
name|regbase
init|=
operator|(
name|incoming_p
condition|?
name|SPARC_OUTGOING_INT_ARG_FIRST
else|:
name|SPARC_INCOMING_INT_ARG_FIRST
operator|)
decl_stmt|;
name|enum
name|mode_class
name|mclass
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* Vector types deserve special treatment because they are polymorphic wrt      their mode, depending upon whether VIS instructions are enabled.  */
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|TARGET_ARCH32
operator|&&
name|size
operator|<=
literal|8
operator|)
operator|||
operator|(
name|TARGET_ARCH64
operator|&&
name|size
operator|<=
literal|32
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
return|return
name|function_arg_vector_value
argument_list|(
name|size
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|SPARC_FP_ARG_FIRST
argument_list|)
return|;
else|else
name|mclass
operator|=
name|MODE_FLOAT
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|type
condition|)
block|{
comment|/* Structures up to 32 bytes in size are returned in registers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|32
argument_list|)
expr_stmt|;
return|return
name|function_arg_record_value
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|regbase
argument_list|)
return|;
block|}
comment|/* Unions up to 32 bytes in size are returned in integer registers.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|32
argument_list|)
expr_stmt|;
return|return
name|function_arg_union_value
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|regbase
argument_list|)
return|;
block|}
comment|/* Objects that require it are returned in FP registers.  */
elseif|else
if|if
condition|(
name|mclass
operator|==
name|MODE_FLOAT
operator|||
name|mclass
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
empty_stmt|;
comment|/* All other aggregate types are returned in an integer register in a 	 mode corresponding to the size of the type.  */
elseif|else
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* All other aggregate types are passed in an integer register 	     in a mode corresponding to the size of the type.  */
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|32
argument_list|)
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? We probably should have made the same ABI change in 	     3.4.0 as the one we made for unions.   The latter was 	     required by the SCD though, while the former is not 	     specified, so we favored compatibility and efficiency.  	     Now we're stuck for aggregates larger than 16 bytes, 	     because OImode vanished in the meantime.  Let's not 	     try to be unduly clever, and simply follow the ABI 	     for unions in that case.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
return|return
name|function_arg_union_value
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|regbase
argument_list|)
return|;
else|else
name|mclass
operator|=
name|MODE_INT
expr_stmt|;
block|}
comment|/* This must match PROMOTE_FUNCTION_MODE.  */
elseif|else
if|if
condition|(
name|mclass
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|mode
operator|=
name|word_mode
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mclass
operator|==
name|MODE_FLOAT
operator|||
name|mclass
operator|==
name|MODE_COMPLEX_FLOAT
operator|)
operator|&&
name|TARGET_FPU
condition|)
name|regno
operator|=
name|SPARC_FP_ARG_FIRST
expr_stmt|;
else|else
name|regno
operator|=
name|regbase
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do what is necessary for `va_start'.  We look at the current function    to determine if stdarg or varargs is used and return the address of    the first unnamed parameter.  */
end_comment

begin_function
specifier|static
name|rtx
name|sparc_builtin_saveregs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|first_reg
init|=
name|current_function_args_info
operator|.
name|words
decl_stmt|;
name|rtx
name|address
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|first_reg
init|;
name|regno
operator|<
name|SPARC_INT_ARG_MAX
condition|;
name|regno
operator|++
control|)
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|*
name|regno
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|SPARC_INCOMING_INT_ARG_FIRST
operator|+
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|*
name|first_reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|address
return|;
block|}
end_function

begin_comment
comment|/* Implement `va_start' for stdarg.  */
end_comment

begin_function
name|void
name|sparc_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
parameter_list|)
block|{
name|nextarg
operator|=
name|expand_builtin_saveregs
argument_list|()
expr_stmt|;
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement `va_arg' for stdarg.  */
end_comment

begin_function
specifier|static
name|tree
name|sparc_gimplify_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|rsize
decl_stmt|,
name|align
decl_stmt|;
name|tree
name|addr
decl_stmt|,
name|incr
decl_stmt|;
name|bool
name|indirect
decl_stmt|;
name|tree
name|ptrtype
init|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|pass_by_reference
argument_list|(
name|NULL
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|indirect
operator|=
name|true
expr_stmt|;
name|size
operator|=
name|rsize
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|indirect
operator|=
name|false
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rsize
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|UNITS_PER_WORD
expr_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
comment|/* For SPARC64, objects requiring 16-byte alignment get it.  */
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
literal|2
operator|*
operator|(
name|unsigned
operator|)
name|BITS_PER_WORD
condition|)
name|align
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
comment|/* SPARC-V9 ABI states that structures up to 16 bytes in size 	     are left-justified in their slots.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|rsize
operator|=
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|size
operator|=
name|rsize
expr_stmt|;
block|}
block|}
block|}
name|incr
operator|=
name|valist
expr_stmt|;
if|if
condition|(
name|align
condition|)
block|{
name|incr
operator|=
name|fold
argument_list|(
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|incr
argument_list|,
name|ssize_int
argument_list|(
name|align
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|incr
operator|=
name|fold
argument_list|(
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|incr
argument_list|,
name|ssize_int
argument_list|(
operator|-
name|align
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimplify_expr
argument_list|(
operator|&
name|incr
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|addr
operator|=
name|incr
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|size
operator|<
name|rsize
condition|)
name|addr
operator|=
name|fold
argument_list|(
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|incr
argument_list|,
name|ssize_int
argument_list|(
name|rsize
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
block|{
name|addr
operator|=
name|fold_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|ptrtype
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* If the address isn't aligned properly for the type,      we may need to copy to a temporary.        FIXME: This is inefficient.  Usually we can do this      in registers.  */
elseif|else
if|if
condition|(
name|align
operator|==
literal|0
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|tree
name|tmp
init|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"va_arg_tmp"
argument_list|)
decl_stmt|;
name|tree
name|dest_addr
init|=
name|build_fold_addr_expr
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|tree
name|copy
init|=
name|build_function_call_expr
argument_list|(
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dest_addr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_int
argument_list|(
name|rsize
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|gimplify_and_add
argument_list|(
name|copy
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|addr
operator|=
name|dest_addr
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|fold_convert
argument_list|(
name|ptrtype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|incr
operator|=
name|fold
argument_list|(
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|incr
argument_list|,
name|ssize_int
argument_list|(
name|rsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|incr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|valist
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|incr
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
return|return
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement the TARGET_VECTOR_MODE_SUPPORTED_P target hook.    Specify whether the vector mode is supported by the hardware.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|TARGET_VIS
operator|&&
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the string to output an unconditional branch to LABEL, which is    the operand number of the label.     DEST is the destination insn (i.e. the label), INSN is the source.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_ubranch
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|int
name|label
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
literal|64
index|]
decl_stmt|;
name|bool
name|v9_form
init|=
name|false
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|TARGET_V9
operator|&&
name|INSN_ADDRESSES_SET_P
argument_list|()
condition|)
block|{
name|int
name|delta
init|=
operator|(
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Leave some instructions for "slop".  */
if|if
condition|(
name|delta
operator|>=
operator|-
literal|260000
operator|&&
name|delta
operator|<
literal|260000
condition|)
name|v9_form
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|v9_form
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"ba%*,pt\t%%xcc, "
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"b%*\t"
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'l'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|label
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'('
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, which is    the operand number of the label.  OP is the conditional expression.    XEXP (OP, 0) is assumed to be a condition code register (integer or    floating point) and its mode specifies what kind of comparison we made.     DEST is the destination insn (i.e. the label), INSN is the source.     REVERSED is nonzero if we should reverse the sense of the comparison.     ANNUL is nonzero if we should generate an annulling branch.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_cbranch
parameter_list|(
name|rtx
name|op
parameter_list|,
name|rtx
name|dest
parameter_list|,
name|int
name|label
parameter_list|,
name|int
name|reversed
parameter_list|,
name|int
name|annul
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
literal|64
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|cc_reg
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|labelno
decl_stmt|,
modifier|*
name|branch
decl_stmt|;
name|int
name|spaces
init|=
literal|8
decl_stmt|,
name|far
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* v9 branches are limited to +-1MB.  If it is too far away,      change       bne,pt %xcc, .LC30       to       be,pn %xcc, .+12       nop      ba .LC30       and       fbne,a,pn %fcc2, .LC29       to       fbe,pt %fcc2, .+16       nop      ba .LC29  */
name|far
operator|=
name|TARGET_V9
operator|&&
operator|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|>=
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|reversed
operator|^
name|far
condition|)
block|{
comment|/* Reversal of FP compares takes care -- an ordered compare 	 becomes an unordered compare and vice versa.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Start by writing the branch condition.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
name|branch
operator|=
literal|"fbne"
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|branch
operator|=
literal|"fbe"
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|branch
operator|=
literal|"fbge"
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|branch
operator|=
literal|"fbg"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|branch
operator|=
literal|"fble"
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|branch
operator|=
literal|"fbl"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|branch
operator|=
literal|"fbu"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|branch
operator|=
literal|"fbo"
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
name|branch
operator|=
literal|"fbug"
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|branch
operator|=
literal|"fbul"
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|branch
operator|=
literal|"fbue"
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|branch
operator|=
literal|"fbuge"
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|branch
operator|=
literal|"fbule"
expr_stmt|;
break|break;
case|case
name|LTGT
case|:
name|branch
operator|=
literal|"fblg"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* ??? !v9: FP branches cannot be preceded by another floating point 	 insn.  Because there is currently no concept of pre-delay slots, 	 we can fix this only by always emitting a nop before a floating 	 point branch.  */
name|string
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_V9
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"nop\n\t"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
name|branch
operator|=
literal|"bne"
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|branch
operator|=
literal|"be"
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|mode
operator|==
name|CC_NOOVmode
operator|||
name|mode
operator|==
name|CCX_NOOVmode
condition|)
name|branch
operator|=
literal|"bpos"
expr_stmt|;
else|else
name|branch
operator|=
literal|"bge"
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|branch
operator|=
literal|"bg"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|branch
operator|=
literal|"ble"
expr_stmt|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|mode
operator|==
name|CC_NOOVmode
operator|||
name|mode
operator|==
name|CCX_NOOVmode
condition|)
name|branch
operator|=
literal|"bneg"
expr_stmt|;
else|else
name|branch
operator|=
literal|"bl"
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|branch
operator|=
literal|"bgeu"
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|branch
operator|=
literal|"bgu"
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|branch
operator|=
literal|"bleu"
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|branch
operator|=
literal|"blu"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|string
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
name|spaces
operator|-=
name|strlen
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* Now add the annulling, the label, and a possible noop.  */
if|if
condition|(
name|annul
operator|&&
operator|!
name|far
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|",a"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|spaces
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_V9
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|int
name|v8
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|far
operator|&&
name|insn
operator|&&
name|INSN_ADDRESSES_SET_P
argument_list|()
condition|)
block|{
name|int
name|delta
init|=
operator|(
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Leave some instructions for "slop".  */
if|if
condition|(
name|delta
operator|<
operator|-
literal|260000
operator|||
name|delta
operator|>=
literal|260000
condition|)
name|v8
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
specifier|static
name|char
name|v9_fcc_labelno
index|[]
init|=
literal|"%%fccX, "
decl_stmt|;
comment|/* Set the char indicating the number of the fcc reg to use.  */
name|v9_fcc_labelno
index|[
literal|5
index|]
operator|=
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
operator|-
name|SPARC_FIRST_V9_FCC_REG
operator|+
literal|'0'
expr_stmt|;
name|labelno
operator|=
name|v9_fcc_labelno
expr_stmt|;
if|if
condition|(
name|v8
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|cc_reg
argument_list|)
operator|==
name|SPARC_FCC_REG
argument_list|)
expr_stmt|;
name|labelno
operator|=
literal|""
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCXmode
operator|||
name|mode
operator|==
name|CCX_NOOVmode
condition|)
block|{
name|labelno
operator|=
literal|"%%xcc, "
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|v8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|labelno
operator|=
literal|"%%icc, "
expr_stmt|;
if|if
condition|(
name|v8
condition|)
name|labelno
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|labelno
operator|&&
name|insn
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|REG_BR_PROB_BASE
operator|/
literal|2
operator|)
operator|^
name|far
operator|)
condition|?
literal|",pt"
else|:
literal|",pn"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
name|spaces
operator|-=
literal|3
expr_stmt|;
block|}
block|}
else|else
name|labelno
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|spaces
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\t'
expr_stmt|;
else|else
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|far
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|".+12\n\t nop\n\tb\t"
argument_list|)
expr_stmt|;
comment|/* Skip the next insn if requested or 	 if we know that it will be a nop.  */
if|if
condition|(
name|annul
operator|||
operator|!
name|final_sequence
condition|)
name|p
index|[
literal|3
index|]
operator|=
literal|'6'
expr_stmt|;
name|p
operator|+=
literal|14
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'l'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|label
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Emit a library call comparison between floating point X and Y.    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).    TARGET_ARCH64 uses _Qp_* functions, which use pointers to TFmode    values as arguments instead of the TFmode registers themselves,    that's why we cannot call emit_float_lib_cmp.  */
end_comment

begin_function
name|void
name|sparc_emit_float_lib_cmp
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|enum
name|rtx_code
name|comparison
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|qpfunc
decl_stmt|;
name|rtx
name|slot0
decl_stmt|,
name|slot1
decl_stmt|,
name|result
decl_stmt|,
name|tem
decl_stmt|,
name|tem2
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_feq"
else|:
literal|"_Q_feq"
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_fne"
else|:
literal|"_Q_fne"
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_fgt"
else|:
literal|"_Q_fgt"
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_fge"
else|:
literal|"_Q_fge"
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_flt"
else|:
literal|"_Q_flt"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_fle"
else|:
literal|"_Q_fle"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
case|case
name|UNGT
case|:
case|case
name|UNLT
case|:
case|case
name|UNEQ
case|:
case|case
name|UNGE
case|:
case|case
name|UNLE
case|:
case|case
name|LTGT
case|:
name|qpfunc
operator|=
operator|(
name|TARGET_ARCH64
operator|)
condition|?
literal|"_Qp_cmp"
else|:
literal|"_Q_cmp"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|slot0
operator|=
name|assign_stack_temp
argument_list|(
name|TFmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|TFmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|slot0
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|slot0
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MEM
condition|)
block|{
name|slot1
operator|=
name|assign_stack_temp
argument_list|(
name|TFmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|TFmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|slot1
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
name|slot1
operator|=
name|y
expr_stmt|;
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|qpfunc
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|DImode
argument_list|,
literal|2
argument_list|,
name|XEXP
argument_list|(
name|slot0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|slot1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DImode
expr_stmt|;
block|}
else|else
block|{
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|qpfunc
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|SImode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|TFmode
argument_list|,
name|y
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SImode
expr_stmt|;
block|}
comment|/* Immediately move the result of the libcall into a pseudo      register so reload doesn't clobber the value if it needs      the return register for a spill reg.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|hard_libcall_value
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
default|default:
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|comparison
operator|==
name|UNORDERED
condition|?
name|EQ
else|:
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const1_rtx
argument_list|,
name|comparison
operator|==
name|UNGT
condition|?
name|GT
else|:
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|emit_cmp_insn
argument_list|(
name|result
argument_list|,
name|const2_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tem
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|tem
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|tem
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|tem
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|tem
argument_list|,
name|result
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH32
condition|)
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tem2
argument_list|,
name|tem
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|tem2
argument_list|,
name|tem
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|tem2
argument_list|,
name|const0_rtx
argument_list|,
name|comparison
operator|==
name|UNEQ
condition|?
name|EQ
else|:
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Generate an unsigned DImode to FP conversion.  This is the same code    optabs would emit if we didn't have TFmode patterns.  */
end_comment

begin_function
name|void
name|sparc_emit_floatunsdi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|neglab
decl_stmt|,
name|donelab
decl_stmt|,
name|i0
decl_stmt|,
name|i1
decl_stmt|,
name|f0
decl_stmt|,
name|in
decl_stmt|,
name|out
decl_stmt|;
name|out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|in
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|neglab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|donelab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i0
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|i1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|f0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|in
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|const0_rtx
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|mode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|donelab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|i0
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|i1
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iordi3
argument_list|(
name|i0
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|f0
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|mode
argument_list|,
name|i0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|f0
argument_list|,
name|f0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|donelab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an FP to unsigned DImode conversion.  This is the same code    optabs would emit if we didn't have TFmode patterns.  */
end_comment

begin_function
name|void
name|sparc_emit_fixunsdi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|neglab
decl_stmt|,
name|donelab
decl_stmt|,
name|i0
decl_stmt|,
name|i1
decl_stmt|,
name|f0
decl_stmt|,
name|in
decl_stmt|,
name|out
decl_stmt|,
name|limit
decl_stmt|;
name|out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|in
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|neglab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|donelab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i0
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|i1
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|limit
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|f0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|limit
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|REAL_VALUE_ATOF
argument_list|(
literal|"9223372036854775808.0"
argument_list|,
name|mode
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|in
argument_list|,
name|limit
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_FIX
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_FIX
argument_list|(
name|mode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|donelab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|f0
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|in
argument_list|,
name|limit
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|i0
argument_list|,
name|gen_rtx_FIX
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_FIX
argument_list|(
name|mode
argument_list|,
name|f0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movdi
argument_list|(
name|i1
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashldi3
argument_list|(
name|i1
argument_list|,
name|i1
argument_list|,
name|GEN_INT
argument_list|(
literal|63
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xordi3
argument_list|(
name|out
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|donelab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, testing    register REG.  LABEL is the operand number of the label; REG is the    operand number of the reg.  OP is the conditional expression.  The mode    of REG says what kind of comparison we made.     DEST is the destination insn (i.e. the label), INSN is the source.     REVERSED is nonzero if we should reverse the sense of the comparison.     ANNUL is nonzero if we should generate an annulling branch.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_v9branch
parameter_list|(
name|rtx
name|op
parameter_list|,
name|rtx
name|dest
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|label
parameter_list|,
name|int
name|reversed
parameter_list|,
name|int
name|annul
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
literal|64
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|far
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* branch on register are limited to +-128KB.  If it is too far away,      change            brnz,pt %g1, .LC30            to            brz,pn %g1, .+12       nop      ba,pt %xcc, .LC30            and            brgez,a,pn %o1, .LC29            to            brlz,pt %o1, .+16       nop      ba,pt %xcc, .LC29  */
name|far
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|>=
literal|3
expr_stmt|;
comment|/* If not floating-point or if EQ or NE, we can just reverse the code.  */
if|if
condition|(
name|reversed
operator|^
name|far
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Only 64 bit versions of these instructions exist.  */
name|gcc_assert
argument_list|(
name|mode
operator|==
name|DImode
argument_list|)
expr_stmt|;
comment|/* Start by writing the branch condition.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brnz"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brz"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brgez"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brlz"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brlez"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"brgz"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* Now add the annulling, reg, label, and nop.  */
if|if
condition|(
name|annul
operator|&&
operator|!
name|far
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|",a"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|REG_BR_PROB_BASE
operator|/
literal|2
operator|)
operator|^
name|far
operator|)
condition|?
literal|",pt"
else|:
literal|",pn"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|p
operator|<
name|string
operator|+
literal|8
condition|?
literal|'\t'
else|:
literal|' '
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|reg
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|far
condition|)
block|{
name|int
name|veryfar
init|=
literal|1
decl_stmt|,
name|delta
decl_stmt|;
if|if
condition|(
name|INSN_ADDRESSES_SET_P
argument_list|()
condition|)
block|{
name|delta
operator|=
operator|(
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Leave some instructions for "slop".  */
if|if
condition|(
name|delta
operator|>=
operator|-
literal|260000
operator|&&
name|delta
operator|<
literal|260000
condition|)
name|veryfar
operator|=
literal|0
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
literal|".+12\n\t nop\n\t"
argument_list|)
expr_stmt|;
comment|/* Skip the next insn if requested or 	 if we know that it will be a nop.  */
if|if
condition|(
name|annul
operator|||
operator|!
name|final_sequence
condition|)
name|p
index|[
literal|3
index|]
operator|=
literal|'6'
expr_stmt|;
name|p
operator|+=
literal|12
expr_stmt|;
if|if
condition|(
name|veryfar
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"b\t"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"ba,pt\t%%xcc, "
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|13
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'l'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|label
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return 1, if any of the registers of the instruction are %l[0-7] or %o[0-7].    Such instructions cannot be used in the delay slot of return insn on v9.    If TEST is 0, also rename all %i[0-7] registers to their %o[0-7] counterparts.  */
end_comment

begin_function
specifier|static
name|int
name|epilogue_renumber
parameter_list|(
specifier|register
name|rtx
modifier|*
name|where
parameter_list|,
name|int
name|test
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
operator|*
name|where
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
operator|*
name|where
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
operator|>=
literal|8
operator|&&
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
operator|<
literal|24
condition|)
comment|/* oX or lX */
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|test
operator|&&
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
operator|<
literal|32
condition|)
operator|*
name|where
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|where
argument_list|)
argument_list|,
name|OUTGOING_REGNO
argument_list|(
name|REGNO
argument_list|(
operator|*
name|where
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|SCRATCH
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
return|return
literal|0
return|;
comment|/* Do not replace the frame pointer with the stack pointer because 	 it can cause the delayed instruction to load below the stack. 	 This occurs when instructions like:  	 (set (reg/i:SI 24 %i0) 	     (mem/f:SI (plus:SI (reg/f:SI 30 %fp)                        (const_int -20 [0xffffffec])) 0))  	 are in the return delayed slot.  */
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|SPARC_STACK_BIAS
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|MEM
case|:
if|if
condition|(
name|SPARC_STACK_BIAS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
operator|*
name|where
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|epilogue_renumber
argument_list|(
operator|&
operator|(
name|XVECEXP
argument_list|(
operator|*
name|where
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|)
argument_list|,
name|test
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|epilogue_renumber
argument_list|(
operator|&
operator|(
name|XEXP
argument_list|(
operator|*
name|where
argument_list|,
name|i
argument_list|)
operator|)
argument_list|,
name|test
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Leaf functions and non-leaf functions have different needs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|reg_leaf_alloc_order
index|[]
init|=
name|REG_LEAF_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|reg_nonleaf_alloc_order
index|[]
init|=
name|REG_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
modifier|*
specifier|const
name|reg_alloc_orders
index|[]
init|=
block|{
name|reg_leaf_alloc_order
block|,
name|reg_nonleaf_alloc_order
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|order_regs_for_local_alloc
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|last_order_nonleaf
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|15
index|]
operator|!=
name|last_order_nonleaf
condition|)
block|{
name|last_order_nonleaf
operator|=
operator|!
name|last_order_nonleaf
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_alloc_order
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|reg_alloc_orders
index|[
name|last_order_nonleaf
index|]
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if REG and MEM are legitimate enough to allow the various    mem<-->reg splits to be run.  */
end_comment

begin_function
name|int
name|sparc_splitdi_legitimate
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|mem
parameter_list|)
block|{
comment|/* Punt if we are here by mistake.  */
name|gcc_assert
argument_list|(
name|reload_completed
argument_list|)
expr_stmt|;
comment|/* We must have an offsettable memory reference.  */
if|if
condition|(
operator|!
name|offsettable_memref_p
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we have legitimate args for ldd/std, we do not want      the split to happen.  */
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|%
literal|2
operator|)
operator|==
literal|0
operator|&&
name|mem_min_alignment
argument_list|(
name|mem
argument_list|,
literal|8
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Success.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if x and y are some kind of REG and they refer to    different hard registers.  This test is guaranteed to be    run after reload.  */
end_comment

begin_function
name|int
name|sparc_absnegfloat_split_legitimate
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.    This makes them candidates for using ldd and std insns.      Note reg1 and reg2 *must* be hard registers.  */
end_comment

begin_function
name|int
name|registers_ok_for_ldd_peep
parameter_list|(
name|rtx
name|reg1
parameter_list|,
name|rtx
name|reg2
parameter_list|)
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|%
literal|2
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Integer ldd is deprecated in SPARC V9 */
if|if
condition|(
name|TARGET_V9
operator|&&
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg2
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the addresses in mem1 and mem2 are suitable for use in    an ldd or std insn.        This can only happen when addr1 and addr2, the addresses in mem1    and mem2, are consecutive memory locations (addr1 + 4 == addr2).    addr1 must also be aligned on a 64-bit boundary.     Also iff dependent_reg_rtx is not null it should not be used to    compute the address for mem1, i.e. we cannot optimize a sequence    like:    	ld [%o0], %o0 	ld [%o0 + 4], %o1    to    	ldd [%o0], %o0    nor: 	ld [%g3 + 4], %g3 	ld [%g3], %g2    to         ldd [%g3], %g2     But, note that the transformation from: 	ld [%g2 + 4], %g3         ld [%g2], %g2    to 	ldd [%g2], %g2    is perfectly fine.  Thus, the peephole2 patterns always pass us    the destination register of the first load, never the second one.     For stores we don't have a similar problem, so dependent_reg_rtx is    NULL_RTX.  */
end_comment

begin_function
name|int
name|mems_ok_for_ldd_peep
parameter_list|(
name|rtx
name|mem1
parameter_list|,
name|rtx
name|mem2
parameter_list|,
name|rtx
name|dependent_reg_rtx
parameter_list|)
block|{
name|rtx
name|addr1
decl_stmt|,
name|addr2
decl_stmt|;
name|unsigned
name|int
name|reg1
decl_stmt|;
name|HOST_WIDE_INT
name|offset1
decl_stmt|;
comment|/* The mems cannot be volatile.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|mem1
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|mem2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* MEM1 should be aligned on a 64-bit boundary.  */
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|mem1
argument_list|)
operator|<
literal|64
condition|)
return|return
literal|0
return|;
name|addr1
operator|=
name|XEXP
argument_list|(
name|mem1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|XEXP
argument_list|(
name|mem2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Extract a register number and offset (if used) from the first addr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* If not a REG, return zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset must be constant!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
comment|/* This was a simple (mem (reg)) expression.  Offset is 0.  */
name|offset1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure the second address is a (mem (plus (reg) (const_int).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg1
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dependent_reg_rtx
operator|!=
name|NULL_RTX
operator|&&
name|reg1
operator|==
name|REGNO
argument_list|(
name|dependent_reg_rtx
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The first offset must be evenly divisible by 8 to ensure the       address is 64 bit aligned.  */
if|if
condition|(
name|offset1
operator|%
literal|8
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* The offset for the second addr must be 4 more than the first addr.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|offset1
operator|+
literal|4
condition|)
return|return
literal|0
return|;
comment|/* All the tests passed.  addr1 and addr2 are valid for ldd and std      instructions.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if reg is a pseudo, or is the first register in     a hard register pair.  This makes it a candidate for use in    ldd and std insns.  */
end_comment

begin_function
name|int
name|register_ok_for_ldd
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|%
literal|2
operator|==
literal|0
operator|)
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print operand X (an rtx) in assembler syntax to file FILE.    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.    For `%' followed by punctuation, CODE is the punctuation and X is null.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* Output an insn in a delay slot.  */
if|if
condition|(
name|final_sequence
condition|)
name|sparc_indent_opcode
operator|=
literal|1
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\n\t nop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'*'
case|:
comment|/* Output an annul flag if there's nothing for the delay slot and we 	 are optimizing.  This is always used with '(' below.          Sun OS 4.1.1 dbx can't handle an annulled unconditional branch; 	 this is a dbx bug.  So, we only do this when optimizing.          On UltraSPARC, a branch in a delay slot causes a pipeline flush. 	 Always emit a nop in case the next instruction is a branch.  */
if|if
condition|(
operator|!
name|final_sequence
operator|&&
operator|(
name|optimize
operator|&&
operator|(
name|int
operator|)
name|sparc_cpu
operator|<
name|PROCESSOR_V9
operator|)
condition|)
name|fputs
argument_list|(
literal|",a"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'('
case|:
comment|/* Output a 'nop' if there's nothing for the delay slot and we are 	 not optimizing.  This is always used with '*' above.  */
if|if
condition|(
operator|!
name|final_sequence
operator|&&
operator|!
operator|(
name|optimize
operator|&&
operator|(
name|int
operator|)
name|sparc_cpu
operator|<
name|PROCESSOR_V9
operator|)
condition|)
name|fputs
argument_list|(
literal|"\n\t nop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|final_sequence
condition|)
name|sparc_indent_opcode
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|')'
case|:
comment|/* Output the right displacement from the saved PC on function return. 	 The caller may have placed an "unimp" insn immediately after the call 	 so we have to account for it.  This insn is used in the 32-bit ABI 	 when calling a function that returns a non zero-sized structure. The 	 64-bit ABI doesn't have it.  Be careful to have this test be the same 	 as that used on the call. The exception here is that when  	 sparc_std_struct_return is enabled, the psABI is followed exactly 	 and the adjustment is made by the code in sparc_struct_value_rtx.  	 The call emitted is the same when sparc_std_struct_return is  	 present. */
if|if
condition|(
operator|!
name|TARGET_ARCH64
operator|&&
name|current_function_returns_struct
operator|&&
operator|!
name|sparc_std_struct_return
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"12"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|'8'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'_'
case|:
comment|/* Output the Embedded Medium/Anywhere code model base register.  */
name|fputs
argument_list|(
name|EMBMEDANY_BASE_REG
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'&'
case|:
comment|/* Print some local dynamic TLS name.  */
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Y'
case|:
comment|/* Adjust the operand to take into account a RESTORE operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%Y operand"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
literal|8
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
literal|32
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
literal|16
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%Y operand"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
comment|/* Print out the low order register name of a register pair.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* Print out the high order register name of a register pair.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
comment|/* Print out the second register name of a register pair or quad. 	 I.e., R (%o0) => %o1.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* Print out the third register name of a register quad. 	 I.e., S (%o0) => %o2.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* Print out the fourth register name of a register quad. 	 I.e., T (%o0) => %o3.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'x'
case|:
comment|/* Print a condition code register.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|SPARC_ICC_REG
condition|)
block|{
comment|/* We don't handle CC[X]_NOOVmode because they're not supposed 	     to occur here.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|CCmode
condition|)
name|fputs
argument_list|(
literal|"%icc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|CCXmode
condition|)
name|fputs
argument_list|(
literal|"%xcc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* %fccN register */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
comment|/* Print the operand's address only.  */
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
comment|/* In this case we need a register.  Use %g0 if the 	 operand is const0_rtx.  */
if|if
condition|(
name|x
operator|==
name|const0_rtx
operator|||
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"%g0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
case|case
literal|'A'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"or"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"and"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%A operand"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'B'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"orn"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"andn"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xnor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%B operand"
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* These are used by the conditional move instructions.  */
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
block|{
name|enum
name|rtx_code
name|rc
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|'c'
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|rc
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"g"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"geu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"gu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"leu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"lu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTGT
case|:
name|fputs
argument_list|(
literal|"lg"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|fputs
argument_list|(
literal|"u"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|fputs
argument_list|(
literal|"o"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLT
case|:
name|fputs
argument_list|(
literal|"ul"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNLE
case|:
name|fputs
argument_list|(
literal|"ule"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
name|fputs
argument_list|(
literal|"ug"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
name|fputs
argument_list|(
literal|"uge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEQ
case|:
name|fputs
argument_list|(
literal|"ue"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
name|code
operator|==
literal|'c'
condition|?
literal|"invalid %%c operand"
else|:
literal|"invalid %%C operand"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* These are used by the movr instruction pattern.  */
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
block|{
name|enum
name|rtx_code
name|rc
init|=
operator|(
name|code
operator|==
literal|'d'
condition|?
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|)
decl_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"gez"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lz"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"lez"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gz"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
name|code
operator|==
literal|'d'
condition|?
literal|"invalid %%d operand"
else|:
literal|"invalid %%D operand"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
literal|'b'
case|:
block|{
comment|/* Print a sign-extended character.  */
name|int
name|i
init|=
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|,
name|QImode
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'f'
case|:
comment|/* Operand must be a MEM; write its address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%f operand"
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
block|{
comment|/* Print a sign-extended 32-bit value.  */
name|HOST_WIDE_INT
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|i
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|i
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid %%s operand"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|trunc_int_for_mode
argument_list|(
name|i
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|0
case|:
comment|/* Do nothing special.  */
break|break;
default|default:
comment|/* Undocumented flag.  */
name|output_operand_lossage
argument_list|(
literal|"invalid operand output code"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|fputc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Poor Sun assembler doesn't understand absolute addressing.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"%g0+"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
block|{
name|fputs
argument_list|(
literal|"%hi("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
name|print_operand
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CM_MEDMID
condition|)
name|fputs
argument_list|(
literal|"+%l44("
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"+%lo("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"long long constant not a valid immediate operand"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|output_operand_lossage
argument_list|(
literal|"floating point constant not a valid immediate operand"
argument_list|)
expr_stmt|;
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Target hook for assembling integer objects.  The sparc version has    special handling for aligned DI-mode objects.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
comment|/* ??? We only output .xword's for symbols and only then in environments      where the assembler can handle them.  */
if|if
condition|(
name|aligned_p
operator|&&
name|size
operator|==
literal|8
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|)
condition|)
block|{
if|if
condition|(
name|TARGET_V9
condition|)
block|{
name|assemble_integer_with_op
argument_list|(
literal|"\t.xword\t"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|assemble_aligned_integer
argument_list|(
literal|4
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|assemble_aligned_integer
argument_list|(
literal|4
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value of a code used in the .proc pseudo-op that says    what kind of result this function returns.  For non-C types, we pick    the closest C type.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|long
name|sparc_type_code
parameter_list|(
specifier|register
name|tree
name|type
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
name|qualifiers
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|shift
decl_stmt|;
comment|/* Only the first 30 bits of the qualifier are valid.  We must refrain from      setting more, since some assemblers will give an error for this.  Also,      we must be careful to avoid shifts of 32 bits or more to avoid getting      unpredictable results.  */
for|for
control|(
name|shift
operator|=
literal|6
init|;
name|shift
operator|<
literal|30
condition|;
name|shift
operator|+=
literal|2
operator|,
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|qualifiers
return|;
case|case
name|ARRAY_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|3
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|2
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|8
operator|)
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|9
operator|)
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|10
operator|)
return|;
case|case
name|VOID_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|16
operator|)
return|;
case|case
name|INTEGER_TYPE
case|:
comment|/* If this is a range type, consider it to be the underlying 	     type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Carefully distinguish all the standard types of C, 	     without messing up if the language is not C.  We do this by 	     testing TYPE_PRECISION and TYPE_UNSIGNED.  The old code used to 	     look at both the names and the above fields, but that's redundant. 	     Any type whose size is between two C types will be considered 	     to be the wider of the two types.  Also, we do not have a 	     special code to use for "long long", so anything wider than 	     long is treated the same.  Note that we can't distinguish 	     between "int" and "long" in this code if they are the same 	     size, but that's fine, since neither can the assembler.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|CHAR_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|12
else|:
literal|2
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|SHORT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|13
else|:
literal|3
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|INT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|14
else|:
literal|4
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|15
else|:
literal|5
operator|)
operator|)
return|;
case|case
name|REAL_TYPE
case|:
comment|/* If this is a range type, consider it to be the underlying 	     type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Carefully distinguish all the standard types of C, 	     without messing up if the language is not C.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|FLOAT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|6
operator|)
return|;
else|else
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
case|case
name|COMPLEX_TYPE
case|:
comment|/* GNU Fortran COMPLEX type.  */
comment|/* ??? We need to distinguish between double and float complex types, 	     but I don't know how yet because I can't reach this code from 	     existing front-ends.  */
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
comment|/* Who knows? */
case|case
name|VECTOR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
comment|/* Boolean truth value type.  */
case|case
name|LANG_TYPE
case|:
comment|/* ? */
return|return
name|qualifiers
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Not a type! */
block|}
block|}
return|return
name|qualifiers
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nested function support.  */
end_comment

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.     This takes 16 insns: 2 shifts& 2 ands (to split up addresses), 4 sethi    (to load in opcodes), 4 iors (to merge address and opcodes), and 4 writes    (to store insns).  This is a bit excessive.  Perhaps a different    mechanism would be better here.     Emit enough FLUSH insns to synchronize the data and instruction caches.  */
end_comment

begin_function
name|void
name|sparc_initialize_trampoline
parameter_list|(
name|rtx
name|tramp
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|)
block|{
comment|/* SPARC 32-bit trampoline:   	sethi	%hi(fn), %g1  	sethi	%hi(static), %g2  	jmp	%g1+%lo(fn)  	or	%g2, %lo(static), %g2      SETHI i,r  = 00rr rrr1 00ii iiii iiii iiii iiii iiii     JMPL r+i,d = 10dd ddd1 1100 0rrr rr1i iiii iiii iiii    */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|fnaddr
argument_list|,
name|size_int
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0x03000000
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|cxt
argument_list|,
name|size_int
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0x05000000
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_and
argument_list|(
name|SImode
argument_list|,
name|fnaddr
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3ff
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0x81c06000
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|12
argument_list|)
argument_list|)
argument_list|,
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|expand_and
argument_list|(
name|SImode
argument_list|,
name|cxt
argument_list|,
name|GEN_INT
argument_list|(
literal|0x3ff
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0x8410a000
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On UltraSPARC a flush flushes an entire cache line.  The trampoline is      aligned on a 16 byte boundary so one flush clears it all.  */
name|emit_insn
argument_list|(
name|gen_flush
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|tramp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_cpu
operator|!=
name|PROCESSOR_ULTRASPARC
operator|&&
name|sparc_cpu
operator|!=
name|PROCESSOR_ULTRASPARC3
operator|&&
name|sparc_cpu
operator|!=
name|PROCESSOR_NIAGARA
condition|)
name|emit_insn
argument_list|(
name|gen_flush
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call __enable_execute_stack after writing onto the stack to make sure      the stack address is accessible.  */
ifdef|#
directive|ifdef
name|ENABLE_EXECUTE_STACK
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|tramp
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The 64-bit version is simpler because it makes more sense to load the    values as "immediate" data out of the trampoline.  It's also easier since    we can read the PC without clobbering a register.  */
end_comment

begin_function
name|void
name|sparc64_initialize_trampoline
parameter_list|(
name|rtx
name|tramp
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|)
block|{
comment|/* SPARC 64-bit trampoline:  	rd	%pc, %g1 	ldx	[%g1+24], %g5 	jmp	%g5 	ldx	[%g1+16], %g5 	+16 bytes data    */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|tramp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0x83414000
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xca586018
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0x81c14000
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|12
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xca586010
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|24
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_flushdi
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|tramp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_cpu
operator|!=
name|PROCESSOR_ULTRASPARC
operator|&&
name|sparc_cpu
operator|!=
name|PROCESSOR_ULTRASPARC3
operator|&&
name|sparc_cpu
operator|!=
name|PROCESSOR_NIAGARA
condition|)
name|emit_insn
argument_list|(
name|gen_flushdi
argument_list|(
name|validize_mem
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call __enable_execute_stack after writing onto the stack to make sure      the stack address is accessible.  */
ifdef|#
directive|ifdef
name|ENABLE_EXECUTE_STACK
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|tramp
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|supersparc_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|;
if|if
condition|(
operator|!
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Data dependency; DEP_INSN writes a register that INSN reads some 	 cycles later.  */
comment|/* if a load, then the dependence must be on the memory address; 	 add an extra "cycle".  Note that the cost could be two cycles 	 if the reg was written late in an instruction group; we ca not tell 	 here.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_LOAD
operator|||
name|insn_type
operator|==
name|TYPE_FPLOAD
condition|)
return|return
name|cost
operator|+
literal|3
return|;
comment|/* Get the delay only if the address of the store is the dependence.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_STORE
operator|||
name|insn_type
operator|==
name|TYPE_FPSTORE
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dep_pat
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|cost
return|;
comment|/* This should not happen!  */
comment|/* The dependency between the two instructions was on the data that 	     is being stored.  Assume that this implies that the address of the 	     store is not dependent.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|cost
return|;
return|return
name|cost
operator|+
literal|3
return|;
comment|/* An approximation.  */
block|}
comment|/* A shift instruction cannot receive its data from an instruction 	 in the same cycle; add a one cycle penalty.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_SHIFT
condition|)
return|return
name|cost
operator|+
literal|3
return|;
comment|/* Split before cascade into shift.  */
block|}
else|else
block|{
comment|/* Anti- or output- dependency; DEP_INSN reads/writes a register that 	 INSN writes some cycles later.  */
comment|/* These are only significant for the fpu unit; writing a fp reg before          the fpu has finished with it stalls the processor.  */
comment|/* Reusing an integer register causes no problems.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IALU
operator|||
name|insn_type
operator|==
name|TYPE_SHIFT
condition|)
return|return
literal|0
return|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hypersparc_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_type
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dep_pat
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Data dependency; DEP_INSN writes a register that INSN reads some 	 cycles later.  */
switch|switch
condition|(
name|insn_type
condition|)
block|{
case|case
name|TYPE_STORE
case|:
case|case
name|TYPE_FPSTORE
case|:
comment|/* Get the delay iff the address of the store is the dependence.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|cost
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|cost
return|;
return|return
name|cost
operator|+
literal|3
return|;
case|case
name|TYPE_LOAD
case|:
case|case
name|TYPE_SLOAD
case|:
case|case
name|TYPE_FPLOAD
case|:
comment|/* If a load, then the dependence must be on the memory address.  If 	     the addresses aren't equal, then it might be a false dependency */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_STORE
operator|||
name|dep_type
operator|==
name|TYPE_FPSTORE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|dep_pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|dep_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|cost
operator|+
literal|2
return|;
return|return
name|cost
operator|+
literal|8
return|;
block|}
break|break;
case|case
name|TYPE_BRANCH
case|:
comment|/* Compare to branch latency is 0.  There is no benefit from 	     separating compare and branch.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_COMPARE
condition|)
return|return
literal|0
return|;
comment|/* Floating point compare to branch latency is less than 	     compare to conditional move.  */
if|if
condition|(
name|dep_type
operator|==
name|TYPE_FPCMP
condition|)
return|return
name|cost
operator|-
literal|1
return|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|REG_DEP_ANTI
case|:
comment|/* Anti-dependencies only penalize the fpu unit.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_IALU
operator|||
name|insn_type
operator|==
name|TYPE_SHIFT
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
switch|switch
condition|(
name|sparc_cpu
condition|)
block|{
case|case
name|PROCESSOR_SUPERSPARC
case|:
name|cost
operator|=
name|supersparc_adjust_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|dep
argument_list|,
name|cost
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_HYPERSPARC
case|:
case|case
name|PROCESSOR_SPARCLITE86X
case|:
name|cost
operator|=
name|hypersparc_adjust_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|dep
argument_list|,
name|cost
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_sched_init
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|max_ready
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|sparc_use_sched_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sparc_cpu
operator|==
name|PROCESSOR_NIAGARA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC
operator|||
name|sparc_cpu
operator|==
name|PROCESSOR_ULTRASPARC3
condition|)
return|return
literal|4
return|;
if|if
condition|(
operator|(
literal|1
operator|<<
name|sparc_cpu
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|PROCESSOR_SUPERSPARC
operator|)
operator||
operator|(
literal|1
operator|<<
name|PROCESSOR_HYPERSPARC
operator|)
operator||
operator|(
literal|1
operator|<<
name|PROCESSOR_SPARCLITE86X
operator|)
operator|)
condition|)
return|return
literal|3
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|sparc_cpu
condition|)
block|{
case|case
name|PROCESSOR_NIAGARA
case|:
default|default:
return|return
literal|1
return|;
case|case
name|PROCESSOR_V9
case|:
comment|/* Assume V9 processors are capable of at least dual-issue.  */
return|return
literal|2
return|;
case|case
name|PROCESSOR_SUPERSPARC
case|:
return|return
literal|3
return|;
case|case
name|PROCESSOR_HYPERSPARC
case|:
case|case
name|PROCESSOR_SPARCLITE86X
case|:
return|return
literal|2
return|;
case|case
name|PROCESSOR_ULTRASPARC
case|:
case|case
name|PROCESSOR_ULTRASPARC3
case|:
return|return
literal|4
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|set_extends
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
specifier|register
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Load and some shift instructions zero extend.  */
case|case
name|MEM
case|:
case|case
name|ZERO_EXTEND
case|:
comment|/* sethi clears the high bits */
case|case
name|HIGH
case|:
comment|/* LO_SUM is used with sethi.  sethi cleared the high 	 bits and the values used with lo_sum are positive */
case|case
name|LO_SUM
case|:
comment|/* Store flag stores 0 or 1 */
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
literal|1
return|;
case|case
name|AND
case|:
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sparc_check_64
argument_list|(
name|op0
argument_list|,
name|insn
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|sparc_check_64
argument_list|(
name|op1
argument_list|,
name|insn
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
case|case
name|IOR
case|:
case|case
name|XOR
case|:
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
name|sparc_check_64
argument_list|(
name|op0
argument_list|,
name|insn
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|sparc_check_64
argument_list|(
name|op1
argument_list|,
name|insn
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
case|case
name|LSHIFTRT
case|:
return|return
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SImode
return|;
comment|/* Positive integers leave the high bits zero.  */
case|case
name|CONST_DOUBLE
case|:
return|return
operator|!
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|&
literal|0x80000000
operator|)
return|;
case|case
name|CONST_INT
case|:
return|return
operator|!
operator|(
name|INTVAL
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|&
literal|0x80000000
operator|)
return|;
case|case
name|ASHIFTRT
case|:
case|case
name|SIGN_EXTEND
case|:
return|return
operator|-
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SImode
operator|)
return|;
case|case
name|REG
case|:
return|return
name|sparc_check_64
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* We _ought_ to have only one kind per function, but...  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|sparc_addr_diff_list
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|sparc_addr_list
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|sparc_defer_case_vector
parameter_list|(
name|rtx
name|lab
parameter_list|,
name|rtx
name|vec
parameter_list|,
name|int
name|diff
parameter_list|)
block|{
name|vec
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|lab
argument_list|,
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
name|sparc_addr_diff_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|,
name|sparc_addr_diff_list
argument_list|)
expr_stmt|;
else|else
name|sparc_addr_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|,
name|sparc_addr_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_output_addr_vec
parameter_list|(
name|rtx
name|vec
parameter_list|)
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|body
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|vlen
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_START
name|ASM_OUTPUT_ADDR_VEC_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_LABEL
name|ASM_OUTPUT_CASE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
name|ASM_OUTPUT_ADDR_VEC_ELT
argument_list|(
name|asm_out_file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_END
name|ASM_OUTPUT_ADDR_VEC_END
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_output_addr_diff_vec
parameter_list|(
name|rtx
name|vec
parameter_list|)
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|body
init|=
name|XEXP
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|vlen
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_START
name|ASM_OUTPUT_ADDR_VEC_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_LABEL
name|ASM_OUTPUT_CASE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|lab
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
name|ASM_OUTPUT_ADDR_DIFF_ELT
argument_list|(
name|asm_out_file
argument_list|,
name|body
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_END
name|ASM_OUTPUT_ADDR_VEC_END
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_output_deferred_case_vectors
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|t
decl_stmt|;
name|int
name|align
decl_stmt|;
if|if
condition|(
name|sparc_addr_list
operator|==
name|NULL_RTX
operator|&&
name|sparc_addr_diff_list
operator|==
name|NULL_RTX
condition|)
return|return;
comment|/* Align to cache line in the function's code section.  */
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|sparc_addr_list
init|;
name|t
condition|;
name|t
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
control|)
name|sparc_output_addr_vec
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|sparc_addr_diff_list
init|;
name|t
condition|;
name|t
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
control|)
name|sparc_output_addr_diff_vec
argument_list|(
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sparc_addr_list
operator|=
name|sparc_addr_diff_list
operator|=
name|NULL_RTX
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 0 if the high 32 bits of X (the low word of X, if DImode) are    unknown.  Return 1 if the high bits are zero, -1 if the register is    sign extended.  */
end_comment

begin_function
name|int
name|sparc_check_64
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* If a register is set only once it is safe to ignore insns this      code does not know how to handle.  The loop will either recognize      the single set and return the correct value or fail to recognize      it and return 0.  */
name|int
name|set_once
init|=
literal|0
decl_stmt|;
name|rtx
name|y
init|=
name|x
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
name|y
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|WORDS_BIG_ENDIAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|set_once
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|set_once
condition|)
name|insn
operator|=
name|get_last_insn_anywhere
argument_list|()
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|JUMP_INSN
case|:
case|case
name|NOTE
case|:
break|break;
case|case
name|CODE_LABEL
case|:
case|case
name|CALL_INSN
case|:
default|default:
if|if
condition|(
operator|!
name|set_once
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|INSN
case|:
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|set_extends
argument_list|(
name|insn
argument_list|)
return|;
if|if
condition|(
name|y
operator|&&
name|rtx_equal_p
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
return|return
name|set_extends
argument_list|(
name|insn
argument_list|)
return|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns assembly code to perform a DImode shift using    a 64-bit global or out register on SPARC-V8+.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_v8plus_shift
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|rtx
name|insn
parameter_list|,
specifier|const
name|char
modifier|*
name|opcode
parameter_list|)
block|{
specifier|static
name|char
name|asm_code
index|[
literal|60
index|]
decl_stmt|;
comment|/* The scratch register is only required when the destination      register is not a 64-bit global or out register.  */
if|if
condition|(
name|which_alternative
operator|!=
literal|2
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
comment|/* We can only shift by constants<= 63. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"mov\t%1, %3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"sllx\t%H1, 32, %3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|sparc_check_64
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|insn
argument_list|)
operator|<=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"srl\t%L1, 0, %L1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"or\t%L1, %3, %3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|asm_code
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_alternative
operator|!=
literal|2
condition|)
return|return
name|strcat
argument_list|(
name|asm_code
argument_list|,
literal|"\t%0, %2, %L0\n\tsrlx\t%L0, 32, %H0"
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|asm_code
argument_list|,
literal|"\t%3, %2, %3\n\tsrlx\t%3, 32, %H0\n\tmov\t%3, %L0"
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output rtl to increment the profiler label LABELNO    for profiling a function entry.  */
end_comment

begin_function
name|void
name|sparc_profile_hook
parameter_list|(
name|int
name|labelno
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|rtx
name|lab
decl_stmt|,
name|fun
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|lab
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|fun
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|MCOUNT_FUNCTION
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|fun
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|lab
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_function
specifier|static
name|void
name|sparc_elf_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|SECTION_MERGE
condition|)
block|{
comment|/* entsize cannot be expressed in this section attributes 	 encoding style.  */
name|default_elf_asm_named_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t\"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_DEBUG
operator|)
condition|)
name|fputs
argument_list|(
literal|",#alloc"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
name|fputs
argument_list|(
literal|",#write"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_TLS
condition|)
name|fputs
argument_list|(
literal|",#tls"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
name|fputs
argument_list|(
literal|",#execinstr"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* ??? Handle SECTION_BSS.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ELF */
end_comment

begin_comment
comment|/* We do not allow indirect calls to be optimized into sibling calls.     We cannot use sibling calls when delayed branches are disabled    because they will likely require the call delay slot to be filled.     Also, on SPARC 32-bit we cannot emit a sibling call when the    current function returns a structure.  This is because the "unimp    after call" convention would cause the callee to return to the    wrong place.  The generic code already disallows cases where the    function being called returns a structure.     It may seem strange how this last case could occur.  Usually there    is code after the call which jumps to epilogue code which dumps the    return value into the struct return area.  That ought to invalidate    the sibling call right?  Well, in the C++ case we can end up passing    the pointer to the struct return area to a constructor (which returns    void) and then nothing else happens.  Such a sibling call would look    valid without the added check here.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|decl
operator|&&
name|flag_delayed_branch
operator|&&
operator|(
name|TARGET_ARCH64
operator|||
operator|!
name|current_function_returns_struct
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* libfunc renaming.  */
end_comment

begin_include
include|#
directive|include
file|"config/gofast.h"
end_include

begin_function
specifier|static
name|void
name|sparc_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
comment|/* Use the subroutines that Sun's library provides for integer 	 multiply and divide.  The `*' prevents an underscore from 	 being prepended by the compiler. .umul is a little faster 	 than .mul.  */
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|SImode
argument_list|,
literal|"*.umul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"*.div"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"*.udiv"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
literal|"*.rem"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|SImode
argument_list|,
literal|"*.urem"
argument_list|)
expr_stmt|;
comment|/* TFmode arithmetic.  These names are part of the SPARC 32bit ABI.  */
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_add"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_sub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|neg_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_neg"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_mul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_div"
argument_list|)
expr_stmt|;
comment|/* We can define the TFmode sqrt optab only if TARGET_FPU.  This 	 is because with soft-float, the SFmode and DFmode sqrt 	 instructions will be absent, and the compiler will notice and 	 try to use the TFmode sqrt instruction for calls to the 	 builtin function sqrt, but this fails.  */
if|if
condition|(
name|TARGET_FPU
condition|)
name|set_optab_libfunc
argument_list|(
name|sqrt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_sqrt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_feq"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_fne"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_fgt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_fge"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_flt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_fle"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|SFmode
argument_list|,
literal|"_Q_stoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|DFmode
argument_list|,
literal|"_Q_dtoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|SFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_qtos"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|DFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_qtod"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_qtoi"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_qtou"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"_Q_itoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"_Q_utoq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITF_CONVERSION_LIBFUNCS
condition|)
block|{
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_qtoll"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|TFmode
argument_list|,
literal|"_Q_qtoull"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|DImode
argument_list|,
literal|"_Q_lltoq"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|TFmode
argument_list|,
name|DImode
argument_list|,
literal|"_Q_ulltoq"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUN_CONVERSION_LIBFUNCS
condition|)
block|{
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|SFmode
argument_list|,
literal|"__ftoll"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|SFmode
argument_list|,
literal|"__ftoull"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|DFmode
argument_list|,
literal|"__dtoll"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|DFmode
argument_list|,
literal|"__dtoull"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_ARCH64
condition|)
block|{
comment|/* In the SPARC 64bit ABI, SImode multiply and divide functions 	 do not exist in the library.  Make sure the compiler does not 	 emit calls to them by accident.  (It should always use the          hardware instructions.)  */
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUN_INTEGER_MULTIPLY_64
condition|)
block|{
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|DImode
argument_list|,
literal|"__mul64"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"__div64"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"__udiv64"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|DImode
argument_list|,
literal|"__rem64"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|DImode
argument_list|,
literal|"__urem64"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SUN_CONVERSION_LIBFUNCS
condition|)
block|{
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|SFmode
argument_list|,
literal|"__ftol"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|SFmode
argument_list|,
literal|"__ftoul"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|DFmode
argument_list|,
literal|"__dtol"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|DFmode
argument_list|,
literal|"__dtoul"
argument_list|)
expr_stmt|;
block|}
block|}
name|gofast_maybe_init_libfuncs
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|def_builtin
parameter_list|(
name|NAME
parameter_list|,
name|CODE
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|lang_hooks.builtin_function((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL, \                               NULL_TREE)
end_define

begin_comment
comment|/* Implement the TARGET_INIT_BUILTINS target hook.    Create builtin functions for special SPARC instructions.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_VIS
condition|)
name|sparc_vis_init_builtins
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create builtin functions for VIS 1.0 instructions.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_vis_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|v4qi
init|=
name|build_vector_type
argument_list|(
name|unsigned_intQI_type_node
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|tree
name|v8qi
init|=
name|build_vector_type
argument_list|(
name|unsigned_intQI_type_node
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|tree
name|v4hi
init|=
name|build_vector_type
argument_list|(
name|intHI_type_node
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|tree
name|v2hi
init|=
name|build_vector_type
argument_list|(
name|intHI_type_node
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|v2si
init|=
name|build_vector_type
argument_list|(
name|intSI_type_node
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|v4qi_ftype_v4hi
init|=
name|build_function_type_list
argument_list|(
name|v4qi
argument_list|,
name|v4hi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v2si_v8qi
init|=
name|build_function_type_list
argument_list|(
name|v8qi
argument_list|,
name|v2si
argument_list|,
name|v8qi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v2hi_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|v2hi
argument_list|,
name|v2si
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4qi
init|=
name|build_function_type_list
argument_list|(
name|v4hi
argument_list|,
name|v4qi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v4qi_v4qi
init|=
name|build_function_type_list
argument_list|(
name|v8qi
argument_list|,
name|v4qi
argument_list|,
name|v4qi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4qi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|v4hi
argument_list|,
name|v4qi
argument_list|,
name|v4hi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4qi_v2hi
init|=
name|build_function_type_list
argument_list|(
name|v4hi
argument_list|,
name|v4qi
argument_list|,
name|v2hi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4qi_v2hi
init|=
name|build_function_type_list
argument_list|(
name|v2si
argument_list|,
name|v4qi
argument_list|,
name|v2hi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v8qi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|v4hi
argument_list|,
name|v8qi
argument_list|,
name|v4hi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|v4hi
argument_list|,
name|v4hi
argument_list|,
name|v4hi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_v2si
init|=
name|build_function_type_list
argument_list|(
name|v2si
argument_list|,
name|v2si
argument_list|,
name|v2si
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v8qi_v8qi
init|=
name|build_function_type_list
argument_list|(
name|v8qi
argument_list|,
name|v8qi
argument_list|,
name|v8qi
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v8qi_v8qi_di
init|=
name|build_function_type_list
argument_list|(
name|intDI_type_node
argument_list|,
name|v8qi
argument_list|,
name|v8qi
argument_list|,
name|intDI_type_node
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_di
init|=
name|build_function_type_list
argument_list|(
name|intDI_type_node
argument_list|,
name|intDI_type_node
argument_list|,
name|intDI_type_node
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|ptr_ftype_ptr_si
init|=
name|build_function_type_list
argument_list|(
name|ptr_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|intSI_type_node
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|ptr_ftype_ptr_di
init|=
name|build_function_type_list
argument_list|(
name|ptr_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|intDI_type_node
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Packing and expanding vectors.  */
name|def_builtin
argument_list|(
literal|"__builtin_vis_fpack16"
argument_list|,
name|CODE_FOR_fpack16_vis
argument_list|,
name|v4qi_ftype_v4hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fpack32"
argument_list|,
name|CODE_FOR_fpack32_vis
argument_list|,
name|v8qi_ftype_v2si_v8qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fpackfix"
argument_list|,
name|CODE_FOR_fpackfix_vis
argument_list|,
name|v2hi_ftype_v2si
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fexpand"
argument_list|,
name|CODE_FOR_fexpand_vis
argument_list|,
name|v4hi_ftype_v4qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fpmerge"
argument_list|,
name|CODE_FOR_fpmerge_vis
argument_list|,
name|v8qi_ftype_v4qi_v4qi
argument_list|)
expr_stmt|;
comment|/* Multiplications.  */
name|def_builtin
argument_list|(
literal|"__builtin_vis_fmul8x16"
argument_list|,
name|CODE_FOR_fmul8x16_vis
argument_list|,
name|v4hi_ftype_v4qi_v4hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fmul8x16au"
argument_list|,
name|CODE_FOR_fmul8x16au_vis
argument_list|,
name|v4hi_ftype_v4qi_v2hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fmul8x16al"
argument_list|,
name|CODE_FOR_fmul8x16al_vis
argument_list|,
name|v4hi_ftype_v4qi_v2hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fmul8sux16"
argument_list|,
name|CODE_FOR_fmul8sux16_vis
argument_list|,
name|v4hi_ftype_v8qi_v4hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fmul8ulx16"
argument_list|,
name|CODE_FOR_fmul8ulx16_vis
argument_list|,
name|v4hi_ftype_v8qi_v4hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fmuld8sux16"
argument_list|,
name|CODE_FOR_fmuld8sux16_vis
argument_list|,
name|v2si_ftype_v4qi_v2hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_fmuld8ulx16"
argument_list|,
name|CODE_FOR_fmuld8ulx16_vis
argument_list|,
name|v2si_ftype_v4qi_v2hi
argument_list|)
expr_stmt|;
comment|/* Data aligning.  */
name|def_builtin
argument_list|(
literal|"__builtin_vis_faligndatav4hi"
argument_list|,
name|CODE_FOR_faligndatav4hi_vis
argument_list|,
name|v4hi_ftype_v4hi_v4hi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_faligndatav8qi"
argument_list|,
name|CODE_FOR_faligndatav8qi_vis
argument_list|,
name|v8qi_ftype_v8qi_v8qi
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_faligndatav2si"
argument_list|,
name|CODE_FOR_faligndatav2si_vis
argument_list|,
name|v2si_ftype_v2si_v2si
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_vis_faligndatadi"
argument_list|,
name|CODE_FOR_faligndatadi_vis
argument_list|,
name|di_ftype_di_di
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARCH64
condition|)
name|def_builtin
argument_list|(
literal|"__builtin_vis_alignaddr"
argument_list|,
name|CODE_FOR_alignaddrdi_vis
argument_list|,
name|ptr_ftype_ptr_di
argument_list|)
expr_stmt|;
else|else
name|def_builtin
argument_list|(
literal|"__builtin_vis_alignaddr"
argument_list|,
name|CODE_FOR_alignaddrsi_vis
argument_list|,
name|ptr_ftype_ptr_si
argument_list|)
expr_stmt|;
comment|/* Pixel distance.  */
name|def_builtin
argument_list|(
literal|"__builtin_vis_pdist"
argument_list|,
name|CODE_FOR_pdist_vis
argument_list|,
name|di_ftype_v8qi_v8qi_di
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle TARGET_EXPAND_BUILTIN target hook.    Expand builtin functions for sparc intrinsics.  */
end_comment

begin_function
specifier|static
name|rtx
name|sparc_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|tmode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|arglist
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|icode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|op
index|[
literal|4
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
index|[
literal|4
index|]
decl_stmt|;
name|int
name|arg_count
init|=
literal|0
decl_stmt|;
name|mode
index|[
literal|0
index|]
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
index|[
literal|0
index|]
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|mode
index|[
literal|0
index|]
operator|)
condition|)
name|op
index|[
literal|0
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|op
index|[
literal|0
index|]
operator|=
name|target
expr_stmt|;
for|for
control|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|arg_count
operator|++
expr_stmt|;
name|mode
index|[
name|arg_count
index|]
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|arg_count
index|]
operator|.
name|mode
expr_stmt|;
name|op
index|[
name|arg_count
index|]
operator|=
name|expand_normal
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|arg_count
index|]
operator|.
name|predicate
operator|)
operator|(
name|op
index|[
name|arg_count
index|]
operator|,
name|mode
index|[
name|arg_count
index|]
operator|)
condition|)
name|op
index|[
name|arg_count
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
index|[
name|arg_count
index|]
argument_list|,
name|op
index|[
name|arg_count
index|]
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|arg_count
condition|)
block|{
case|case
literal|1
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|,
name|op
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|,
name|op
index|[
literal|2
index|]
argument_list|,
name|op
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|op
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_vis_mul8x16
parameter_list|(
name|int
name|e8
parameter_list|,
name|int
name|e16
parameter_list|)
block|{
return|return
operator|(
name|e8
operator|*
name|e16
operator|+
literal|128
operator|)
operator|/
literal|256
return|;
block|}
end_function

begin_comment
comment|/* Multiply the vector elements in ELTS0 to the elements in ELTS1 as specified    by FNCODE.  All of the elements in ELTS0 and ELTS1 lists must be integer    constants.  A tree list with the results of the multiplications is returned,    and each element in the list is of INNER_TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|sparc_handle_vis_mul8x16
parameter_list|(
name|int
name|fncode
parameter_list|,
name|tree
name|inner_type
parameter_list|,
name|tree
name|elts0
parameter_list|,
name|tree
name|elts1
parameter_list|)
block|{
name|tree
name|n_elts
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|scale
decl_stmt|;
switch|switch
condition|(
name|fncode
condition|)
block|{
case|case
name|CODE_FOR_fmul8x16_vis
case|:
for|for
control|(
init|;
name|elts0
operator|&&
name|elts1
condition|;
name|elts0
operator|=
name|TREE_CHAIN
argument_list|(
name|elts0
argument_list|)
operator|,
name|elts1
operator|=
name|TREE_CHAIN
argument_list|(
name|elts1
argument_list|)
control|)
block|{
name|int
name|val
init|=
name|sparc_vis_mul8x16
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts0
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|n_elts
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|inner_type
argument_list|,
name|val
argument_list|)
argument_list|,
name|n_elts
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CODE_FOR_fmul8x16au_vis
case|:
name|scale
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elts0
condition|;
name|elts0
operator|=
name|TREE_CHAIN
argument_list|(
name|elts0
argument_list|)
control|)
block|{
name|int
name|val
init|=
name|sparc_vis_mul8x16
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts0
argument_list|)
argument_list|)
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|n_elts
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|inner_type
argument_list|,
name|val
argument_list|)
argument_list|,
name|n_elts
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CODE_FOR_fmul8x16al_vis
case|:
name|scale
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|elts1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elts0
condition|;
name|elts0
operator|=
name|TREE_CHAIN
argument_list|(
name|elts0
argument_list|)
control|)
block|{
name|int
name|val
init|=
name|sparc_vis_mul8x16
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts0
argument_list|)
argument_list|)
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|n_elts
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|inner_type
argument_list|,
name|val
argument_list|)
argument_list|,
name|n_elts
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|nreverse
argument_list|(
name|n_elts
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle TARGET_FOLD_BUILTIN target hook.    Fold builtin functions for SPARC intrinsics.  If IGNORE is true the    result of the function call is ignored.  NULL_TREE is returned if the    function could not be folded.  */
end_comment

begin_function
specifier|static
name|tree
name|sparc_fold_builtin
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|bool
name|ignore
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|tree
name|rtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignore
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|CODE_FOR_alignaddrsi_vis
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|CODE_FOR_alignaddrdi_vis
condition|)
return|return
name|fold_convert
argument_list|(
name|rtype
argument_list|,
name|integer_zero_node
argument_list|)
return|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
case|case
name|CODE_FOR_fexpand_vis
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|VECTOR_CST
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
decl_stmt|;
name|tree
name|elts
init|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|n_elts
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
init|;
name|elts
condition|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
control|)
block|{
name|unsigned
name|int
name|val
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
argument_list|)
operator|<<
literal|4
decl_stmt|;
name|n_elts
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|inner_type
argument_list|,
name|val
argument_list|)
argument_list|,
name|n_elts
argument_list|)
expr_stmt|;
block|}
return|return
name|build_vector
argument_list|(
name|rtype
argument_list|,
name|nreverse
argument_list|(
name|n_elts
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|CODE_FOR_fmul8x16_vis
case|:
case|case
name|CODE_FOR_fmul8x16au_vis
case|:
case|case
name|CODE_FOR_fmul8x16al_vis
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|VECTOR_CST
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
decl_stmt|;
name|tree
name|elts0
init|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|elts1
init|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|n_elts
init|=
name|sparc_handle_vis_mul8x16
argument_list|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|inner_type
argument_list|,
name|elts0
argument_list|,
name|elts1
argument_list|)
decl_stmt|;
return|return
name|build_vector
argument_list|(
name|rtype
argument_list|,
name|n_elts
argument_list|)
return|;
block|}
break|break;
case|case
name|CODE_FOR_fpmerge_vis
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|VECTOR_CST
condition|)
block|{
name|tree
name|elts0
init|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|elts1
init|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|n_elts
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
init|;
name|elts0
operator|&&
name|elts1
condition|;
name|elts0
operator|=
name|TREE_CHAIN
argument_list|(
name|elts0
argument_list|)
operator|,
name|elts1
operator|=
name|TREE_CHAIN
argument_list|(
name|elts1
argument_list|)
control|)
block|{
name|n_elts
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|elts0
argument_list|)
argument_list|,
name|n_elts
argument_list|)
expr_stmt|;
name|n_elts
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|elts1
argument_list|)
argument_list|,
name|n_elts
argument_list|)
expr_stmt|;
block|}
return|return
name|build_vector
argument_list|(
name|rtype
argument_list|,
name|nreverse
argument_list|(
name|n_elts
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|CODE_FOR_pdist_vis
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|VECTOR_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|overflow
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|tree
name|elts0
init|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|tree
name|elts1
init|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|elts0
operator|&&
name|elts1
condition|;
name|elts0
operator|=
name|TREE_CHAIN
argument_list|(
name|elts0
argument_list|)
operator|,
name|elts1
operator|=
name|TREE_CHAIN
argument_list|(
name|elts1
argument_list|)
control|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|low0
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts0
argument_list|)
argument_list|)
decl_stmt|,
name|low1
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|high0
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|high1
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|elts1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|HOST_WIDE_INT
name|h
decl_stmt|;
name|overflow
operator||=
name|neg_double
argument_list|(
name|low1
argument_list|,
name|high1
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
name|overflow
operator||=
name|add_double
argument_list|(
name|low0
argument_list|,
name|high0
argument_list|,
name|l
argument_list|,
name|h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|overflow
operator||=
name|neg_double
argument_list|(
name|l
argument_list|,
name|h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
name|overflow
operator||=
name|add_double
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|l
argument_list|,
name|h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|overflow
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_int_cst_wide
argument_list|(
name|rtype
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|sparc_extra_constraint_check
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|int
name|reload_ok_mem
decl_stmt|;
if|if
condition|(
name|TARGET_ARCH64
operator|&&
operator|(
name|c
operator|==
literal|'T'
operator|||
name|c
operator|==
literal|'U'
operator|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
return|return
name|fp_sethi_p
argument_list|(
name|op
argument_list|)
return|;
case|case
literal|'R'
case|:
return|return
name|fp_mov_p
argument_list|(
name|op
argument_list|)
return|;
case|case
literal|'S'
case|:
return|return
name|fp_high_losum_p
argument_list|(
name|op
argument_list|)
return|;
case|case
literal|'U'
case|:
if|if
condition|(
operator|!
name|strict
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
operator|>=
literal|0
operator|)
operator|)
condition|)
return|return
name|register_ok_for_ldd
argument_list|(
name|op
argument_list|)
return|;
return|return
literal|0
return|;
case|case
literal|'W'
case|:
case|case
literal|'T'
case|:
break|break;
case|case
literal|'Y'
case|:
return|return
name|const_zero_operand
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Our memory extra constraints have to emulate the      behavior of 'm' and 'o' in order for reload to work      correctly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|reload_ok_mem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|TARGET_ARCH64
operator|||
name|mem_min_alignment
argument_list|(
name|op
argument_list|,
literal|8
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|strict
operator|||
name|strict_memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|reload_ok_mem
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|reload_ok_mem
operator|=
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
operator|<
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|reload_ok_mem
return|;
block|}
end_function

begin_comment
comment|/* ??? This duplicates information provided to the compiler by the    ??? scheduler description.  Some day, teach genautomata to output    ??? the latencies and then CSE will just use that.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|bool
name|float_mode_p
init|=
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0x1000
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
operator|-
literal|0x1000
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* FALLTHRU */
case|case
name|HIGH
case|:
operator|*
name|total
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
operator|*
name|total
operator|=
literal|4
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0x1000
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|>=
operator|-
literal|0x1000
operator|)
operator|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
literal|8
expr_stmt|;
return|return
name|true
return|;
case|case
name|MEM
case|:
comment|/* If outer-code was a sign or zero extension, a cost 	 of COSTS_N_INSNS (1) was already added in.  This is 	 why we are subtracting it back out.  */
if|if
condition|(
name|outer_code
operator|==
name|ZERO_EXTEND
condition|)
block|{
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|int_zload
operator|-
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outer_code
operator|==
name|SIGN_EXTEND
condition|)
block|{
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|int_sload
operator|-
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|float_mode_p
condition|)
block|{
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_load
expr_stmt|;
block|}
else|else
block|{
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|int_load
expr_stmt|;
block|}
return|return
name|true
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_plusminus
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_mul
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_HARD_MUL
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|25
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|bit_cost
decl_stmt|;
name|bit_cost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sparc_costs
operator|->
name|int_mul_bit_factor
condition|)
block|{
name|int
name|nbits
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|nbits
operator|=
literal|0
init|;
name|value
operator|!=
literal|0
condition|;
name|value
operator|&=
name|value
operator|-
literal|1
control|)
name|nbits
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|value1
init|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|value2
init|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x1
argument_list|)
decl_stmt|;
for|for
control|(
name|nbits
operator|=
literal|0
init|;
name|value1
operator|!=
literal|0
condition|;
name|value1
operator|&=
name|value1
operator|-
literal|1
control|)
name|nbits
operator|++
expr_stmt|;
for|for
control|(
init|;
name|value2
operator|!=
literal|0
condition|;
name|value2
operator|&=
name|value2
operator|-
literal|1
control|)
name|nbits
operator|++
expr_stmt|;
block|}
else|else
name|nbits
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|nbits
operator|<
literal|3
condition|)
name|nbits
operator|=
literal|3
expr_stmt|;
name|bit_cost
operator|=
operator|(
name|nbits
operator|-
literal|3
operator|)
operator|/
name|sparc_costs
operator|->
name|int_mul_bit_factor
expr_stmt|;
name|bit_cost
operator|=
name|COSTS_N_INSNS
argument_list|(
name|bit_cost
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|int_mulX
operator|+
name|bit_cost
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|int_mul
operator|+
name|bit_cost
expr_stmt|;
block|}
return|return
name|false
return|;
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
name|sparc_costs
operator|->
name|shift_penalty
expr_stmt|;
return|return
name|false
return|;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
if|if
condition|(
name|float_mode_p
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_div_df
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_div_sf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|int_divX
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|int_div
expr_stmt|;
block|}
return|return
name|false
return|;
case|case
name|NEG
case|:
if|if
condition|(
operator|!
name|float_mode_p
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|ABS
case|:
case|case
name|FLOAT
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_move
expr_stmt|;
return|return
name|false
return|;
case|case
name|SQRT
case|:
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_sqrt_df
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_sqrt_sf
expr_stmt|;
return|return
name|false
return|;
case|case
name|COMPARE
case|:
if|if
condition|(
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_cmp
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|float_cmove
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|sparc_costs
operator|->
name|int_cmove
expr_stmt|;
return|return
name|false
return|;
case|case
name|IOR
case|:
comment|/* Handle the NAND vector patterns.  */
if|if
condition|(
name|sparc_vector_mode_supported_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Emit the sequence of insns SEQ while preserving the registers REG and REG2.    This is achieved by means of a manual dynamic stack space allocation in    the current frame.  We make the assumption that SEQ doesn't contain any    function calls, with the possible exception of calls to the PIC helper.  */
end_comment

begin_function
specifier|static
name|void
name|emit_and_preserve
parameter_list|(
name|rtx
name|seq
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
name|reg2
parameter_list|)
block|{
comment|/* We must preserve the lowest 16 words for the register save area.  */
name|HOST_WIDE_INT
name|offset
init|=
literal|16
operator|*
name|UNITS_PER_WORD
decl_stmt|;
comment|/* We really need only 2 words of fresh stack space.  */
name|HOST_WIDE_INT
name|size
init|=
name|SPARC_STACK_ALIGN
argument_list|(
name|offset
operator|+
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
name|rtx
name|slot
init|=
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|SPARC_STACK_BIAS
operator|+
name|offset
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_stack_pointer_dec
argument_list|(
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|slot
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg2
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|adjust_address
argument_list|(
name|slot
argument_list|,
name|word_mode
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|,
name|reg2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg2
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg2
argument_list|,
name|adjust_address
argument_list|(
name|slot
argument_list|,
name|word_mode
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_stack_pointer_inc
argument_list|(
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the assembler code for a thunk function.  THUNK_DECL is the    declaration for the thunk function itself, FUNCTION is the decl for    the target function.  DELTA is an immediate constant offset to be    added to THIS.  If VCALL_OFFSET is nonzero, the word at address    (*THIS + VCALL_OFFSET) should be additionally added to THIS.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk_fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|this
decl_stmt|,
name|insn
decl_stmt|,
name|funexp
decl_stmt|;
name|unsigned
name|int
name|int_arg_first
decl_stmt|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|epilogue_completed
operator|=
literal|1
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|reset_block_changes
argument_list|()
expr_stmt|;
name|emit_note
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_delayed_branch
condition|)
block|{
comment|/* We will emit a regular sibcall below, so we need to instruct 	 output_sibcall that we are in a leaf function.  */
name|sparc_leaf_function_p
operator|=
name|current_function_uses_only_leaf_regs
operator|=
literal|1
expr_stmt|;
comment|/* This will cause final.c to invoke leaf_renumber_regs so we 	 must behave as if we were in a not-yet-leafified function.  */
name|int_arg_first
operator|=
name|SPARC_INCOMING_INT_ARG_FIRST
expr_stmt|;
block|}
else|else
block|{
comment|/* We will emit the sibcall manually below, so we will need to 	 manually spill non-leaf registers.  */
name|sparc_leaf_function_p
operator|=
name|current_function_uses_only_leaf_regs
operator|=
literal|0
expr_stmt|;
comment|/* We really are in a leaf function.  */
name|int_arg_first
operator|=
name|SPARC_OUTGOING_INT_ARG_FIRST
expr_stmt|;
block|}
comment|/* Find the "this" pointer.  Normally in %o0, but in ARCH64 if the function      returns a structure, the structure return pointer is there instead.  */
if|if
condition|(
name|TARGET_ARCH64
operator|&&
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|)
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|int_arg_first
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|int_arg_first
argument_list|)
expr_stmt|;
comment|/* Add DELTA.  When possible use a plain add, otherwise load it into      a register first.  */
if|if
condition|(
name|delta
condition|)
block|{
name|rtx
name|delta_rtx
init|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SPARC_SIMM13_P
argument_list|(
name|delta
argument_list|)
condition|)
block|{
name|rtx
name|scratch
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|delta_rtx
argument_list|)
expr_stmt|;
name|delta_rtx
operator|=
name|scratch
expr_stmt|;
block|}
comment|/* THIS += DELTA.  */
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|this
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the word at address (*THIS + VCALL_OFFSET).  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
name|rtx
name|vcall_offset_rtx
init|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
decl_stmt|;
name|rtx
name|scratch
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|vcall_offset
operator|<
literal|0
argument_list|)
expr_stmt|;
comment|/* SCRATCH = *THIS.  */
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare for adding VCALL_OFFSET.  The difficulty is that we 	 may not have any available scratch register at this point.  */
if|if
condition|(
name|SPARC_SIMM13_P
argument_list|(
name|vcall_offset
argument_list|)
condition|)
empty_stmt|;
comment|/* This is the case if ARCH64 (unless -ffixed-g5 is passed).  */
elseif|else
if|if
condition|(
operator|!
name|fixed_regs
index|[
literal|5
index|]
comment|/* The below sequence is made up of at least 2 insns, 		  while the default method may need only one.  */
operator|&&
name|vcall_offset
operator|<
operator|-
literal|8192
condition|)
block|{
name|rtx
name|scratch2
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|scratch2
argument_list|,
name|vcall_offset_rtx
argument_list|)
expr_stmt|;
name|vcall_offset_rtx
operator|=
name|scratch2
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|increment
init|=
name|GEN_INT
argument_list|(
operator|-
literal|4096
argument_list|)
decl_stmt|;
comment|/* VCALL_OFFSET is a negative number whose typical range can be 	     estimated as -32768..0 in 32-bit mode.  In almost all cases 	     it is therefore cheaper to emit multiple add insns than 	     spilling and loading the constant into a register (at least 	     6 insns).  */
while|while
condition|(
operator|!
name|SPARC_SIMM13_P
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|scratch
argument_list|,
name|increment
argument_list|)
argument_list|)
expr_stmt|;
name|vcall_offset
operator|+=
literal|4096
expr_stmt|;
block|}
name|vcall_offset_rtx
operator|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
expr_stmt|;
comment|/* cannot be 0 */
block|}
comment|/* SCRATCH = *(*THIS + VCALL_OFFSET).  */
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|scratch
argument_list|,
name|vcall_offset_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* THIS += *(*THIS + VCALL_OFFSET).  */
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|this
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate a tail call to the target function.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_delayed_branch
condition|)
block|{
name|funexp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_sibcall
argument_list|(
name|funexp
argument_list|)
argument_list|)
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* The hoops we have to jump through in order to generate a sibcall 	 without using delay slots...  */
name|rtx
name|spill_reg
decl_stmt|,
name|spill_reg2
decl_stmt|,
name|seq
decl_stmt|,
name|scratch
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|spill_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* %o7 */
name|spill_reg2
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Delay emitting the PIC helper function because it needs to 	     change the section and we are emitting assembly code.  */
name|load_pic_register
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* clobbers %o7 */
name|scratch
operator|=
name|legitimize_pic_address
argument_list|(
name|funexp
argument_list|,
name|Pmode
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_and_preserve
argument_list|(
name|seq
argument_list|,
name|spill_reg
argument_list|,
name|spill_reg2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_ARCH32
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|SImode
argument_list|,
name|funexp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|SImode
argument_list|,
name|scratch
argument_list|,
name|funexp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* TARGET_ARCH64 */
block|{
switch|switch
condition|(
name|sparc_cmodel
condition|)
block|{
case|case
name|CM_MEDLOW
case|:
case|case
name|CM_MEDMID
case|:
comment|/* The destination can serve as a temporary.  */
name|sparc_emit_set_symbolic_const64
argument_list|(
name|scratch
argument_list|,
name|funexp
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
break|break;
case|case
name|CM_MEDANY
case|:
case|case
name|CM_EMBMEDANY
case|:
comment|/* The destination cannot serve as a temporary.  */
name|spill_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* %o7 */
name|start_sequence
argument_list|()
expr_stmt|;
name|sparc_emit_set_symbolic_const64
argument_list|(
name|scratch
argument_list|,
name|funexp
argument_list|,
name|spill_reg
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_and_preserve
argument_list|(
name|seq
argument_list|,
name|spill_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|emit_jump_insn
argument_list|(
name|gen_indirect_jump
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Run just enough of rest_of_compilation to get the insns emitted.      There's not really enough bulk here to make other passes such as      instruction scheduling worth while.  Note that use_thunk calls      assemble_start_function and assemble_end_function.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|insn_locators_initialize
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|epilogue_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if sparc_output_mi_thunk would be able to output the    assembler code for the thunk function specified by the arguments    it is passed, and false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|sparc_can_output_mi_thunk
parameter_list|(
name|tree
name|thunk_fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Bound the loop used in the default method above.  */
return|return
operator|(
name|vcall_offset
operator|>=
operator|-
literal|32768
operator|||
operator|!
name|fixed_regs
index|[
literal|5
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to allocate a 'struct machine_function'.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|sparc_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in local-dynamic base patterns.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.    This is called from dwarf2out.c to emit call frame instructions    for frame-related insns containing UNSPECs and UNSPEC_VOLATILEs. */
end_comment

begin_function
specifier|static
name|void
name|sparc_dwarf_handle_frame_unspec
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|rtx
name|pattern
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|index
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|index
operator|==
name|UNSPECV_SAVEW
argument_list|)
expr_stmt|;
name|dwarf2out_window_save
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|fputs
argument_list|(
literal|"\t.word\t%r_tls_dtpoff32("
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
literal|"\t.xword\t%r_tls_dtpoff64("
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do whatever processing is required at the end of a file.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_file_end
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If we haven't emitted the special PIC helper function, do so now.  */
if|if
condition|(
name|pic_helper_symbol_name
index|[
literal|0
index|]
operator|&&
operator|!
name|pic_helper_emitted_p
condition|)
name|emit_pic_helper
argument_list|()
expr_stmt|;
if|if
condition|(
name|NEED_INDICATE_EXEC_STACK
condition|)
name|file_end_indicate_exec_stack
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_ALTERNATE_LONG_DOUBLE_MANGLING
end_ifdef

begin_comment
comment|/* Implement TARGET_MANGLE_FUNDAMENTAL_TYPE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sparc_mangle_fundamental_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|long_double_type_node
operator|&&
name|TARGET_LONG_DOUBLE_128
condition|)
return|return
literal|"g"
return|;
comment|/* For all other types, use normal C++ mangling.  */
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Expand code to perform a 8 or 16-bit compare and swap by doing 32-bit    compare and swap on the word containing the byte or half-word.  */
end_comment

begin_function
name|void
name|sparc_expand_compare_and_swap_12
parameter_list|(
name|rtx
name|result
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|oldval
parameter_list|,
name|rtx
name|newval
parameter_list|)
block|{
name|rtx
name|addr1
init|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|off
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|oldv
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|newv
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|oldvalue
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|newvalue
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|res
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|resv
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|memsi
decl_stmt|,
name|val
decl_stmt|,
name|mask
decl_stmt|,
name|end_label
decl_stmt|,
name|loop_label
decl_stmt|,
name|cc
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|addr
argument_list|,
name|gen_rtx_AND
argument_list|(
name|Pmode
argument_list|,
name|addr1
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pmode
operator|!=
name|SImode
condition|)
name|addr1
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|addr1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|off
argument_list|,
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|addr1
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memsi
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|memsi
argument_list|,
name|ALIAS_SET_MEMORY_BARRIER
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|memsi
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|memsi
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|off
argument_list|,
name|gen_rtx_XOR
argument_list|(
name|SImode
argument_list|,
name|off
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|==
name|QImode
condition|?
literal|3
else|:
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|off
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|off
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|==
name|QImode
condition|)
name|mask
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|GEN_INT
argument_list|(
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mask
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|GEN_INT
argument_list|(
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mask
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|mask
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|val
argument_list|,
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|SImode
argument_list|,
name|mask
argument_list|)
argument_list|,
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|oldval
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|oldv
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|oldval
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newval
operator|=
name|gen_lowpart_common
argument_list|(
name|SImode
argument_list|,
name|newval
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|newv
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|newval
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|oldv
argument_list|,
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|oldv
argument_list|,
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|newv
argument_list|,
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|newv
argument_list|,
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|loop_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|loop_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|oldvalue
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|oldv
argument_list|,
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|newvalue
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|newv
argument_list|,
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sync_compare_and_swapsi
argument_list|(
name|res
argument_list|,
name|memsi
argument_list|,
name|oldvalue
argument_list|,
name|newvalue
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|res
argument_list|,
name|oldvalue
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|resv
argument_list|,
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|SImode
argument_list|,
name|mask
argument_list|)
argument_list|,
name|res
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sparc_compare_op0
operator|=
name|resv
expr_stmt|;
name|sparc_compare_op1
operator|=
name|val
expr_stmt|;
name|cc
operator|=
name|gen_compare_reg
argument_list|(
name|NE
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|val
argument_list|,
name|resv
argument_list|)
argument_list|)
expr_stmt|;
name|sparc_compare_emitted
operator|=
name|cc
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bne
argument_list|(
name|loop_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|res
argument_list|,
name|gen_rtx_AND
argument_list|(
name|SImode
argument_list|,
name|res
argument_list|,
name|mask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|res
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|SImode
argument_list|,
name|res
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
argument_list|,
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-sparc.h"
end_include

end_unit

