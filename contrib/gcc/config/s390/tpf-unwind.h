begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 EH unwinding support for TPF OS.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.    Contributed by P.J. Darcy (darcypj@us.ibm.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combined executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_comment
comment|/* Function Name: __isPATrange    Parameters passed into it:  address to check    Return Value: A 1 if address is in pat code "range", 0 if not    Description: This function simply checks to see if the address    passed to it is in the CP pat code range.  */
end_comment

begin_define
define|#
directive|define
name|MIN_PATRANGE
value|0x10000
end_define

begin_define
define|#
directive|define
name|MAX_PATRANGE
value|0x800000
end_define

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|__isPATrange
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|>
operator|(
name|void
operator|*
operator|)
name|MIN_PATRANGE
operator|&&
name|addr
operator|<
operator|(
name|void
operator|*
operator|)
name|MAX_PATRANGE
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* TPF return address offset from start of stack frame.  */
end_comment

begin_define
define|#
directive|define
name|TPFRA_OFFSET
value|168
end_define

begin_comment
comment|/* Exceptions macro defined for TPF so that functions without     dwarf frame information can be used with exceptions.  */
end_comment

begin_define
define|#
directive|define
name|MD_FALLBACK_FRAME_STATE_FOR
value|s390_fallback_frame_state
end_define

begin_function
specifier|static
name|_Unwind_Reason_Code
name|s390_fallback_frame_state
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|unsigned
name|long
name|int
name|regs
decl_stmt|;
name|unsigned
name|long
name|int
name|new_cfa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|regs
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|long
name|int
operator|)
name|context
operator|->
name|cfa
operator|)
operator|-
name|STACK_POINTER_OFFSET
operator|)
operator|)
expr_stmt|;
comment|/* Are we going through special linkage code?  */
if|if
condition|(
name|__isPATrange
argument_list|(
name|context
operator|->
name|ra
argument_list|)
condition|)
block|{
comment|/* Our return register isn't zero for end of stack, so          check backward stackpointer to see if it is zero.  */
if|if
condition|(
name|regs
operator|==
name|NULL
condition|)
return|return
name|_URC_END_OF_STACK
return|;
comment|/* No stack frame.  */
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
literal|15
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|STACK_POINTER_OFFSET
expr_stmt|;
comment|/* All registers remain unchanged ...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_REG
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
operator|=
name|i
expr_stmt|;
block|}
comment|/* ... except for %r14, which is stored at CFA-112 	 and used as return address.  */
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|14
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|14
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|TPFRA_OFFSET
operator|-
name|STACK_POINTER_OFFSET
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
literal|14
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
name|regs
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|long
name|int
operator|)
name|context
operator|->
name|cfa
operator|)
operator|-
name|STACK_POINTER_OFFSET
operator|)
operator|)
expr_stmt|;
name|new_cfa
operator|=
name|regs
operator|+
name|STACK_POINTER_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
literal|15
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|new_cfa
operator|-
operator|(
name|unsigned
name|long
name|int
operator|)
name|context
operator|->
name|cfa
operator|+
name|STACK_POINTER_OFFSET
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|regs
operator|+
name|i
operator|*
literal|8
operator|-
name|new_cfa
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|16
operator|+
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|16
operator|+
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|regs
operator|+
literal|16
operator|*
literal|8
operator|+
name|i
operator|*
literal|8
operator|-
name|new_cfa
expr_stmt|;
block|}
name|fs
operator|->
name|retaddr_column
operator|=
literal|14
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_comment
comment|/* Function Name: __tpf_eh_return    Parameters passed into it: Destination address to jump to.    Return Value: Converted Destination address if a Pat Stub exists.    Description: This function swaps the unwinding return address       with the cp stub code.  The original target return address is       then stored into the tpf return address field.  The cp stub       code is searched for by climbing back up the stack and       comparing the tpf stored return address object address to       that of the targets object address.  */
end_comment

begin_define
define|#
directive|define
name|CURRENT_STACK_PTR
parameter_list|()
define|\
value|({ register unsigned long int *stack_ptr asm ("%r15"); stack_ptr; })
end_define

begin_define
define|#
directive|define
name|PREVIOUS_STACK_PTR
parameter_list|()
define|\
value|((unsigned long int *)(*(CURRENT_STACK_PTR())))
end_define

begin_define
define|#
directive|define
name|RA_OFFSET
value|112
end_define

begin_define
define|#
directive|define
name|R15_OFFSET
value|120
end_define

begin_define
define|#
directive|define
name|TPFAREA_OFFSET
value|160
end_define

begin_define
define|#
directive|define
name|TPFAREA_SIZE
value|STACK_POINTER_OFFSET-TPFAREA_OFFSET
end_define

begin_define
define|#
directive|define
name|INVALID_RETURN
value|0
end_define

begin_function_decl
name|void
modifier|*
name|__tpf_eh_return
parameter_list|(
name|void
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
modifier|*
name|__tpf_eh_return
parameter_list|(
name|void
modifier|*
name|target
parameter_list|)
block|{
name|Dl_info
name|targetcodeInfo
decl_stmt|,
name|currentcodeInfo
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|void
modifier|*
name|current
decl_stmt|,
modifier|*
name|stackptr
decl_stmt|,
modifier|*
name|destination_frame
decl_stmt|;
name|unsigned
name|long
name|int
name|shifter
decl_stmt|,
name|is_a_stub
decl_stmt|;
name|is_a_stub
operator|=
literal|0
expr_stmt|;
comment|/* Get code info for target return's address.  */
name|retval
operator|=
name|dladdr
argument_list|(
name|target
argument_list|,
operator|&
name|targetcodeInfo
argument_list|)
expr_stmt|;
comment|/* Ensure the code info is valid (for target).  */
if|if
condition|(
name|retval
operator|!=
name|INVALID_RETURN
condition|)
block|{
comment|/* Get the stack pointer of the stack frame to be modified by          the exception unwinder.  So that we can begin our climb          there.  */
name|stackptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
operator|*
operator|(
name|PREVIOUS_STACK_PTR
argument_list|()
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Begin looping through stack frames.  Stop if invalid          code information is retrieved or if a match between the          current stack frame iteration shared object's address           matches that of the target, calculated above.  */
do|do
block|{
comment|/* Get return address based on our stackptr iterator.  */
name|current
operator|=
operator|(
name|void
operator|*
operator|)
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
name|stackptr
operator|+
name|RA_OFFSET
operator|)
operator|)
expr_stmt|;
comment|/* Is it a Pat Stub?  */
if|if
condition|(
name|__isPATrange
argument_list|(
name|current
argument_list|)
condition|)
block|{
comment|/* Yes it was, get real return address                   in TPF stack area.  */
name|current
operator|=
operator|(
name|void
operator|*
operator|)
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
name|stackptr
operator|+
name|TPFRA_OFFSET
operator|)
operator|)
expr_stmt|;
name|is_a_stub
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get codeinfo on RA so that we can figure out              the module address.  */
name|retval
operator|=
name|dladdr
argument_list|(
name|current
argument_list|,
operator|&
name|currentcodeInfo
argument_list|)
expr_stmt|;
comment|/* Check that codeinfo for current stack frame is valid.              Then compare the module address of current stack frame              to target stack frame to determine if we have the pat              stub address we want.  Also ensure we are dealing              with a module crossing, stub return address. */
if|if
condition|(
name|is_a_stub
operator|&&
name|retval
operator|!=
name|INVALID_RETURN
operator|&&
name|targetcodeInfo
operator|.
name|dli_fbase
operator|==
name|currentcodeInfo
operator|.
name|dli_fbase
condition|)
block|{
comment|/* Yes! They are in the same module.                   Force copy of TPF private stack area to                   destination stack frame TPF private area. */
name|destination_frame
operator|=
operator|(
name|void
operator|*
operator|)
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
operator|*
name|PREVIOUS_STACK_PTR
argument_list|()
operator|+
name|R15_OFFSET
operator|)
operator|)
expr_stmt|;
comment|/* Copy TPF linkage area from current frame to                   destination frame.  */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|destination_frame
operator|+
name|TPFAREA_OFFSET
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|stackptr
operator|+
name|TPFAREA_OFFSET
operator|)
argument_list|,
name|TPFAREA_SIZE
argument_list|)
expr_stmt|;
comment|/* Now overlay the                   real target address into the TPF stack area of                   the target frame we are jumping to.  */
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
name|destination_frame
operator|+
name|TPFRA_OFFSET
operator|)
operator|)
operator|=
operator|(
name|unsigned
name|long
name|int
operator|)
name|target
expr_stmt|;
comment|/* Before returning the desired pat stub address to                   the exception handling unwinder so that it can                    actually do the "leap" shift out the low order                    bit designated to determine if we are in 64BIT mode.                   This is necessary for CTOA stubs.                   Otherwise we leap one byte past where we want to                    go to in the TPF pat stub linkage code.  */
name|shifter
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
name|stackptr
operator|+
name|RA_OFFSET
operator|)
operator|)
expr_stmt|;
name|shifter
operator|&=
operator|~
literal|1ul
expr_stmt|;
comment|/* Store Pat Stub Address in destination Stack Frame.  */
operator|*
operator|(
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
operator|(
name|destination_frame
operator|+
name|RA_OFFSET
operator|)
operator|)
operator|=
name|shifter
expr_stmt|;
comment|/* Re-adjust pat stub address to go to correct place                   in linkage.  */
name|shifter
operator|=
name|shifter
operator|-
literal|4
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|shifter
return|;
block|}
comment|/* Desired module pat stub not found ...              Bump stack frame iterator.  */
name|stackptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|*
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
name|stackptr
expr_stmt|;
name|is_a_stub
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|stackptr
operator|&&
name|retval
operator|!=
name|INVALID_RETURN
operator|&&
name|targetcodeInfo
operator|.
name|dli_fbase
operator|!=
name|currentcodeInfo
operator|.
name|dli_fbase
condition|)
do|;
block|}
comment|/* No pat stub found, could be a problem?  Simply return unmodified      target address.  */
return|return
name|target
return|;
block|}
end_function

end_unit

