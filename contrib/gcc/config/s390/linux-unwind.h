begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 EH unwinding support for S/390 Linux.    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file with other programs, and to distribute those programs without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into another program.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Do code reading to identify a signal frame, and set the frame    state data appropriately.  See unwind-dw2.c for the structs.  */
end_comment

begin_define
define|#
directive|define
name|MD_FALLBACK_FRAME_STATE_FOR
value|s390_fallback_frame_state
end_define

begin_function
specifier|static
name|_Unwind_Reason_Code
name|s390_fallback_frame_state
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|pc
init|=
name|context
operator|->
name|ra
decl_stmt|;
name|long
name|new_cfa
decl_stmt|;
name|int
name|i
decl_stmt|;
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|psw_mask
decl_stmt|;
name|unsigned
name|long
name|psw_addr
decl_stmt|;
name|unsigned
name|long
name|gprs
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|int
name|acrs
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|int
name|fpc
decl_stmt|;
name|unsigned
name|int
name|__pad
decl_stmt|;
name|double
name|fprs
index|[
literal|16
index|]
decl_stmt|;
block|}
name|__attribute__
typedef|((
name|__aligned__
typedef|(8)))
name|sigregs_
typedef|;
name|sigregs_
modifier|*
name|regs
decl_stmt|;
name|int
modifier|*
name|signo
decl_stmt|;
comment|/* svc $__NR_sigreturn or svc $__NR_rt_sigreturn  */
if|if
condition|(
name|pc
index|[
literal|0
index|]
operator|!=
literal|0x0a
operator|||
operator|(
name|pc
index|[
literal|1
index|]
operator|!=
literal|119
operator|&&
name|pc
index|[
literal|1
index|]
operator|!=
literal|173
operator|)
condition|)
return|return
name|_URC_END_OF_STACK
return|;
comment|/* Legacy frames:        old signal mask (8 bytes)        pointer to sigregs (8 bytes) - points always to next location        sigregs        retcode      This frame layout was used on kernels< 2.6.9 for non-RT frames,      and on kernels< 2.4.13 for RT frames as well.  Note that we need      to look at RA to detect this layout -- this means that if you use      sa_restorer to install a different signal restorer on a legacy      kernel, unwinding from signal frames will not work.  */
if|if
condition|(
name|context
operator|->
name|ra
operator|==
name|context
operator|->
name|cfa
operator|+
literal|16
operator|+
sizeof|sizeof
argument_list|(
name|sigregs_
argument_list|)
condition|)
block|{
name|regs
operator|=
operator|(
name|sigregs_
operator|*
operator|)
operator|(
name|context
operator|->
name|cfa
operator|+
literal|16
operator|)
expr_stmt|;
name|signo
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* New-style RT frame:      retcode + alignment (8 bytes)      siginfo (128 bytes)      ucontext (contains sigregs)  */
elseif|else
if|if
condition|(
name|pc
index|[
literal|1
index|]
operator|==
literal|173
comment|/* __NR_rt_sigreturn */
condition|)
block|{
struct|struct
name|ucontext_
block|{
name|unsigned
name|long
name|uc_flags
decl_stmt|;
name|struct
name|ucontext_
modifier|*
name|uc_link
decl_stmt|;
name|unsigned
name|long
name|uc_stack
index|[
literal|3
index|]
decl_stmt|;
name|sigregs_
name|uc_mcontext
decl_stmt|;
block|}
modifier|*
name|uc
init|=
name|context
operator|->
name|cfa
operator|+
literal|8
operator|+
literal|128
struct|;
name|regs
operator|=
operator|&
name|uc
operator|->
name|uc_mcontext
expr_stmt|;
name|signo
operator|=
name|context
operator|->
name|cfa
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
comment|/* New-style non-RT frame:      old signal mask (8 bytes)      pointer to sigregs (followed by signal number)  */
else|else
block|{
name|regs
operator|=
operator|*
operator|(
name|sigregs_
operator|*
operator|*
operator|)
operator|(
name|context
operator|->
name|cfa
operator|+
literal|8
operator|)
expr_stmt|;
name|signo
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|regs
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|new_cfa
operator|=
name|regs
operator|->
name|gprs
index|[
literal|15
index|]
operator|+
literal|16
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
literal|32
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
literal|15
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|new_cfa
operator|-
operator|(
name|long
operator|)
name|context
operator|->
name|cfa
operator|+
literal|16
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
literal|32
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|regs
operator|->
name|gprs
index|[
name|i
index|]
operator|-
name|new_cfa
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|16
operator|+
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|16
operator|+
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|regs
operator|->
name|fprs
index|[
name|i
index|]
operator|-
name|new_cfa
expr_stmt|;
block|}
comment|/* Load return addr from PSW into dummy register 32.  */
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|32
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|32
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|long
operator|)
operator|&
name|regs
operator|->
name|psw_addr
operator|-
name|new_cfa
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
literal|32
expr_stmt|;
comment|/* SIGILL, SIGFPE and SIGTRAP are delivered with psw_addr      after the faulting instruction rather than before it.      Don't set FS->signal_frame in that case.  */
if|if
condition|(
operator|!
name|signo
operator|||
operator|(
operator|*
name|signo
operator|!=
literal|4
operator|&&
operator|*
name|signo
operator|!=
literal|5
operator|&&
operator|*
name|signo
operator|!=
literal|8
operator|)
condition|)
name|fs
operator|->
name|signal_frame
operator|=
literal|1
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

end_unit

