begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IBM S/390 and zSeries    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.    Contributed by Hartmut Penner (hpenner@de.ibm.com) and                   Ulrich Weigand (uweigand@de.ibm.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_decl_stmt
specifier|static
name|bool
name|s390_assemble_integer
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_adjust_priority
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_select_rtx_section
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_encode_section_info
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s390_strip_name_encoding
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|s390_cannot_force_const_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_init_builtins
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|s390_expand_builtin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_output_mi_thunk
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|tree
operator|,
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\t.quad\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|s390_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OPEN_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OPEN_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CLOSE_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CLOSE_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_SELECT_RTX_SECTION
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_SELECT_RTX_SECTION
value|s390_select_rtx_section
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|s390_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_PRIORITY
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_PRIORITY
value|s390_adjust_priority
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|s390_encode_section_info
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRIP_NAME_ENCODING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRIP_NAME_ENCODING
value|s390_strip_name_encoding
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|s390_cannot_force_const_mem
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|s390_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|s390_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|s390_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The alias set for prologue/epilogue register save/restore.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s390_sr_alias_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|s390_compare_op0
decl_stmt|,
name|s390_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The encoding characters for the four TLS models present in ELF.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|tls_model_chars
index|[]
init|=
literal|" GLil"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to hold the components of a S/390 memory    address.  A legitimate address on S/390 is of the general    form           base + index + displacement    where any of the components is optional.     base and index are registers of the class ADDR_REGS,    displacement is an unsigned 12-bit immediate constant.  */
end_comment

begin_struct
struct|struct
name|s390_address
block|{
name|rtx
name|base
decl_stmt|;
name|rtx
name|indx
decl_stmt|;
name|rtx
name|disp
decl_stmt|;
name|int
name|pointer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Define the structure for the machine field in struct function.  */
end_comment

begin_decl_stmt
name|struct
name|machine_function
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Label of start of initial literal pool.  */
name|rtx
name|literal_pool_label
decl_stmt|;
comment|/* Set, if some of the fprs 8-15 need to be saved (64 bit abi).  */
name|int
name|save_fprs_p
decl_stmt|;
comment|/* Number of first and last gpr to be saved, restored.  */
name|int
name|first_save_gpr
decl_stmt|;
name|int
name|first_restore_gpr
decl_stmt|;
name|int
name|last_save_gpr
decl_stmt|;
comment|/* Size of stack frame.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Some local-dynamic TLS symbol name.  */
specifier|const
name|char
modifier|*
name|some_ld_name
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_match_ccmode_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_branch_condition_mask
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s390_branch_condition_mnemonic
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_mode
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|general_s_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_decompose_address
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|s390_address
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_thread_pointer
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|legitimize_tls_address
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_some_local_dynamic_name_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_used_in_mem_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addr_generation_dependency_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_split_branches
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_constant_pool_ref
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_constant_pool_ref
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_base_register_in_addr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|s390_address
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|find_base_register_ref
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_base_register_ref
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_optimize_prolog
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|s390_fixup_clobbered_return_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_unused_clobbered_reg
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_frame_info
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|save_fpr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|restore_fpr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|save_gprs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|restore_gprs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_function_arg_size
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|machine_function
modifier|*
name|s390_init_machine_status
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if SET either doesn't set the CC register, or else    the source and destination have matching CC modes and that     CC mode is at least as constrained as REQ_MODE.  */
end_comment

begin_function
specifier|static
name|int
name|s390_match_ccmode_set
parameter_list|(
name|set
parameter_list|,
name|req_mode
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|enum
name|machine_mode
name|req_mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|set_mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CC_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|set_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|set_mode
condition|)
block|{
case|case
name|CCSmode
case|:
case|case
name|CCSRmode
case|:
case|case
name|CCUmode
case|:
case|case
name|CCURmode
case|:
case|case
name|CCLmode
case|:
case|case
name|CCL1mode
case|:
case|case
name|CCL2mode
case|:
case|case
name|CCT1mode
case|:
case|case
name|CCT2mode
case|:
case|case
name|CCT3mode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|set_mode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCZmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCSmode
operator|&&
name|req_mode
operator|!=
name|CCUmode
operator|&&
name|req_mode
operator|!=
name|CCTmode
operator|&&
name|req_mode
operator|!=
name|CCSRmode
operator|&&
name|req_mode
operator|!=
name|CCURmode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCAPmode
case|:
case|case
name|CCANmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCAmode
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|set_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if every SET in INSN that sets the CC register     has source and destination with matching CC modes and that     CC mode is at least as constrained as REQ_MODE.      If REQ_MODE is VOIDmode, always return false.  */
end_comment

begin_function
name|int
name|s390_match_ccmode
parameter_list|(
name|insn
parameter_list|,
name|req_mode
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|machine_mode
name|req_mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* s390_tm_ccmode returns VOIDmode to indicate failure.  */
if|if
condition|(
name|req_mode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
name|s390_match_ccmode_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|req_mode
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
condition|)
if|if
condition|(
operator|!
name|s390_match_ccmode_set
argument_list|(
name|set
argument_list|,
name|req_mode
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If a test-under-mask instruction can be used to implement     (compare (and ... OP1) OP2), return the CC mode required    to do that.  Otherwise, return VOIDmode.      MIXED is true if the instruction can distinguish between    CC1 and CC2 for mixed selected bits (TMxx), it is false    if the instruction cannot (TM).  */
end_comment

begin_function
name|enum
name|machine_mode
name|s390_tm_ccmode
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|,
name|mixed
parameter_list|)
name|rtx
name|op1
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|int
name|mixed
decl_stmt|;
block|{
name|int
name|bit0
decl_stmt|,
name|bit1
decl_stmt|;
comment|/* ??? Fixme: should work on CONST_DOUBLE as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|VOIDmode
return|;
comment|/* Selected bits all zero: CC0.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|CCTmode
return|;
comment|/* Selected bits all one: CC3.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|CCT3mode
return|;
comment|/* Exactly two bits selected, mixed zeroes and ones: CC1 or CC2.  */
if|if
condition|(
name|mixed
condition|)
block|{
name|bit1
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|bit0
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|^
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit0
operator|!=
operator|-
literal|1
operator|&&
name|bit1
operator|!=
operator|-
literal|1
condition|)
return|return
name|bit0
operator|>
name|bit1
condition|?
name|CCT1mode
else|:
name|CCT2mode
return|;
block|}
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Given a comparison code OP (EQ, NE, etc.) and the operands     OP0 and OP1 of a COMPARE, return the mode to be used for the     comparison.  */
end_comment

begin_function
name|enum
name|machine_mode
name|s390_select_ccmode
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
return|return
name|CCAPmode
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|CCLmode
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
condition|)
block|{
comment|/* Check whether we can potentially do it via TM.  */
name|enum
name|machine_mode
name|ccmode
decl_stmt|;
name|ccmode
operator|=
name|s390_tm_ccmode
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccmode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* Relax CCTmode to CCZmode to allow fall-back to AND 		   if that turns out to be beneficial.  */
return|return
name|ccmode
operator|==
name|CCTmode
condition|?
name|CCZmode
else|:
name|ccmode
return|;
block|}
block|}
if|if
condition|(
name|register_operand
argument_list|(
name|op0
argument_list|,
name|HImode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|65535
operator|)
condition|)
return|return
name|CCT3mode
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op0
argument_list|,
name|QImode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|255
operator|)
condition|)
return|return
name|CCT3mode
return|;
return|return
name|CCZmode
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|(
name|op0
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|CCANmode
return|;
else|else
return|return
name|CCAPmode
return|;
block|}
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|UNGE
case|:
case|case
name|UNGT
case|:
case|case
name|LTGT
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCSRmode
return|;
return|return
name|CCSmode
return|;
case|case
name|LTU
case|:
case|case
name|GEU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|CCL1mode
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCURmode
return|;
return|return
name|CCUmode
return|;
case|case
name|LEU
case|:
case|case
name|GTU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
condition|)
return|return
name|CCL2mode
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCURmode
return|;
return|return
name|CCUmode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return branch condition mask to implement a branch     specified by CODE.  */
end_comment

begin_function
specifier|static
name|int
name|s390_branch_condition_mask
parameter_list|(
name|code
parameter_list|)
name|rtx
name|code
decl_stmt|;
block|{
specifier|const
name|int
name|CC0
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
specifier|const
name|int
name|CC1
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
specifier|const
name|int
name|CC2
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
specifier|const
name|int
name|CC3
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|CC_REGNUM
operator|||
name|XEXP
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CCZmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCT1mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC1
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCT2mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC2
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCT3mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC3
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCLmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCL1mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|LTU
case|:
return|return
name|CC2
operator||
name|CC3
return|;
comment|/* carry */
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
comment|/* no carry */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCL2mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|GTU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
comment|/* borrow */
case|case
name|LEU
case|:
return|return
name|CC2
operator||
name|CC3
return|;
comment|/* no borrow */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCUmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LTU
case|:
return|return
name|CC1
return|;
case|case
name|GTU
case|:
return|return
name|CC2
return|;
case|case
name|LEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCURmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC2
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LTU
case|:
return|return
name|CC2
return|;
case|case
name|GTU
case|:
return|return
name|CC1
return|;
case|case
name|LEU
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCAPmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|GT
case|:
return|return
name|CC2
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCANmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
return|;
case|case
name|GT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCSmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
return|;
case|case
name|GT
case|:
return|return
name|CC2
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|UNORDERED
case|:
return|return
name|CC3
return|;
case|case
name|ORDERED
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC2
return|;
case|case
name|UNEQ
case|:
return|return
name|CC0
operator||
name|CC3
return|;
case|case
name|UNLT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|UNGT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|UNLE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|UNGE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LTGT
case|:
return|return
name|CC1
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCSRmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC2
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC2
return|;
case|case
name|GT
case|:
return|return
name|CC1
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|UNORDERED
case|:
return|return
name|CC3
return|;
case|case
name|ORDERED
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC1
return|;
case|case
name|UNEQ
case|:
return|return
name|CC0
operator||
name|CC3
return|;
case|case
name|UNLT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|UNGT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|UNLE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|UNGE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LTGT
case|:
return|return
name|CC2
operator||
name|CC1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If INV is false, return assembler mnemonic string to implement     a branch specified by CODE.  If INV is true, return mnemonic     for the corresponding inverted branch.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|s390_branch_condition_mnemonic
parameter_list|(
name|code
parameter_list|,
name|inv
parameter_list|)
name|rtx
name|code
decl_stmt|;
name|int
name|inv
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mnemonic
index|[
literal|16
index|]
init|=
block|{
name|NULL
block|,
literal|"o"
block|,
literal|"h"
block|,
literal|"nle"
block|,
literal|"l"
block|,
literal|"nhe"
block|,
literal|"lh"
block|,
literal|"ne"
block|,
literal|"e"
block|,
literal|"nlh"
block|,
literal|"he"
block|,
literal|"nl"
block|,
literal|"le"
block|,
literal|"nh"
block|,
literal|"no"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|mask
init|=
name|s390_branch_condition_mask
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|inv
condition|)
name|mask
operator|^=
literal|15
expr_stmt|;
if|if
condition|(
name|mask
operator|<
literal|1
operator|||
name|mask
operator|>
literal|14
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|mnemonic
index|[
name|mask
index|]
return|;
block|}
end_function

begin_comment
comment|/* If OP is an integer constant of mode MODE with exactly one    HImode subpart unequal to DEF, return the number of that     subpart.  As a special case, all HImode subparts of OP are    equal to DEF, return zero.  Otherwise, return -1.  */
end_comment

begin_function
name|int
name|s390_single_hi
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|def
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|def
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
literal|0
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|def
operator|&
literal|0xffff
argument_list|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|n_parts
operator|-
literal|1
operator|-
name|part
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
literal|0
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|16
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|def
operator|&
literal|0xffff
argument_list|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|n_parts
operator|-
literal|1
operator|-
name|part
operator|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Extract the HImode part number PART from integer     constant OP of mode MODE.  */
end_comment

begin_function
name|int
name|s390_extract_hi
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|part
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|part
operator|<
literal|0
operator|||
name|part
operator|>=
name|n_parts
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|part
operator|=
name|n_parts
operator|-
literal|1
operator|-
name|part
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|value
operator|>>
operator|(
literal|16
operator|*
name|part
operator|)
operator|)
operator|&
literal|0xffff
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
if|if
condition|(
name|part
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|16
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|,
name|part
operator|-=
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|16
expr_stmt|;
return|return
operator|(
operator|(
name|value
operator|>>
operator|(
literal|16
operator|*
name|part
operator|)
operator|)
operator|&
literal|0xffff
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If OP is an integer constant of mode MODE with exactly one    QImode subpart unequal to DEF, return the number of that     subpart.  As a special case, all QImode subparts of OP are    equal to DEF, return zero.  Otherwise, return -1.  */
end_comment

begin_function
name|int
name|s390_single_qi
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|def
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|def
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
literal|0
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|def
operator|&
literal|0xff
argument_list|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|n_parts
operator|-
literal|1
operator|-
name|part
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
literal|0
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|8
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|def
operator|&
literal|0xff
argument_list|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|n_parts
operator|-
literal|1
operator|-
name|part
operator|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Extract the QImode part number PART from integer     constant OP of mode MODE.  */
end_comment

begin_function
name|int
name|s390_extract_qi
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|part
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|<
literal|0
operator|||
name|part
operator|>=
name|n_parts
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|part
operator|=
name|n_parts
operator|-
literal|1
operator|-
name|part
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|value
operator|>>
operator|(
literal|8
operator|*
name|part
operator|)
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
if|if
condition|(
name|part
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|8
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|,
name|part
operator|-=
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|8
expr_stmt|;
return|return
operator|(
operator|(
name|value
operator|>>
operator|(
literal|8
operator|*
name|part
operator|)
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether we can (and want to) split a double-word     move in mode MODE from SRC to DST into two single-word     moves, moving the subword FIRST_SUBWORD first.  */
end_comment

begin_function
name|bool
name|s390_split_ok_p
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|mode
parameter_list|,
name|first_subword
parameter_list|)
name|rtx
name|dst
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|first_subword
decl_stmt|;
block|{
comment|/* Floating point registers cannot be split.  */
if|if
condition|(
name|FP_REG_P
argument_list|(
name|src
argument_list|)
operator|||
name|FP_REG_P
argument_list|(
name|dst
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We don't need to split if operands are directly accessable.  */
if|if
condition|(
name|s_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
operator|||
name|s_operand
argument_list|(
name|dst
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Non-offsettable memory references cannot be split.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|src
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Moving the first subword must not clobber a register      needed to move the second subword.  */
if|if
condition|(
name|register_operand
argument_list|(
name|dst
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|subreg
init|=
name|operand_subword
argument_list|(
name|dst
argument_list|,
name|first_subword
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|subreg
argument_list|,
name|src
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Change optimizations to be performed, depending on the     optimization level.     LEVEL is the optimization level specified; 2 if `-O2' is    specified, 1 if `-O' is specified, and 0 if neither is specified.     SIZE is nonzero if `-Os' is specified and zero otherwise.  */
end_comment

begin_function
name|void
name|optimization_options
parameter_list|(
name|level
parameter_list|,
name|size
parameter_list|)
name|int
name|level
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* ??? There are apparently still problems with -fcaller-saves.  */
name|flag_caller_saves
operator|=
literal|0
expr_stmt|;
comment|/* By default, always emit DWARF-2 unwind info.  This allows debugging      without maintaining a stack frame back-chain.  */
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|override_options
parameter_list|()
block|{
comment|/* Acquire a unique set number for our register saves and restores.  */
name|s390_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
comment|/* Set up function hooks.  */
name|init_machine_status
operator|=
name|s390_init_machine_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map for smallest class containing reg regno.  */
end_comment

begin_decl_stmt
specifier|const
name|enum
name|reg_class
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
name|GENERAL_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|ADDR_REGS
block|,
name|NO_REGS
block|,
name|ADDR_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if OP a (const_int 0) operand.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|const0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is constant.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|consttable_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the mode of operand OP matches MODE.    If MODE is set to VOIDmode, set it to the mode of OP.  */
end_comment

begin_function
specifier|static
name|int
name|check_mode
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|mode
operator|==
name|VOIDmode
condition|)
operator|*
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
operator|*
name|mode
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP a valid operand for the LARL instruction.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|larl_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|check_mode
argument_list|(
name|op
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow labels and local symbols.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|&&
operator|!
name|tls_symbolic_operand
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Everything else must have a CONST, so strip it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow adding *even* constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Labels and local symbols allowed here as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|&&
operator|!
name|tls_symbolic_operand
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Now we must have a @GOTENT offset or @PLT stub      or an @INDNTPOFF TLS offset.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
literal|111
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
literal|113
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_INDNTPOFF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper routine to implement s_operand and s_imm_operand.    OP is the current operation.    MODE is the current operation mode.    ALLOW_IMMEDIATE specifies whether immediate operands should    be accepted or not.  */
end_comment

begin_function
specifier|static
name|int
name|general_s_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|allow_immediate
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|allow_immediate
decl_stmt|;
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
comment|/* Call general_operand first, so that we don't have to      check for many special cases.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Just like memory_operand, allow (subreg (mem ...))      after reload.  */
if|if
condition|(
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Constants that we are sure will be forced to the          literal pool in reload are OK as s-operand.  Note 	 that we cannot call s390_preferred_reload_class here 	 because it might not be known yet at this point  	 whether the current function is a leaf or not.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
operator|!
name|allow_immediate
operator|||
name|reload_completed
condition|)
break|break;
if|if
condition|(
operator|!
name|legitimate_reload_constant_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
literal|1
return|;
break|break;
comment|/* Memory operands are OK unless they already use an 	 index register.  */
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|!
name|addr
operator|.
name|indx
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid S-type operand.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|general_s_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid S-type operand or an immediate     operand that can be addressed as S-type operand by forcing     it into the literal pool.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s_imm_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|general_s_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid operand for a 'Q' constraint.    This differs from s_operand in that only memory operands    without index register are accepted, nothing else.  */
end_comment

begin_function
name|int
name|q_constraint
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the cost of an address rtx ADDR.  */
end_comment

begin_function
name|int
name|s390_address_cost
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
condition|)
return|return
literal|1000
return|;
return|return
name|ad
operator|.
name|indx
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid operand for the BRAS instruction.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|bras_sym_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* Allow SYMBOL_REFs.  */
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
comment|/* Allow @PLT stubs.  */
if|if
condition|(
name|code
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|113
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If OP is a SYMBOL_REF of a thread-local symbol, return its TLS mode,    otherwise return 0.  */
end_comment

begin_function
name|int
name|tls_symbolic_operand
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|symbol_str
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
name|symbol_str
operator|=
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_str
index|[
literal|0
index|]
operator|!=
literal|'%'
condition|)
return|return
literal|0
return|;
return|return
name|strchr
argument_list|(
name|tls_model_chars
argument_list|,
name|symbol_str
index|[
literal|1
index|]
argument_list|)
operator|-
name|tls_model_chars
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if OP is a load multiple operation.  It is known to be a    PARALLEL and the first section will be tested.     OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check, is base, or base + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_addr
argument_list|)
operator|==
name|REG
condition|)
name|off
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|src_addr
operator|==
name|frame_pointer_rtx
operator|||
name|src_addr
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|Pmode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|Pmode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|off
operator|+
name|i
operator|*
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a store multiple operation.  It is known to be a    PARALLEL and the first section will be tested.     OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check, is base, or base + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest_addr
argument_list|)
operator|==
name|REG
condition|)
name|off
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest_addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|dest_addr
operator|==
name|frame_pointer_rtx
operator|||
name|dest_addr
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|Pmode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|Pmode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|off
operator|+
name|i
operator|*
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP contains a symbol reference */
end_comment

begin_function
name|int
name|symbolic_reference_mentioned_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP contains a reference to a thread-local symbol.  */
end_comment

begin_function
name|int
name|tls_symbolic_reference_mentioned_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|tls_symbolic_operand
argument_list|(
name|op
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|tls_symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|tls_symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a legitimate general operand when     generating PIC code.  It is given that flag_pic is on     and that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|legitimate_pic_operand_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
comment|/* Accept all non-symbolic constants.  */
if|if
condition|(
operator|!
name|SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Reject everything else; must be handled       via emit_symbolic_move.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the constant value OP is a legitimate general operand.    It is given that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|legitimate_constant_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
comment|/* Accept all non-symbolic constants.  */
if|if
condition|(
operator|!
name|SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Accept immediate LARL operands.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|larl_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Thread-local symbols are never legal constants.  This is      so that emit_call knows that computing such addresses      might require a function call.  */
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* In the PIC case, symbolic constants must *not* be      forced into the literal pool.  We accept them here,      so that they will be handled by emit_symbolic_move.  */
if|if
condition|(
name|flag_pic
condition|)
return|return
literal|1
return|;
comment|/* All remaining non-PIC symbolic constants are      forced into the literal pool.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine if it's legal to put X into the constant pool.  This    is not possible if X contains the address of a symbol that is    not constant (TLS) or not known at final link time (PIC).  */
end_comment

begin_function
specifier|static
name|bool
name|s390_cannot_force_const_mem
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
comment|/* Accept all non-symbolic constants.  */
return|return
name|false
return|;
case|case
name|LABEL_REF
case|:
comment|/* Labels are OK iff we are non-PIC.  */
return|return
name|flag_pic
operator|!=
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* 'Naked' TLS symbol references are never OK,          non-TLS symbols are OK iff we are non-PIC.  */
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|flag_pic
operator|!=
literal|0
return|;
case|case
name|CONST
case|:
return|return
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Only lt-relative or GOT-relative UNSPECs are OK.  */
case|case
literal|100
case|:
case|case
literal|104
case|:
case|case
literal|112
case|:
case|case
literal|114
case|:
case|case
name|UNSPEC_TLSGD
case|:
case|case
name|UNSPEC_TLSLDM
case|:
case|case
name|UNSPEC_NTPOFF
case|:
case|case
name|UNSPEC_DTPOFF
case|:
case|case
name|UNSPEC_GOTNTPOFF
case|:
case|case
name|UNSPEC_INDNTPOFF
case|:
return|return
name|false
return|;
default|default:
return|return
name|true
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if the constant value OP is a legitimate general    operand during and after reload.  The difference to     legitimate_constant_p is that this function will not accept    a constant that would need to be forced to the literal pool    before it can be used as operand.  */
end_comment

begin_function
name|int
name|legitimate_reload_constant_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
comment|/* Accept l(g)hi operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Accept lliXX operands.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|s390_single_hi
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Accept larl operands.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|larl_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Everything else cannot be handled without reload.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx OP being reloaded into a reg required to be in class CLASS,    return the class of reg to actually use.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_preferred_reload_class
parameter_list|(
name|op
parameter_list|,
name|class
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
comment|/* This can happen if a floating point constant is being      reloaded into an integer register.  Leave well alone.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|class
operator|!=
name|FP_REGS
condition|)
return|return
name|class
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Constants we cannot reload must be forced into the 	 literal pool.  */
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
if|if
condition|(
name|legitimate_reload_constant_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|class
return|;
else|else
return|return
name|NO_REGS
return|;
comment|/* If a symbolic constant or a PLUS is reloaded, 	 it is most likely being used as an address, so 	 prefer ADDR_REGS.  If 'class' is not a superset 	 of ADDR_REGS, e.g. FP_REGS, reject this reload.  */
case|case
name|PLUS
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|ADDR_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
else|else
return|return
name|NO_REGS
return|;
default|default:
break|break;
block|}
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* Return the register class of a scratch register needed to    load IN into a register of class CLASS in MODE.     We need a temporary when loading a PLUS expression which    is not a legitimate operand of the LOAD ADDRESS instruction.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_secondary_input_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
if|if
condition|(
name|s390_plus_operand
argument_list|(
name|in
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return the register class of a scratch register needed to    store a register of class CLASS in MODE into OUT:     We need a temporary when storing a double-word to a     non-offsettable memory address.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_secondary_output_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|out
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|out
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TARGET_64BIT
condition|?
name|mode
operator|==
name|TImode
else|:
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|)
operator|&&
name|reg_classes_intersect_p
argument_list|(
name|GENERAL_REGS
argument_list|,
name|class
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|out
argument_list|)
operator|&&
operator|!
name|s_operand
argument_list|(
name|out
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a PLUS that is not a legitimate    operand for the LA instruction.     OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s390_plus_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|check_mode
argument_list|(
name|op
argument_list|,
operator|&
name|mode
argument_list|)
operator|||
name|mode
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|legitimate_la_operand_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Generate code to load SRC, which is PLUS that is not a    legitimate operand for the LA instruction, into TARGET.    SCRATCH may be used as scratch register.  */
end_comment

begin_function
name|void
name|s390_expand_plus_operand
parameter_list|(
name|target
parameter_list|,
name|src
parameter_list|,
name|scratch
parameter_list|)
specifier|register
name|rtx
name|target
decl_stmt|;
specifier|register
name|rtx
name|src
decl_stmt|;
specifier|register
name|rtx
name|scratch
decl_stmt|;
block|{
name|rtx
name|sum1
decl_stmt|,
name|sum2
decl_stmt|;
name|struct
name|s390_address
name|ad
decl_stmt|;
comment|/* src must be a PLUS; get its two operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|Pmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check if any of the two operands is already scheduled      for replacement by reload.  This can happen e.g. when      float registers occur in an address.  */
name|sum1
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum1
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
comment|/* If the address is already strictly valid, there's nothing to do.  */
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|src
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|)
operator|||
operator|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
operator|)
condition|)
block|{
comment|/* Otherwise, one of the operands cannot be an address register;          we reload its value into the scratch register.  */
if|if
condition|(
name|true_regnum
argument_list|(
name|sum1
argument_list|)
operator|<
literal|1
operator|||
name|true_regnum
argument_list|(
name|sum1
argument_list|)
operator|>
literal|15
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|sum1
argument_list|)
expr_stmt|;
name|sum1
operator|=
name|scratch
expr_stmt|;
block|}
if|if
condition|(
name|true_regnum
argument_list|(
name|sum2
argument_list|)
operator|<
literal|1
operator|||
name|true_regnum
argument_list|(
name|sum2
argument_list|)
operator|>
literal|15
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|scratch
expr_stmt|;
block|}
comment|/* According to the way these invalid addresses are generated          in reload.c, it should never happen (at least on s390) that          *neither* of the PLUS components, after find_replacements          was applied, is an address register.  */
if|if
condition|(
name|sum1
operator|==
name|scratch
operator|&&
name|sum2
operator|==
name|scratch
condition|)
block|{
name|debug_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|src
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum1
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the LOAD ADDRESS pattern.  Note that reload of PLUS      is only ever performed on addresses, so we can mark the      sum as legitimate for LA in any case.  */
name|s390_load_address
argument_list|(
name|target
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decompose a RTL expression ADDR for a memory address into    its components, returned in OUT.     Returns 0 if ADDR is not a valid memory address, nonzero    otherwise.  If OUT is NULL, don't return the components,    but check for validity only.     Note: Only addresses in canonical form are recognized.    LEGITIMIZE_ADDRESS should convert non-canonical forms to the    canonical form so that they will be recognized.  */
end_comment

begin_function
specifier|static
name|int
name|s390_decompose_address
parameter_list|(
name|addr
parameter_list|,
name|out
parameter_list|)
specifier|register
name|rtx
name|addr
decl_stmt|;
name|struct
name|s390_address
modifier|*
name|out
decl_stmt|;
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|indx
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|disp
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|pointer
init|=
name|FALSE
decl_stmt|;
comment|/* Decompose address into base + index + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|UNSPEC
condition|)
block|{
name|indx
operator|=
name|op0
expr_stmt|;
comment|/* index + base */
name|base
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|op0
expr_stmt|;
comment|/* base + displacement */
name|disp
operator|=
name|op1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index + base + disp */
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Prefer to use pointer as base, not index.  */
if|if
condition|(
name|base
operator|&&
name|indx
condition|)
block|{
name|int
name|base_ptr
init|=
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|UNSPEC
operator|||
operator|(
name|REG_P
argument_list|(
name|base
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|base
argument_list|)
operator|)
decl_stmt|;
name|int
name|indx_ptr
init|=
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|==
name|UNSPEC
operator|||
operator|(
name|REG_P
argument_list|(
name|indx
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|indx
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|base_ptr
operator|&&
name|indx_ptr
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|indx
expr_stmt|;
name|indx
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* Validate base register.  */
if|if
condition|(
name|base
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
operator|!=
literal|101
condition|)
return|return
name|FALSE
return|;
name|base
operator|=
name|XVECEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|BASE_REGISTER
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Validate index register.  */
if|if
condition|(
name|indx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|indx
argument_list|,
literal|1
argument_list|)
operator|!=
literal|101
condition|)
return|return
name|FALSE
return|;
name|indx
operator|=
name|XVECEXP
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|BASE_REGISTER
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Validate displacement.  */
if|if
condition|(
name|disp
condition|)
block|{
comment|/* Allow integer constant in range.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* If the argument pointer is involved, the displacement will change 	     later anyway as the argument pointer gets eliminated.  This could 	     make a valid displacement invalid, but it is more likely to make 	     an invalid displacement valid, because we sometimes access the 	     register save area via negative offsets to the arg pointer. 	     Thus we don't check the displacement for validity here.  If after 	     elimination the displacement turns out to be invalid after all, 	     this is fixed up by reload in any case.  */
if|if
condition|(
name|base
operator|!=
name|arg_pointer_rtx
operator|&&
name|indx
operator|!=
name|arg_pointer_rtx
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|disp
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|disp
argument_list|)
operator|>=
literal|4096
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* In the small-PIC case, the linker converts @GOT12           and @GOTNTPOFF offsets to possible displacements.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|110
operator|||
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTNTPOFF
operator|)
condition|)
block|{
if|if
condition|(
name|flag_pic
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Accept chunkfied literal pool symbol references.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Likewise if a constant offset is present.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We can convert literal pool addresses to           displacements by basing them off the base register.  */
else|else
block|{
comment|/* In some cases, we can accept an additional              small constant offset.  Split these off here.  */
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now we must have a literal pool address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|disp
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we have an offset, make sure it does not              exceed the size of the constant pool entry.  */
if|if
condition|(
name|offset
operator|&&
name|offset
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|disp
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Either base or index must be free to               hold the base register.  */
if|if
condition|(
name|base
operator|&&
name|indx
condition|)
return|return
name|FALSE
return|;
comment|/* Convert the address.  */
if|if
condition|(
name|base
condition|)
name|indx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|disp
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|disp
operator|=
name|plus_constant
argument_list|(
name|disp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|indx
condition|)
name|pointer
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|out
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|out
operator|->
name|indx
operator|=
name|indx
expr_stmt|;
name|out
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|out
operator|->
name|pointer
operator|=
name|pointer
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ADDR is a valid memory address.    STRICT specifies whether strict register checking applies.  */
end_comment

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|,
name|strict
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strict
condition|)
block|{
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REG_OK_FOR_INDEX_NONSTRICT_P
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the LA instruction.    In 31-bit, we need to prove that the result is used as an    address, as LA performs only a 31-bit addition.  */
end_comment

begin_function
name|int
name|legitimate_la_operand_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|addr
operator|.
name|pointer
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the LA instruction,    and we prefer to use LA over addition to compute it.  */
end_comment

begin_function
name|int
name|preferred_la_operand_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
operator|!
name|addr
operator|.
name|pointer
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|addr
operator|.
name|pointer
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
name|addr
operator|.
name|base
operator|&&
name|REG_P
argument_list|(
name|addr
operator|.
name|base
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|addr
operator|.
name|base
argument_list|)
operator|)
operator|||
operator|(
name|addr
operator|.
name|indx
operator|&&
name|REG_P
argument_list|(
name|addr
operator|.
name|indx
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|addr
operator|.
name|indx
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Emit a forced load-address operation to load SRC into DST.    This will use the LOAD ADDRESS instruction even in situations    where legitimate_la_operand_p (SRC) returns false.  */
end_comment

begin_function
name|void
name|s390_load_address
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|rtx
name|dst
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_force_la_31
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are two types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references, constant pool addresses, and code labels       compute the address as an offset from the GOT, whose base is in       the PIC reg.  Static data objects have SYMBOL_REF_FLAG set to       differentiate them from global data objects.  The returned       address is the PIC reg + an unspec constant.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|SYMBOL_REF_FLAG
argument_list|(
name|addr
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This is a local symbol.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|larl_operand
argument_list|(
name|addr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
comment|/* Access local symbols PC-relative via LARL.                This is the same as in the non-PIC case, so it is               handled automatically ...  */
block|}
else|else
block|{
comment|/* Access local symbols relative to the literal pool.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|base
argument_list|)
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
comment|/* Assume GOT offset< 4k.  This is handled the same way              in both 31- and 64-bit code (@GOT12).  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|110
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we determine the position              of the GOT entry via a PC-relative LARL (@GOTENT).  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|111
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* If the GOT offset might be>= 4k, we have to load it               from the literal pool (@GOT).  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|112
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If someone moved an @GOT or lt-relative UNSPEC                      out of the literal pool, force them back in.  */
case|case
literal|100
case|:
case|case
literal|112
case|:
case|case
literal|114
case|:
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
break|break;
comment|/* @GOTENT is OK as is.  */
case|case
literal|111
case|:
break|break;
comment|/* @PLT is OK as is on 64-bit, must be converted to                      lt-relative PLT on 31-bit.  */
case|case
literal|113
case|:
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|114
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|base
argument_list|)
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
break|break;
comment|/* Everything else cannot happen.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check first to see if this is a constant offset               from a local symbol reference.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|SYMBOL_REF_FLAG
argument_list|(
name|op0
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op0
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|larl_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
condition|)
block|{
comment|/* LARL can't handle odd offsets, so emit a                           pair of LARL and LA.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|4096
condition|)
block|{
name|int
name|even
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
decl_stmt|;
name|op0
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|even
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the offset is even, we can just use LARL.                          This will happen automatically.  */
block|}
block|}
else|else
block|{
comment|/* Access local symbols relative to the literal pool.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op0
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|base
argument_list|)
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
comment|/* Now, check whether it is an LT-relative symbol plus offset              that was pulled out of the literal pool.  Force it back in.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|!=
literal|100
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, compute the sum.  */
else|else
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST
condition|)
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_operand
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Load the thread pointer into a register.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_thread_pointer
parameter_list|()
block|{
name|rtx
name|tp
decl_stmt|;
name|tp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TP
argument_list|)
expr_stmt|;
name|tp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|mark_reg_pointer
argument_list|(
name|tp
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for the tls_get_offset function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|s390_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|s390_tls_get_offset
parameter_list|()
block|{
if|if
condition|(
operator|!
name|s390_tls_symbol
condition|)
name|s390_tls_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__tls_get_offset"
argument_list|)
expr_stmt|;
return|return
name|s390_tls_symbol
return|;
block|}
end_function

begin_comment
comment|/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute    this (thread-local) address.  REG may be used as temporary.  */
end_comment

begin_function
specifier|static
name|rtx
name|legitimize_tls_address
parameter_list|(
name|addr
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|new
decl_stmt|,
name|tls_call
decl_stmt|,
name|temp
decl_stmt|,
name|base
decl_stmt|,
name|r2
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
switch|switch
condition|(
name|tls_symbolic_operand
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|r2
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tls_call
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLSGD
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|tls_call
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_call_value_tls
argument_list|(
name|r2
argument_list|,
name|tls_call
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_NTPOFF
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|,
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|r2
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tls_call
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLDM
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|tls_call
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_call_value_tls
argument_list|(
name|r2
argument_list|,
name|tls_call
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLDM_NTPOFF
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|,
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_DTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
comment|/* Assume GOT offset< 4k.  This is handled the same way 	       in both 31- and 64-bit code.  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we determine the position 	       of the GOT entry via a PC-relative LARL.  */
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_INDNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we have to load it  	       from the literal pool.  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|new
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLS_LOAD
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In position-dependent code, load the absolute address of 	       the GOT entry from the literal pool.  */
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_INDNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|temp
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|new
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLS_LOAD
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_NTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
switch|switch
condition|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_INDNTPOFF
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
name|new
operator|=
name|addr
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* for now ... */
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].  */
end_comment

begin_function
name|void
name|emit_symbolic_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|no_new_pseudos
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_tls_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address X    to be legitimate.  If we find one, return the new, valid address.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE is the mode of the operand pointed to by X.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|x
parameter_list|,
name|oldx
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|legitimize_tls_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
if|if
condition|(
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
block|}
name|x
operator|=
name|eliminate_constant_term
argument_list|(
name|x
argument_list|,
operator|&
name|constant_term
argument_list|)
expr_stmt|;
comment|/* Optimize loading of large displacements by splitting them      into the multiple of 4K and the rest; this allows the      former to be CSE'd if possible.        Don't do this if the displacement is added to a register      pointing into the stack frame, as the offsets will      change later anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|constant_term
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
operator|>=
literal|4096
operator|)
operator|&&
operator|!
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO_PTR_FRAME_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|lower
init|=
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
operator|&
literal|0xfff
decl_stmt|;
name|HOST_WIDE_INT
name|upper
init|=
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
operator|^
name|lower
decl_stmt|;
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|GEN_INT
argument_list|(
name|upper
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|constant_term
operator|=
name|GEN_INT
argument_list|(
name|lower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constant_term
operator|!=
name|const0_rtx
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|constant_term
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Emit code to move LEN bytes from DST to SRC.  */
end_comment

begin_function
name|void
name|s390_expand_movstr
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
name|rtx
name|dst
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|rtx
name|len
decl_stmt|;
block|{
name|rtx
argument_list|(
argument|*gen_short
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|TARGET_64BIT
condition|?
name|gen_movstr_short_64
else|:
name|gen_movstr_short_31
expr_stmt|;
name|rtx
argument_list|(
argument|*gen_long
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|TARGET_64BIT
condition|?
name|gen_movstr_long_64
else|:
name|gen_movstr_long_31
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_short
call|)
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MVCLE
condition|)
block|{
name|enum
name|machine_mode
name|double_mode
init|=
name|TARGET_64BIT
condition|?
name|TImode
else|:
name|DImode
decl_stmt|;
name|enum
name|machine_mode
name|single_mode
init|=
name|TARGET_64BIT
condition|?
name|DImode
else|:
name|SImode
decl_stmt|;
name|rtx
name|reg0
init|=
name|gen_reg_rtx
argument_list|(
name|double_mode
argument_list|)
decl_stmt|;
name|rtx
name|reg1
init|=
name|gen_reg_rtx
argument_list|(
name|double_mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|single_mode
argument_list|,
name|reg0
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|single_mode
argument_list|,
name|reg1
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|single_mode
argument_list|,
name|reg0
argument_list|)
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|single_mode
argument_list|,
name|reg1
argument_list|)
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_long
call|)
argument_list|(
name|reg0
argument_list|,
name|reg1
argument_list|,
name|reg0
argument_list|,
name|reg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dst_addr
decl_stmt|,
name|src_addr
decl_stmt|,
name|count
decl_stmt|,
name|blocks
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|word_mode
expr_stmt|;
name|type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dst_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|count
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|count
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|count
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dst_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|src_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|VOIDmode
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|src
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|count
argument_list|,
name|constm1_rtx
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|count
condition|)
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_exit_loop_top_cond
argument_list|(
literal|0
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|blocks
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_short
call|)
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
literal|255
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|dst_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dst_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|src_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|src_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|blocks
argument_list|,
name|constm1_rtx
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_short
call|)
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to clear LEN bytes at DST.  */
end_comment

begin_function
name|void
name|s390_expand_clrstr
parameter_list|(
name|dst
parameter_list|,
name|len
parameter_list|)
name|rtx
name|dst
decl_stmt|;
name|rtx
name|len
decl_stmt|;
block|{
name|rtx
argument_list|(
argument|*gen_short
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|TARGET_64BIT
condition|?
name|gen_clrstr_short_64
else|:
name|gen_clrstr_short_31
expr_stmt|;
name|rtx
argument_list|(
argument|*gen_long
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|TARGET_64BIT
condition|?
name|gen_clrstr_long_64
else|:
name|gen_clrstr_long_31
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_short
call|)
argument_list|(
name|dst
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MVCLE
condition|)
block|{
name|enum
name|machine_mode
name|double_mode
init|=
name|TARGET_64BIT
condition|?
name|TImode
else|:
name|DImode
decl_stmt|;
name|enum
name|machine_mode
name|single_mode
init|=
name|TARGET_64BIT
condition|?
name|DImode
else|:
name|SImode
decl_stmt|;
name|rtx
name|reg0
init|=
name|gen_reg_rtx
argument_list|(
name|double_mode
argument_list|)
decl_stmt|;
name|rtx
name|reg1
init|=
name|gen_reg_rtx
argument_list|(
name|double_mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|single_mode
argument_list|,
name|reg0
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|single_mode
argument_list|,
name|reg0
argument_list|)
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|single_mode
argument_list|,
name|reg1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|single_mode
argument_list|,
name|reg1
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_long
call|)
argument_list|(
name|reg0
argument_list|,
name|reg1
argument_list|,
name|reg0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dst_addr
decl_stmt|,
name|src_addr
decl_stmt|,
name|count
decl_stmt|,
name|blocks
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|word_mode
expr_stmt|;
name|type
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
call|)
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dst_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|count
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|count
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|count
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dst_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|VOIDmode
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|count
argument_list|,
name|constm1_rtx
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|count
condition|)
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_exit_loop_top_cond
argument_list|(
literal|0
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|blocks
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_short
call|)
argument_list|(
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|255
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|dst_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dst_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|blocks
argument_list|,
name|constm1_rtx
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_short
call|)
argument_list|(
name|dst
argument_list|,
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to compare LEN bytes at OP0 with those at OP1,    and return the result in TARGET.  */
end_comment

begin_function
name|void
name|s390_expand_cmpstr
parameter_list|(
name|target
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|len
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|rtx
name|len
decl_stmt|;
block|{
name|rtx
argument_list|(
argument|*gen_short
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|TARGET_64BIT
condition|?
name|gen_cmpstr_short_64
else|:
name|gen_cmpstr_short_31
expr_stmt|;
name|rtx
argument_list|(
argument|*gen_long
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|TARGET_64BIT
condition|?
name|gen_cmpstr_long_64
else|:
name|gen_cmpstr_long_31
expr_stmt|;
name|rtx
argument_list|(
argument|*gen_result
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
operator|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|DImode
condition|?
name|gen_cmpint_di
else|:
name|gen_cmpint_si
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|protect_from_queue
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_short
call|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_result
call|)
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if (TARGET_MVCLE) */
block|{
name|enum
name|machine_mode
name|double_mode
init|=
name|TARGET_64BIT
condition|?
name|TImode
else|:
name|DImode
decl_stmt|;
name|enum
name|machine_mode
name|single_mode
init|=
name|TARGET_64BIT
condition|?
name|DImode
else|:
name|SImode
decl_stmt|;
name|rtx
name|reg0
init|=
name|gen_reg_rtx
argument_list|(
name|double_mode
argument_list|)
decl_stmt|;
name|rtx
name|reg1
init|=
name|gen_reg_rtx
argument_list|(
name|double_mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|single_mode
argument_list|,
name|reg0
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|single_mode
argument_list|,
name|reg1
argument_list|)
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|single_mode
argument_list|,
name|reg0
argument_list|)
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|gen_lowpart
argument_list|(
name|single_mode
argument_list|,
name|reg1
argument_list|)
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_long
call|)
argument_list|(
name|reg0
argument_list|,
name|reg1
argument_list|,
name|reg0
argument_list|,
name|reg1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
call|(
modifier|*
name|gen_result
call|)
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Deactivate for now as profile code cannot cope with      CC being live across basic block boundaries.  */
block|else     {       rtx addr0, addr1, count, blocks, temp;       rtx end_label = gen_label_rtx ();       enum machine_mode mode;       tree type;        mode = GET_MODE (len);       if (mode == VOIDmode)         mode = word_mode;        type = (*lang_hooks.types.type_for_mode) (mode, 1);       if (!type)         abort ();        addr0 = gen_reg_rtx (Pmode);       addr1 = gen_reg_rtx (Pmode);       count = gen_reg_rtx (mode);       blocks = gen_reg_rtx (mode);        convert_move (count, len, 1);       emit_cmp_and_jump_insns (count, const0_rtx,  			       EQ, NULL_RTX, mode, 1, end_label);        emit_move_insn (addr0, force_operand (XEXP (op0, 0), NULL_RTX));       emit_move_insn (addr1, force_operand (XEXP (op1, 0), NULL_RTX));       op0 = change_address (op0, VOIDmode, addr0);       op1 = change_address (op1, VOIDmode, addr1);             temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);       if (temp != count)         emit_move_insn (count, temp);        temp = expand_binop (mode, ashr_optab, count, GEN_INT (8), blocks, 1, 0);       if (temp != blocks)         emit_move_insn (blocks, temp);        expand_start_loop (1);       expand_exit_loop_top_cond (0, build (NE_EXPR, type, 					   make_tree (type, blocks), 					   make_tree (type, const0_rtx)));        emit_insn ((*gen_short) (op0, op1, GEN_INT (255)));       temp = gen_rtx_NE (VOIDmode, gen_rtx_REG (CCSmode, 33), const0_rtx);       temp = gen_rtx_IF_THEN_ELSE (VOIDmode, temp,  			gen_rtx_LABEL_REF (VOIDmode, end_label), pc_rtx);       temp = gen_rtx_SET (VOIDmode, pc_rtx, temp);       emit_jump_insn (temp);        s390_load_address (addr0,  			 gen_rtx_PLUS (Pmode, addr0, GEN_INT (256)));       s390_load_address (addr1,  			 gen_rtx_PLUS (Pmode, addr1, GEN_INT (256)));              temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);       if (temp != blocks)         emit_move_insn (blocks, temp);        expand_end_loop ();        emit_insn ((*gen_short) (op0, op1, convert_to_mode (word_mode, count, 1)));       emit_label (end_label);        emit_insn ((*gen_result) (target));     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* In the name of slightly smaller debug output, and to cater to    general assembler losage, recognize various UNSPEC sequences    and turn them back into a direct symbol reference.  */
end_comment

begin_function
name|rtx
name|s390_simplify_dwarf_addr
parameter_list|(
name|orig_x
parameter_list|)
name|rtx
name|orig_x
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|orig_x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|orig_x
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
block|{
name|y
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
literal|110
condition|)
return|return
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
literal|111
condition|)
return|return
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
return|return
name|orig_x
return|;
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in local-dynamic base patterns.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|get_pool_constant
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|tls_symbolic_operand
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output symbolic constant X in assembler syntax to     stdio stream FILE.  */
end_comment

begin_function
name|void
name|s390_output_symbolic_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|SYMBOL_REF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand (1)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|100
case|:
case|case
literal|104
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|literal_pool_label
argument_list|)
expr_stmt|;
break|break;
case|case
literal|105
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|literal_pool_label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|110
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOT12"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|111
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTENT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|112
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|113
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|114
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLT-"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|literal_pool_label
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TLSGD
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@TLSGD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TLSLDM
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@TLSLDM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_DTPOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@DTPOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_NTPOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@NTPOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTNTPOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTNTPOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_INDNTPOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@INDNTPOFF"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand (2)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"UNKNOWN in s390_output_symbolic_const !?"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output address operand ADDR in assembler syntax to     stdio stream FILE.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|)
operator|||
operator|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"Cannot decompose address."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
name|ad
operator|.
name|indx
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s,%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output operand X in assembler syntax to stdio stream FILE.      CODE specified the format flag.  The following format flags     are recognized:      'C': print opcode suffix for branch condition.     'D': print opcode suffix for inverse branch condition.     'J': print tls_load/tls_gdcall/tls_ldcall suffix     'O': print only the displacement of a memory reference.     'R': print only the base register of a memory reference.     'N': print the second word of a DImode operand.     'M': print the second word of a TImode operand.      'b': print integer X as if it's an unsigned byte.     'x': print integer X as if it's an unsigned word.     'h': print integer X as if it's a signed word.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'C'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|s390_branch_condition_mnemonic
argument_list|(
name|x
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|s390_branch_condition_mnemonic
argument_list|(
name|x
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_load:"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSGD
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_gdcall:"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSLDM
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_ldcall:"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|)
operator|||
name|ad
operator|.
name|indx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'R'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|)
operator|||
name|ad
operator|.
name|indx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'N'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'x'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'x'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"UNKNOWN in print_operand !?"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Target hook for assembling integer objects.  We need to define it    here to work a round a bug in some versions of GAS, which couldn't    handle values smaller than INT_MIN when printed in decimal.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|aligned_p
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
name|aligned_p
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
name|INT_MIN
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.quad\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DEBUG_SCHED
value|0
end_define

begin_comment
comment|/* Returns true if register REGNO is used  for forming     a memory address in expression X.  */
end_comment

begin_function
specifier|static
name|int
name|reg_used_in_mem_p
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if expression DEP_RTX sets an address register    used by instruction INSN to address memory.  */
end_comment

begin_function
specifier|static
name|int
name|addr_generation_dependency_p
parameter_list|(
name|dep_rtx
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|dep_rtx
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|target
decl_stmt|,
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
condition|)
block|{
name|target
operator|=
name|SET_DEST
argument_list|(
name|dep_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|target
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
condition|)
name|target
operator|=
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_LA
condition|)
block|{
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|get_attr_atype
argument_list|(
name|insn
argument_list|)
operator|==
name|ATYPE_MEM
condition|)
return|return
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the modified cost of the dependency of instruction INSN    on instruction DEP_INSN through the link LINK.  COST is the     default cost of that dependency.     Data dependencies are all handled without delay.  However, if a    register is modified and subsequently used as base or index     register of a memory reference, at least 4 cycles need to pass    between setting and using the register to avoid pipeline stalls.      An exception is the LA instruction. An address generated by LA can    be used by introducing only a one cycle stall on the pipeline.  */
end_comment

begin_function
specifier|static
name|int
name|s390_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|rtx
name|dep_rtx
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If the dependence is an anti-dependence, there is no cost.  For an      output dependence, there is sometimes a cost, but it doesn't seem      worth handling those few cases.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|dep_rtx
operator|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|addr_generation_dependency_p
argument_list|(
name|dep_rtx
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|cost
operator|+=
operator|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LA
operator|)
condition|?
literal|1
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|DEBUG_SCHED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\nAddress dependency detected: cost %d\n"
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr_generation_dependency_p
argument_list|(
name|XVECEXP
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|cost
operator|+=
operator|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LA
operator|)
condition|?
literal|1
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|DEBUG_SCHED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\nAddress dependency detected: cost %d\n"
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* A C statement (sans semicolon) to update the integer scheduling priority    INSN_PRIORITY (INSN).  Reduce the priority to execute the INSN earlier,    increase the priority to execute INSN later.  Do not define this macro if    you do not need to adjust the scheduling priorities of insns.      A LA instruction maybe scheduled later, since the pipeline bypasses the    calculated value.  */
end_comment

begin_function
specifier|static
name|int
name|s390_adjust_priority
parameter_list|(
name|insn
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|priority
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|priority
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|TYPE_LA
case|:
if|if
condition|(
name|priority
operator|>=
literal|0
operator|&&
name|priority
operator|<
literal|0x01000000
condition|)
name|priority
operator|<<=
literal|3
expr_stmt|;
break|break;
case|case
name|TYPE_LM
case|:
comment|/* LM in epilogue should never be scheduled. This 	 is due to literal access done in function body. 	 The usage of register 13 is not mentioned explicitly, 	 leading to scheduling 'LM' accross this instructions.         */
name|priority
operator|=
literal|0x7fffffff
expr_stmt|;
break|break;
block|}
return|return
name|priority
return|;
block|}
end_function

begin_comment
comment|/* Split all branches that exceed the maximum distance.      Returns true if this created a new literal pool entry.       Code generated by this routine is allowed to use    TEMP_REG as temporary scratch register.  If this is    done, TEMP_USED is set to true.  */
end_comment

begin_function
specifier|static
name|int
name|s390_split_branches
parameter_list|(
name|temp_reg
parameter_list|,
name|temp_used
parameter_list|)
name|rtx
name|temp_reg
decl_stmt|;
name|bool
modifier|*
name|temp_used
decl_stmt|;
block|{
name|int
name|new_literal
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|,
name|tmp
decl_stmt|,
name|target
decl_stmt|;
name|rtx
modifier|*
name|label
decl_stmt|;
comment|/* We need correct insn addresses.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Find all branches that exceed 64KB, and split them.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|!=
name|pc_rtx
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
else|else
continue|continue;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|<=
operator|(
name|TARGET_64BIT
condition|?
literal|6
else|:
literal|4
operator|)
condition|)
continue|continue;
operator|*
name|temp_used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
operator|*
name|label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|temp_reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|new_literal
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
operator|*
name|label
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|temp_reg
expr_stmt|;
block|}
else|else
block|{
name|new_literal
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
operator|*
name|label
argument_list|)
argument_list|,
literal|104
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_const_mem
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|target
argument_list|,
name|temp_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
name|label
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|new_literal
return|;
block|}
end_function

begin_comment
comment|/* Find a literal pool symbol referenced in RTX X, and store     it at REF.  Will abort if X contains references to more than     one such pool symbol; multiple references to the same symbol    are allowed, however.      The rtx pointed to by REF must be initialized to NULL_RTX     by the caller before calling this routine.  */
end_comment

begin_function
specifier|static
name|void
name|find_constant_pool_ref
parameter_list|(
name|x
parameter_list|,
name|ref
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|ref
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|ref
operator|==
name|NULL_RTX
condition|)
operator|*
name|ref
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ref
operator|!=
name|x
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|find_constant_pool_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_constant_pool_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace every reference to the literal pool symbol REF    in X by the address ADDR.  Fix up MEMs as required.  */
end_comment

begin_function
specifier|static
name|void
name|replace_constant_pool_ref
parameter_list|(
name|x
parameter_list|,
name|ref
parameter_list|,
name|addr
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|rtx
name|ref
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
operator|*
name|x
operator|==
name|ref
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Literal pool references can only occur inside a MEM ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|memref
init|=
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|memref
operator|==
name|ref
condition|)
block|{
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|ref
condition|)
block|{
name|HOST_WIDE_INT
name|off
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* ... or a load-address type pattern.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|addrref
init|=
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|addrref
operator|==
name|ref
condition|)
block|{
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addrref
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|ref
condition|)
block|{
name|HOST_WIDE_INT
name|off
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|replace_constant_pool_ref
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_constant_pool_ref
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check whether ADDR is an address that uses the base register,     without actually constituting a literal pool access.  (This happens    in 31-bit PIC mode, where the base register is used as anchor for    relative addressing of local symbols.)      Returns 1 if the base register occupies the base slot,    returns 2 if the base register occupies the index slot,    returns 0 if the address is not of this form.  */
end_comment

begin_function
specifier|static
name|int
name|find_base_register_in_addr
parameter_list|(
name|addr
parameter_list|)
name|struct
name|s390_address
modifier|*
name|addr
decl_stmt|;
block|{
comment|/* If DISP is complex, we might have a literal pool reference.  */
if|if
condition|(
name|addr
operator|->
name|disp
operator|&&
name|GET_CODE
argument_list|(
name|addr
operator|->
name|disp
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
operator|->
name|base
operator|&&
name|REG_P
argument_list|(
name|addr
operator|->
name|base
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|addr
operator|->
name|base
argument_list|)
operator|==
name|BASE_REGISTER
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|addr
operator|->
name|indx
operator|&&
name|REG_P
argument_list|(
name|addr
operator|->
name|indx
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|addr
operator|->
name|indx
argument_list|)
operator|==
name|BASE_REGISTER
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if X contains an address that uses the base register,     without actually constituting a literal pool access.  */
end_comment

begin_function
specifier|static
name|bool
name|find_base_register_ref
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|bool
name|retv
init|=
name|FALSE
decl_stmt|;
name|struct
name|s390_address
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Addresses can only occur inside a MEM ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
name|find_base_register_in_addr
argument_list|(
operator|&
name|addr
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* ... or a load-address type pattern.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
name|find_base_register_in_addr
argument_list|(
operator|&
name|addr
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|retv
operator||=
name|find_base_register_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|retv
operator||=
name|find_base_register_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/* If X contains an address that uses the base register,    without actually constituting a literal pool access,    replace the base register with REPL in all such cases.     Handles both MEMs and load address patterns.  */
end_comment

begin_function
specifier|static
name|void
name|replace_base_register_ref
parameter_list|(
name|x
parameter_list|,
name|repl
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|rtx
name|repl
decl_stmt|;
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
name|rtx
name|new_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|pos
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Addresses can only occur inside a MEM ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|(
name|pos
operator|=
name|find_base_register_in_addr
argument_list|(
operator|&
name|addr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|1
condition|)
name|addr
operator|.
name|base
operator|=
name|repl
expr_stmt|;
else|else
name|addr
operator|.
name|indx
operator|=
name|repl
expr_stmt|;
name|new_addr
operator|=
name|addr
operator|.
name|base
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
name|new_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new_addr
argument_list|,
name|addr
operator|.
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|disp
condition|)
name|new_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new_addr
argument_list|,
name|addr
operator|.
name|disp
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|new_addr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* ... or a load-address type pattern.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|(
name|pos
operator|=
name|find_base_register_in_addr
argument_list|(
operator|&
name|addr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|1
condition|)
name|addr
operator|.
name|base
operator|=
name|repl
expr_stmt|;
else|else
name|addr
operator|.
name|indx
operator|=
name|repl
expr_stmt|;
name|new_addr
operator|=
name|addr
operator|.
name|base
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
name|new_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new_addr
argument_list|,
name|addr
operator|.
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|disp
condition|)
name|new_addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new_addr
argument_list|,
name|addr
operator|.
name|disp
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|new_addr
expr_stmt|;
return|return;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|replace_base_register_ref
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|repl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_base_register_ref
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|repl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We keep a list of constants we which we have to add to internal    constant tables in the middle of large functions.  */
end_comment

begin_define
define|#
directive|define
name|NR_C_MODES
value|6
end_define

begin_decl_stmt
name|enum
name|machine_mode
name|constant_modes
index|[
name|NR_C_MODES
index|]
init|=
block|{
name|DFmode
block|,
name|DImode
block|,
name|SFmode
block|,
name|SImode
block|,
name|HImode
block|,
name|QImode
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
function_decl|(
modifier|*
name|gen_consttable
index|[
name|NR_C_MODES
index|]
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
init|=
block|{
name|gen_consttable_df
operator|,
function_decl|gen_consttable_di
operator|,
function_decl|gen_consttable_sf
operator|,
function_decl|gen_consttable_si
operator|,
function_decl|gen_consttable_hi
operator|,
function_decl|gen_consttable_qi
end_function_decl

begin_struct
unit|};
struct|struct
name|constant
block|{
name|struct
name|constant
modifier|*
name|next
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|constant_pool
block|{
name|struct
name|constant_pool
modifier|*
name|next
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|rtx
name|pool_insn
decl_stmt|;
name|bitmap
name|insns
decl_stmt|;
name|struct
name|constant
modifier|*
name|constants
index|[
name|NR_C_MODES
index|]
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|size
decl_stmt|;
name|bool
name|anchor
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_chunkify_start
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_chunkify_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_chunkify_cancel
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_start_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_end_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_add_pool_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_find_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_add_constant
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|s390_find_constant
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_add_anchor
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|s390_dump_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_free_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create new constant pool covering instructions starting at INSN    and chain it to the end of POOL_LIST.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_start_pool
parameter_list|(
name|pool_list
parameter_list|,
name|insn
parameter_list|)
name|struct
name|constant_pool
modifier|*
modifier|*
name|pool_list
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pool
operator|=
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
name|pool
operator|->
name|constants
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pool
operator|->
name|first_insn
operator|=
name|insn
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|pool
operator|->
name|insns
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|pool
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|anchor
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|pool_list
init|;
operator|*
name|prev
condition|;
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|prev
operator|=
name|pool
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* End range of instructions covered by POOL at INSN and emit    placeholder insn representing the pool.  */
end_comment

begin_function
specifier|static
name|void
name|s390_end_pool
parameter_list|(
name|pool
parameter_list|,
name|insn
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pool_size
init|=
name|GEN_INT
argument_list|(
name|pool
operator|->
name|size
operator|+
literal|8
comment|/* alignment slop */
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|pool_size
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the list of insns covered by POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_add_pool_insn
parameter_list|(
name|pool
parameter_list|,
name|insn
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|bitmap_set_bit
argument_list|(
name|pool
operator|->
name|insns
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return pool out of POOL_LIST that covers INSN.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_find_pool
parameter_list|(
name|pool_list
parameter_list|,
name|insn
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool_list
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|pool_list
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|pool
operator|->
name|insns
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
break|break;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* Add constant VAL of mode MODE to the constant pool POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_add_constant
parameter_list|(
name|pool
parameter_list|,
name|val
parameter_list|,
name|mode
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constant_modes
index|[
name|i
index|]
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NR_C_MODES
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|val
argument_list|,
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
operator|(
expr|struct
name|constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|c
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
expr_stmt|;
name|pool
operator|->
name|constants
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|pool
operator|->
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find constant VAL of mode MODE in the constant pool POOL.    Return an RTX describing the distance from the start of    the pool to the location of the new constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_find_constant
parameter_list|(
name|pool
parameter_list|,
name|val
parameter_list|,
name|mode
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constant_modes
index|[
name|i
index|]
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NR_C_MODES
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|val
argument_list|,
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|c
operator|->
name|label
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Set 'anchor' flag in POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_add_anchor
parameter_list|(
name|pool
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|pool
operator|->
name|anchor
condition|)
block|{
name|pool
operator|->
name|anchor
operator|=
name|TRUE
expr_stmt|;
name|pool
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump out the constants in POOL.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_dump_pool
parameter_list|(
name|pool
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Pool start insn switches to proper section       and guarantees necessary alignment.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_start_64
argument_list|()
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_start_31
argument_list|()
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Emit anchor if we need one.  */
if|if
condition|(
name|pool
operator|->
name|anchor
condition|)
block|{
name|rtx
name|anchor
init|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|anchor
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|anchor
argument_list|)
argument_list|,
literal|105
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_si
argument_list|(
name|anchor
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Dump constants in descending alignment requirement order,      ensuring proper alignment for every constant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
comment|/* Convert 104 unspecs to pool-relative references.  */
name|rtx
name|value
init|=
name|c
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|104
operator|&&
name|XVECLEN
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_label_after
argument_list|(
name|c
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
argument|gen_consttable[i] (value)
argument_list|,
argument|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Pool end insn switches back to previous section       and guarantees necessary alignment.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_end_64
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_end_31
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Remove placeholder insn.  */
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Free all memory used by POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_free_pool
parameter_list|(
name|pool
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constant
modifier|*
name|c
init|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|struct
name|constant
modifier|*
name|next
init|=
name|c
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|next
expr_stmt|;
block|}
block|}
name|BITMAP_XFREE
argument_list|(
name|pool
operator|->
name|insns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Chunkify the literal pool if required.     Code generated by this routine is allowed to use    TEMP_REG as temporary scratch register.  If this is    done, TEMP_USED is set to true.  */
end_comment

begin_define
define|#
directive|define
name|S390_POOL_CHUNK_MIN
value|0xc00
end_define

begin_define
define|#
directive|define
name|S390_POOL_CHUNK_MAX
value|0xe00
end_define

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_chunkify_start
parameter_list|(
name|temp_reg
parameter_list|,
name|temp_used
parameter_list|)
name|rtx
name|temp_reg
decl_stmt|;
name|bool
modifier|*
name|temp_used
decl_stmt|;
block|{
name|rtx
name|base_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
decl_stmt|;
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|,
modifier|*
name|pool_list
init|=
name|NULL
decl_stmt|;
name|int
name|extra_size
init|=
literal|0
decl_stmt|;
name|bitmap
name|far_labels
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
argument_list|(
argument|*gen_reload_base
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|TARGET_64BIT
condition|?
name|gen_reload_base_64
else|:
name|gen_reload_base_31
expr_stmt|;
comment|/* Do we need to chunkify the literal pool?  */
if|if
condition|(
name|get_pool_size
argument_list|()
operator|<
name|S390_POOL_CHUNK_MAX
condition|)
return|return
name|NULL
return|;
comment|/* We need correct insn addresses.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Scan all insns and move literals to pool chunks.      Also, emit anchor reload insns before every insn that uses       the literal pool base register as anchor pointer.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
if|if
condition|(
operator|!
name|curr_pool
condition|)
name|curr_pool
operator|=
name|s390_start_pool
argument_list|(
operator|&
name|pool_list
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|s390_add_constant
argument_list|(
name|curr_pool
argument_list|,
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
argument_list|)
expr_stmt|;
name|s390_add_pool_insn
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|flag_pic
operator|&&
name|find_base_register_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|new
init|=
name|gen_reload_anchor
argument_list|(
name|temp_reg
argument_list|,
name|base_reg
argument_list|)
decl_stmt|;
name|new
operator|=
name|emit_insn_before
argument_list|(
name|new
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new
argument_list|,
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|extra_size
operator|+=
literal|8
expr_stmt|;
operator|*
name|temp_used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|curr_pool
condition|)
name|curr_pool
operator|=
name|s390_start_pool
argument_list|(
operator|&
name|pool_list
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|s390_add_anchor
argument_list|(
name|curr_pool
argument_list|)
expr_stmt|;
name|s390_add_pool_insn
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
if|if
condition|(
name|curr_pool
condition|)
name|s390_add_pool_insn
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curr_pool
operator|||
name|INSN_ADDRESSES_SIZE
argument_list|()
operator|<=
operator|(
name|size_t
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|||
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|curr_pool
operator|->
name|size
operator|<
name|S390_POOL_CHUNK_MAX
condition|)
continue|continue;
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|chunk_size
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|curr_pool
operator|->
name|first_insn
argument_list|)
argument_list|)
operator|+
name|extra_size
decl_stmt|;
comment|/* We will later have to insert base register reload insns. 	     Those will have an effect on code size, which we need to 	     consider here.  This calculation makes rather pessimistic 	     worst-case assumptions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|extra_size
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|<
name|S390_POOL_CHUNK_MIN
operator|&&
name|curr_pool
operator|->
name|size
operator|<
name|S390_POOL_CHUNK_MIN
condition|)
continue|continue;
comment|/* Pool chunks can only be inserted after BARRIERs ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
name|extra_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ... so if we don't find one in time, create one.  */
elseif|else
if|if
condition|(
operator|(
name|chunk_size
operator|>
name|S390_POOL_CHUNK_MAX
operator|||
name|curr_pool
operator|->
name|size
operator|>
name|S390_POOL_CHUNK_MAX
operator|)
condition|)
block|{
name|rtx
name|label
decl_stmt|,
name|jump
decl_stmt|,
name|barrier
decl_stmt|;
comment|/* We can insert the barrier only after a 'real' insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
continue|continue;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Don't separate insns created by s390_split_branches.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|temp_reg
argument_list|)
condition|)
continue|continue;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|jump
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|barrier
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
name|extra_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|curr_pool
condition|)
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Find all labels that are branched into       from an insn belonging to a different chunk.  */
name|far_labels
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Labels marked with LABEL_PRESERVE_P can be target 	 of non-local jumps, so we have to mark them. 	 The same holds for named labels.  	 Don't do that, however, if it is the label before 	 a jump table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|||
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|vec_insn
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|vec_pat
init|=
name|vec_insn
operator|&&
name|GET_CODE
argument_list|(
name|vec_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|PATTERN
argument_list|(
name|vec_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
if|if
condition|(
operator|!
name|vec_pat
operator|||
operator|!
operator|(
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a direct jump (conditional or unconditional) 	 or a casesi jump, check all potential targets.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
if|if
condition|(
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|label
argument_list|)
operator|!=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
comment|/* Find the jump table used by this casesi jump.  */
name|rtx
name|vec_label
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|vec_insn
init|=
name|next_real_insn
argument_list|(
name|vec_label
argument_list|)
decl_stmt|;
name|rtx
name|vec_pat
init|=
name|vec_insn
operator|&&
name|GET_CODE
argument_list|(
name|vec_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|PATTERN
argument_list|(
name|vec_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|vec_pat
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|diff_p
init|=
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|vec_pat
argument_list|,
name|diff_p
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|vec_pat
argument_list|,
name|diff_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|label
argument_list|)
operator|!=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Insert base register reload insns before every pool.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|base_reg
argument_list|,
name|curr_pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|curr_pool
operator|->
name|first_insn
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Insert base register reload insns at every far label.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|bitmap_bit_p
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
init|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_XFREE
argument_list|(
name|far_labels
argument_list|)
expr_stmt|;
comment|/* Recompute insn addresses.  */
name|init_insn_lengths
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|pool_list
return|;
block|}
end_function

begin_comment
comment|/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.    After we have decided to use this list, finish implementing     all changes to the current function as required.     Code generated by this routine is allowed to use    TEMP_REG as temporary scratch register.  */
end_comment

begin_function
specifier|static
name|void
name|s390_chunkify_finish
parameter_list|(
name|pool_list
parameter_list|,
name|temp_reg
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool_list
decl_stmt|;
name|rtx
name|temp_reg
decl_stmt|;
block|{
name|rtx
name|base_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
decl_stmt|;
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Replace all literal pool references.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|curr_pool
operator|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curr_pool
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
name|addr
operator|=
name|s390_find_constant
argument_list|(
name|curr_pool
argument_list|,
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|replace_constant_pool_ref
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pool_ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|flag_pic
operator|&&
name|find_base_register_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|replace_base_register_ref
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|temp_reg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Dump out all literal pools.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
name|s390_dump_pool
argument_list|(
name|curr_pool
argument_list|)
expr_stmt|;
comment|/* Free pool list.  */
while|while
condition|(
name|pool_list
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|next
init|=
name|pool_list
operator|->
name|next
decl_stmt|;
name|s390_free_pool
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
name|pool_list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.    We have decided we cannot use this list, so revert all changes    to the current function that were done by s390_chunkify_start.  */
end_comment

begin_function
specifier|static
name|void
name|s390_chunkify_cancel
parameter_list|(
name|pool_list
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool_list
decl_stmt|;
block|{
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Remove all pool placeholder insns.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
block|{
comment|/* Did we insert an extra barrier?  Remove it.  */
name|rtx
name|barrier
init|=
name|PREV_INSN
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
decl_stmt|;
name|rtx
name|jump
init|=
name|barrier
condition|?
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|rtx
name|label
init|=
name|NEXT_INSN
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|jump
operator|&&
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|barrier
operator|&&
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|==
name|BARRIER
operator|&&
name|label
operator|&&
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
block|{
name|remove_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Remove all base/anchor register reload insns.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
control|)
block|{
name|rtx
name|next_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|210
operator|||
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|211
operator|)
condition|)
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next_insn
expr_stmt|;
block|}
comment|/* Free pool list.  */
while|while
condition|(
name|pool_list
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|next
init|=
name|pool_list
operator|->
name|next
decl_stmt|;
name|s390_free_pool
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
name|pool_list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Index of constant pool chunk that is currently being processed.    Set to -1 before function output has started.  */
end_comment

begin_decl_stmt
name|int
name|s390_pool_count
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of current constant pool.  */
end_comment

begin_decl_stmt
name|int
name|s390_nr_constants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output main constant pool to stdio stream FILE.  */
end_comment

begin_function
name|void
name|s390_output_constant_pool
parameter_list|(
name|start_label
parameter_list|,
name|end_label
parameter_list|)
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|end_label
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|readonly_data_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|start_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|start_label
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|s390_pool_count
operator|=
literal|0
expr_stmt|;
name|output_constant_pool
argument_list|(
name|current_function_name
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|s390_pool_count
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rework the prolog/epilog to avoid saving/restoring    registers unnecessarily.  If TEMP_REGNO is nonnegative,    it specifies the number of a caller-saved register used     as temporary scratch register by code emitted during     machine dependent reorg.  */
end_comment

begin_function
specifier|static
name|void
name|s390_optimize_prolog
parameter_list|(
name|temp_regno
parameter_list|)
name|int
name|temp_regno
decl_stmt|;
block|{
name|int
name|save_first
decl_stmt|,
name|save_last
decl_stmt|,
name|restore_first
decl_stmt|,
name|restore_last
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|new_insn
decl_stmt|,
name|next_insn
decl_stmt|;
comment|/* Recompute regs_ever_live data for special registers.  */
name|regs_ever_live
index|[
name|BASE_REGISTER
index|]
operator|=
literal|0
expr_stmt|;
name|regs_ever_live
index|[
name|RETURN_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
name|regs_ever_live
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|>
literal|0
expr_stmt|;
comment|/* If there is (possibly) any pool entry, we need to      load the base register.        ??? FIXME: this should be more precise.  */
if|if
condition|(
name|get_pool_size
argument_list|()
condition|)
name|regs_ever_live
index|[
name|BASE_REGISTER
index|]
operator|=
literal|1
expr_stmt|;
comment|/* In non-leaf functions, the prolog/epilog code relies       on RETURN_REGNUM being saved in any case.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
condition|)
name|regs_ever_live
index|[
name|RETURN_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
comment|/* We need to save/restore the temporary register.  */
if|if
condition|(
name|temp_regno
operator|>=
literal|0
condition|)
name|regs_ever_live
index|[
name|temp_regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Find first and last gpr to be saved.  */
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|!
name|global_regs
index|[
name|i
index|]
operator|||
name|i
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|i
operator|==
name|RETURN_REGNUM
operator|||
name|i
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|i
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|j
index|]
condition|)
if|if
condition|(
operator|!
name|global_regs
index|[
name|j
index|]
operator|||
name|j
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|j
operator|==
name|RETURN_REGNUM
operator|||
name|j
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|j
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|16
condition|)
block|{
comment|/* Nothing to save/restore.  */
name|save_first
operator|=
name|restore_first
operator|=
operator|-
literal|1
expr_stmt|;
name|save_last
operator|=
name|restore_last
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Save/restore from i to j.  */
name|save_first
operator|=
name|restore_first
operator|=
name|i
expr_stmt|;
name|save_last
operator|=
name|restore_last
operator|=
name|j
expr_stmt|;
block|}
comment|/* Varargs functions need to save gprs 2 to 6.  */
if|if
condition|(
name|current_function_stdarg
condition|)
block|{
name|save_first
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|save_last
operator|<
literal|6
condition|)
name|save_last
operator|=
literal|6
expr_stmt|;
block|}
comment|/* If all special registers are in fact used, there's nothing we      can do, so no point in walking the insn list.  */
if|if
condition|(
name|i
operator|<=
name|BASE_REGISTER
operator|&&
name|j
operator|>=
name|BASE_REGISTER
operator|&&
name|i
operator|<=
name|RETURN_REGNUM
operator|&&
name|j
operator|>=
name|RETURN_REGNUM
condition|)
return|return;
comment|/* Search for prolog/epilog insns and replace them.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
name|int
name|first
decl_stmt|,
name|last
decl_stmt|,
name|off
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|base
decl_stmt|,
name|offset
decl_stmt|;
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|PARALLEL
condition|)
continue|continue;
if|if
condition|(
name|store_multiple_operation
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|first
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|first
operator|>
name|BASE_REGISTER
operator|&&
name|first
operator|>
name|RETURN_REGNUM
condition|)
continue|continue;
if|if
condition|(
name|last
operator|<
name|BASE_REGISTER
operator|&&
name|last
operator|<
name|RETURN_REGNUM
condition|)
continue|continue;
if|if
condition|(
name|save_first
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_insn
operator|=
name|save_gprs
argument_list|(
name|base
argument_list|,
name|off
argument_list|,
name|save_first
argument_list|,
name|save_last
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|load_multiple_operation
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|first
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|first
operator|>
name|BASE_REGISTER
operator|&&
name|first
operator|>
name|RETURN_REGNUM
condition|)
continue|continue;
if|if
condition|(
name|last
operator|<
name|BASE_REGISTER
operator|&&
name|last
operator|<
name|RETURN_REGNUM
condition|)
continue|continue;
if|if
condition|(
name|restore_first
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_insn
operator|=
name|restore_gprs
argument_list|(
name|base
argument_list|,
name|off
argument_list|,
name|restore_first
argument_list|,
name|restore_last
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check whether any insn in the function makes use of the original    value of RETURN_REG (e.g. for __builtin_return_address).    If so, insert an insn reloading that value.     Return true if any such insn was found.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_fixup_clobbered_return_reg
parameter_list|(
name|return_reg
parameter_list|)
name|rtx
name|return_reg
decl_stmt|;
block|{
name|bool
name|replacement_done
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* If we never called __builtin_return_address, register 14      might have been used as temp during the prolog; we do      not want to touch those uses.  */
if|if
condition|(
operator|!
name|has_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|return_reg
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|reg
decl_stmt|,
name|off
decl_stmt|,
name|new_insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
continue|continue;
if|if
condition|(
operator|!
name|reg_referenced_p
argument_list|(
name|return_reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|store_multiple_operation
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|reg
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
else|else
name|reg
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|off
operator|=
name|GEN_INT
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|+
name|REGNO
argument_list|(
name|return_reg
argument_list|)
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|off
argument_list|)
operator|>=
literal|4096
condition|)
block|{
name|off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|return_reg
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|return_reg
expr_stmt|;
block|}
name|new_insn
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|return_reg
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|replacement_done
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|replacement_done
return|;
block|}
end_function

begin_comment
comment|/* Perform machine-dependent processing.  */
end_comment

begin_function
name|void
name|s390_machine_dependent_reorg
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bool
name|fixed_up_clobbered_return_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|temp_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
decl_stmt|;
name|bool
name|temp_used
init|=
literal|0
decl_stmt|;
comment|/* Make sure all splits have been performed; splits after      machine_dependent_reorg might confuse insn length counts.  */
name|split_all_insns_noflow
argument_list|()
expr_stmt|;
comment|/* There are two problematic situations we need to correct:        - the literal pool might be> 4096 bytes in size, so that        some of its elements cannot be directly accessed        - a branch target might be> 64K away from the branch, so that        it is not possible to use a PC-relative instruction.        To fix those, we split the single literal pool into multiple      pool chunks, reloading the pool base register at various      points throughout the function to ensure it always points to      the pool chunk the following code expects, and / or replace      PC-relative branches by absolute branches.        However, the two problems are interdependent: splitting the      literal pool can move a branch further away from its target,      causing the 64K limit to overflow, and on the other hand,      replacing a PC-relative branch by an absolute branch means      we need to put the branch target address into the literal      pool, possibly causing it to overflow.        So, we loop trying to fix up both problems until we manage      to satisfy both conditions at the same time.  Note that the      loop is guaranteed to terminate as every pass of the loop      strictly decreases the total number of PC-relative branches      in the function.  (This is not completely true as there      might be branch-over-pool insns introduced by chunkify_start.      Those never need to be split however.)  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool_list
decl_stmt|;
comment|/* Try to chunkify the literal pool.  */
name|pool_list
operator|=
name|s390_chunkify_start
argument_list|(
name|temp_reg
argument_list|,
operator|&
name|temp_used
argument_list|)
expr_stmt|;
comment|/* Split out-of-range branches.  If this has created new 	 literal pool entries, cancel current chunk list and 	 recompute it.  */
if|if
condition|(
name|s390_split_branches
argument_list|(
name|temp_reg
argument_list|,
operator|&
name|temp_used
argument_list|)
condition|)
block|{
if|if
condition|(
name|pool_list
condition|)
name|s390_chunkify_cancel
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check whether we have clobbered a use of the return 	 register (e.g. for __builtin_return_address).  If so, 	 add insns reloading the register where necessary.  */
if|if
condition|(
name|temp_used
operator|&&
operator|!
name|fixed_up_clobbered_return_reg
operator|&&
name|s390_fixup_clobbered_return_reg
argument_list|(
name|temp_reg
argument_list|)
condition|)
block|{
name|fixed_up_clobbered_return_reg
operator|=
literal|1
expr_stmt|;
comment|/* The fixup insns might have caused a jump to overflow.  */
if|if
condition|(
name|pool_list
condition|)
name|s390_chunkify_cancel
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we made it up to here, both conditions are satisfied. 	 Finish up pool chunkification if required.  */
if|if
condition|(
name|pool_list
condition|)
name|s390_chunkify_finish
argument_list|(
name|pool_list
argument_list|,
name|temp_reg
argument_list|)
expr_stmt|;
break|break;
block|}
name|s390_optimize_prolog
argument_list|(
name|temp_used
condition|?
name|RETURN_REGNUM
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an RTL expression representing the value of the return address    for the frame COUNT steps up from the current frame.  FRAME is the    frame pointer of that frame.  */
end_comment

begin_function
name|rtx
name|s390_return_addr_rtx
parameter_list|(
name|count
parameter_list|,
name|frame
parameter_list|)
name|int
name|count
decl_stmt|;
name|rtx
name|frame
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* For the current frame, we use the initial value of RETURN_REGNUM.      This works both in leaf and non-leaf functions.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
return|;
comment|/* For frames farther back, we read the stack slot where the      corresponding RETURN_REGNUM value was saved.  */
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame
argument_list|,
name|RETURN_REGNUM
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find first call clobbered register unsused in a function.    This could be used as base register in a leaf function    or for holding the return address before epilogue.  */
end_comment

begin_function
specifier|static
name|int
name|find_unused_clobbered_reg
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill FRAME with info about frame of current function.  */
end_comment

begin_function
specifier|static
name|void
name|s390_frame_info
parameter_list|()
block|{
name|char
name|gprs_ever_live
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|HOST_WIDE_INT
name|fsize
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
if|if
condition|(
name|fsize
operator|>
literal|0x7fff0000
condition|)
name|fatal_error
argument_list|(
literal|"Total size of local variables exceeds architecture limit."
argument_list|)
expr_stmt|;
comment|/* fprs 8 - 15 are caller saved for 64 Bit ABI.  */
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|=
name|fsize
operator|+
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
operator|*
literal|64
expr_stmt|;
comment|/* Does function need to setup frame and save area.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|||
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|>
literal|0
operator|||
name|current_function_calls_alloca
operator|||
name|current_function_stdarg
condition|)
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|+=
name|STARTING_FRAME_OFFSET
expr_stmt|;
comment|/* Find first and last gpr to be saved.  Note that at this point,      we assume the return register and the base register always      need to be saved.  This is done because the usage of these      register might change even after the prolog was emitted.      If it turns out later that we really don't need them, the      prolog/epilog code is modified again.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|gprs_ever_live
index|[
name|i
index|]
operator|=
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|gprs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
expr_stmt|;
name|gprs_ever_live
index|[
name|BASE_REGISTER
index|]
operator|=
literal|1
expr_stmt|;
name|gprs_ever_live
index|[
name|RETURN_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|gprs_ever_live
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|>
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|gprs_ever_live
index|[
name|i
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|gprs_ever_live
index|[
name|j
index|]
condition|)
break|break;
comment|/* Save / Restore from gpr i to j.  */
name|cfun
operator|->
name|machine
operator|->
name|first_save_gpr
operator|=
name|i
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|=
name|i
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
operator|=
name|j
expr_stmt|;
comment|/* Varargs functions need to save gprs 2 to 6.  */
if|if
condition|(
name|current_function_stdarg
condition|)
name|cfun
operator|->
name|machine
operator|->
name|first_save_gpr
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return offset between argument pointer and frame pointer     initially after prologue.  */
end_comment

begin_function
name|int
name|s390_arg_frame_offset
parameter_list|()
block|{
name|HOST_WIDE_INT
name|fsize
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
name|int
name|save_fprs_p
decl_stmt|,
name|i
decl_stmt|;
comment|/* fprs 8 - 15 are caller saved for 64 Bit ABI.  */
name|save_fprs_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|save_fprs_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|fsize
operator|=
name|fsize
operator|+
name|save_fprs_p
operator|*
literal|64
expr_stmt|;
comment|/* Does function need to setup frame and save area.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|||
name|fsize
operator|>
literal|0
operator|||
name|current_function_calls_alloca
operator|||
name|current_function_stdarg
condition|)
name|fsize
operator|+=
name|STARTING_FRAME_OFFSET
expr_stmt|;
return|return
name|fsize
operator|+
name|STACK_POINTER_OFFSET
return|;
block|}
end_function

begin_comment
comment|/* Emit insn to save fpr REGNUM at offset OFFSET relative    to register BASE.  Return generated insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_fpr
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|regnum
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regnum
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit insn to restore fpr REGNUM from offset OFFSET relative    to register BASE.  Return generated insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|restore_fpr
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|regnum
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate insn to save registers FIRST to LAST into    the register save area located at offset OFFSET     relative to register BASE.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_gprs
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|,
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|int
name|i
decl_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
name|first
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
comment|/* Special-case single register.  */
if|if
condition|(
name|first
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_movdi
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_movsi
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|insn
return|;
block|}
name|insn
operator|=
name|gen_store_multiple
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to set the FRAME_RELATED flag on all SETs      inside the store-multiple pattern.       However, we must not emit DWARF records for registers 2..5      if they are stored for use by variable arguments ...         ??? Unfortunately, it is not enough to simply not the the      FRAME_RELATED flags for those SETs, because the first SET      of the PARALLEL is always treated as if it had the flag      set, even if it does not.  Therefore we emit a new pattern      without those registers as REG_FRAME_RELATED_EXPR note.  */
if|if
condition|(
name|first
operator|>=
literal|6
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|>=
literal|6
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|6
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_store_multiple
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|6
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
literal|6
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|note
operator|=
name|PATTERN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|note
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Generate insn to restore registers FIRST to LAST from    the register save area located at offset OFFSET     relative to register BASE.  */
end_comment

begin_function
specifier|static
name|rtx
name|restore_gprs
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|,
name|insn
decl_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
name|first
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
comment|/* Special-case single register.  */
if|if
condition|(
name|first
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_movdi
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_movsi
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
name|insn
operator|=
name|gen_load_multiple
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|s390_emit_prologue
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|rtx
name|temp_reg
decl_stmt|;
name|rtx
name|pool_start_label
decl_stmt|,
name|pool_end_label
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Compute frame_info.  */
name|s390_frame_info
argument_list|()
expr_stmt|;
comment|/* Choose best register to use for temp use within prologue.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|&&
operator|!
name|has_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
operator|&&
name|get_pool_size
argument_list|()
operator|<
name|S390_POOL_CHUNK_MAX
operator|/
literal|2
condition|)
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
else|else
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Save call saved gprs.  */
name|insn
operator|=
name|save_gprs
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|first_save_gpr
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Dump constant pool and set constant pool register.  */
name|pool_start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pool_end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|literal_pool_label
operator|=
name|pool_start_label
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_literal_pool_64
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
argument_list|,
name|pool_start_label
argument_list|,
name|pool_end_label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_literal_pool_31
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
argument_list|,
name|pool_start_label
argument_list|,
name|pool_end_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save fprs for variable args.  */
if|if
condition|(
name|current_function_stdarg
condition|)
block|{
comment|/* Save fpr 0 and 2.  */
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|32
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|24
argument_list|,
literal|17
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* Save fpr 4 and 6.  */
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|16
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|8
argument_list|,
literal|19
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save fprs 4 and 6 if used (31 bit ABI).  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
comment|/* Save fpr 4 and 6.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|18
index|]
operator|&&
operator|!
name|global_regs
index|[
literal|18
index|]
condition|)
block|{
name|insn
operator|=
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|16
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|19
index|]
operator|&&
operator|!
name|global_regs
index|[
literal|19
index|]
condition|)
block|{
name|insn
operator|=
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|8
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Decrement stack pointer.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|>
literal|0
condition|)
block|{
name|rtx
name|frame_off
init|=
name|GEN_INT
argument_list|(
operator|-
name|cfun
operator|->
name|machine
operator|->
name|frame_size
argument_list|)
decl_stmt|;
comment|/* Save incoming stack pointer into temp reg.  */
if|if
condition|(
name|TARGET_BACKCHAIN
operator|||
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|temp_reg
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Substract frame size from stack pointer.  */
name|frame_off
operator|=
name|GEN_INT
argument_list|(
operator|-
name|cfun
operator|->
name|machine
operator|->
name|frame_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
operator|-
name|cfun
operator|->
name|machine
operator|->
name|frame_size
argument_list|,
literal|'K'
argument_list|)
condition|)
name|frame_off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|cfun
operator|->
name|machine
operator|->
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set backchain.  */
if|if
condition|(
name|TARGET_BACKCHAIN
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|addr
argument_list|,
name|temp_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we support asynchronous exceptions (e.g. for Java), 	 we need to make sure the backchain pointer is set up 	 before any possibly trapping memory access.  */
if|if
condition|(
name|TARGET_BACKCHAIN
operator|&&
name|flag_non_call_exceptions
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save fprs 8 - 15 (64 bit ABI).  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|temp_reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|rtx
name|addr
init|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|-
literal|64
operator|+
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|)
decl_stmt|;
name|insn
operator|=
name|save_fpr
argument_list|(
name|temp_reg
argument_list|,
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set frame pointer, if needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set up got pointer, if needed.  */
if|if
condition|(
name|flag_pic
operator|&&
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
block|{
name|rtx
name|got_symbol
init|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
decl_stmt|;
name|SYMBOL_REF_FLAG
argument_list|(
name|got_symbol
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_movdi
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|got_symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It can happen that the GOT pointer isn't really needed ...  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|got_symbol
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|got_symbol
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|got_symbol
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|got_symbol
argument_list|)
expr_stmt|;
name|got_symbol
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|got_symbol
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|got_symbol
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|got_symbol
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|got_symbol
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|got_symbol
argument_list|)
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|got_symbol
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|got_symbol
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|got_symbol
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Expand the epilogue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|s390_emit_epilogue
parameter_list|()
block|{
name|rtx
name|frame_pointer
decl_stmt|,
name|return_reg
decl_stmt|;
name|int
name|area_bottom
decl_stmt|,
name|area_top
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
comment|/* Check whether to use frame or stack pointer for restore.  */
name|frame_pointer
operator|=
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
expr_stmt|;
comment|/* Compute which parts of the save area we need to access.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|area_bottom
operator|=
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|area_top
operator|=
operator|(
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
operator|+
literal|1
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
block|{
name|area_bottom
operator|=
name|INT_MAX
expr_stmt|;
name|area_top
operator|=
name|INT_MIN
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
condition|)
block|{
if|if
condition|(
name|area_bottom
operator|>
operator|-
literal|64
condition|)
name|area_bottom
operator|=
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|area_top
operator|<
literal|0
condition|)
name|area_top
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
literal|18
index|]
operator|&&
operator|!
name|global_regs
index|[
literal|18
index|]
condition|)
block|{
if|if
condition|(
name|area_bottom
operator|>
name|STACK_POINTER_OFFSET
operator|-
literal|16
condition|)
name|area_bottom
operator|=
name|STACK_POINTER_OFFSET
operator|-
literal|16
expr_stmt|;
if|if
condition|(
name|area_top
operator|<
name|STACK_POINTER_OFFSET
operator|-
literal|8
condition|)
name|area_top
operator|=
name|STACK_POINTER_OFFSET
operator|-
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|19
index|]
operator|&&
operator|!
name|global_regs
index|[
literal|19
index|]
condition|)
block|{
if|if
condition|(
name|area_bottom
operator|>
name|STACK_POINTER_OFFSET
operator|-
literal|8
condition|)
name|area_bottom
operator|=
name|STACK_POINTER_OFFSET
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|area_top
operator|<
name|STACK_POINTER_OFFSET
condition|)
name|area_top
operator|=
name|STACK_POINTER_OFFSET
expr_stmt|;
block|}
block|}
comment|/* Check whether we can access the register save area.        If not, increment the frame pointer as required.  */
if|if
condition|(
name|area_top
operator|<=
name|area_bottom
condition|)
block|{
comment|/* Nothing to restore.  */
block|}
elseif|else
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|+
name|area_bottom
operator|>=
literal|0
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|+
name|area_top
operator|<=
literal|4096
condition|)
block|{
comment|/* Area is in range.  */
name|offset
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame_size
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|insn
decl_stmt|,
name|frame_off
decl_stmt|;
name|offset
operator|=
name|area_bottom
operator|<
literal|0
condition|?
operator|-
name|area_bottom
else|:
literal|0
expr_stmt|;
name|frame_off
operator|=
name|GEN_INT
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
name|frame_off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|frame_pointer
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore call saved fprs.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
condition|)
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|-
literal|64
operator|+
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
literal|18
index|]
operator|&&
operator|!
name|global_regs
index|[
literal|18
index|]
condition|)
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|STACK_POINTER_OFFSET
operator|-
literal|16
argument_list|,
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|19
index|]
operator|&&
operator|!
name|global_regs
index|[
literal|19
index|]
condition|)
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|STACK_POINTER_OFFSET
operator|-
literal|8
argument_list|,
literal|19
argument_list|)
expr_stmt|;
block|}
comment|/* Return register.  */
name|return_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
comment|/* Restore call saved gprs.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for global register and save them  	 to stack location from where they get restored.  */
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
init|;
name|i
operator|<=
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
condition|;
name|i
operator|++
control|)
block|{
comment|/* These registers are special and need to be  	     restored in any case.  */
if|if
condition|(
name|i
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|i
operator|==
name|RETURN_REGNUM
operator|||
name|i
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|i
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|i
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fetch return address from stack before load multiple, 	 this will do good for scheduling.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
condition|)
block|{
name|int
name|return_regnum
init|=
name|find_unused_clobbered_reg
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|return_regnum
condition|)
name|return_regnum
operator|=
literal|4
expr_stmt|;
name|return_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|return_regnum
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|RETURN_REGNUM
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* ??? As references to the base register are not made 	 explicit in insn RTX code, we have to add a barrier here 	 to prevent incorrect scheduling.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|insn
operator|=
name|restore_gprs
argument_list|(
name|frame_pointer
argument_list|,
name|offset
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Return to caller.  */
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|return_reg
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size in bytes of a function argument of     type TYPE and/or mode MODE.  At least one of TYPE or    MODE must be specified.  */
end_comment

begin_function
specifier|static
name|int
name|s390_function_arg_size
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
condition|)
return|return
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
return|;
comment|/* No type info available for some library calls ...  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
comment|/* If we have neither type nor mode, abort */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if a function argument of type TYPE and mode MODE    is to be passed by reference.  The ABI specifies that only    structures of size 1, 2, 4, or 8 bytes are passed by value,    all other structures (and complex numbers) are passed by    reference.  */
end_comment

begin_function
name|int
name|s390_function_arg_pass_by_reference
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|size
operator|!=
literal|1
operator|&&
name|size
operator|!=
literal|2
operator|&&
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument of mode MODE and    data type TYPE.  (TYPE is null for libcalls where that information    may not be available.).  The boolean NAMED specifies whether the    argument is a named argument (as opposed to an unnamed argument    matching an ellipsis).  */
end_comment

begin_function
name|void
name|s390_function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_SOFT_FLOAT
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|SFmode
operator|)
condition|)
block|{
name|cum
operator|->
name|fprs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|cum
operator|->
name|gprs
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|cum
operator|->
name|gprs
operator|+=
operator|(
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).       On S/390, we use general purpose registers 2 through 6 to    pass integer, pointer, and certain structure arguments, and    floating point registers 0 and 2 (0, 2, 4, and 6 on 64-bit)    to pass floating point arguments.  All remaining arguments    are pushed to the stack.  */
end_comment

begin_function
name|rtx
name|s390_function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TARGET_SOFT_FLOAT
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|SFmode
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fprs
operator|+
literal|1
operator|>
operator|(
name|TARGET_64BIT
condition|?
literal|4
else|:
literal|2
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|cum
operator|->
name|fprs
operator|+
literal|16
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|n_gprs
init|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|gprs
operator|+
name|n_gprs
operator|>
literal|5
condition|)
return|return
literal|0
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|cum
operator|->
name|gprs
operator|+
literal|2
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create and return the va_list datatype.     On S/390, va_list is an array type equivalent to        typedef struct __va_list_tag         {             long __gpr;             long __fpr;             void *__overflow_arg_area;             void *__reg_save_area;                      } va_list[1];     where __gpr and __fpr hold the number of general purpose    or floating point arguments used up to now, respectively,    __overflow_arg_area points to the stack location of the     next argument passed on the stack, and __reg_save_area    always points to the start of the register area in the    call frame of the current function.  The function prologue    saves all registers used for argument passing into this    area if the function uses variable arguments.  */
end_comment

begin_function
name|tree
name|s390_build_va_list
parameter_list|()
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
name|record
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__gpr"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__fpr"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement va_start by filling the va_list structure VALIST.    STDARG_P is always true, and ignored.    NEXTARG points to the first anonymous stack argument.     The following global variables are used to initialize    the va_list structure:       current_function_args_info:        holds number of gprs and fprs used for named arguments.      current_function_arg_offset_rtx:        holds the offset of the first anonymous stack argument        (relative to the virtual arg pointer).  */
end_comment

begin_function
name|void
name|s390_va_start
parameter_list|(
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|int
name|off
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|gprs
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|fprs
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|n_gpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|n_fpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the overflow area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|current_function_arg_offset_rtx
argument_list|)
expr_stmt|;
name|off
operator|=
name|off
operator|<
literal|0
condition|?
literal|0
else|:
name|off
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: n_gpr = %d, n_fpr = %d off %d\n"
argument_list|,
operator|(
name|int
operator|)
name|n_gpr
argument_list|,
operator|(
name|int
operator|)
name|n_fpr
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|off
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the register save area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|STACK_POINTER_OFFSET
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg by updating the va_list structure     VALIST as required to retrieve an argument of type    TYPE, and returning that argument.         Generates code equivalent to:        if (integral value) {      if (size<= 4&& args.gpr< 5 ||          size> 4&& args.gpr< 4 )         ret = args.reg_save_area[args.gpr+8]      else        ret = *args.overflow_arg_area++;    } else if (float value) {      if (args.fgpr< 2)        ret = args.reg_save_area[args.fpr+64]      else        ret = *args.overflow_arg_area++;    } else if (aggregate value) {      if (args.gpr< 5)        ret = *args.reg_save_area[args.gpr]      else        ret = **args.overflow_arg_area++;    } */
end_comment

begin_function
name|rtx
name|s390_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|reg
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|;
name|int
name|indirect_p
decl_stmt|,
name|size
decl_stmt|,
name|n_reg
decl_stmt|,
name|sav_ofs
decl_stmt|,
name|sav_scale
decl_stmt|,
name|max_reg
decl_stmt|;
name|rtx
name|lab_false
decl_stmt|,
name|lab_over
decl_stmt|,
name|addr_rtx
decl_stmt|,
name|r
decl_stmt|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: aggregate type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Aggregates are passed by reference.  */
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|sav_scale
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|size
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|max_reg
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TARGET_SOFT_FLOAT
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: float type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* FP args go in FP registers, if present.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|fpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|16
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|sav_scale
operator|=
literal|8
expr_stmt|;
comment|/* TARGET_64BIT has up to 4 parameter in fprs */
name|max_reg
operator|=
name|TARGET_64BIT
condition|?
literal|3
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: other type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise into GP registers.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|sav_ofs
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|sav_ofs
operator|+=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SImode
condition|?
literal|4
else|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|HImode
condition|?
literal|6
else|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|QImode
condition|?
literal|7
else|:
literal|0
expr_stmt|;
else|else
name|sav_ofs
operator|+=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|HImode
condition|?
literal|2
else|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|QImode
condition|?
literal|3
else|:
literal|0
expr_stmt|;
name|sav_scale
operator|=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|n_reg
operator|>
literal|1
condition|)
name|max_reg
operator|=
literal|3
expr_stmt|;
else|else
name|max_reg
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Pull the value out of the saved registers ...  */
name|lab_false
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab_over
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|reg
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|max_reg
argument_list|)
argument_list|,
name|GT
argument_list|,
name|const1_rtx
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav_ofs
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|build_int_2
argument_list|(
name|sav_ofs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|sav
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|long_integer_type_node
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|sav_scale
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab_over
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab_false
argument_list|)
expr_stmt|;
comment|/* ... Otherwise out of the overflow area.  */
name|t
operator|=
name|save_expr
argument_list|(
name|ovf
argument_list|)
expr_stmt|;
comment|/* In 64 BIT for each argument on stack, a full 64 bit slot is allocated.  */
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|UNITS_PER_WORD
operator|-
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|save_expr
argument_list|(
name|ovf
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab_over
argument_list|)
expr_stmt|;
comment|/* If less than max_regs a registers are retrieved out       of register save area, increment.  */
name|u
operator|=
name|build
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|n_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|u
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
block|{
name|r
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|r
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|addr_rtx
return|;
block|}
end_function

begin_comment
comment|/* Builtins.  */
end_comment

begin_enum
enum|enum
name|s390_builtin
block|{
name|S390_BUILTIN_THREAD_POINTER
block|,
name|S390_BUILTIN_SET_THREAD_POINTER
block|,
name|S390_BUILTIN_max
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|unsigned
name|int
specifier|const
name|code_for_builtin_64
index|[
name|S390_BUILTIN_max
index|]
init|=
block|{
name|CODE_FOR_get_tp_64
block|,
name|CODE_FOR_set_tp_64
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
specifier|const
name|code_for_builtin_31
index|[
name|S390_BUILTIN_max
index|]
init|=
block|{
name|CODE_FOR_get_tp_31
block|,
name|CODE_FOR_set_tp_31
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|s390_init_builtins
parameter_list|()
block|{
name|tree
name|ftype
decl_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|S390_BUILTIN_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_set_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|S390_BUILTIN_SET_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
define|#
directive|define
name|MAX_ARGS
value|2
name|unsigned
name|int
specifier|const
modifier|*
name|code_for_builtin
init|=
name|TARGET_64BIT
condition|?
name|code_for_builtin_64
else|:
name|code_for_builtin_31
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|op
index|[
name|MAX_ARGS
index|]
decl_stmt|,
name|pat
decl_stmt|;
name|int
name|arity
decl_stmt|;
name|bool
name|nonvoid
decl_stmt|;
if|if
condition|(
name|fcode
operator|>=
name|S390_BUILTIN_max
condition|)
name|internal_error
argument_list|(
literal|"bad builtin fcode"
argument_list|)
expr_stmt|;
name|icode
operator|=
name|code_for_builtin
index|[
name|fcode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
literal|0
condition|)
name|internal_error
argument_list|(
literal|"bad builtin fcode"
argument_list|)
expr_stmt|;
name|nonvoid
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
expr_stmt|;
for|for
control|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|arity
operator|=
literal|0
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|,
name|arity
operator|++
control|)
block|{
specifier|const
name|struct
name|insn_operand_data
modifier|*
name|insn_op
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|arity
operator|>
name|MAX_ARGS
condition|)
return|return
name|NULL_RTX
return|;
name|insn_op
operator|=
operator|&
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|arity
operator|+
name|nonvoid
index|]
expr_stmt|;
name|op
index|[
name|arity
index|]
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|insn_op
operator|->
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_op
operator|->
name|predicate
call|)
argument_list|(
name|op
index|[
name|arity
index|]
argument_list|,
name|insn_op
operator|->
name|mode
argument_list|)
condition|)
name|op
index|[
name|arity
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_op
operator|->
name|mode
argument_list|,
name|op
index|[
name|arity
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nonvoid
condition|)
block|{
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|arity
condition|)
block|{
case|case
literal|0
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|nonvoid
condition|)
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonvoid
condition|)
return|return
name|target
return|;
else|else
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Output assembly code for the trampoline template to    stdio stream FILE.     On S/390, we use gpr 1 internally in the trampoline code;    gpr 0 is used to hold the static chain.  */
end_comment

begin_function
name|void
name|s390_trampoline_template
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"larl\t%s,0f\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lg\t%s,0(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lg\t%s,8(%s)\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"br\t%s\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0:\t.quad\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".quad\t0\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"basr\t%s,0\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l\t%s,10(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l\t%s,14(%s)\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"br\t%s\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".long\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".long\t0\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|s390_initialize_trampoline
parameter_list|(
name|addr
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|rtx
name|fnaddr
decl_stmt|;
name|rtx
name|cxt
decl_stmt|;
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|20
else|:
literal|12
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|28
else|:
literal|16
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return rtx for 64-bit constant formed from the 32-bit subwords    LOW and HIGH, independent of the host word size.  */
end_comment

begin_function
name|rtx
name|s390_gen_rtx_const_DI
parameter_list|(
name|high
parameter_list|,
name|low
parameter_list|)
name|int
name|high
decl_stmt|;
name|int
name|low
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|high
expr_stmt|;
name|val
operator|<<=
literal|32
expr_stmt|;
name|val
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|low
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|32
return|return
name|immed_double_const
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|low
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|high
argument_list|,
name|DImode
argument_list|)
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output assembler code to FILE to increment profiler label # LABELNO    for profiling a function entry.  */
end_comment

begin_function
name|void
name|s390_function_profiler
parameter_list|(
name|file
parameter_list|,
name|labelno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|rtx
name|op
index|[
literal|7
index|]
decl_stmt|;
name|char
name|label
index|[
literal|128
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"# function profiler \n"
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|op
index|[
literal|1
index|]
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAG
argument_list|(
name|op
index|[
literal|3
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_mcount"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op
index|[
literal|4
index|]
argument_list|)
argument_list|,
literal|113
argument_list|)
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"stg\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"larl\t%2,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"brasl\t%0,%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lg\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bras\t%2,%l6"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,0(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%2,4(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%0,%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bras\t%2,%l6"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%4-%l5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3-%l5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lr\t%0,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%0,0(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%2,4(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%0,%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Select section for constant in constant pool.  In 32-bit mode,    constants go in the function section; in 64-bit mode in .rodata.  */
end_comment

begin_function
specifier|static
name|void
name|s390_select_rtx_section
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|align
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|readonly_data_section
argument_list|()
expr_stmt|;
else|else
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encode symbol attributes (local vs. global, tls model) of a SYMBOL_REF    into its name and SYMBOL_REF_FLAG.  */
end_comment

begin_function
specifier|static
name|void
name|s390_encode_section_info
parameter_list|(
name|decl
parameter_list|,
name|first
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|first
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bool
name|local_p
init|=
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|rtx
name|rtl
decl_stmt|,
name|symbol
decl_stmt|;
name|rtl
operator|=
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|?
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
else|:
name|TREE_CST_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|symbol
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|symbol
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return;
comment|/* When using PIC, SYMBOL_REF_FLAG marks non-global symbols      that can be accessed directly.  */
if|if
condition|(
name|flag_pic
condition|)
name|SYMBOL_REF_FLAG
argument_list|(
name|symbol
argument_list|)
operator|=
name|local_p
expr_stmt|;
comment|/* Encode thread-local data with %[GLil] for "global dynamic",      "local dynamic", "initial exec" or "local exec" TLS models,      respectively.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|symbol_str
init|=
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|enum
name|tls_model
name|kind
init|=
name|decl_tls_model
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
comment|/* We don't allow non-pic code for shared libraries, 	     so don't generate GD/LD TLS models for non-pic code.  */
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|kind
operator|=
name|TLS_MODEL_INITIAL_EXEC
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|kind
operator|=
name|TLS_MODEL_LOCAL_EXEC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|symbol_str
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|symbol_str
index|[
literal|1
index|]
operator|==
name|tls_model_chars
index|[
name|kind
index|]
condition|)
return|return;
name|symbol_str
operator|+=
literal|2
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|symbol_str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|newstr
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|newstr
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|newstr
index|[
literal|1
index|]
operator|=
name|tls_model_chars
index|[
name|kind
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|newstr
operator|+
literal|2
argument_list|,
name|symbol_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|newstr
argument_list|,
name|len
operator|+
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If a variable has a forced alignment to< 2 bytes, mark it      with '@' to prevent it from being used as LARL operand.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|<
literal|16
operator|&&
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
specifier|const
name|char
modifier|*
name|symbol_str
init|=
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|symbol_str
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|newstr
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newstr
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|memcpy
argument_list|(
name|newstr
operator|+
literal|1
argument_list|,
name|symbol_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|newstr
argument_list|,
name|len
operator|+
literal|1
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Undo the above when printing symbol names.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|s390_strip_name_encoding
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
name|str
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|str
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|str
operator|+=
literal|1
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Output thunk to FILE that implements a C++ virtual function call (with    multiple inheritance) to FUNCTION.  The thunk adjusts the this pointer     by DELTA, and unless VCALL_OFFSET is zero, applies an additional adjustment    stored at VCALL_OFFSET in the vtable whose address is located at offset 0    relative to the resulting this pointer.  */
end_comment

begin_function
specifier|static
name|void
name|s390_output_mi_thunk
parameter_list|(
name|file
parameter_list|,
name|thunk
parameter_list|,
name|delta
parameter_list|,
name|vcall_offset
parameter_list|,
name|function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|delta
decl_stmt|;
name|HOST_WIDE_INT
name|vcall_offset
decl_stmt|;
name|tree
name|function
decl_stmt|;
block|{
name|rtx
name|op
index|[
literal|10
index|]
decl_stmt|;
name|int
name|nonlocal
init|=
literal|0
decl_stmt|;
comment|/* Operand 0 is the target function.  */
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|SYMBOL_REF_FLAG
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|nonlocal
operator|=
literal|1
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|TARGET_64BIT
condition|?
literal|113
else|:
name|flag_pic
operator|==
literal|2
condition|?
literal|112
else|:
literal|110
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Operand 1 is the 'this' pointer.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
condition|)
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Operand 2 is the delta.  */
name|op
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
comment|/* Operand 3 is the vcall_offset.  */
name|op
index|[
literal|3
index|]
operator|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
expr_stmt|;
comment|/* Operand 4 is the temporary register.  */
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Operands 5 to 8 can be used as labels.  */
name|op
index|[
literal|5
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|6
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|7
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|8
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Operand 9 can be used for temporary register.  */
name|op
index|[
literal|9
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Generate code.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* Setup literal pool pointer if required.  */
if|if
condition|(
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|delta
argument_list|,
literal|'K'
argument_list|)
operator|||
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'K'
argument_list|)
condition|)
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"larl\t%4,%5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* Add DELTA to this pointer.  */
if|if
condition|(
name|delta
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|delta
argument_list|,
literal|'J'
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"la\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|delta
argument_list|,
literal|'K'
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"aghi\t%1,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"agf\t%1,%6-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Perform vcall adjustment.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'J'
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lg\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,%3(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'K'
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lghi\t%4,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|7
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"llgf\t%4,%7-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Jump to target.  */
name|output_asm_insn
argument_list|(
literal|"jg\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Output literal pool if required.  */
if|if
condition|(
name|op
index|[
literal|5
index|]
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|".align\t4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|6
index|]
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|7
index|]
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Setup base pointer if required.  */
if|if
condition|(
operator|!
name|vcall_offset
operator|||
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|delta
argument_list|,
literal|'K'
argument_list|)
operator|||
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'K'
argument_list|)
condition|)
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%4,0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add DELTA to this pointer.  */
if|if
condition|(
name|delta
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|delta
argument_list|,
literal|'J'
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"la\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|delta
argument_list|,
literal|'K'
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"ahi\t%1,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,%6-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Perform vcall adjustment.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'J'
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lg\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,%3(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'K'
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lhi\t%4,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|7
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,%7-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We had to clobber the base pointer register. 	     Re-setup the base pointer (with a different base).  */
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%4,0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Jump to target.  */
name|op
index|[
literal|8
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|"l\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nonlocal
condition|)
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* We cannot call through .plt, since .plt requires %r12 loaded.  */
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,%0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|op
index|[
literal|9
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%9,%8-4-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ar\t%4,%9"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"br\t%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Output literal pool.  */
name|output_asm_insn
argument_list|(
literal|".align\t4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal
operator|&&
name|flag_pic
operator|==
literal|2
condition|)
name|output_asm_insn
argument_list|(
literal|".long\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAG
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|8
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|".long\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|".long\t%0-%5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
literal|6
index|]
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|7
index|]
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* How to allocate a 'struct machine_function'.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|s390_init_machine_status
parameter_list|()
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-s390.h"
end_include

end_unit

