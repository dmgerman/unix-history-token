begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IBM S/390 and zSeries    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Hartmut Penner (hpenner@de.ibm.com) and                   Ulrich Weigand (uweigand@de.ibm.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_comment
comment|/* Define the specific costs for a given cpu.  */
end_comment

begin_struct
struct|struct
name|processor_costs
block|{
comment|/* multiplication */
specifier|const
name|int
name|m
decl_stmt|;
comment|/* cost of an M instruction.  */
specifier|const
name|int
name|mghi
decl_stmt|;
comment|/* cost of an MGHI instruction.  */
specifier|const
name|int
name|mh
decl_stmt|;
comment|/* cost of an MH instruction.  */
specifier|const
name|int
name|mhi
decl_stmt|;
comment|/* cost of an MHI instruction.  */
specifier|const
name|int
name|ml
decl_stmt|;
comment|/* cost of an ML instruction.  */
specifier|const
name|int
name|mr
decl_stmt|;
comment|/* cost of an MR instruction.  */
specifier|const
name|int
name|ms
decl_stmt|;
comment|/* cost of an MS instruction.  */
specifier|const
name|int
name|msg
decl_stmt|;
comment|/* cost of an MSG instruction.  */
specifier|const
name|int
name|msgf
decl_stmt|;
comment|/* cost of an MSGF instruction.  */
specifier|const
name|int
name|msgfr
decl_stmt|;
comment|/* cost of an MSGFR instruction.  */
specifier|const
name|int
name|msgr
decl_stmt|;
comment|/* cost of an MSGR instruction.  */
specifier|const
name|int
name|msr
decl_stmt|;
comment|/* cost of an MSR instruction.  */
specifier|const
name|int
name|mult_df
decl_stmt|;
comment|/* cost of multiplication in DFmode.  */
specifier|const
name|int
name|mxbr
decl_stmt|;
comment|/* square root */
specifier|const
name|int
name|sqxbr
decl_stmt|;
comment|/* cost of square root in TFmode.  */
specifier|const
name|int
name|sqdbr
decl_stmt|;
comment|/* cost of square root in DFmode.  */
specifier|const
name|int
name|sqebr
decl_stmt|;
comment|/* cost of square root in SFmode.  */
comment|/* multiply and add */
specifier|const
name|int
name|madbr
decl_stmt|;
comment|/* cost of multiply and add in DFmode.  */
specifier|const
name|int
name|maebr
decl_stmt|;
comment|/* cost of multiply and add in SFmode.  */
comment|/* division */
specifier|const
name|int
name|dxbr
decl_stmt|;
specifier|const
name|int
name|dxr
decl_stmt|;
specifier|const
name|int
name|ddbr
decl_stmt|;
specifier|const
name|int
name|ddr
decl_stmt|;
specifier|const
name|int
name|debr
decl_stmt|;
specifier|const
name|int
name|der
decl_stmt|;
specifier|const
name|int
name|dlgr
decl_stmt|;
specifier|const
name|int
name|dlr
decl_stmt|;
specifier|const
name|int
name|dr
decl_stmt|;
specifier|const
name|int
name|dsgfr
decl_stmt|;
specifier|const
name|int
name|dsgr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|processor_costs
modifier|*
name|s390_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|z900_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* M     */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/* MGHI  */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* MH    */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MHI   */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* ML    */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* MR    */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MS    */
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|,
comment|/* MSG   */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* MSGF  */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* MSGFR */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/* MSGR  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSR   */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* multiplication in DFmode */
name|COSTS_N_INSNS
argument_list|(
literal|13
argument_list|)
block|,
comment|/* MXBR */
name|COSTS_N_INSNS
argument_list|(
literal|136
argument_list|)
block|,
comment|/* SQXBR */
name|COSTS_N_INSNS
argument_list|(
literal|44
argument_list|)
block|,
comment|/* SQDBR */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* SQEBR */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* MADBR */
name|COSTS_N_INSNS
argument_list|(
literal|13
argument_list|)
block|,
comment|/* MAEBR */
name|COSTS_N_INSNS
argument_list|(
literal|134
argument_list|)
block|,
comment|/* DXBR */
name|COSTS_N_INSNS
argument_list|(
literal|135
argument_list|)
block|,
comment|/* DXR */
name|COSTS_N_INSNS
argument_list|(
literal|30
argument_list|)
block|,
comment|/* DDBR */
name|COSTS_N_INSNS
argument_list|(
literal|30
argument_list|)
block|,
comment|/* DDR  */
name|COSTS_N_INSNS
argument_list|(
literal|27
argument_list|)
block|,
comment|/* DEBR */
name|COSTS_N_INSNS
argument_list|(
literal|26
argument_list|)
block|,
comment|/* DER  */
name|COSTS_N_INSNS
argument_list|(
literal|220
argument_list|)
block|,
comment|/* DLGR */
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
block|,
comment|/* DLR */
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
block|,
comment|/* DR */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* DSGFR */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* DSGR */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|z990_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* M     */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* MGHI  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* MH    */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* MHI   */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* ML    */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MR    */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* MS    */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* MSG   */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSGF  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSGFR */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSGR  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSR   */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* multiplication in DFmode */
name|COSTS_N_INSNS
argument_list|(
literal|28
argument_list|)
block|,
comment|/* MXBR */
name|COSTS_N_INSNS
argument_list|(
literal|130
argument_list|)
block|,
comment|/* SQXBR */
name|COSTS_N_INSNS
argument_list|(
literal|66
argument_list|)
block|,
comment|/* SQDBR */
name|COSTS_N_INSNS
argument_list|(
literal|38
argument_list|)
block|,
comment|/* SQEBR */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* MADBR */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* MAEBR */
name|COSTS_N_INSNS
argument_list|(
literal|60
argument_list|)
block|,
comment|/* DXBR */
name|COSTS_N_INSNS
argument_list|(
literal|72
argument_list|)
block|,
comment|/* DXR */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/* DDBR */
name|COSTS_N_INSNS
argument_list|(
literal|44
argument_list|)
block|,
comment|/* DDR  */
name|COSTS_N_INSNS
argument_list|(
literal|26
argument_list|)
block|,
comment|/* DDBR */
name|COSTS_N_INSNS
argument_list|(
literal|28
argument_list|)
block|,
comment|/* DER  */
name|COSTS_N_INSNS
argument_list|(
literal|176
argument_list|)
block|,
comment|/* DLGR */
name|COSTS_N_INSNS
argument_list|(
literal|31
argument_list|)
block|,
comment|/* DLR */
name|COSTS_N_INSNS
argument_list|(
literal|31
argument_list|)
block|,
comment|/* DR */
name|COSTS_N_INSNS
argument_list|(
literal|31
argument_list|)
block|,
comment|/* DSGFR */
name|COSTS_N_INSNS
argument_list|(
literal|31
argument_list|)
block|,
comment|/* DSGR */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|z9_109_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* M     */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* MGHI  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* MH    */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* MHI   */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* ML    */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MR    */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* MS    */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* MSG   */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSGF  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSGFR */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSGR  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* MSR   */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* multiplication in DFmode */
name|COSTS_N_INSNS
argument_list|(
literal|28
argument_list|)
block|,
comment|/* MXBR */
name|COSTS_N_INSNS
argument_list|(
literal|130
argument_list|)
block|,
comment|/* SQXBR */
name|COSTS_N_INSNS
argument_list|(
literal|66
argument_list|)
block|,
comment|/* SQDBR */
name|COSTS_N_INSNS
argument_list|(
literal|38
argument_list|)
block|,
comment|/* SQEBR */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* MADBR */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* MAEBR */
name|COSTS_N_INSNS
argument_list|(
literal|60
argument_list|)
block|,
comment|/* DXBR */
name|COSTS_N_INSNS
argument_list|(
literal|72
argument_list|)
block|,
comment|/* DXR */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/* DDBR */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* DDR  */
name|COSTS_N_INSNS
argument_list|(
literal|26
argument_list|)
block|,
comment|/* DDBR */
name|COSTS_N_INSNS
argument_list|(
literal|28
argument_list|)
block|,
comment|/* DER  */
name|COSTS_N_INSNS
argument_list|(
literal|30
argument_list|)
block|,
comment|/* DLGR */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* DLR */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* DR */
name|COSTS_N_INSNS
argument_list|(
literal|24
argument_list|)
block|,
comment|/* DSGFR */
name|COSTS_N_INSNS
argument_list|(
literal|24
argument_list|)
block|,
comment|/* DSGR */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|s390_compare_op0
decl_stmt|,
name|s390_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save the result of a compare_and_swap  until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|s390_compare_emitted
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to hold the components of a S/390 memory    address.  A legitimate address on S/390 is of the general    form           base + index + displacement    where any of the components is optional.     base and index are registers of the class ADDR_REGS,    displacement is an unsigned 12-bit immediate constant.  */
end_comment

begin_struct
struct|struct
name|s390_address
block|{
name|rtx
name|base
decl_stmt|;
name|rtx
name|indx
decl_stmt|;
name|rtx
name|disp
decl_stmt|;
name|bool
name|pointer
decl_stmt|;
name|bool
name|literal_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Which cpu are we tuning for.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|s390_tune
init|=
name|PROCESSOR_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|processor_flags
name|s390_tune_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|s390_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|processor_flags
name|s390_arch_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|s390_warn_framesize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|s390_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|s390_stack_guard
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following structure is embedded in the machine     specific part of struct function.  */
end_comment

begin_decl_stmt
name|struct
name|s390_frame_layout
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Offset within stack frame.  */
name|HOST_WIDE_INT
name|gprs_offset
decl_stmt|;
name|HOST_WIDE_INT
name|f0_offset
decl_stmt|;
name|HOST_WIDE_INT
name|f4_offset
decl_stmt|;
name|HOST_WIDE_INT
name|f8_offset
decl_stmt|;
name|HOST_WIDE_INT
name|backchain_offset
decl_stmt|;
comment|/* Number of first and last gpr where slots in the register      save area are reserved for.  */
name|int
name|first_save_gpr_slot
decl_stmt|;
name|int
name|last_save_gpr_slot
decl_stmt|;
comment|/* Number of first and last gpr to be saved, restored.  */
name|int
name|first_save_gpr
decl_stmt|;
name|int
name|first_restore_gpr
decl_stmt|;
name|int
name|last_save_gpr
decl_stmt|;
name|int
name|last_restore_gpr
decl_stmt|;
comment|/* Bits standing for floating point registers. Set, if the       respective register has to be saved. Starting with reg 16 (f0)       at the rightmost bit.      Bit 15 -  8  7  6  5  4  3  2  1  0      fpr 15 -  8  7  5  3  1  6  4  2  0      reg 31 - 24 23 22 21 20 19 18 17 16  */
name|unsigned
name|int
name|fpr_bitmap
decl_stmt|;
comment|/* Number of floating point registers f8-f15 which must be saved.  */
name|int
name|high_fprs
decl_stmt|;
comment|/* Set if return address needs to be saved.      This flag is set by s390_return_addr_rtx if it could not use      the initial value of r14 and therefore depends on r14 saved      to the stack.  */
name|bool
name|save_return_addr_p
decl_stmt|;
comment|/* Size of stack frame.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Define the structure for the machine field in struct function.  */
end_comment

begin_decl_stmt
name|struct
name|machine_function
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|s390_frame_layout
name|frame_layout
decl_stmt|;
comment|/* Literal pool base register.  */
name|rtx
name|base_reg
decl_stmt|;
comment|/* True if we may need to perform branch splitting.  */
name|bool
name|split_branches_pending_p
decl_stmt|;
comment|/* True during final stage of literal pool processing.  */
name|bool
name|decomposed_literal_pool_addresses_ok_p
decl_stmt|;
comment|/* Some local-dynamic TLS symbol name.  */
specifier|const
name|char
modifier|*
name|some_ld_name
decl_stmt|;
name|bool
name|has_landing_pad_p
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Few accessor macros for struct cfun->machine->s390_frame_layout.  */
end_comment

begin_define
define|#
directive|define
name|cfun_frame_layout
value|(cfun->machine->frame_layout)
end_define

begin_define
define|#
directive|define
name|cfun_save_high_fprs_p
value|(!!cfun_frame_layout.high_fprs)
end_define

begin_define
define|#
directive|define
name|cfun_gprs_save_area_size
value|((cfun_frame_layout.last_save_gpr_slot -           \   cfun_frame_layout.first_save_gpr_slot + 1) * UNITS_PER_WORD)
end_define

begin_define
define|#
directive|define
name|cfun_set_fpr_bit
parameter_list|(
name|BITNUM
parameter_list|)
value|(cfun->machine->frame_layout.fpr_bitmap |=    \   (1<< (BITNUM)))
end_define

begin_define
define|#
directive|define
name|cfun_fpr_bit_p
parameter_list|(
name|BITNUM
parameter_list|)
value|(!!(cfun->machine->frame_layout.fpr_bitmap&    \   (1<< (BITNUM))))
end_define

begin_comment
comment|/* Number of GPRs and FPRs used for argument passing.  */
end_comment

begin_define
define|#
directive|define
name|GP_ARG_NUM_REG
value|5
end_define

begin_define
define|#
directive|define
name|FP_ARG_NUM_REG
value|(TARGET_64BIT? 4 : 2)
end_define

begin_comment
comment|/* A couple of shortcuts.  */
end_comment

begin_define
define|#
directive|define
name|CONST_OK_FOR_J
parameter_list|(
name|x
parameter_list|)
define|\
value|CONST_OK_FOR_CONSTRAINT_P((x), 'J', "J")
end_define

begin_define
define|#
directive|define
name|CONST_OK_FOR_K
parameter_list|(
name|x
parameter_list|)
define|\
value|CONST_OK_FOR_CONSTRAINT_P((x), 'K', "K")
end_define

begin_define
define|#
directive|define
name|CONST_OK_FOR_Os
parameter_list|(
name|x
parameter_list|)
define|\
value|CONST_OK_FOR_CONSTRAINT_P((x), 'O', "Os")
end_define

begin_define
define|#
directive|define
name|CONST_OK_FOR_Op
parameter_list|(
name|x
parameter_list|)
define|\
value|CONST_OK_FOR_CONSTRAINT_P((x), 'O', "Op")
end_define

begin_define
define|#
directive|define
name|CONST_OK_FOR_On
parameter_list|(
name|x
parameter_list|)
define|\
value|CONST_OK_FOR_CONSTRAINT_P((x), 'O', "On")
end_define

begin_define
define|#
directive|define
name|REGNO_PAIR_OK
parameter_list|(
name|REGNO
parameter_list|,
name|MODE
parameter_list|)
define|\
value|(HARD_REGNO_NREGS ((REGNO), (MODE)) == 1 || !((REGNO)& 1))
end_define

begin_comment
comment|/* Return true if the back end supports mode MODE.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_scalar_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|default_scalar_mode_supported_p
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the has_landing_pad_p flag in struct machine_function to VALUE.  */
end_comment

begin_function
name|void
name|s390_set_has_landing_pad_p
parameter_list|(
name|bool
name|value
parameter_list|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|has_landing_pad_p
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If two condition code modes are compatible, return a condition code    mode which is compatible with both.  Otherwise, return    VOIDmode.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|s390_cc_modes_compatible
parameter_list|(
name|enum
name|machine_mode
name|m1
parameter_list|,
name|enum
name|machine_mode
name|m2
parameter_list|)
block|{
if|if
condition|(
name|m1
operator|==
name|m2
condition|)
return|return
name|m1
return|;
switch|switch
condition|(
name|m1
condition|)
block|{
case|case
name|CCZmode
case|:
if|if
condition|(
name|m2
operator|==
name|CCUmode
operator|||
name|m2
operator|==
name|CCTmode
operator|||
name|m2
operator|==
name|CCZ1mode
operator|||
name|m2
operator|==
name|CCSmode
operator|||
name|m2
operator|==
name|CCSRmode
operator|||
name|m2
operator|==
name|CCURmode
condition|)
return|return
name|m2
return|;
return|return
name|VOIDmode
return|;
case|case
name|CCSmode
case|:
case|case
name|CCUmode
case|:
case|case
name|CCTmode
case|:
case|case
name|CCSRmode
case|:
case|case
name|CCURmode
case|:
case|case
name|CCZ1mode
case|:
if|if
condition|(
name|m2
operator|==
name|CCZmode
condition|)
return|return
name|m1
return|;
return|return
name|VOIDmode
return|;
default|default:
return|return
name|VOIDmode
return|;
block|}
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Return true if SET either doesn't set the CC register, or else    the source and destination have matching CC modes and that    CC mode is at least as constrained as REQ_MODE.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_match_ccmode_set
parameter_list|(
name|rtx
name|set
parameter_list|,
name|enum
name|machine_mode
name|req_mode
parameter_list|)
block|{
name|enum
name|machine_mode
name|set_mode
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CC_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|set_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|set_mode
condition|)
block|{
case|case
name|CCSmode
case|:
case|case
name|CCSRmode
case|:
case|case
name|CCUmode
case|:
case|case
name|CCURmode
case|:
case|case
name|CCLmode
case|:
case|case
name|CCL1mode
case|:
case|case
name|CCL2mode
case|:
case|case
name|CCL3mode
case|:
case|case
name|CCT1mode
case|:
case|case
name|CCT2mode
case|:
case|case
name|CCT3mode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|set_mode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCZmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCSmode
operator|&&
name|req_mode
operator|!=
name|CCUmode
operator|&&
name|req_mode
operator|!=
name|CCTmode
operator|&&
name|req_mode
operator|!=
name|CCSRmode
operator|&&
name|req_mode
operator|!=
name|CCURmode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCAPmode
case|:
case|case
name|CCANmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCAmode
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|set_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if every SET in INSN that sets the CC register    has source and destination with matching CC modes and that    CC mode is at least as constrained as REQ_MODE.    If REQ_MODE is VOIDmode, always return false.  */
end_comment

begin_function
name|bool
name|s390_match_ccmode
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|machine_mode
name|req_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* s390_tm_ccmode returns VOIDmode to indicate failure.  */
if|if
condition|(
name|req_mode
operator|==
name|VOIDmode
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
name|s390_match_ccmode_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|req_mode
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
condition|)
if|if
condition|(
operator|!
name|s390_match_ccmode_set
argument_list|(
name|set
argument_list|,
name|req_mode
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If a test-under-mask instruction can be used to implement    (compare (and ... OP1) OP2), return the CC mode required    to do that.  Otherwise, return VOIDmode.    MIXED is true if the instruction can distinguish between    CC1 and CC2 for mixed selected bits (TMxx), it is false    if the instruction cannot (TM).  */
end_comment

begin_function
name|enum
name|machine_mode
name|s390_tm_ccmode
parameter_list|(
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|bool
name|mixed
parameter_list|)
block|{
name|int
name|bit0
decl_stmt|,
name|bit1
decl_stmt|;
comment|/* ??? Fixme: should work on CONST_DOUBLE as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|VOIDmode
return|;
comment|/* Selected bits all zero: CC0.      e.g.: int a; if ((a& (16 + 128)) == 0) */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|CCTmode
return|;
comment|/* Selected bits all one: CC3.       e.g.: int a; if ((a& (16 + 128)) == 16 + 128) */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|CCT3mode
return|;
comment|/* Exactly two bits selected, mixed zeroes and ones: CC1 or CC2. e.g.:      int a;      if ((a& (16 + 128)) == 16)         -> CCT1      if ((a& (16 + 128)) == 128)        -> CCT2  */
if|if
condition|(
name|mixed
condition|)
block|{
name|bit1
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|bit0
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|^
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit0
operator|!=
operator|-
literal|1
operator|&&
name|bit1
operator|!=
operator|-
literal|1
condition|)
return|return
name|bit0
operator|>
name|bit1
condition|?
name|CCT1mode
else|:
name|CCT2mode
return|;
block|}
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Given a comparison code OP (EQ, NE, etc.) and the operands    OP0 and OP1 of a COMPARE, return the mode to be used for the    comparison.  */
end_comment

begin_function
name|enum
name|machine_mode
name|s390_select_ccmode
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ABS
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|CCAPmode
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|CCAPmode
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|CCLmode
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
condition|)
block|{
comment|/* Check whether we can potentially do it via TM.  */
name|enum
name|machine_mode
name|ccmode
decl_stmt|;
name|ccmode
operator|=
name|s390_tm_ccmode
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccmode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* Relax CCTmode to CCZmode to allow fall-back to AND 		   if that turns out to be beneficial.  */
return|return
name|ccmode
operator|==
name|CCTmode
condition|?
name|CCZmode
else|:
name|ccmode
return|;
block|}
block|}
if|if
condition|(
name|register_operand
argument_list|(
name|op0
argument_list|,
name|HImode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|65535
operator|)
condition|)
return|return
name|CCT3mode
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op0
argument_list|,
name|QImode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|255
operator|)
condition|)
return|return
name|CCT3mode
return|;
return|return
name|CCZmode
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
comment|/* The only overflow condition of NEG and ABS happens when 	   -INT_MAX is used as parameter, which stays negative. So 	   we have an overflow from a positive value to a negative.  	   Using CCAP mode the resulting cc can be used for comparisons.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ABS
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|CCAPmode
return|;
comment|/* If constants are involved in an add instruction it is possible to use  	   the resulting cc for comparisons with zero. Knowing the sign of the 	   constant the overflow behavior gets predictable. e.g.:  	     int a, b; if ((b = a + c)> 0)    	   with c as a constant value: c< 0 -> CCAN and c>= 0 -> CCAP  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|(
name|op0
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|CCANmode
return|;
else|else
return|return
name|CCAPmode
return|;
block|}
comment|/* Fall through.  */
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|UNGE
case|:
case|case
name|UNGT
case|:
case|case
name|LTGT
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCSRmode
return|;
return|return
name|CCSmode
return|;
case|case
name|LTU
case|:
case|case
name|GEU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|CCL1mode
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCURmode
return|;
return|return
name|CCUmode
return|;
case|case
name|LEU
case|:
case|case
name|GTU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|CCL2mode
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCURmode
return|;
return|return
name|CCUmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Replace the comparison OP0 CODE OP1 by a semantically equivalent one    that we can implement more efficiently.  */
end_comment

begin_function
name|void
name|s390_canonicalize_comparison
parameter_list|(
name|enum
name|rtx_code
modifier|*
name|code
parameter_list|,
name|rtx
modifier|*
name|op0
parameter_list|,
name|rtx
modifier|*
name|op1
parameter_list|)
block|{
comment|/* Convert ZERO_EXTRACT back to AND to enable TM patterns.  */
if|if
condition|(
operator|(
operator|*
name|code
operator|==
name|EQ
operator|||
operator|*
name|code
operator|==
name|NE
operator|)
operator|&&
operator|*
name|op1
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|op0
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|inner
init|=
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|modesize
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|len
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<
name|modesize
operator|&&
name|pos
operator|>=
literal|0
operator|&&
name|pos
operator|+
name|len
operator|<=
name|modesize
operator|&&
name|modesize
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|block
decl_stmt|;
name|block
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
expr_stmt|;
name|block
operator|<<=
name|modesize
operator|-
name|pos
operator|-
name|len
expr_stmt|;
operator|*
name|op0
operator|=
name|gen_rtx_AND
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|,
name|inner
argument_list|,
name|gen_int_mode
argument_list|(
name|block
argument_list|,
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Narrow AND of memory against immediate to enable TM.  */
if|if
condition|(
operator|(
operator|*
name|code
operator|==
name|EQ
operator|||
operator|*
name|code
operator|==
name|NE
operator|)
operator|&&
operator|*
name|op1
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|op0
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|inner
init|=
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mask
init|=
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Ignore paradoxical SUBREGs if all extra bits are masked out.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|mask
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
comment|/* Do not change volatile MEMs.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|inner
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|inner
argument_list|)
condition|)
block|{
name|int
name|part
init|=
name|s390_single_part
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|,
name|QImode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|>=
literal|0
condition|)
block|{
name|mask
operator|=
name|gen_int_mode
argument_list|(
name|s390_extract_part
argument_list|(
name|mask
argument_list|,
name|QImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|inner
operator|=
name|adjust_address_nv
argument_list|(
name|inner
argument_list|,
name|QImode
argument_list|,
name|part
argument_list|)
expr_stmt|;
operator|*
name|op0
operator|=
name|gen_rtx_AND
argument_list|(
name|QImode
argument_list|,
name|inner
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Narrow comparisons against 0xffff to HImode if possible.  */
if|if
condition|(
operator|(
operator|*
name|code
operator|==
name|EQ
operator|||
operator|*
name|code
operator|==
name|NE
operator|)
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
operator|*
name|op1
argument_list|)
operator|==
literal|0xffff
operator|&&
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|op0
argument_list|)
argument_list|)
operator|&&
operator|(
name|nonzero_bits
argument_list|(
operator|*
name|op0
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|op0
argument_list|)
argument_list|)
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
operator|*
name|op0
argument_list|)
expr_stmt|;
operator|*
name|op1
operator|=
name|constm1_rtx
expr_stmt|;
block|}
comment|/* Remove redundant UNSPEC_CMPINT conversions if possible.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|op0
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
operator|*
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_CMPINT
operator|&&
name|XVECLEN
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|&&
name|GET_MODE
argument_list|(
name|XVECEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCUmode
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XVECEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CC_REGNUM
operator|&&
operator|*
name|op1
operator|==
name|const0_rtx
condition|)
block|{
name|enum
name|rtx_code
name|new_code
init|=
name|UNKNOWN
decl_stmt|;
switch|switch
condition|(
operator|*
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|new_code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|new_code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|new_code
operator|=
name|GTU
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|new_code
operator|=
name|LTU
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|new_code
operator|=
name|GEU
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|new_code
operator|=
name|LEU
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|new_code
operator|!=
name|UNKNOWN
condition|)
block|{
operator|*
name|op0
operator|=
name|XVECEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
name|new_code
expr_stmt|;
block|}
block|}
comment|/* Simplify cascaded EQ, NE with const0_rtx.  */
if|if
condition|(
operator|(
operator|*
name|code
operator|==
name|NE
operator|||
operator|*
name|code
operator|==
name|EQ
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
operator|*
name|op0
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
operator|*
name|op0
argument_list|)
operator|==
name|NE
operator|)
operator|&&
name|GET_MODE
argument_list|(
operator|*
name|op0
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCZ1mode
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
operator|*
name|op1
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|code
operator|==
name|EQ
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|op0
argument_list|)
operator|==
name|NE
operator|)
operator|||
operator|(
operator|*
name|code
operator|==
name|NE
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|op0
argument_list|)
operator|==
name|EQ
operator|)
condition|)
operator|*
name|code
operator|=
name|EQ
expr_stmt|;
else|else
operator|*
name|code
operator|=
name|NE
expr_stmt|;
operator|*
name|op0
operator|=
name|XEXP
argument_list|(
operator|*
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Prefer register over memory as first operand.  */
if|if
condition|(
name|MEM_P
argument_list|(
operator|*
name|op0
argument_list|)
operator|&&
name|REG_P
argument_list|(
operator|*
name|op1
argument_list|)
condition|)
block|{
name|rtx
name|tem
init|=
operator|*
name|op0
decl_stmt|;
operator|*
name|op0
operator|=
operator|*
name|op1
expr_stmt|;
operator|*
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|code
operator|=
name|swap_condition
argument_list|(
operator|*
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a compare instruction suitable to implement the comparison    OP0 CODE OP1.  Return the correct condition RTL to be placed in    the IF_THEN_ELSE of the conditional branch testing the result.  */
end_comment

begin_function
name|rtx
name|s390_emit_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|s390_select_ccmode
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Do not output a redundant compare instruction if a compare_and_swap      pattern already computed the result and the machine modes are compatible.  */
if|if
condition|(
name|s390_compare_emitted
operator|&&
operator|(
name|s390_cc_modes_compatible
argument_list|(
name|GET_MODE
argument_list|(
name|s390_compare_emitted
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|s390_compare_emitted
argument_list|)
operator|)
condition|)
name|ret
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|s390_compare_emitted
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|cc
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|CC_REGNUM
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|cc
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|s390_compare_emitted
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Emit a SImode compare and swap instruction setting MEM to NEW if OLD    matches CMP.    Return the correct condition RTL to be placed in the IF_THEN_ELSE of the    conditional branch testing the result.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_emit_compare_and_swap
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|old
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|cmp
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
name|rtx
name|ret
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_sync_compare_and_swap_ccsi
argument_list|(
name|old
argument_list|,
name|mem
argument_list|,
name|cmp
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|s390_compare_emitted
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|s390_compare_emitted
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Emit a jump instruction to TARGET.  If COND is NULL_RTX, emit an    unconditional jump, else a conditional jump under condition COND.  */
end_comment

begin_function
name|void
name|s390_emit_jump
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|cond
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|target
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|target
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|cond
argument_list|,
name|target
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return branch condition mask to implement a branch    specified by CODE.  Return -1 for invalid comparisons.  */
end_comment

begin_function
name|int
name|s390_branch_condition_mask
parameter_list|(
name|rtx
name|code
parameter_list|)
block|{
specifier|const
name|int
name|CC0
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
specifier|const
name|int
name|CC1
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
specifier|const
name|int
name|CC2
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
specifier|const
name|int
name|CC3
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CC_REGNUM
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CCZmode
case|:
case|case
name|CCZ1mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCT1mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC1
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCT2mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC2
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCT3mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC3
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC2
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCLmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC3
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCL1mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|LTU
case|:
return|return
name|CC2
operator||
name|CC3
return|;
comment|/* carry */
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
comment|/* no carry */
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCL2mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|GTU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
comment|/* borrow */
case|case
name|LEU
case|:
return|return
name|CC2
operator||
name|CC3
return|;
comment|/* no borrow */
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCL3mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|LTU
case|:
return|return
name|CC1
return|;
case|case
name|GTU
case|:
return|return
name|CC3
return|;
case|case
name|LEU
case|:
return|return
name|CC1
operator||
name|CC2
return|;
case|case
name|GEU
case|:
return|return
name|CC2
operator||
name|CC3
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
case|case
name|CCUmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LTU
case|:
return|return
name|CC1
return|;
case|case
name|GTU
case|:
return|return
name|CC2
return|;
case|case
name|LEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC2
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCURmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC2
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LTU
case|:
return|return
name|CC2
return|;
case|case
name|GTU
case|:
return|return
name|CC1
return|;
case|case
name|LEU
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCAPmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|GT
case|:
return|return
name|CC2
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCANmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
return|;
case|case
name|GT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCSmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
return|;
case|case
name|GT
case|:
return|return
name|CC2
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|UNORDERED
case|:
return|return
name|CC3
return|;
case|case
name|ORDERED
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC2
return|;
case|case
name|UNEQ
case|:
return|return
name|CC0
operator||
name|CC3
return|;
case|case
name|UNLT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|UNGT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|UNLE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|UNGE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LTGT
case|:
return|return
name|CC1
operator||
name|CC2
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|CCSRmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC2
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC2
return|;
case|case
name|GT
case|:
return|return
name|CC1
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|UNORDERED
case|:
return|return
name|CC3
return|;
case|case
name|ORDERED
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC1
return|;
case|case
name|UNEQ
case|:
return|return
name|CC0
operator||
name|CC3
return|;
case|case
name|UNLT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|UNGT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|UNLE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|UNGE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LTGT
case|:
return|return
name|CC2
operator||
name|CC1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* If INV is false, return assembler mnemonic string to implement    a branch specified by CODE.  If INV is true, return mnemonic    for the corresponding inverted branch.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|s390_branch_condition_mnemonic
parameter_list|(
name|rtx
name|code
parameter_list|,
name|int
name|inv
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mnemonic
index|[
literal|16
index|]
init|=
block|{
name|NULL
block|,
literal|"o"
block|,
literal|"h"
block|,
literal|"nle"
block|,
literal|"l"
block|,
literal|"nhe"
block|,
literal|"lh"
block|,
literal|"ne"
block|,
literal|"e"
block|,
literal|"nlh"
block|,
literal|"he"
block|,
literal|"nl"
block|,
literal|"le"
block|,
literal|"nh"
block|,
literal|"no"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|mask
init|=
name|s390_branch_condition_mask
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|mask
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|mask
operator|^=
literal|15
expr_stmt|;
name|gcc_assert
argument_list|(
name|mask
operator|>=
literal|1
operator|&&
name|mask
operator|<=
literal|14
argument_list|)
expr_stmt|;
return|return
name|mnemonic
index|[
name|mask
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the part of op which has a value different from def.    The size of the part is determined by mode.    Use this function only if you already know that op really    contains such a part.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|s390_extract_part
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|def
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
literal|0
decl_stmt|;
name|int
name|max_parts
init|=
name|HOST_BITS_PER_WIDE_INT
operator|/
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|part_bits
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|part_mask
init|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|part_bits
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
name|part_bits
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
name|part_mask
operator|)
operator|!=
operator|(
name|def
operator|&
name|part_mask
operator|)
condition|)
return|return
name|value
operator|&
name|part_mask
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If OP is an integer constant of mode MODE with exactly one    part of mode PART_MODE unequal to DEF, return the number of that    part. Otherwise, return -1.  */
end_comment

begin_function
name|int
name|s390_single_part
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|part_mode
parameter_list|,
name|int
name|def
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
literal|0
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|part_mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|part_mask
init|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|part_mode
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
name|GET_MODE_BITSIZE
argument_list|(
name|part_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
name|part_mask
operator|)
operator|!=
operator|(
name|def
operator|&
name|part_mask
operator|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|n_parts
operator|-
literal|1
operator|-
name|part
return|;
block|}
end_function

begin_comment
comment|/* Check whether we can (and want to) split a double-word    move in mode MODE from SRC to DST into two single-word    moves, moving the subword FIRST_SUBWORD first.  */
end_comment

begin_function
name|bool
name|s390_split_ok_p
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|first_subword
parameter_list|)
block|{
comment|/* Floating point registers cannot be split.  */
if|if
condition|(
name|FP_REG_P
argument_list|(
name|src
argument_list|)
operator|||
name|FP_REG_P
argument_list|(
name|dst
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We don't need to split if operands are directly accessible.  */
if|if
condition|(
name|s_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
operator|||
name|s_operand
argument_list|(
name|dst
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Non-offsettable memory references cannot be split.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|src
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Moving the first subword must not clobber a register      needed to move the second subword.  */
if|if
condition|(
name|register_operand
argument_list|(
name|dst
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|subreg
init|=
name|operand_subword
argument_list|(
name|dst
argument_list|,
name|first_subword
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|subreg
argument_list|,
name|src
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if it can be proven that [MEM1, MEM1 + SIZE]    and [MEM2, MEM2 + SIZE] do overlap and false    otherwise.  */
end_comment

begin_function
name|bool
name|s390_overlap_p
parameter_list|(
name|rtx
name|mem1
parameter_list|,
name|rtx
name|mem2
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|rtx
name|addr1
decl_stmt|,
name|addr2
decl_stmt|,
name|addr_delta
decl_stmt|;
name|HOST_WIDE_INT
name|delta
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem1
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|mem2
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|true
return|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|addr1
operator|=
name|XEXP
argument_list|(
name|mem1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|XEXP
argument_list|(
name|mem2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr_delta
operator|=
name|simplify_binary_operation
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|addr2
argument_list|,
name|addr1
argument_list|)
expr_stmt|;
comment|/* This overlapping check is used by peepholes merging memory block operations.      Overlapping operations would otherwise be recognized by the S/390 hardware      and would fall back to a slower implementation. Allowing overlapping       operations would lead to slow code but not to wrong code. Therefore we are      somewhat optimistic if we cannot prove that the memory blocks are       overlapping.      That's why we return false here although this may accept operations on      overlapping memory areas.  */
if|if
condition|(
operator|!
name|addr_delta
operator|||
name|GET_CODE
argument_list|(
name|addr_delta
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|false
return|;
name|delta
operator|=
name|INTVAL
argument_list|(
name|addr_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
operator|||
operator|(
name|delta
operator|>
literal|0
operator|&&
name|delta
operator|<
name|size
operator|)
operator|||
operator|(
name|delta
operator|<
literal|0
operator|&&
operator|-
name|delta
operator|<
name|size
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check whether the address of memory reference MEM2 equals exactly    the address of memory reference MEM1 plus DELTA.  Return true if    we can prove this to be the case, false otherwise.  */
end_comment

begin_function
name|bool
name|s390_offset_p
parameter_list|(
name|rtx
name|mem1
parameter_list|,
name|rtx
name|mem2
parameter_list|,
name|rtx
name|delta
parameter_list|)
block|{
name|rtx
name|addr1
decl_stmt|,
name|addr2
decl_stmt|,
name|addr_delta
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem1
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|mem2
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|false
return|;
name|addr1
operator|=
name|XEXP
argument_list|(
name|mem1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|XEXP
argument_list|(
name|mem2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr_delta
operator|=
name|simplify_binary_operation
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|addr2
argument_list|,
name|addr1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr_delta
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|addr_delta
argument_list|,
name|delta
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Expand logical operator CODE in mode MODE with operands OPERANDS.  */
end_comment

begin_function
name|void
name|s390_expand_logical_operator
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|enum
name|machine_mode
name|wmode
init|=
name|mode
decl_stmt|;
name|rtx
name|dst
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|src1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|src2
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|op
decl_stmt|,
name|clob
decl_stmt|,
name|tem
decl_stmt|;
comment|/* If we cannot handle the operation directly, use a temp register.  */
if|if
condition|(
operator|!
name|s390_logical_operator_ok_p
argument_list|(
name|operands
argument_list|)
condition|)
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* QImode and HImode patterns make sense only if we have a destination      in memory.  Otherwise perform the operation in SImode.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|MEM
condition|)
name|wmode
operator|=
name|SImode
expr_stmt|;
comment|/* Widen operands if required.  */
if|if
condition|(
name|mode
operator|!=
name|wmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|tem
operator|=
name|simplify_subreg
argument_list|(
name|wmode
argument_list|,
name|dst
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|dst
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|dst
argument_list|)
condition|)
name|dst
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|wmode
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|wmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|tem
operator|=
name|simplify_subreg
argument_list|(
name|wmode
argument_list|,
name|src1
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|src1
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|src1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|src1
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|wmode
argument_list|,
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|tem
operator|=
name|simplify_subreg
argument_list|(
name|wmode
argument_list|,
name|src2
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|src2
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|src2
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|src2
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|wmode
argument_list|,
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the instruction.  */
name|op
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|wmode
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op
argument_list|,
name|clob
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fix up the destination if needed.  */
if|if
condition|(
name|dst
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether OPERANDS are OK for a logical operation (AND, IOR, XOR).  */
end_comment

begin_function
name|bool
name|s390_logical_operator_ok_p
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
comment|/* If the destination operand is in memory, it needs to coincide      with one of the source operands.  After reload, it has to be      the first source operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
operator|!
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
operator|)
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Narrow logical operation CODE of memory operand MEMOP with immediate    operand IMMOP to switch from SS to SI type instructions.  */
end_comment

begin_function
name|void
name|s390_narrow_logical_operator
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|memop
parameter_list|,
name|rtx
modifier|*
name|immop
parameter_list|)
block|{
name|int
name|def
init|=
name|code
operator|==
name|AND
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|int
name|part
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|memop
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
operator|*
name|memop
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|s390_extract_part
argument_list|(
operator|*
name|immop
argument_list|,
name|QImode
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|part
operator|=
name|s390_single_part
argument_list|(
operator|*
name|immop
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|memop
argument_list|)
argument_list|,
name|QImode
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|part
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|memop
operator|=
name|adjust_address
argument_list|(
operator|*
name|memop
argument_list|,
name|QImode
argument_list|,
name|part
argument_list|)
expr_stmt|;
operator|*
name|immop
operator|=
name|gen_int_mode
argument_list|(
name|mask
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How to allocate a 'struct machine_function'.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|s390_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Change optimizations to be performed, depending on the    optimization level.     LEVEL is the optimization level specified; 2 if `-O2' is    specified, 1 if `-O' is specified, and 0 if neither is specified.     SIZE is nonzero if `-Os' is specified and zero otherwise.  */
end_comment

begin_function
name|void
name|optimization_options
parameter_list|(
name|int
name|level
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* ??? There are apparently still problems with -fcaller-saves.  */
name|flag_caller_saves
operator|=
literal|0
expr_stmt|;
comment|/* By default, always emit DWARF-2 unwind info.  This allows debugging      without maintaining a stack frame back-chain.  */
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
comment|/* Use MVCLE instructions to decrease code size if requested.  */
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
name|target_flags
operator||=
name|MASK_MVCLE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if ARG is the name of a processor.  Set *TYPE and *FLAGS    to the associated processor_type and processor_flags if so.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_handle_arch_option
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|enum
name|processor_type
modifier|*
name|type
parameter_list|,
name|enum
name|processor_flags
modifier|*
name|flags
parameter_list|)
block|{
specifier|static
struct|struct
name|pta
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* processor name or nickname.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
name|enum
name|processor_flags
name|flags
decl_stmt|;
block|}
decl|const
name|processor_alias_table
index|[]
init|=
block|{
block|{
literal|"g5"
block|,
name|PROCESSOR_9672_G5
block|,
name|PF_IEEE_FLOAT
block|}
block|,
block|{
literal|"g6"
block|,
name|PROCESSOR_9672_G6
block|,
name|PF_IEEE_FLOAT
block|}
block|,
block|{
literal|"z900"
block|,
name|PROCESSOR_2064_Z900
block|,
name|PF_IEEE_FLOAT
operator||
name|PF_ZARCH
block|}
block|,
block|{
literal|"z990"
block|,
name|PROCESSOR_2084_Z990
block|,
name|PF_IEEE_FLOAT
operator||
name|PF_ZARCH
operator||
name|PF_LONG_DISPLACEMENT
block|}
block|,
block|{
literal|"z9-109"
block|,
name|PROCESSOR_2094_Z9_109
block|,
name|PF_IEEE_FLOAT
operator||
name|PF_ZARCH
operator||
name|PF_LONG_DISPLACEMENT
operator||
name|PF_EXTIMM
block|}
block|,     }
struct|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|processor_alias_table
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
operator|*
name|flags
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_HANDLE_OPTION.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_handle_option
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPT_march_
case|:
return|return
name|s390_handle_arch_option
argument_list|(
name|arg
argument_list|,
operator|&
name|s390_arch
argument_list|,
operator|&
name|s390_arch_flags
argument_list|)
return|;
case|case
name|OPT_mstack_guard_
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|&
name|s390_stack_guard
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|exact_log2
argument_list|(
name|s390_stack_guard
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"stack guard value must be an exact power of 2"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|OPT_mstack_size_
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|&
name|s390_stack_size
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|exact_log2
argument_list|(
name|s390_stack_size
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"stack size must be an exact power of 2"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|OPT_mtune_
case|:
return|return
name|s390_handle_arch_option
argument_list|(
name|arg
argument_list|,
operator|&
name|s390_tune
argument_list|,
operator|&
name|s390_tune_flags
argument_list|)
return|;
case|case
name|OPT_mwarn_framesize_
case|:
return|return
name|sscanf
argument_list|(
name|arg
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|&
name|s390_warn_framesize
argument_list|)
operator|==
literal|1
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_function
name|void
name|override_options
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set up function hooks.  */
name|init_machine_status
operator|=
name|s390_init_machine_status
expr_stmt|;
comment|/* Architecture mode defaults according to ABI.  */
if|if
condition|(
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_ZARCH
operator|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|target_flags
operator||=
name|MASK_ZARCH
expr_stmt|;
else|else
name|target_flags
operator|&=
operator|~
name|MASK_ZARCH
expr_stmt|;
block|}
comment|/* Determine processor architectural level.  */
if|if
condition|(
operator|!
name|s390_arch_string
condition|)
block|{
name|s390_arch_string
operator|=
name|TARGET_ZARCH
condition|?
literal|"z900"
else|:
literal|"g5"
expr_stmt|;
name|s390_handle_arch_option
argument_list|(
name|s390_arch_string
argument_list|,
operator|&
name|s390_arch
argument_list|,
operator|&
name|s390_arch_flags
argument_list|)
expr_stmt|;
block|}
comment|/* Determine processor to tune for.  */
if|if
condition|(
name|s390_tune
operator|==
name|PROCESSOR_max
condition|)
block|{
name|s390_tune
operator|=
name|s390_arch
expr_stmt|;
name|s390_tune_flags
operator|=
name|s390_arch_flags
expr_stmt|;
block|}
comment|/* Sanity checks.  */
if|if
condition|(
name|TARGET_ZARCH
operator|&&
operator|!
operator|(
name|s390_arch_flags
operator|&
name|PF_ZARCH
operator|)
condition|)
name|error
argument_list|(
literal|"z/Architecture mode not supported on %s"
argument_list|,
name|s390_arch_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|TARGET_ZARCH
condition|)
name|error
argument_list|(
literal|"64-bit ABI not supported in ESA/390 mode"
argument_list|)
expr_stmt|;
comment|/* Set processor cost function.  */
if|if
condition|(
name|s390_tune
operator|==
name|PROCESSOR_2094_Z9_109
condition|)
name|s390_cost
operator|=
operator|&
name|z9_109_cost
expr_stmt|;
elseif|else
if|if
condition|(
name|s390_tune
operator|==
name|PROCESSOR_2084_Z990
condition|)
name|s390_cost
operator|=
operator|&
name|z990_cost
expr_stmt|;
else|else
name|s390_cost
operator|=
operator|&
name|z900_cost
expr_stmt|;
if|if
condition|(
name|TARGET_BACKCHAIN
operator|&&
name|TARGET_PACKED_STACK
operator|&&
name|TARGET_HARD_FLOAT
condition|)
name|error
argument_list|(
literal|"-mbackchain -mpacked-stack -mhard-float are not supported "
literal|"in combination"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s390_stack_size
condition|)
block|{
if|if
condition|(
operator|!
name|s390_stack_guard
condition|)
name|error
argument_list|(
literal|"-mstack-size implies use of -mstack-guard"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s390_stack_guard
operator|>=
name|s390_stack_size
condition|)
name|error
argument_list|(
literal|"stack size must be greater than the stack guard value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s390_stack_size
operator|>
literal|1
operator|<<
literal|16
condition|)
name|error
argument_list|(
literal|"stack size must not be greater than 64k"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s390_stack_guard
condition|)
name|error
argument_list|(
literal|"-mstack-guard implies use of -mstack-size"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_DEFAULT_LONG_DOUBLE_128
if|if
condition|(
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_LONG_DOUBLE_128
operator|)
condition|)
name|target_flags
operator||=
name|MASK_LONG_DOUBLE_128
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Map for smallest class containing reg regno.  */
end_comment

begin_decl_stmt
specifier|const
name|enum
name|reg_class
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
name|GENERAL_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|ADDR_REGS
block|,
name|CC_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ACCESS_REGS
block|,
name|ACCESS_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return attribute type of insn.  */
end_comment

begin_function
specifier|static
name|enum
name|attr_type
name|s390_safe_attr_type
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_type
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|TYPE_NONE
return|;
block|}
end_function

begin_comment
comment|/* Return true if DISP is a valid short displacement.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_short_displacement
parameter_list|(
name|rtx
name|disp
parameter_list|)
block|{
comment|/* No displacement is OK.  */
if|if
condition|(
operator|!
name|disp
condition|)
return|return
name|true
return|;
comment|/* Integer displacement in range.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|disp
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|disp
argument_list|)
operator|<
literal|4096
return|;
comment|/* GOT offset is not OK, the GOT can be large.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
operator|||
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTNTPOFF
operator|)
condition|)
return|return
name|false
return|;
comment|/* All other symbolic constants are literal pool references,      which are OK as the literal pool must be small.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Decompose a RTL expression ADDR for a memory address into    its components, returned in OUT.     Returns false if ADDR is not a valid memory address, true    otherwise.  If OUT is NULL, don't return the components,    but check for validity only.     Note: Only addresses in canonical form are recognized.    LEGITIMIZE_ADDRESS should convert non-canonical forms to the    canonical form so that they will be recognized.  */
end_comment

begin_function
specifier|static
name|int
name|s390_decompose_address
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|struct
name|s390_address
modifier|*
name|out
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|indx
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|disp
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|orig_disp
decl_stmt|;
name|bool
name|pointer
init|=
name|false
decl_stmt|;
name|bool
name|base_ptr
init|=
name|false
decl_stmt|;
name|bool
name|indx_ptr
init|=
name|false
decl_stmt|;
name|bool
name|literal_pool
init|=
name|false
decl_stmt|;
comment|/* We may need to substitute the literal pool base register into the address      below.  However, at this point we do not know which register is going to      be used as base, so we substitute the arg pointer register.  This is going      to be treated as holding a pointer below -- it shouldn't be used for any      other purpose.  */
name|rtx
name|fake_pool_base
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
decl_stmt|;
comment|/* Decompose address into base + index + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|UNSPEC
condition|)
block|{
name|indx
operator|=
name|op0
expr_stmt|;
comment|/* index + base */
name|base
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|op0
expr_stmt|;
comment|/* base + displacement */
name|disp
operator|=
name|op1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index + base + disp */
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
return|return
name|false
return|;
block|}
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Extract integer part of displacement.  */
name|orig_disp
operator|=
name|disp
expr_stmt|;
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|disp
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Strip off CONST here to avoid special case tests later.  */
if|if
condition|(
name|disp
operator|&&
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
condition|)
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We can convert literal pool addresses to      displacements by basing them off the base register.  */
if|if
condition|(
name|disp
operator|&&
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|disp
argument_list|)
condition|)
block|{
comment|/* Either base or index must be free to hold the base register.  */
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|fake_pool_base
operator|,
name|literal_pool
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indx
condition|)
name|indx
operator|=
name|fake_pool_base
operator|,
name|literal_pool
operator|=
name|true
expr_stmt|;
else|else
return|return
name|false
return|;
comment|/* Mark up the displacement.  */
name|disp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|disp
argument_list|)
argument_list|,
name|UNSPEC_LTREL_OFFSET
argument_list|)
expr_stmt|;
block|}
comment|/* Validate base register.  */
if|if
condition|(
name|base
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_LTREF
case|:
if|if
condition|(
operator|!
name|disp
condition|)
name|disp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_LTREL_OFFSET
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
name|base
operator|=
name|XVECEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_LTREL_BASE
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
name|base
operator|=
name|fake_pool_base
operator|,
name|literal_pool
operator|=
name|true
expr_stmt|;
else|else
name|base
operator|=
name|XVECEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|base
argument_list|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|SImode
operator|&&
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|flag_pic
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
name|pointer
operator|=
name|base_ptr
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|base
operator|==
name|cfun
operator|->
name|machine
operator|->
name|base_reg
condition|)
name|pointer
operator|=
name|base_ptr
operator|=
name|literal_pool
operator|=
name|true
expr_stmt|;
block|}
comment|/* Validate index register.  */
if|if
condition|(
name|indx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|indx
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_LTREF
case|:
if|if
condition|(
operator|!
name|disp
condition|)
name|disp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_LTREL_OFFSET
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
name|indx
operator|=
name|XVECEXP
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_LTREL_BASE
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
name|indx
operator|=
name|fake_pool_base
operator|,
name|literal_pool
operator|=
name|true
expr_stmt|;
else|else
name|indx
operator|=
name|XVECEXP
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|indx
argument_list|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|SImode
operator|&&
name|GET_MODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|Pmode
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|flag_pic
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
name|pointer
operator|=
name|indx_ptr
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|indx
operator|==
name|cfun
operator|->
name|machine
operator|->
name|base_reg
condition|)
name|pointer
operator|=
name|indx_ptr
operator|=
name|literal_pool
operator|=
name|true
expr_stmt|;
block|}
comment|/* Prefer to use pointer as base, not index.  */
if|if
condition|(
name|base
operator|&&
name|indx
operator|&&
operator|!
name|base_ptr
operator|&&
operator|(
name|indx_ptr
operator|||
operator|(
operator|!
name|REG_POINTER
argument_list|(
name|base
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|indx
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|indx
expr_stmt|;
name|indx
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Validate displacement.  */
if|if
condition|(
operator|!
name|disp
condition|)
block|{
comment|/* If virtual registers are involved, the displacement will change later  	 anyway as the virtual registers get eliminated.  This could make a  	 valid displacement invalid, but it is more likely to make an invalid  	 displacement valid, because we sometimes access the register save area  	 via negative offsets to one of those registers. 	 Thus we don't check the displacement for validity here.  If after 	 elimination the displacement turns out to be invalid after all, 	 this is fixed up by reload in any case.  */
if|if
condition|(
name|base
operator|!=
name|arg_pointer_rtx
operator|&&
name|indx
operator|!=
name|arg_pointer_rtx
operator|&&
name|base
operator|!=
name|return_address_pointer_rtx
operator|&&
name|indx
operator|!=
name|return_address_pointer_rtx
operator|&&
name|base
operator|!=
name|frame_pointer_rtx
operator|&&
name|indx
operator|!=
name|frame_pointer_rtx
operator|&&
name|base
operator|!=
name|virtual_stack_vars_rtx
operator|&&
name|indx
operator|!=
name|virtual_stack_vars_rtx
condition|)
if|if
condition|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* All the special cases are pointers.  */
name|pointer
operator|=
name|true
expr_stmt|;
comment|/* In the small-PIC case, the linker converts @GOT          and @GOTNTPOFF offsets to possible displacements.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
operator|||
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTNTPOFF
operator|)
operator|&&
name|flag_pic
operator|==
literal|1
condition|)
block|{
empty_stmt|;
block|}
comment|/* Accept chunkified literal pool symbol references.  */
elseif|else
if|if
condition|(
name|cfun
operator|&&
name|cfun
operator|->
name|machine
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|decomposed_literal_pool_addresses_ok_p
operator|&&
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
empty_stmt|;
block|}
comment|/* Accept literal pool references.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_OFFSET
condition|)
block|{
name|orig_disp
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
comment|/* If we have an offset, make sure it does not 		 exceed the size of the constant pool entry.  */
name|rtx
name|sym
init|=
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|orig_disp
operator|=
name|plus_constant
argument_list|(
name|orig_disp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|indx
condition|)
name|pointer
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|out
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|out
operator|->
name|indx
operator|=
name|indx
expr_stmt|;
name|out
operator|->
name|disp
operator|=
name|orig_disp
expr_stmt|;
name|out
operator|->
name|pointer
operator|=
name|pointer
expr_stmt|;
name|out
operator|->
name|literal_pool
operator|=
name|literal_pool
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Decompose a RTL expression OP for a shift count into its components,    and return the base register in BASE and the offset in OFFSET.     Return true if OP is a valid shift count, false if not.  */
end_comment

begin_function
name|bool
name|s390_decompose_shift_count
parameter_list|(
name|rtx
name|op
parameter_list|,
name|rtx
modifier|*
name|base
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|)
block|{
name|HOST_WIDE_INT
name|off
init|=
literal|0
decl_stmt|;
comment|/* We can have an integer constant, an address register,      or a sum of the two.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|off
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
name|false
return|;
if|if
condition|(
name|offset
condition|)
operator|*
name|offset
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|base
condition|)
operator|*
name|base
operator|=
name|op
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if CODE is a valid address without index.  */
end_comment

begin_function
name|bool
name|s390_legitimate_address_without_index_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Evaluates constraint strings described by the regular expression    ([A|B](Q|R|S|T))|U|W and returns 1 if OP is a valid operand for the    constraint given in STR, or 0 else.  */
end_comment

begin_function
name|int
name|s390_mem_constraint
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|rtx
name|op
parameter_list|)
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
name|char
name|c
init|=
name|str
index|[
literal|0
index|]
decl_stmt|;
comment|/* Check for offsettable variants of memory constraints.  */
if|if
condition|(
name|c
operator|==
literal|'A'
condition|)
block|{
comment|/* Only accept non-volatile MEMs.  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|op
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
condition|?
operator|!
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
else|:
operator|!
name|offsettable_nonstrict_memref_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|str
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* Check for non-literal-pool variants of memory constraints.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
operator|.
name|literal_pool
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|str
index|[
literal|1
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_LONG_DISPLACEMENT
condition|)
block|{
if|if
condition|(
operator|!
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_LONG_DISPLACEMENT
condition|)
block|{
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
name|TARGET_LONG_DISPLACEMENT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|TARGET_LONG_DISPLACEMENT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* Any invalid address here will be fixed up by reload, 	 so accept it for the most generic constraint.  */
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|TARGET_LONG_DISPLACEMENT
condition|)
block|{
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|TARGET_LONG_DISPLACEMENT
condition|)
return|return
literal|0
return|;
comment|/* Any invalid address here will be fixed up by reload, 	 so accept it for the most generic constraint.  */
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'Y'
case|:
comment|/* Simply check for the basic form of a shift count.  Reload will 	 take care of making sure we have a proper base register.  */
if|if
condition|(
operator|!
name|s390_decompose_shift_count
argument_list|(
name|op
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Evaluates constraint strings starting with letter O.  Input    parameter C is the second letter following the "O" in the constraint    string. Returns 1 if VALUE meets the respective constraint and 0    otherwise.  */
end_comment

begin_function
name|int
name|s390_O_constraint_str
parameter_list|(
specifier|const
name|char
name|c
parameter_list|,
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_EXTIMM
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
return|return
name|trunc_int_for_mode
argument_list|(
name|value
argument_list|,
name|SImode
argument_list|)
operator|==
name|value
return|;
case|case
literal|'p'
case|:
return|return
name|value
operator|==
literal|0
operator|||
name|s390_single_part
argument_list|(
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|,
name|DImode
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
return|;
case|case
literal|'n'
case|:
return|return
name|value
operator|==
operator|-
literal|1
operator|||
name|s390_single_part
argument_list|(
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|,
name|DImode
argument_list|,
name|SImode
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Evaluates constraint strings starting with letter N.  Parameter STR    contains the letters following letter "N" in the constraint string.    Returns true if VALUE matches the constraint.  */
end_comment

begin_function
name|int
name|s390_N_constraint_str
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|part_mode
decl_stmt|;
name|int
name|def
decl_stmt|;
name|int
name|part
decl_stmt|,
name|part_goal
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'x'
condition|)
name|part_goal
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|part_goal
operator|=
name|str
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'Q'
case|:
name|part_mode
operator|=
name|QImode
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|part_mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|part_mode
operator|=
name|SImode
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|str
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'H'
case|:
name|mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|str
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'0'
case|:
name|def
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|def
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|part_mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|part
operator|=
name|s390_single_part
argument_list|(
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|,
name|mode
argument_list|,
name|part_mode
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|part_goal
operator|!=
operator|-
literal|1
operator|&&
name|part_goal
operator|!=
name|part
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the input parameter VALUE is a float zero.  */
end_comment

begin_function
name|int
name|s390_float_const_zero_p
parameter_list|(
name|rtx
name|value
parameter_list|)
block|{
return|return
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|value
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.      CODE contains GET_CODE (x), OUTER_CODE contains the code     of the superexpression of x.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|MEM
case|:
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
comment|/* Check for multiply and add.  */
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_IEEE_FLOAT
operator|&&
name|TARGET_FUSED_MADD
condition|)
block|{
comment|/* This is the multiply and add case.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|madbr
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|maebr
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MULT
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|MULT
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
comment|/* Do not do an additional recursive descent.  */
block|}
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|MULT
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
block|{
name|rtx
name|left
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|right
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|right
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|mhi
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|mh
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|ms
expr_stmt|;
comment|/* msr, ms, msy */
break|break;
block|}
case|case
name|DImode
case|:
block|{
name|rtx
name|left
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|right
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|right
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|mghi
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|msgf
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|msg
expr_stmt|;
comment|/* msgr, msg */
block|}
else|else
comment|/* TARGET_31BIT */
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|SIGN_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
comment|/* mulsidi case: mr, m */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|m
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|ZERO_EXTEND
operator|&&
name|TARGET_CPU_ZARCH
condition|)
comment|/* umulsidi case: ml, mlr */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|ml
expr_stmt|;
else|else
comment|/* Complex calculation is required.  */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SFmode
case|:
case|case
name|DFmode
case|:
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|mult_df
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|mxbr
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|TImode
condition|)
comment|/* 128 bit division */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dlgr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|rtx
name|right
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
comment|/* 64 by 32 bit division */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dlr
expr_stmt|;
else|else
comment|/* 64 by 64 bit division */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dlgr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|)
comment|/* 32 bit division */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dlr
expr_stmt|;
return|return
name|false
return|;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|rtx
name|right
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
comment|/* 64 by 32 bit division */
if|if
condition|(
name|TARGET_64BIT
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dsgfr
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dr
expr_stmt|;
else|else
comment|/* 64 by 64 bit division */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dsgr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|)
comment|/* 32 bit division */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dlr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
if|if
condition|(
name|TARGET_IEEE_FLOAT
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|debr
expr_stmt|;
else|else
comment|/* TARGET_IBM_FLOAT */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|der
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|TARGET_IEEE_FLOAT
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|ddbr
expr_stmt|;
else|else
comment|/* TARGET_IBM_FLOAT */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|ddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|TARGET_IEEE_FLOAT
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dxbr
expr_stmt|;
else|else
comment|/* TARGET_IBM_FLOAT */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|dxr
expr_stmt|;
block|}
return|return
name|false
return|;
case|case
name|SQRT
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|sqebr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|sqdbr
expr_stmt|;
else|else
comment|/* TFmode */
operator|*
name|total
operator|=
name|s390_cost
operator|->
name|sqxbr
expr_stmt|;
return|return
name|false
return|;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|outer_code
operator|==
name|MULT
operator|||
name|outer_code
operator|==
name|DIV
operator|||
name|outer_code
operator|==
name|MOD
operator|||
name|outer_code
operator|==
name|PLUS
operator|||
name|outer_code
operator|==
name|MINUS
operator|||
name|outer_code
operator|==
name|COMPARE
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
case|case
name|COMPARE
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|s390_tm_ccmode
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|true
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|s390_tm_ccmode
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
literal|1
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the cost of an address rtx ADDR.  */
end_comment

begin_function
specifier|static
name|int
name|s390_address_cost
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
condition|)
return|return
literal|1000
return|;
return|return
name|ad
operator|.
name|indx
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If OP is a SYMBOL_REF of a thread-local symbol, return its TLS mode,    otherwise return 0.  */
end_comment

begin_function
name|int
name|tls_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split DImode access register reference REG (on 64-bit) into its constituent    low and high parts, and store them into LO and HI.  Note that gen_lowpart/    gen_highpart cannot be used as they assume all registers are word-sized,    while our access registers have only half that size.  */
end_comment

begin_function
name|void
name|s390_split_access_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
modifier|*
name|lo
parameter_list|,
name|rtx
modifier|*
name|hi
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TARGET_64BIT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ACCESS_REG_P
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|DImode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|*
name|lo
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|hi
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if OP contains a symbol reference */
end_comment

begin_function
name|bool
name|symbolic_reference_mentioned_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP contains a reference to a thread-local symbol.  */
end_comment

begin_function
name|bool
name|tls_symbolic_reference_mentioned_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|tls_symbolic_operand
argument_list|(
name|op
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|tls_symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|tls_symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a legitimate general operand when    generating PIC code.  It is given that flag_pic is on    and that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|legitimate_pic_operand_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
comment|/* Accept all non-symbolic constants.  */
if|if
condition|(
operator|!
name|SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Reject everything else; must be handled      via emit_symbolic_move.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the constant value OP is a legitimate general operand.    It is given that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|legitimate_constant_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
comment|/* Accept all non-symbolic constants.  */
if|if
condition|(
operator|!
name|SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Accept immediate LARL operands.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
operator|&&
name|larl_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Thread-local symbols are never legal constants.  This is      so that emit_call knows that computing such addresses      might require a function call.  */
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* In the PIC case, symbolic constants must *not* be      forced into the literal pool.  We accept them here,      so that they will be handled by emit_symbolic_move.  */
if|if
condition|(
name|flag_pic
condition|)
return|return
literal|1
return|;
comment|/* All remaining non-PIC symbolic constants are      forced into the literal pool.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine if it's legal to put X into the constant pool.  This    is not possible if X contains the address of a symbol that is    not constant (TLS) or not known at final link time (PIC).  */
end_comment

begin_function
specifier|static
name|bool
name|s390_cannot_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
comment|/* Accept all non-symbolic constants.  */
return|return
name|false
return|;
case|case
name|LABEL_REF
case|:
comment|/* Labels are OK iff we are non-PIC.  */
return|return
name|flag_pic
operator|!=
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* 'Naked' TLS symbol references are never OK,          non-TLS symbols are OK iff we are non-PIC.  */
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|flag_pic
operator|!=
literal|0
return|;
case|case
name|CONST
case|:
return|return
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Only lt-relative or GOT-relative UNSPECs are OK.  */
case|case
name|UNSPEC_LTREL_OFFSET
case|:
case|case
name|UNSPEC_GOT
case|:
case|case
name|UNSPEC_GOTOFF
case|:
case|case
name|UNSPEC_PLTOFF
case|:
case|case
name|UNSPEC_TLSGD
case|:
case|case
name|UNSPEC_TLSLDM
case|:
case|case
name|UNSPEC_NTPOFF
case|:
case|case
name|UNSPEC_DTPOFF
case|:
case|case
name|UNSPEC_GOTNTPOFF
case|:
case|case
name|UNSPEC_INDNTPOFF
case|:
return|return
name|false
return|;
comment|/* If the literal pool shares the code section, be put 	   execute template placeholders into the pool as well.  */
case|case
name|UNSPEC_INSN
case|:
return|return
name|TARGET_CPU_ZARCH
return|;
default|default:
return|return
name|true
return|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if the constant value OP is a legitimate general    operand during and after reload.  The difference to    legitimate_constant_p is that this function will not accept    a constant that would need to be forced to the literal pool    before it can be used as operand.  */
end_comment

begin_function
name|bool
name|legitimate_reload_constant_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
comment|/* Accept la(y) operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Accept l(g)hi/l(g)fi operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
name|CONST_OK_FOR_Os
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* Accept lliXX operands.  */
if|if
condition|(
name|TARGET_ZARCH
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|word_mode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&&
name|s390_single_part
argument_list|(
name|op
argument_list|,
name|word_mode
argument_list|,
name|HImode
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TARGET_EXTIMM
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|word_mode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&&
name|s390_single_part
argument_list|(
name|op
argument_list|,
name|word_mode
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|true
return|;
comment|/* Accept larl operands.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
operator|&&
name|larl_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Accept lzXX operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_CONSTRAINT_P
argument_list|(
name|op
argument_list|,
literal|'G'
argument_list|,
literal|"G"
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Accept double-word operands that can be split.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|word_mode
argument_list|)
operator|!=
name|INTVAL
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|dword_mode
init|=
name|word_mode
operator|==
name|SImode
condition|?
name|DImode
else|:
name|TImode
decl_stmt|;
name|rtx
name|hi
init|=
name|operand_subword
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dword_mode
argument_list|)
decl_stmt|;
name|rtx
name|lo
init|=
name|operand_subword
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|dword_mode
argument_list|)
decl_stmt|;
return|return
name|legitimate_reload_constant_p
argument_list|(
name|hi
argument_list|)
operator|&&
name|legitimate_reload_constant_p
argument_list|(
name|lo
argument_list|)
return|;
block|}
comment|/* Everything else cannot be handled without reload.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx OP being reloaded into a reg required to be in class CLASS,    return the class of reg to actually use.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_preferred_reload_class
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Constants we cannot reload must be forced into the 	 literal pool.  */
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
if|if
condition|(
name|legitimate_reload_constant_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|class
return|;
else|else
return|return
name|NO_REGS
return|;
comment|/* If a symbolic constant or a PLUS is reloaded, 	 it is most likely being used as an address, so 	 prefer ADDR_REGS.  If 'class' is not a superset 	 of ADDR_REGS, e.g. FP_REGS, reject this reload.  */
case|case
name|PLUS
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|ADDR_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
else|else
return|return
name|NO_REGS
return|;
default|default:
break|break;
block|}
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* Return the register class of a scratch register needed to    load IN into a register of class CLASS in MODE.     We need a temporary when loading a PLUS expression which    is not a legitimate operand of the LOAD ADDRESS instruction.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_secondary_input_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
if|if
condition|(
name|s390_plus_operand
argument_list|(
name|in
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|FP_REGS
argument_list|,
name|class
argument_list|)
operator|&&
name|mode
operator|==
name|TFmode
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|CC_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return the register class of a scratch register needed to    store a register of class CLASS in MODE into OUT:     We need a temporary when storing a double-word to a    non-offsettable memory address.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_secondary_output_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|out
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TARGET_64BIT
condition|?
operator|(
name|mode
operator|==
name|TImode
operator|||
name|mode
operator|==
name|TFmode
operator|)
else|:
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|)
operator|&&
name|reg_classes_intersect_p
argument_list|(
name|GENERAL_REGS
argument_list|,
name|class
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|FP_REGS
argument_list|,
name|class
argument_list|)
operator|&&
name|mode
operator|==
name|TFmode
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|CC_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Generate code to load SRC, which is PLUS that is not a    legitimate operand for the LA instruction, into TARGET.    SCRATCH may be used as scratch register.  */
end_comment

begin_function
name|void
name|s390_expand_plus_operand
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rtx
name|sum1
decl_stmt|,
name|sum2
decl_stmt|;
name|struct
name|s390_address
name|ad
decl_stmt|;
comment|/* src must be a PLUS; get its two operands.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Check if any of the two operands is already scheduled      for replacement by reload.  This can happen e.g. when      float registers occur in an address.  */
name|sum1
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum1
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
comment|/* If the address is already strictly valid, there's nothing to do.  */
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|src
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Otherwise, one of the operands cannot be an address register;          we reload its value into the scratch register.  */
if|if
condition|(
name|true_regnum
argument_list|(
name|sum1
argument_list|)
operator|<
literal|1
operator|||
name|true_regnum
argument_list|(
name|sum1
argument_list|)
operator|>
literal|15
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|sum1
argument_list|)
expr_stmt|;
name|sum1
operator|=
name|scratch
expr_stmt|;
block|}
if|if
condition|(
name|true_regnum
argument_list|(
name|sum2
argument_list|)
operator|<
literal|1
operator|||
name|true_regnum
argument_list|(
name|sum2
argument_list|)
operator|>
literal|15
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|scratch
expr_stmt|;
block|}
comment|/* According to the way these invalid addresses are generated          in reload.c, it should never happen (at least on s390) that          *neither* of the PLUS components, after find_replacements          was applied, is an address register.  */
if|if
condition|(
name|sum1
operator|==
name|scratch
operator|&&
name|sum2
operator|==
name|scratch
condition|)
block|{
name|debug_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|src
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum1
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the LOAD ADDRESS pattern.  Note that reload of PLUS      is only ever performed on addresses, so we can mark the      sum as legitimate for LA in any case.  */
name|s390_load_address
argument_list|(
name|target
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if ADDR is a valid memory address.    STRICT specifies whether strict register checking applies.  */
end_comment

begin_function
name|bool
name|legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strict
condition|)
block|{
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
operator|!
operator|(
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
argument_list|)
operator|==
name|ADDR_REGS
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ad
operator|.
name|indx
operator|&&
operator|!
operator|(
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
argument_list|)
operator|==
name|ADDR_REGS
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid operand for the LA instruction.    In 31-bit, we need to prove that the result is used as an    address, as LA performs only a 31-bit addition.  */
end_comment

begin_function
name|bool
name|legitimate_la_operand_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|(
name|TARGET_64BIT
operator|||
name|addr
operator|.
name|pointer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if it is valid *and* preferable to use LA to    compute the sum of OP1 and OP2.  */
end_comment

begin_function
name|bool
name|preferred_la_operand_p
parameter_list|(
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
name|op2
operator|!=
name|const0_rtx
condition|)
name|op1
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op1
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|addr
operator|.
name|base
operator|&&
operator|!
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|addr
operator|.
name|base
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|addr
operator|.
name|indx
operator|&&
operator|!
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|REGNO
argument_list|(
name|addr
operator|.
name|indx
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
operator|!
name|addr
operator|.
name|pointer
condition|)
return|return
name|false
return|;
if|if
condition|(
name|addr
operator|.
name|pointer
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|addr
operator|.
name|base
operator|&&
name|REG_P
argument_list|(
name|addr
operator|.
name|base
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|addr
operator|.
name|base
argument_list|)
operator|)
operator|||
operator|(
name|addr
operator|.
name|indx
operator|&&
name|REG_P
argument_list|(
name|addr
operator|.
name|indx
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|addr
operator|.
name|indx
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Emit a forced load-address operation to load SRC into DST.    This will use the LOAD ADDRESS instruction even in situations    where legitimate_la_operand_p (SRC) returns false.  */
end_comment

begin_function
name|void
name|s390_load_address
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_force_la_31
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are two types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references, constant pool addresses, and code labels       compute the address as an offset from the GOT, whose base is in       the PIC reg.  Static data objects have SYMBOL_FLAG_LOCAL set to       differentiate them from global data objects.  The returned       address is the PIC reg + an unspec constant.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TLS_SYMBOLIC_CONST
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
block|{
comment|/* This is a local symbol.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
operator|&&
name|larl_operand
argument_list|(
name|addr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
comment|/* Access local symbols PC-relative via LARL.              This is the same as in the non-PIC case, so it is              handled automatically ...  */
block|}
else|else
block|{
comment|/* Access local symbols relative to the GOT.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
comment|/* Assume GOT offset< 4k.  This is handled the same way              in both 31- and 64-bit code (@GOT).  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOT
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we determine the position              of the GOT entry via a PC-relative LARL (@GOTENT).  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTENT
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* If the GOT offset might be>= 4k, we have to load it              from the literal pool (@GOT).  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOT
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
name|gcc_assert
argument_list|(
name|XVECLEN
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If someone moved a GOT-relative UNSPEC                      out of the literal pool, force them back in.  */
case|case
name|UNSPEC_GOTOFF
case|:
case|case
name|UNSPEC_PLTOFF
case|:
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
break|break;
comment|/* @GOT is OK as is if small.  */
case|case
name|UNSPEC_GOT
case|:
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
break|break;
comment|/* @GOTENT is OK as is.  */
case|case
name|UNSPEC_GOTENT
case|:
break|break;
comment|/* @PLT is OK as is on 64-bit, must be converted to                      GOT-relative @PLTOFF on 31-bit.  */
case|case
name|UNSPEC_PLT
case|:
if|if
condition|(
operator|!
name|TARGET_CPU_ZARCH
condition|)
block|{
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_PLTOFF
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
break|break;
comment|/* Everything else cannot happen.  */
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TLS_SYMBOLIC_CONST
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TLS_SYMBOLIC_CONST
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check first to see if this is a constant offset              from a local symbol reference.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op0
argument_list|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|TARGET_CPU_ZARCH
operator|&&
name|larl_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|31
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
operator|-
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
condition|)
block|{
comment|/* LARL can't handle odd offsets, so emit a                          pair of LARL and LA.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|even
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
decl_stmt|;
name|op0
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|even
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|const1_rtx
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the offset is even, we can just use LARL.                          This will happen automatically.  */
block|}
block|}
else|else
block|{
comment|/* Access local symbols relative to the GOT.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op0
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
comment|/* Now, check whether it is a GOT relative symbol plus offset              that was pulled out of the literal pool.  Force it back in.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XINT
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTOFF
condition|)
block|{
name|gcc_assert
argument_list|(
name|XVECLEN
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, compute the sum.  */
else|else
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST
condition|)
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_operand
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Load the thread pointer into a register.  */
end_comment

begin_function
name|rtx
name|s390_get_thread_pointer
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|tp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tp
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|TP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|mark_reg_pointer
argument_list|(
name|tp
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/* Emit a tls call insn. The call target is the SYMBOL_REF stored    in s390_tls_symbol which always refers to __tls_get_offset.    The returned offset is written to RESULT_REG and an USE rtx is    generated for TLS_CALL.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|s390_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|s390_emit_tls_call_insn
parameter_list|(
name|rtx
name|result_reg
parameter_list|,
name|rtx
name|tls_call
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|gcc_assert
argument_list|(
name|flag_pic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s390_tls_symbol
condition|)
name|s390_tls_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__tls_get_offset"
argument_list|)
expr_stmt|;
name|insn
operator|=
name|s390_emit_call
argument_list|(
name|s390_tls_symbol
argument_list|,
name|tls_call
argument_list|,
name|result_reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|result_reg
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute    this (thread-local) address.  REG may be used as temporary.  */
end_comment

begin_function
specifier|static
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|,
name|tls_call
decl_stmt|,
name|temp
decl_stmt|,
name|base
decl_stmt|,
name|r2
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
switch|switch
condition|(
name|tls_symbolic_operand
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|r2
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tls_call
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLSGD
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|tls_call
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|s390_emit_tls_call_insn
argument_list|(
name|r2
argument_list|,
name|tls_call
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_NTPOFF
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|,
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|s390_get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|r2
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tls_call
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLDM
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|tls_call
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|s390_emit_tls_call_insn
argument_list|(
name|r2
argument_list|,
name|tls_call
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLDM_NTPOFF
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|,
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|s390_get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_DTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
comment|/* Assume GOT offset< 4k.  This is handled the same way 	       in both 31- and 64-bit code.  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we determine the position 	       of the GOT entry via a PC-relative LARL.  */
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_INDNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we have to load it 	       from the literal pool.  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|new
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLS_LOAD
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In position-dependent code, load the absolute address of 	       the GOT entry from the literal pool.  */
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_INDNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|temp
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|new
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLS_LOAD
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|s390_get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_NTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|s390_get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
switch|switch
condition|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_INDNTPOFF
case|:
name|gcc_assert
argument_list|(
name|TARGET_CPU_ZARCH
argument_list|)
expr_stmt|;
name|new
operator|=
name|addr
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|new
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_tls_address
argument_list|(
name|new
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|plus_constant
argument_list|(
name|new
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_operand
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* for now ... */
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].  */
end_comment

begin_function
name|void
name|emit_symbolic_move
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|temp
init|=
name|no_new_pseudos
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_tls_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address X    to be legitimate.  If we find one, return the new, valid address.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE is the mode of the operand pointed to by X.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|legitimize_tls_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TLS_SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
if|if
condition|(
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
block|}
name|x
operator|=
name|eliminate_constant_term
argument_list|(
name|x
argument_list|,
operator|&
name|constant_term
argument_list|)
expr_stmt|;
comment|/* Optimize loading of large displacements by splitting them      into the multiple of 4K and the rest; this allows the      former to be CSE'd if possible.       Don't do this if the displacement is added to a register      pointing into the stack frame, as the offsets will      change later anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|constant_term
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|TARGET_LONG_DISPLACEMENT
operator|&&
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO_PTR_FRAME_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|lower
init|=
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
operator|&
literal|0xfff
decl_stmt|;
name|HOST_WIDE_INT
name|upper
init|=
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
operator|^
name|lower
decl_stmt|;
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|GEN_INT
argument_list|(
name|upper
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|constant_term
operator|=
name|GEN_INT
argument_list|(
name|lower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constant_term
operator|!=
name|const0_rtx
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|constant_term
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Try a machine-dependent way of reloading an illegitimate address AD    operand.  If we find one, push the reload and and return the new address.     MODE is the mode of the enclosing MEM.  OPNUM is the operand number    and TYPE is the reload type of the current reload.  */
end_comment

begin_function
name|rtx
name|legitimize_reload_address
parameter_list|(
name|rtx
name|ad
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|opnum
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|optimize
operator|||
name|TARGET_LONG_DISPLACEMENT
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|tem
init|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
name|ad
operator|=
name|tem
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|lower
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xfff
decl_stmt|;
name|HOST_WIDE_INT
name|upper
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|^
name|lower
decl_stmt|;
name|rtx
name|cst
decl_stmt|,
name|tem
decl_stmt|,
name|new
decl_stmt|;
name|cst
operator|=
name|GEN_INT
argument_list|(
name|upper
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|legitimate_reload_constant_p
argument_list|(
name|cst
argument_list|)
condition|)
name|cst
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|cst
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cst
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tem
argument_list|,
name|GEN_INT
argument_list|(
name|lower
argument_list|)
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
operator|(
expr|enum
name|reload_type
operator|)
name|type
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Emit code to move LEN bytes from DST to SRC.  */
end_comment

begin_function
name|void
name|s390_expand_movmem
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|len
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_movmem_short
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MVCLE
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movmem_long
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dst_addr
decl_stmt|,
name|src_addr
decl_stmt|,
name|count
decl_stmt|,
name|blocks
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|loop_start_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|loop_end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|Pmode
expr_stmt|;
name|dst_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|count
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|count
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|count
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dst_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|src_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|VOIDmode
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|src
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|count
argument_list|,
name|constm1_rtx
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|count
condition|)
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|lshr_optab
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|blocks
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|loop_end_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_start_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movmem_short
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
literal|255
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|dst_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dst_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|src_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|src_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|blocks
argument_list|,
name|constm1_rtx
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|blocks
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|loop_end_label
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|loop_start_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_end_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movmem_short
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to set LEN bytes at DST to VAL.    Make use of clrmem if VAL is zero.  */
end_comment

begin_function
name|void
name|s390_expand_setmem
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|len
parameter_list|,
name|rtx
name|val
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|QImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|257
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|const0_rtx
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
name|emit_insn
argument_list|(
name|gen_clrmem_short
argument_list|(
name|dst
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Initialize memory by storing the first byte.  */
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* Initiate 1 byte overlap move. 	         The first byte of DST is propagated through DSTP1. 		 Prepare a movmem for:  DST+1 = DST (length = LEN - 1). 		 DST is set to size 1 so the rest of the memory location 		 does not count as source operand.  */
name|rtx
name|dstp1
init|=
name|adjust_address
argument_list|(
name|dst
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|set_mem_size
argument_list|(
name|dst
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movmem_short
argument_list|(
name|dstp1
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_MVCLE
condition|)
block|{
name|val
operator|=
name|force_not_mem
argument_list|(
name|convert_modes
argument_list|(
name|Pmode
argument_list|,
name|QImode
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_setmem_long
argument_list|(
name|dst
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dst_addr
decl_stmt|,
name|src_addr
decl_stmt|,
name|count
decl_stmt|,
name|blocks
decl_stmt|,
name|temp
decl_stmt|,
name|dstp1
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|loop_start_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|loop_end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|Pmode
expr_stmt|;
name|dst_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|count
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|count
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|count
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dst_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|VOIDmode
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|const0_rtx
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|count
argument_list|,
name|constm1_rtx
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|dstp1
operator|=
name|adjust_address
argument_list|(
name|dst
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|dst
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
comment|/* Initialize memory by storing the first byte.  */
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* If count is 1 we are done.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|count
argument_list|,
name|const1_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|2
argument_list|)
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|!=
name|count
condition|)
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|lshr_optab
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|blocks
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|loop_end_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_start_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|const0_rtx
condition|)
name|emit_insn
argument_list|(
name|gen_clrmem_short
argument_list|(
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|255
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_movmem_short
argument_list|(
name|dstp1
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|255
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|dst_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dst_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|blocks
argument_list|,
name|constm1_rtx
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|blocks
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|loop_end_label
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|loop_start_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_end_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|const0_rtx
condition|)
name|emit_insn
argument_list|(
name|gen_clrmem_short
argument_list|(
name|dst
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_movmem_short
argument_list|(
name|dstp1
argument_list|,
name|dst
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to compare LEN bytes at OP0 with those at OP1,    and return the result in TARGET.  */
end_comment

begin_function
name|void
name|s390_expand_cmpmem
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|len
parameter_list|)
block|{
name|rtx
name|ccreg
init|=
name|gen_rtx_REG
argument_list|(
name|CCUmode
argument_list|,
name|CC_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* As the result of CMPINT is inverted compared to what we need,      we have to swap the operands.  */
name|tmp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_cmpmem_short
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpint
argument_list|(
name|target
argument_list|,
name|ccreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MVCLE
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_cmpmem_long
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpint
argument_list|(
name|target
argument_list|,
name|ccreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|addr0
decl_stmt|,
name|addr1
decl_stmt|,
name|count
decl_stmt|,
name|blocks
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|loop_start_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|loop_end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|Pmode
expr_stmt|;
name|addr0
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|addr1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|count
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|count
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|count
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr0
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr1
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|,
name|addr0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|change_address
argument_list|(
name|op1
argument_list|,
name|VOIDmode
argument_list|,
name|addr1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|count
argument_list|,
name|constm1_rtx
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|count
condition|)
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|lshr_optab
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|blocks
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|loop_end_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_start_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpmem_short
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|GEN_INT
argument_list|(
literal|255
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|ccreg
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|end_label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|addr0
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr0
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|addr1
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr1
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|blocks
argument_list|,
name|constm1_rtx
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|blocks
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|loop_end_label
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|loop_start_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_end_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpmem_short
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpint
argument_list|(
name|target
argument_list|,
name|ccreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand conditional increment or decrement using alc/slb instructions.    Should generate code setting DST to either SRC or SRC + INCREMENT,    depending on the result of the comparison CMP_OP0 CMP_CODE CMP_OP1.    Returns true if successful, false otherwise.     That makes it possible to implement some if-constructs without jumps e.g.:    (borrow = CC0 | CC1 and carry = CC2 | CC3)    unsigned int a, b, c;    if (a< b)  c++; -> CCU  b> a  -> CC2;    c += carry;    if (a< b)  c--; -> CCL3 a - b  -> borrow; c -= borrow;    if (a<= b) c++; -> CCL3 b - a  -> borrow; c += carry;    if (a<= b) c--; -> CCU  a<= b -> borrow; c -= borrow;     Checks for EQ and NE with a nonzero value need an additional xor e.g.:    if (a == b) c++; -> CCL3 a ^= b; 0 - a  -> borrow;    c += carry;    if (a == b) c--; -> CCU  a ^= b; a<= 0 -> CC0 | CC1; c -= borrow;    if (a != b) c++; -> CCU  a ^= b; a> 0  -> CC2;       c += carry;    if (a != b) c--; -> CCL3 a ^= b; 0 - a  -> borrow;    c -= borrow; */
end_comment

begin_function
name|bool
name|s390_expand_addcc
parameter_list|(
name|enum
name|rtx_code
name|cmp_code
parameter_list|,
name|rtx
name|cmp_op0
parameter_list|,
name|rtx
name|cmp_op1
parameter_list|,
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|increment
parameter_list|)
block|{
name|enum
name|machine_mode
name|cmp_mode
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
name|rtx
name|op_res
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|cmp_op0
argument_list|)
operator|==
name|SImode
operator|||
name|GET_MODE
argument_list|(
name|cmp_op0
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|cmp_op1
argument_list|)
operator|==
name|SImode
operator|||
name|GET_MODE
argument_list|(
name|cmp_op1
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|cmp_mode
operator|=
name|SImode
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|cmp_op0
argument_list|)
operator|==
name|DImode
operator|||
name|GET_MODE
argument_list|(
name|cmp_op0
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|cmp_op1
argument_list|)
operator|==
name|DImode
operator|||
name|GET_MODE
argument_list|(
name|cmp_op1
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|cmp_mode
operator|=
name|DImode
expr_stmt|;
else|else
return|return
name|false
return|;
comment|/* Try ADD LOGICAL WITH CARRY.  */
if|if
condition|(
name|increment
operator|==
name|const1_rtx
condition|)
block|{
comment|/* Determine CC mode to use.  */
if|if
condition|(
name|cmp_code
operator|==
name|EQ
operator|||
name|cmp_code
operator|==
name|NE
condition|)
block|{
if|if
condition|(
name|cmp_op1
operator|!=
name|const0_rtx
condition|)
block|{
name|cmp_op0
operator|=
name|expand_simple_binop
argument_list|(
name|cmp_mode
argument_list|,
name|XOR
argument_list|,
name|cmp_op0
argument_list|,
name|cmp_op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|cmp_op1
operator|=
name|const0_rtx
expr_stmt|;
block|}
name|cmp_code
operator|=
name|cmp_code
operator|==
name|EQ
condition|?
name|LEU
else|:
name|GTU
expr_stmt|;
block|}
if|if
condition|(
name|cmp_code
operator|==
name|LTU
operator|||
name|cmp_code
operator|==
name|LEU
condition|)
block|{
name|rtx
name|tem
init|=
name|cmp_op0
decl_stmt|;
name|cmp_op0
operator|=
name|cmp_op1
expr_stmt|;
name|cmp_op1
operator|=
name|tem
expr_stmt|;
name|cmp_code
operator|=
name|swap_condition
argument_list|(
name|cmp_code
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cmp_code
condition|)
block|{
case|case
name|GTU
case|:
name|cc_mode
operator|=
name|CCUmode
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|cc_mode
operator|=
name|CCL3mode
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
comment|/* Emit comparison instruction pattern. */
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|cmp_op0
argument_list|,
name|cmp_mode
argument_list|)
condition|)
name|cmp_op0
operator|=
name|force_reg
argument_list|(
name|cmp_mode
argument_list|,
name|cmp_op0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|cc_mode
argument_list|,
name|CC_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|cc_mode
argument_list|,
name|cmp_op0
argument_list|,
name|cmp_op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use insn_invalid_p here to add clobbers if required.  */
name|ret
operator|=
name|insn_invalid_p
argument_list|(
name|emit_insn
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ret
argument_list|)
expr_stmt|;
comment|/* Emit ALC instruction pattern.  */
name|op_res
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|cc_mode
argument_list|,
name|CC_REGNUM
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|const0_rtx
condition|)
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
name|src
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|src
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|op_res
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|src
argument_list|,
name|op_res
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|op_res
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Try SUBTRACT LOGICAL WITH BORROW.  */
if|if
condition|(
name|increment
operator|==
name|constm1_rtx
condition|)
block|{
comment|/* Determine CC mode to use.  */
if|if
condition|(
name|cmp_code
operator|==
name|EQ
operator|||
name|cmp_code
operator|==
name|NE
condition|)
block|{
if|if
condition|(
name|cmp_op1
operator|!=
name|const0_rtx
condition|)
block|{
name|cmp_op0
operator|=
name|expand_simple_binop
argument_list|(
name|cmp_mode
argument_list|,
name|XOR
argument_list|,
name|cmp_op0
argument_list|,
name|cmp_op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|cmp_op1
operator|=
name|const0_rtx
expr_stmt|;
block|}
name|cmp_code
operator|=
name|cmp_code
operator|==
name|EQ
condition|?
name|LEU
else|:
name|GTU
expr_stmt|;
block|}
if|if
condition|(
name|cmp_code
operator|==
name|GTU
operator|||
name|cmp_code
operator|==
name|GEU
condition|)
block|{
name|rtx
name|tem
init|=
name|cmp_op0
decl_stmt|;
name|cmp_op0
operator|=
name|cmp_op1
expr_stmt|;
name|cmp_op1
operator|=
name|tem
expr_stmt|;
name|cmp_code
operator|=
name|swap_condition
argument_list|(
name|cmp_code
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cmp_code
condition|)
block|{
case|case
name|LEU
case|:
name|cc_mode
operator|=
name|CCUmode
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|cc_mode
operator|=
name|CCL3mode
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
comment|/* Emit comparison instruction pattern. */
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|cmp_op0
argument_list|,
name|cmp_mode
argument_list|)
condition|)
name|cmp_op0
operator|=
name|force_reg
argument_list|(
name|cmp_mode
argument_list|,
name|cmp_op0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|cc_mode
argument_list|,
name|CC_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|cc_mode
argument_list|,
name|cmp_op0
argument_list|,
name|cmp_op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use insn_invalid_p here to add clobbers if required.  */
name|ret
operator|=
name|insn_invalid_p
argument_list|(
name|emit_insn
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ret
argument_list|)
expr_stmt|;
comment|/* Emit SLB instruction pattern.  */
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
name|src
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|op_res
operator|=
name|gen_rtx_MINUS
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|src
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|cc_mode
argument_list|,
name|CC_REGNUM
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|op_res
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Expand code for the insv template. Return true if successful, false else.  */
end_comment

begin_function
name|bool
name|s390_expand_insv
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
name|int
name|bitsize
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|int
name|bitpos
init|=
name|INTVAL
argument_list|(
name|op2
argument_list|)
decl_stmt|;
comment|/* We need byte alignment.  */
if|if
condition|(
name|bitsize
operator|%
name|BITS_PER_UNIT
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bitpos
operator|==
literal|0
operator|&&
name|memory_operand
argument_list|(
name|dest
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|(
name|register_operand
argument_list|(
name|src
argument_list|,
name|word_mode
argument_list|)
operator|||
name|const_int_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
comment|/* Emit standard pattern if possible.  */
name|enum
name|machine_mode
name|mode
init|=
name|smallest_mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|MODE_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|bitsize
condition|)
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (set (ze (mem)) (const_int)).  */
elseif|else
if|if
condition|(
name|const_int_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|bitsize
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|src_mem
init|=
name|adjust_address
argument_list|(
name|force_const_mem
argument_list|(
name|word_mode
argument_list|,
name|src
argument_list|)
argument_list|,
name|BLKmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
operator|-
name|size
argument_list|)
decl_stmt|;
name|dest
operator|=
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|s390_expand_movmem
argument_list|(
name|dest
argument_list|,
name|src_mem
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* (set (ze (mem)) (reg)).  */
elseif|else
if|if
condition|(
name|register_operand
argument_list|(
name|src
argument_list|,
name|word_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitsize
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_ZERO_EXTRACT
argument_list|(
name|word_mode
argument_list|,
name|dest
argument_list|,
name|op1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Emit st,stcmh sequence.  */
name|int
name|stcmh_width
init|=
name|bitsize
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|stcmh_width
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|SImode
argument_list|,
name|size
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_ZERO_EXTRACT
argument_list|(
name|word_mode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|stcmh_width
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|word_mode
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|false
return|;
return|return
name|true
return|;
block|}
comment|/* (set (ze (reg)) (const_int)).  */
if|if
condition|(
name|TARGET_ZARCH
operator|&&
name|register_operand
argument_list|(
name|dest
argument_list|,
name|word_mode
argument_list|)
operator|&&
operator|(
name|bitpos
operator|%
literal|16
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bitsize
operator|%
literal|16
operator|)
operator|==
literal|0
operator|&&
name|const_int_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|regpos
init|=
name|bitpos
operator|+
name|bitsize
decl_stmt|;
while|while
condition|(
name|regpos
operator|>
name|bitpos
condition|)
block|{
name|enum
name|machine_mode
name|putmode
decl_stmt|;
name|int
name|putsize
decl_stmt|;
if|if
condition|(
name|TARGET_EXTIMM
operator|&&
operator|(
name|regpos
operator|%
literal|32
operator|==
literal|0
operator|)
operator|&&
operator|(
name|regpos
operator|>=
name|bitpos
operator|+
literal|32
operator|)
condition|)
name|putmode
operator|=
name|SImode
expr_stmt|;
else|else
name|putmode
operator|=
name|HImode
expr_stmt|;
name|putsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|putmode
argument_list|)
expr_stmt|;
name|regpos
operator|-=
name|putsize
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_ZERO_EXTRACT
argument_list|(
name|word_mode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|putsize
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|regpos
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
name|val
argument_list|,
name|putmode
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|>>=
name|putsize
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|regpos
operator|==
name|bitpos
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of s390_expand_cs_hqi and s390_expand_atomic which returns a    register that holds VAL of mode MODE shifted by COUNT bits.  */
end_comment

begin_function
specifier|static
specifier|inline
name|rtx
name|s390_expand_mask_and_shift
parameter_list|(
name|rtx
name|val
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|count
parameter_list|)
block|{
name|val
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|AND
argument_list|,
name|val
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
return|return
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|ASHIFT
argument_list|,
name|val
argument_list|,
name|count
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Structure to hold the initial parameters for a compare_and_swap operation    in HImode and QImode.  */
end_comment

begin_struct
struct|struct
name|alignment_context
block|{
name|rtx
name|memsi
decl_stmt|;
comment|/* SI aligned memory location.  */
name|rtx
name|shift
decl_stmt|;
comment|/* Bit offset with regard to lsb.  */
name|rtx
name|modemask
decl_stmt|;
comment|/* Mask of the HQImode shifted by SHIFT bits.  */
name|rtx
name|modemaski
decl_stmt|;
comment|/* ~modemask */
name|bool
name|aligned
decl_stmt|;
comment|/* True if memory is aligned, false else.  */
block|}
struct|;
end_struct

begin_comment
comment|/* A subroutine of s390_expand_cs_hqi and s390_expand_atomic to initialize    structure AC for transparent simplifying, if the memory alignment is known    to be at least 32bit.  MEM is the memory location for the actual operation    and MODE its mode.  */
end_comment

begin_function
specifier|static
name|void
name|init_alignment_context
parameter_list|(
name|struct
name|alignment_context
modifier|*
name|ac
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|ac
operator|->
name|shift
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|aligned
operator|=
operator|(
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ac
operator|->
name|aligned
condition|)
name|ac
operator|->
name|memsi
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Memory is aligned.  */
else|else
block|{
comment|/* Alignment is unknown.  */
name|rtx
name|byteoffset
decl_stmt|,
name|addr
decl_stmt|,
name|align
decl_stmt|;
comment|/* Force the address into a register.  */
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Align it to SImode.  */
name|align
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|AND
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* Generate MEM.  */
name|ac
operator|->
name|memsi
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|ac
operator|->
name|memsi
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|ac
operator|->
name|memsi
argument_list|,
name|ALIAS_SET_MEMORY_BARRIER
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|ac
operator|->
name|memsi
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate shiftcount.  */
name|byteoffset
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|AND
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* As we already have some offset, evaluate the remaining distance.  */
name|ac
operator|->
name|shift
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|MINUS
argument_list|,
name|ac
operator|->
name|shift
argument_list|,
name|byteoffset
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
comment|/* Shift is the byte count, but we need the bitcount.  */
name|ac
operator|->
name|shift
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|MULT
argument_list|,
name|ac
operator|->
name|shift
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* Calculate masks.  */
name|ac
operator|->
name|modemask
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|ASHIFT
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|ac
operator|->
name|shift
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|ac
operator|->
name|modemaski
operator|=
name|expand_simple_unop
argument_list|(
name|SImode
argument_list|,
name|NOT
argument_list|,
name|ac
operator|->
name|modemask
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an atomic compare and swap operation for HImode and QImode.  MEM is    the memory location, CMP the old value to compare MEM with and NEW the value    to set if CMP == MEM.    CMP is never in memory for compare_and_swap_cc because    expand_bool_compare_and_swap puts it into a register for later compare.  */
end_comment

begin_function
name|void
name|s390_expand_cs_hqi
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|cmp
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
name|struct
name|alignment_context
name|ac
decl_stmt|;
name|rtx
name|cmpv
decl_stmt|,
name|newv
decl_stmt|,
name|val
decl_stmt|,
name|resv
decl_stmt|,
name|cc
decl_stmt|;
name|rtx
name|res
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|csloop
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|csend
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|gcc_assert
argument_list|(
name|register_operand
argument_list|(
name|target
argument_list|,
name|VOIDmode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|init_alignment_context
argument_list|(
operator|&
name|ac
argument_list|,
name|mem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Shift the values to the correct bit positions.  */
if|if
condition|(
operator|!
operator|(
name|ac
operator|.
name|aligned
operator|&&
name|MEM_P
argument_list|(
name|cmp
argument_list|)
operator|)
condition|)
name|cmp
operator|=
name|s390_expand_mask_and_shift
argument_list|(
name|cmp
argument_list|,
name|mode
argument_list|,
name|ac
operator|.
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ac
operator|.
name|aligned
operator|&&
name|MEM_P
argument_list|(
name|new
argument_list|)
operator|)
condition|)
name|new
operator|=
name|s390_expand_mask_and_shift
argument_list|(
name|new
argument_list|,
name|mode
argument_list|,
name|ac
operator|.
name|shift
argument_list|)
expr_stmt|;
comment|/* Load full word.  Subsequent loads are performed by CS.  */
name|val
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|AND
argument_list|,
name|ac
operator|.
name|memsi
argument_list|,
name|ac
operator|.
name|modemaski
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* Start CS loop.  */
name|emit_label
argument_list|(
name|csloop
argument_list|)
expr_stmt|;
comment|/* val = "<mem>00..0<mem>"     * cmp = "00..0<cmp>00..0"    * new = "00..0<new>00..0"     */
comment|/* Patch cmp and new with val at correct position.  */
if|if
condition|(
name|ac
operator|.
name|aligned
operator|&&
name|MEM_P
argument_list|(
name|cmp
argument_list|)
condition|)
block|{
name|cmpv
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|store_bit_field
argument_list|(
name|cmpv
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
block|}
else|else
name|cmpv
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|IOR
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|.
name|aligned
operator|&&
name|MEM_P
argument_list|(
name|new
argument_list|)
condition|)
block|{
name|newv
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|store_bit_field
argument_list|(
name|newv
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
else|else
name|newv
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|IOR
argument_list|,
name|new
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Jump to end if we're done (likely?).  */
name|s390_emit_jump
argument_list|(
name|csend
argument_list|,
name|s390_emit_compare_and_swap
argument_list|(
name|EQ
argument_list|,
name|res
argument_list|,
name|ac
operator|.
name|memsi
argument_list|,
name|cmpv
argument_list|,
name|newv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for changes outside mode.  */
name|resv
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|AND
argument_list|,
name|res
argument_list|,
name|ac
operator|.
name|modemaski
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|cc
operator|=
name|s390_emit_compare
argument_list|(
name|NE
argument_list|,
name|resv
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|val
argument_list|,
name|resv
argument_list|)
expr_stmt|;
comment|/* Loop internal if so.  */
name|s390_emit_jump
argument_list|(
name|csloop
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|csend
argument_list|)
expr_stmt|;
comment|/* Return the correct part of the bitfield.  */
name|convert_move
argument_list|(
name|target
argument_list|,
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|LSHIFTRT
argument_list|,
name|res
argument_list|,
name|ac
operator|.
name|shift
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an atomic operation CODE of mode MODE.  MEM is the memory location    and VAL the value to play with.  If AFTER is true then store the the value    MEM holds after the operation, if AFTER is false then store the value MEM    holds before the operation.  If TARGET is zero then discard that value, else    store it to TARGET.  */
end_comment

begin_function
name|void
name|s390_expand_atomic
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|val
parameter_list|,
name|bool
name|after
parameter_list|)
block|{
name|struct
name|alignment_context
name|ac
decl_stmt|;
name|rtx
name|cmp
decl_stmt|;
name|rtx
name|new
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|orig
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|csloop
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|target
operator|||
name|register_operand
argument_list|(
name|target
argument_list|,
name|VOIDmode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|init_alignment_context
argument_list|(
operator|&
name|ac
argument_list|,
name|mem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Shift val to the correct bit positions.      Preserve "icm", but prevent "ex icm".  */
if|if
condition|(
operator|!
operator|(
name|ac
operator|.
name|aligned
operator|&&
name|code
operator|==
name|SET
operator|&&
name|MEM_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|s390_expand_mask_and_shift
argument_list|(
name|val
argument_list|,
name|mode
argument_list|,
name|ac
operator|.
name|shift
argument_list|)
expr_stmt|;
comment|/* Further preparation insns.  */
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
condition|)
name|emit_move_insn
argument_list|(
name|orig
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MULT
operator|||
name|code
operator|==
name|AND
condition|)
comment|/* val = "11..1<val>11..1" */
name|val
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|XOR
argument_list|,
name|val
argument_list|,
name|ac
operator|.
name|modemaski
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* Load full word.  Subsequent loads are performed by CS.  */
name|cmp
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|ac
operator|.
name|memsi
argument_list|)
expr_stmt|;
comment|/* Start CS loop.  */
name|emit_label
argument_list|(
name|csloop
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|new
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
comment|/* Patch new with val at correct position.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
name|val
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|code
argument_list|,
name|new
argument_list|,
name|orig
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|AND
argument_list|,
name|val
argument_list|,
name|ac
operator|.
name|modemask
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|SET
case|:
if|if
condition|(
name|ac
operator|.
name|aligned
operator|&&
name|MEM_P
argument_list|(
name|val
argument_list|)
condition|)
name|store_bit_field
argument_list|(
name|new
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|new
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|AND
argument_list|,
name|new
argument_list|,
name|ac
operator|.
name|modemaski
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|new
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|IOR
argument_list|,
name|new
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
name|new
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|code
argument_list|,
name|new
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* NAND */
name|new
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|XOR
argument_list|,
name|new
argument_list|,
name|ac
operator|.
name|modemask
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|new
operator|=
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|AND
argument_list|,
name|new
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|s390_emit_jump
argument_list|(
name|csloop
argument_list|,
name|s390_emit_compare_and_swap
argument_list|(
name|NE
argument_list|,
name|cmp
argument_list|,
name|ac
operator|.
name|memsi
argument_list|,
name|cmp
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the correct part of the bitfield.  */
if|if
condition|(
name|target
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|expand_simple_binop
argument_list|(
name|SImode
argument_list|,
name|LSHIFTRT
argument_list|,
name|after
condition|?
name|new
else|:
name|cmp
argument_list|,
name|ac
operator|.
name|shift
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|s390_output_dwarf_dtprel
argument_list|(
name|FILE
operator|*
argument_list|,
name|int
argument_list|,
name|rtx
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|s390_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|fputs
argument_list|(
literal|"\t.long\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
literal|"\t.quad\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@DTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_ALTERNATE_LONG_DOUBLE_MANGLING
end_ifdef

begin_comment
comment|/* Implement TARGET_MANGLE_FUNDAMENTAL_TYPE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|s390_mangle_fundamental_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|long_double_type_node
operator|&&
name|TARGET_LONG_DOUBLE_128
condition|)
return|return
literal|"g"
return|;
comment|/* For all other types, use normal C++ mangling.  */
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In the name of slightly smaller debug output, and to cater to    general assembler lossage, recognize various UNSPEC sequences    and turn them back into a direct symbol reference.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_delegitimize_address
parameter_list|(
name|rtx
name|orig_x
parameter_list|)
block|{
name|rtx
name|x
init|=
name|orig_x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|orig_x
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
block|{
name|y
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
condition|)
return|return
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTENT
condition|)
return|return
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
return|return
name|orig_x
return|;
block|}
end_function

begin_comment
comment|/* Output operand OP to stdio stream FILE.    OP is an address (register + offset) which is not used to address data;    instead the rightmost bits are interpreted as the value.  */
end_comment

begin_function
specifier|static
name|void
name|print_shift_count_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|op
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|rtx
name|base
decl_stmt|;
comment|/* Extract base register and offset.  */
if|if
condition|(
operator|!
name|s390_decompose_shift_count
argument_list|(
name|op
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|base
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
name|ADDR_REGS
argument_list|)
expr_stmt|;
block|}
comment|/* Offsets are constricted to twelve bits.  */
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See 'get_some_local_dynamic_name'.  */
end_comment

begin_function
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|get_pool_constant
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|tls_symbolic_operand
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in local-dynamic base patterns.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output machine-dependent UNSPECs occurring in address constant X    in assembler syntax to stdio stream FILE.  Returns true if the    constant X could be recognized, false otherwise.  */
end_comment

begin_function
name|bool
name|s390_output_addr_const_extra
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOTENT
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTENT"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_GOT
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOT"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_GOTOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTOFF"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_PLT
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLT"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_PLTOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLTOFF"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_TLSGD
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@TLSGD"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_TLSLDM
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@TLSLDM"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_DTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@DTPOFF"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_NTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@NTPOFF"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_GOTNTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTNTPOFF"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|UNSPEC_INDNTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@INDNTPOFF"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Output address operand ADDR in assembler syntax to    stdio stream FILE.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
argument_list|)
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"cannot decompose address"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
name|ad
operator|.
name|indx
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s,%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output operand X in assembler syntax to stdio stream FILE.    CODE specified the format flag.  The following format flags    are recognized:      'C': print opcode suffix for branch condition.     'D': print opcode suffix for inverse branch condition.     'J': print tls_load/tls_gdcall/tls_ldcall suffix     'G': print the size of the operand in bytes.     'O': print only the displacement of a memory reference.     'R': print only the base register of a memory reference.     'S': print S-type memory reference (base+displacement).     'N': print the second word of a DImode operand.     'M': print the second word of a TImode operand.     'Y': print shift count operand.      'b': print integer X as if it's an unsigned byte.     'x': print integer X as if it's an unsigned halfword.     'h': print integer X as if it's a signed halfword.     'i': print the first nonzero HImode part of X.     'j': print the first HImode part unequal to -1 of X.     'k': print the first nonzero SImode part of X.     'm': print the first SImode part unequal to -1 of X.     'o': print integer X as if it's an unsigned 32bit word.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'C'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|s390_branch_condition_mnemonic
argument_list|(
name|x
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|s390_branch_condition_mnemonic
argument_list|(
name|x
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_load:"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSGD
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_gdcall:"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSLDM
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_ldcall:"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'G'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%u"
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
name|ret
operator|=
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ad
operator|.
name|base
operator|||
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ad
operator|.
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'R'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
name|ret
operator|=
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ad
operator|.
name|base
operator|||
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ad
operator|.
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'S'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
name|ret
operator|=
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ad
operator|.
name|base
operator|||
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ad
operator|.
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'N'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|print_shift_count_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'x'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'i'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|s390_extract_part
argument_list|(
name|x
argument_list|,
name|HImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'j'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|s390_extract_part
argument_list|(
name|x
argument_list|,
name|HImode
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'k'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|s390_extract_part
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'m'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|s390_extract_part
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'o'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'x'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"UNKNOWN in print_operand !?"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Target hook for assembling integer objects.  We need to define it    here to work a round a bug in some versions of GAS, which couldn't    handle values smaller than INT_MIN when printed in decimal.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
name|aligned_p
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
name|INT_MIN
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.quad\t"
name|HOST_WIDE_INT_PRINT_HEX
literal|"\n"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if register REGNO is used  for forming    a memory address in expression X.  */
end_comment

begin_function
specifier|static
name|bool
name|reg_used_in_mem_p
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns true if expression DEP_RTX sets an address register    used by instruction INSN to address memory.  */
end_comment

begin_function
specifier|static
name|bool
name|addr_generation_dependency_p
parameter_list|(
name|rtx
name|dep_rtx
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|target
decl_stmt|,
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|INSN
condition|)
name|dep_rtx
operator|=
name|PATTERN
argument_list|(
name|dep_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
condition|)
block|{
name|target
operator|=
name|SET_DEST
argument_list|(
name|dep_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|target
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
condition|)
name|target
operator|=
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_safe_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_LA
condition|)
block|{
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|gcc_assert
argument_list|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|get_attr_atype
argument_list|(
name|insn
argument_list|)
operator|==
name|ATYPE_AGEN
condition|)
return|return
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return 1, if dep_insn sets register used in insn in the agen unit.  */
end_comment

begin_function
name|int
name|s390_agen_dep_p
parameter_list|(
name|rtx
name|dep_insn
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|dep_rtx
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
operator|&&
name|addr_generation_dependency_p
argument_list|(
name|dep_rtx
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr_generation_dependency_p
argument_list|(
name|XVECEXP
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A C statement (sans semicolon) to update the integer scheduling priority    INSN_PRIORITY (INSN).  Increase the priority to execute the INSN earlier,    reduce the priority to execute INSN later.  Do not define this macro if    you do not need to adjust the scheduling priorities of insns.     A STD instruction should be scheduled earlier,    in order to use the bypass.  */
end_comment

begin_function
specifier|static
name|int
name|s390_adjust_priority
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|priority
return|;
if|if
condition|(
name|s390_tune
operator|!=
name|PROCESSOR_2084_Z990
operator|&&
name|s390_tune
operator|!=
name|PROCESSOR_2094_Z9_109
condition|)
return|return
name|priority
return|;
switch|switch
condition|(
name|s390_safe_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_FSTOREDF
case|:
case|case
name|TYPE_FSTORESF
case|:
name|priority
operator|=
name|priority
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|TYPE_STORE
case|:
case|case
name|TYPE_STM
case|:
name|priority
operator|=
name|priority
operator|<<
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|priority
return|;
block|}
end_function

begin_comment
comment|/* The number of instructions that can be issued per cycle.  */
end_comment

begin_function
specifier|static
name|int
name|s390_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|s390_tune
operator|==
name|PROCESSOR_2084_Z990
operator|||
name|s390_tune
operator|==
name|PROCESSOR_2094_Z9_109
condition|)
return|return
literal|3
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390_first_cycle_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Annotate every literal pool reference in X by an UNSPEC_LTREF expression.    Fix up MEMs as required.  */
end_comment

begin_function
specifier|static
name|void
name|annotate_constant_pool_refs
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Literal pool references can only occur inside a MEM ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|memref
init|=
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|memref
argument_list|)
condition|)
block|{
name|rtx
name|base
init|=
name|cfun
operator|->
name|machine
operator|->
name|base_reg
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|memref
argument_list|,
name|base
argument_list|)
argument_list|,
name|UNSPEC_LTREF
argument_list|)
decl_stmt|;
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|off
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|sym
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
name|cfun
operator|->
name|machine
operator|->
name|base_reg
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|sym
argument_list|,
name|base
argument_list|)
argument_list|,
name|UNSPEC_LTREF
argument_list|)
decl_stmt|;
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* ... or a load-address type pattern.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|addrref
init|=
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addrref
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addrref
argument_list|)
condition|)
block|{
name|rtx
name|base
init|=
name|cfun
operator|->
name|machine
operator|->
name|base_reg
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|addrref
argument_list|,
name|base
argument_list|)
argument_list|,
name|UNSPEC_LTREF
argument_list|)
decl_stmt|;
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addrref
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|off
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|sym
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
name|cfun
operator|->
name|machine
operator|->
name|base_reg
decl_stmt|;
name|rtx
name|addr
init|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|sym
argument_list|,
name|base
argument_list|)
argument_list|,
name|UNSPEC_LTREF
argument_list|)
decl_stmt|;
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Annotate LTREL_BASE as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
operator|*
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_BASE
condition|)
block|{
name|rtx
name|base
init|=
name|cfun
operator|->
name|machine
operator|->
name|base_reg
decl_stmt|;
operator|*
name|x
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|base
argument_list|)
argument_list|,
name|UNSPEC_LTREL_BASE
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|annotate_constant_pool_refs
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|annotate_constant_pool_refs
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Split all branches that exceed the maximum distance.    Returns true if this created a new literal pool entry.  */
end_comment

begin_function
specifier|static
name|int
name|s390_split_branches
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|temp_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
decl_stmt|;
name|int
name|new_literal
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|,
name|tmp
decl_stmt|,
name|target
decl_stmt|;
name|rtx
modifier|*
name|label
decl_stmt|;
comment|/* We need correct insn addresses.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Find all branches that exceed 64KB, and split them.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|!=
name|pc_rtx
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
else|else
continue|continue;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|<=
literal|4
condition|)
continue|continue;
comment|/* We are going to use the return register as scratch register, 	 make sure it will be saved/restored by the prologue/epilogue.  */
name|cfun_frame_layout
operator|.
name|save_return_addr_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|new_literal
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
operator|*
name|label
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|annotate_constant_pool_refs
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|temp_reg
expr_stmt|;
block|}
else|else
block|{
name|new_literal
operator|=
literal|1
expr_stmt|;
name|target
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
operator|*
name|label
argument_list|)
argument_list|,
name|UNSPEC_LTREL_OFFSET
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|target
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|target
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|annotate_constant_pool_refs
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|base_reg
argument_list|)
argument_list|,
name|UNSPEC_LTREL_BASE
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
name|label
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|new_literal
return|;
block|}
end_function

begin_comment
comment|/* Find an annotated literal pool symbol referenced in RTX X,     and store it at REF.  Will abort if X contains references to     more than one such pool symbol; multiple references to the same    symbol are allowed, however.     The rtx pointed to by REF must be initialized to NULL_RTX    by the caller before calling this routine.  */
end_comment

begin_function
specifier|static
name|void
name|find_constant_pool_ref
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|ref
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Ignore LTREL_BASE references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_BASE
condition|)
return|return;
comment|/* Likewise POOL_ENTRY insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_POOL_ENTRY
condition|)
return|return;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREF
condition|)
block|{
name|rtx
name|sym
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|sym
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ref
operator|==
name|NULL_RTX
condition|)
operator|*
name|ref
operator|=
name|sym
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
operator|*
name|ref
operator|==
name|sym
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|find_constant_pool_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_constant_pool_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace every reference to the annotated literal pool     symbol REF in X by its base plus OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|replace_constant_pool_ref
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|rtx
name|ref
parameter_list|,
name|rtx
name|offset
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|x
operator|!=
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
operator|*
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREF
operator|&&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|ref
condition|)
block|{
operator|*
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREF
operator|&&
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|ref
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|offset
argument_list|)
decl_stmt|;
operator|*
name|x
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|replace_constant_pool_ref
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_constant_pool_ref
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check whether X contains an UNSPEC_LTREL_BASE.    Return its constant pool symbol if found, NULL_RTX otherwise.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_ltrel_base
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_BASE
condition|)
return|return
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|fnd
init|=
name|find_ltrel_base
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|fnd
init|=
name|find_ltrel_base
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
block|}
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Replace any occurrence of UNSPEC_LTREL_BASE in X with its base.  */
end_comment

begin_function
specifier|static
name|void
name|replace_ltrel_base
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
operator|*
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_BASE
condition|)
block|{
operator|*
name|x
operator|=
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|replace_ltrel_base
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_ltrel_base
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We keep a list of constants which we have to add to internal    constant tables in the middle of large functions.  */
end_comment

begin_define
define|#
directive|define
name|NR_C_MODES
value|11
end_define

begin_decl_stmt
name|enum
name|machine_mode
name|constant_modes
index|[
name|NR_C_MODES
index|]
init|=
block|{
name|TFmode
block|,
name|TImode
block|,
name|TDmode
block|,
name|DFmode
block|,
name|DImode
block|,
name|DDmode
block|,
name|SFmode
block|,
name|SImode
block|,
name|SDmode
block|,
name|HImode
block|,
name|QImode
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|constant
block|{
name|struct
name|constant
modifier|*
name|next
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|constant_pool
block|{
name|struct
name|constant_pool
modifier|*
name|next
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|rtx
name|pool_insn
decl_stmt|;
name|bitmap
name|insns
decl_stmt|;
name|struct
name|constant
modifier|*
name|constants
index|[
name|NR_C_MODES
index|]
decl_stmt|;
name|struct
name|constant
modifier|*
name|execute
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate new constant_pool structure.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_alloc_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pool
operator|=
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
name|pool
operator|->
name|constants
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|execute
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pool
operator|->
name|first_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|pool
operator|->
name|insns
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|pool
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* Create new constant pool covering instructions starting at INSN    and chain it to the end of POOL_LIST.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_start_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
modifier|*
name|pool_list
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|pool
operator|=
name|s390_alloc_pool
argument_list|()
expr_stmt|;
name|pool
operator|->
name|first_insn
operator|=
name|insn
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|pool_list
init|;
operator|*
name|prev
condition|;
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|prev
operator|=
name|pool
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* End range of instructions covered by POOL at INSN and emit    placeholder insn representing the pool.  */
end_comment

begin_function
specifier|static
name|void
name|s390_end_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pool_size
init|=
name|GEN_INT
argument_list|(
name|pool
operator|->
name|size
operator|+
literal|8
comment|/* alignment slop */
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|pool_size
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the list of insns covered by POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_add_pool_insn
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|bitmap_set_bit
argument_list|(
name|pool
operator|->
name|insns
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return pool out of POOL_LIST that covers INSN.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_find_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool_list
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|pool_list
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|pool
operator|->
name|insns
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
break|break;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* Add constant VAL of mode MODE to the constant pool POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_add_constant
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|val
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constant_modes
index|[
name|i
index|]
operator|==
name|mode
condition|)
break|break;
name|gcc_assert
argument_list|(
name|i
operator|!=
name|NR_C_MODES
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|val
argument_list|,
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
operator|(
expr|struct
name|constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|c
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
expr_stmt|;
name|pool
operator|->
name|constants
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|pool
operator|->
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find constant VAL of mode MODE in the constant pool POOL.    Return an RTX describing the distance from the start of    the pool to the location of the new constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_find_constant
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|val
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constant_modes
index|[
name|i
index|]
operator|==
name|mode
condition|)
break|break;
name|gcc_assert
argument_list|(
name|i
operator|!=
name|NR_C_MODES
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|val
argument_list|,
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
name|gcc_assert
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|c
operator|->
name|label
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Check whether INSN is an execute.  Return the label_ref to its    execute target template if so, NULL_RTX otherwise.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_execute_label
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_EXECUTE
condition|)
return|return
name|XVECEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Add execute target for INSN to the constant pool POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_add_execute
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|execute
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
operator|(
expr|struct
name|constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|insn
expr_stmt|;
name|c
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|pool
operator|->
name|execute
expr_stmt|;
name|pool
operator|->
name|execute
operator|=
name|c
expr_stmt|;
name|pool
operator|->
name|size
operator|+=
literal|6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find execute target for INSN in the constant pool POOL.    Return an RTX describing the distance from the start of    the pool to the location of the execute target.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_find_execute
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|execute
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
name|gcc_assert
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|c
operator|->
name|label
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* For an execute INSN, extract the execute target template.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_execute_target
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|s390_execute_label
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
condition|)
block|{
name|pattern
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtvec
name|vec
init|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
return|return
name|pattern
return|;
block|}
end_function

begin_comment
comment|/* Indicate that INSN cannot be duplicated.  This is the case for    execute insns that carry a unique label.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_cannot_copy_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|label
init|=
name|s390_execute_label
argument_list|(
name|insn
argument_list|)
decl_stmt|;
return|return
name|label
operator|&&
name|label
operator|!=
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Dump out the constants in POOL.  If REMOTE_LABEL is true,    do not emit the pool base label.  */
end_comment

begin_function
specifier|static
name|void
name|s390_dump_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|bool
name|remote_label
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|insn
init|=
name|pool
operator|->
name|pool_insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Switch to rodata section.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_section_start
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure minimum pool alignment.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_align
argument_list|(
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_align
argument_list|(
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Emit pool base label.  */
if|if
condition|(
operator|!
name|remote_label
condition|)
block|{
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Dump constants in descending alignment requirement order,      ensuring proper alignment for every constant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
comment|/* Convert UNSPEC_LTREL_OFFSET unspecs to pool-relative references.  */
name|rtx
name|value
init|=
name|c
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_OFFSET
operator|&&
name|XVECLEN
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_label_after
argument_list|(
name|c
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gen_rtx_UNSPEC_VOLATILE
argument_list|(
name|constant_modes
index|[
name|i
index|]
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
argument_list|,
name|UNSPECV_POOL_ENTRY
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|value
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure minimum alignment for instructions.  */
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_align
argument_list|(
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Output in-pool execute template insns.  */
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|execute
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
name|insn
operator|=
name|emit_label_after
argument_list|(
name|c
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|s390_execute_target
argument_list|(
name|c
operator|->
name|value
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Switch back to previous section.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_section_end
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Remove placeholder insn.  */
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all memory used by POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_free_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
condition|;
name|c
operator|=
name|next
control|)
block|{
name|next
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|execute
init|;
name|c
condition|;
name|c
operator|=
name|next
control|)
block|{
name|next
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|pool
operator|->
name|insns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Collect main literal pool.  Return NULL on overflow.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_mainpool_start
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|pool
operator|=
name|s390_alloc_pool
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_MAIN_POOL
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_CPU_ZARCH
operator|&&
name|s390_execute_label
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|s390_add_execute
argument_list|(
name|pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
name|rtx
name|constant
init|=
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
decl_stmt|;
name|s390_add_constant
argument_list|(
name|pool
argument_list|,
name|constant
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|gcc_assert
argument_list|(
name|pool
operator|->
name|pool_insn
operator|||
name|pool
operator|->
name|size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|size
operator|>=
literal|4096
condition|)
block|{
comment|/* We're going to chunkify the pool, so remove the main 	 pool placeholder insn.  */
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|s390_free_pool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* POOL holds the main literal pool as collected by s390_mainpool_start.    Modify the current function to output the pool constants as well as    the pool register setup instruction.  */
end_comment

begin_function
specifier|static
name|void
name|s390_mainpool_finish
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|)
block|{
name|rtx
name|base_reg
init|=
name|cfun
operator|->
name|machine
operator|->
name|base_reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* If the pool is empty, we're done.  */
if|if
condition|(
name|pool
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* We don't actually need a base register after all.  */
name|cfun
operator|->
name|machine
operator|->
name|base_reg
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|pool_insn
condition|)
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|s390_free_pool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We need correct insn addresses.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* On zSeries, we use a LARL to load the pool register.  The pool is      located in the .rodata section, so we emit it after the function.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|insn
operator|=
name|gen_main_base_64
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|const0_rtx
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_dump_pool
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* On S/390, if the total size of the function's code plus literal pool      does not exceed 4096 bytes, we use BASR to set up a function base      pointer, and emit the literal pool at the end of the function.  */
elseif|else
if|if
condition|(
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
argument_list|)
operator|+
name|pool
operator|->
name|size
operator|+
literal|8
comment|/* alignment slop */
operator|<
literal|4096
condition|)
block|{
name|insn
operator|=
name|gen_main_base_31_small
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|const0_rtx
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_dump_pool
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we emit an inline literal pool and use BASR to branch      over it, setting up the pool register at the same time.  */
else|else
block|{
name|rtx
name|pool_end
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|insn
operator|=
name|gen_main_base_31_large
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|,
name|pool_end
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|const0_rtx
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool_end
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_dump_pool
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Replace all literal pool references.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|replace_ltrel_base
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
if|if
condition|(
name|s390_execute_label
argument_list|(
name|insn
argument_list|)
condition|)
name|addr
operator|=
name|s390_find_execute
argument_list|(
name|pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|s390_find_constant
argument_list|(
name|pool
argument_list|,
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
argument_list|)
expr_stmt|;
name|replace_constant_pool_ref
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pool_ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Free the pool.  */
name|s390_free_pool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* POOL holds the main literal pool as collected by s390_mainpool_start.    We have decided we cannot use this pool, so revert all changes    to the current function that were done by s390_mainpool_start.  */
end_comment

begin_function
specifier|static
name|void
name|s390_mainpool_cancel
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|)
block|{
comment|/* We didn't actually change the instruction stream, so simply      free the pool memory.  */
name|s390_free_pool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Chunkify the literal pool.  */
end_comment

begin_define
define|#
directive|define
name|S390_POOL_CHUNK_MIN
value|0xc00
end_define

begin_define
define|#
directive|define
name|S390_POOL_CHUNK_MAX
value|0xe00
end_define

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_chunkify_start
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|,
modifier|*
name|pool_list
init|=
name|NULL
decl_stmt|;
name|int
name|extra_size
init|=
literal|0
decl_stmt|;
name|bitmap
name|far_labels
decl_stmt|;
name|rtx
name|pending_ltrel
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
function_decl|(
modifier|*
name|gen_reload_base
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
init|=
name|TARGET_CPU_ZARCH
condition|?
name|gen_reload_base_64
operator|:
name|gen_reload_base_31
function_decl|;
comment|/* We need correct insn addresses.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Scan all insns and move literals to pool chunks.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Check for pending LTREL_BASE.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|ltrel_base
init|=
name|find_ltrel_base
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ltrel_base
condition|)
block|{
name|gcc_assert
argument_list|(
name|ltrel_base
operator|==
name|pending_ltrel
argument_list|)
expr_stmt|;
name|pending_ltrel
operator|=
name|NULL_RTX
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TARGET_CPU_ZARCH
operator|&&
name|s390_execute_label
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|curr_pool
condition|)
name|curr_pool
operator|=
name|s390_start_pool
argument_list|(
operator|&
name|pool_list
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|s390_add_execute
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|s390_add_pool_insn
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
name|rtx
name|constant
init|=
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|curr_pool
condition|)
name|curr_pool
operator|=
name|s390_start_pool
argument_list|(
operator|&
name|pool_list
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|s390_add_constant
argument_list|(
name|curr_pool
argument_list|,
name|constant
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|s390_add_pool_insn
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't split the pool chunk between a LTREL_OFFSET load 		 and the corresponding LTREL_BASE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|constant
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|constant
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_OFFSET
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|pending_ltrel
argument_list|)
expr_stmt|;
name|pending_ltrel
operator|=
name|pool_ref
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|curr_pool
condition|)
name|s390_add_pool_insn
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* An LTREL_BASE must follow within the same basic block.  */
name|gcc_assert
argument_list|(
operator|!
name|pending_ltrel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|curr_pool
operator|||
name|INSN_ADDRESSES_SIZE
argument_list|()
operator|<=
operator|(
name|size_t
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|||
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
if|if
condition|(
name|curr_pool
operator|->
name|size
operator|<
name|S390_POOL_CHUNK_MAX
condition|)
continue|continue;
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|chunk_size
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|curr_pool
operator|->
name|first_insn
argument_list|)
argument_list|)
operator|+
name|extra_size
decl_stmt|;
comment|/* We will later have to insert base register reload insns. 	     Those will have an effect on code size, which we need to 	     consider here.  This calculation makes rather pessimistic 	     worst-case assumptions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|extra_size
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|<
name|S390_POOL_CHUNK_MIN
operator|&&
name|curr_pool
operator|->
name|size
operator|<
name|S390_POOL_CHUNK_MIN
condition|)
continue|continue;
comment|/* Pool chunks can only be inserted after BARRIERs ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
name|extra_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ... so if we don't find one in time, create one.  */
elseif|else
if|if
condition|(
operator|(
name|chunk_size
operator|>
name|S390_POOL_CHUNK_MAX
operator|||
name|curr_pool
operator|->
name|size
operator|>
name|S390_POOL_CHUNK_MAX
operator|)
condition|)
block|{
name|rtx
name|label
decl_stmt|,
name|jump
decl_stmt|,
name|barrier
decl_stmt|;
comment|/* We can insert the barrier only after a 'real' insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
continue|continue;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Don't separate LTREL_BASE from the corresponding 		 LTREL_OFFSET load.  */
if|if
condition|(
name|pending_ltrel
condition|)
continue|continue;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|jump
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|barrier
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
name|extra_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|curr_pool
condition|)
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|pending_ltrel
argument_list|)
expr_stmt|;
comment|/* Find all labels that are branched into      from an insn belonging to a different chunk.  */
name|far_labels
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Labels marked with LABEL_PRESERVE_P can be target 	 of non-local jumps, so we have to mark them. 	 The same holds for named labels.  	 Don't do that, however, if it is the label before 	 a jump table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|||
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|vec_insn
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|vec_pat
init|=
name|vec_insn
operator|&&
name|GET_CODE
argument_list|(
name|vec_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|PATTERN
argument_list|(
name|vec_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
if|if
condition|(
operator|!
name|vec_pat
operator|||
operator|!
operator|(
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a direct jump (conditional or unconditional) 	 or a casesi jump, check all potential targets.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
if|if
condition|(
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|label
argument_list|)
operator|!=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
comment|/* Find the jump table used by this casesi jump.  */
name|rtx
name|vec_label
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|vec_insn
init|=
name|next_real_insn
argument_list|(
name|vec_label
argument_list|)
decl_stmt|;
name|rtx
name|vec_pat
init|=
name|vec_insn
operator|&&
name|GET_CODE
argument_list|(
name|vec_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|PATTERN
argument_list|(
name|vec_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|vec_pat
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|diff_p
init|=
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|vec_pat
argument_list|,
name|diff_p
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|vec_pat
argument_list|,
name|diff_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|label
argument_list|)
operator|!=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Insert base register reload insns before every pool.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
argument_list|,
name|curr_pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|curr_pool
operator|->
name|first_insn
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Insert base register reload insns at every far label.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|bitmap_bit_p
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
init|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|far_labels
argument_list|)
expr_stmt|;
comment|/* Recompute insn addresses.  */
name|init_insn_lengths
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|pool_list
return|;
block|}
end_function

begin_comment
comment|/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.    After we have decided to use this list, finish implementing    all changes to the current function as required.  */
end_comment

begin_function
specifier|static
name|void
name|s390_chunkify_finish
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool_list
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Replace all literal pool references.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|replace_ltrel_base
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curr_pool
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
if|if
condition|(
name|s390_execute_label
argument_list|(
name|insn
argument_list|)
condition|)
name|addr
operator|=
name|s390_find_execute
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|s390_find_constant
argument_list|(
name|curr_pool
argument_list|,
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
argument_list|)
expr_stmt|;
name|replace_constant_pool_ref
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pool_ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Dump out all literal pools.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
name|s390_dump_pool
argument_list|(
name|curr_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Free pool list.  */
while|while
condition|(
name|pool_list
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|next
init|=
name|pool_list
operator|->
name|next
decl_stmt|;
name|s390_free_pool
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
name|pool_list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.    We have decided we cannot use this list, so revert all changes    to the current function that were done by s390_chunkify_start.  */
end_comment

begin_function
specifier|static
name|void
name|s390_chunkify_cancel
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool_list
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Remove all pool placeholder insns.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
block|{
comment|/* Did we insert an extra barrier?  Remove it.  */
name|rtx
name|barrier
init|=
name|PREV_INSN
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
decl_stmt|;
name|rtx
name|jump
init|=
name|barrier
condition|?
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|rtx
name|label
init|=
name|NEXT_INSN
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|jump
operator|&&
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|barrier
operator|&&
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|==
name|BARRIER
operator|&&
name|label
operator|&&
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
block|{
name|remove_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Remove all base register reload insns.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
control|)
block|{
name|rtx
name|next_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_RELOAD_BASE
condition|)
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next_insn
expr_stmt|;
block|}
comment|/* Free pool list.  */
while|while
condition|(
name|pool_list
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|next
init|=
name|pool_list
operator|->
name|next
decl_stmt|;
name|s390_free_pool
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
name|pool_list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the constant pool entry EXP in mode MODE with alignment ALIGN.  */
end_comment

begin_function
name|void
name|s390_output_pool_entry
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_DECIMAL_FLOAT
case|:
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
name|assemble_integer
argument_list|(
name|exp
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return an RTL expression representing the value of the return address    for the frame COUNT steps up from the current frame.  FRAME is the    frame pointer of that frame.  */
end_comment

begin_function
name|rtx
name|s390_return_addr_rtx
parameter_list|(
name|int
name|count
parameter_list|,
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* Without backchain, we fail for all but the current frame.  */
if|if
condition|(
operator|!
name|TARGET_BACKCHAIN
operator|&&
name|count
operator|>
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* For the current frame, we need to make sure the initial      value of RETURN_REGNUM is actually saved.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* On non-z architectures branch splitting could overwrite r14.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
return|;
else|else
block|{
name|cfun_frame_layout
operator|.
name|save_return_addr_p
operator|=
name|true
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|return_address_pointer_rtx
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TARGET_PACKED_STACK
condition|)
name|offset
operator|=
operator|-
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|offset
operator|=
name|RETURN_REGNUM
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an RTL expression representing the back chain stored in    the current stack frame.  */
end_comment

begin_function
name|rtx
name|s390_back_chain_rtx
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|chain
decl_stmt|;
name|gcc_assert
argument_list|(
name|TARGET_BACKCHAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_PACKED_STACK
condition|)
name|chain
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
else|else
name|chain
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|chain
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Find first call clobbered register unused in a function.    This could be used as base register in a leaf function    or for holding the return address before epilogue.  */
end_comment

begin_function
specifier|static
name|int
name|find_unused_clobbered_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper function for s390_regs_ever_clobbered.  Sets the fields in DATA for all     clobbered hard regs in SETREG.  */
end_comment

begin_function
specifier|static
name|void
name|s390_reg_clobbered_rtx
parameter_list|(
name|rtx
name|setreg
parameter_list|,
name|rtx
name|set_insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|regs_ever_clobbered
init|=
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|setreg
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|setreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|setreg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|GENERAL_REG_P
argument_list|(
name|inner
argument_list|)
condition|)
return|return;
name|regno
operator|=
name|subreg_regno
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GENERAL_REG_P
argument_list|(
name|setreg
argument_list|)
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
else|else
return|return;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|;
name|i
operator|++
control|)
name|regs_ever_clobbered
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walks through all basic blocks of the current function looking    for clobbered hard regs using s390_reg_clobbered_rtx.  The fields    of the passed integer array REGS_EVER_CLOBBERED are set to one for    each of those regs.  */
end_comment

begin_function
specifier|static
name|void
name|s390_regs_ever_clobbered
parameter_list|(
name|int
modifier|*
name|regs_ever_clobbered
parameter_list|)
block|{
name|basic_block
name|cur_bb
decl_stmt|;
name|rtx
name|cur_insn
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|regs_ever_clobbered
argument_list|,
literal|0
argument_list|,
literal|16
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For non-leaf functions we have to consider all call clobbered regs to be      clobbered.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|regs_ever_clobbered
index|[
name|i
index|]
operator|=
name|call_really_used_regs
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Make the "magic" eh_return registers live if necessary.  For regs_ever_live      this work is done by liveness analysis (mark_regs_live_at_end).      Special care is needed for functions containing landing pads.  Landing pads      may use the eh registers, but the code which sets these registers is not      contained in that function.  Hence s390_regs_ever_clobbered is not able to      deal with this automatically.  */
if|if
condition|(
name|current_function_calls_eh_return
operator|||
name|cfun
operator|->
name|machine
operator|->
name|has_landing_pad_p
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
operator|!=
name|INVALID_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|current_function_calls_eh_return
operator|||
operator|(
name|cfun
operator|->
name|machine
operator|->
name|has_landing_pad_p
operator|&&
name|regs_ever_live
index|[
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
index|]
operator|)
condition|)
name|regs_ever_clobbered
index|[
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
comment|/* For nonlocal gotos all call-saved registers have to be saved.      This flag is also set for the unwinding code in libgcc.      See expand_builtin_unwind_init.  For regs_ever_live this is done by      reload.  */
if|if
condition|(
name|current_function_has_nonlocal_label
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_really_used_regs
index|[
name|i
index|]
condition|)
name|regs_ever_clobbered
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|cur_bb
argument_list|)
block|{
name|FOR_BB_INSNS
argument_list|(
argument|cur_bb
argument_list|,
argument|cur_insn
argument_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|cur_insn
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|cur_insn
argument_list|)
argument_list|,
name|s390_reg_clobbered_rtx
argument_list|,
name|regs_ever_clobbered
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine the frame area which actually has to be accessed     in the function epilogue. The values are stored at the     given pointers AREA_BOTTOM (address of the lowest used stack    address) and AREA_TOP (address of the first item which does     not belong to the stack frame).  */
end_comment

begin_function
specifier|static
name|void
name|s390_frame_area
parameter_list|(
name|int
modifier|*
name|area_bottom
parameter_list|,
name|int
modifier|*
name|area_top
parameter_list|)
block|{
name|int
name|b
decl_stmt|,
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|b
operator|=
name|INT_MAX
expr_stmt|;
name|t
operator|=
name|INT_MIN
expr_stmt|;
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|b
operator|=
operator|(
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|+
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|t
operator|=
name|b
operator|+
operator|(
name|cfun_frame_layout
operator|.
name|last_restore_gpr
operator|-
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|+
literal|1
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|cfun_save_high_fprs_p
condition|)
block|{
name|b
operator|=
name|MIN
argument_list|(
name|b
argument_list|,
name|cfun_frame_layout
operator|.
name|f8_offset
argument_list|)
expr_stmt|;
name|t
operator|=
name|MAX
argument_list|(
name|t
argument_list|,
operator|(
name|cfun_frame_layout
operator|.
name|f8_offset
operator|+
name|cfun_frame_layout
operator|.
name|high_fprs
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cfun_fpr_bit_p
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|b
operator|=
name|MIN
argument_list|(
name|b
argument_list|,
name|cfun_frame_layout
operator|.
name|f4_offset
operator|+
operator|(
name|i
operator|-
literal|2
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
name|t
operator|=
name|MAX
argument_list|(
name|t
argument_list|,
name|cfun_frame_layout
operator|.
name|f4_offset
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
operator|*
name|area_bottom
operator|=
name|b
expr_stmt|;
operator|*
name|area_top
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill cfun->machine with info about register usage of current function.    Return in CLOBBERED_REGS which GPRs are currently considered set.  */
end_comment

begin_function
specifier|static
name|void
name|s390_register_info
parameter_list|(
name|int
name|clobbered_regs
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* fprs 8 - 15 are call saved for 64 Bit ABI.  */
name|cfun_frame_layout
operator|.
name|fpr_bitmap
operator|=
literal|0
expr_stmt|;
name|cfun_frame_layout
operator|.
name|high_fprs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|cfun_set_fpr_bit
argument_list|(
name|i
operator|-
literal|16
argument_list|)
expr_stmt|;
name|cfun_frame_layout
operator|.
name|high_fprs
operator|++
expr_stmt|;
block|}
comment|/* Find first and last gpr to be saved.  We trust regs_ever_live      data, except that we don't save and restore global registers.       Also, all registers with special meaning to the compiler need      to be handled extra.  */
name|s390_regs_ever_clobbered
argument_list|(
name|clobbered_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|clobbered_regs
index|[
name|i
index|]
operator|=
name|clobbered_regs
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|clobbered_regs
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|clobbered_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator||=
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
expr_stmt|;
name|clobbered_regs
index|[
name|BASE_REGNUM
index|]
operator||=
operator|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
operator|&&
name|REGNO
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
argument_list|)
operator|==
name|BASE_REGNUM
operator|)
expr_stmt|;
name|clobbered_regs
index|[
name|RETURN_REGNUM
index|]
operator||=
operator|(
operator|!
name|current_function_is_leaf
operator|||
name|TARGET_TPF_PROFILING
operator|||
name|cfun
operator|->
name|machine
operator|->
name|split_branches_pending_p
operator|||
name|cfun_frame_layout
operator|.
name|save_return_addr_p
operator|||
name|current_function_calls_eh_return
operator|||
name|current_function_stdarg
operator|)
expr_stmt|;
name|clobbered_regs
index|[
name|STACK_POINTER_REGNUM
index|]
operator||=
operator|(
operator|!
name|current_function_is_leaf
operator|||
name|TARGET_TPF_PROFILING
operator|||
name|cfun_save_high_fprs_p
operator|||
name|get_frame_size
argument_list|()
operator|>
literal|0
operator|||
name|current_function_calls_alloca
operator|||
name|current_function_stdarg
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|clobbered_regs
index|[
name|i
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|j
index|]
operator|||
name|clobbered_regs
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|16
condition|)
block|{
comment|/* Nothing to save/restore.  */
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|=
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_save_gpr_slot
operator|=
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_restore_gpr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Save slots for gprs from i to j.  */
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|=
name|i
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_save_gpr_slot
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
init|;
name|i
operator|<
name|cfun_frame_layout
operator|.
name|last_save_gpr_slot
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|clobbered_regs
index|[
name|i
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|cfun_frame_layout
operator|.
name|last_save_gpr_slot
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|clobbered_regs
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|cfun_frame_layout
operator|.
name|last_save_gpr_slot
operator|+
literal|1
condition|)
block|{
comment|/* Nothing to save/restore.  */
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_restore_gpr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Save / Restore from gpr i to j.  */
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|=
name|i
expr_stmt|;
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|=
name|i
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|=
name|j
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_restore_gpr
operator|=
name|j
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_function_stdarg
condition|)
block|{
comment|/* Varargs functions need to save gprs 2 to 6.  */
if|if
condition|(
name|cfun
operator|->
name|va_list_gpr_size
operator|&&
name|current_function_args_info
operator|.
name|gprs
operator|<
name|GP_ARG_NUM_REG
condition|)
block|{
name|int
name|min_gpr
init|=
name|current_function_args_info
operator|.
name|gprs
decl_stmt|;
name|int
name|max_gpr
init|=
name|min_gpr
operator|+
name|cfun
operator|->
name|va_list_gpr_size
decl_stmt|;
if|if
condition|(
name|max_gpr
operator|>
name|GP_ARG_NUM_REG
condition|)
name|max_gpr
operator|=
name|GP_ARG_NUM_REG
expr_stmt|;
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|==
operator|-
literal|1
operator|||
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|>
literal|2
operator|+
name|min_gpr
condition|)
block|{
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|=
literal|2
operator|+
name|min_gpr
expr_stmt|;
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|=
literal|2
operator|+
name|min_gpr
expr_stmt|;
block|}
if|if
condition|(
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|==
operator|-
literal|1
operator|||
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|<
literal|2
operator|+
name|max_gpr
operator|-
literal|1
condition|)
block|{
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|=
literal|2
operator|+
name|max_gpr
operator|-
literal|1
expr_stmt|;
name|cfun_frame_layout
operator|.
name|last_save_gpr_slot
operator|=
literal|2
operator|+
name|max_gpr
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Mark f0, f2 for 31 bit and f0-f4 for 64 bit to be saved.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|cfun
operator|->
name|va_list_fpr_size
operator|&&
name|current_function_args_info
operator|.
name|fprs
operator|<
name|FP_ARG_NUM_REG
condition|)
block|{
name|int
name|min_fpr
init|=
name|current_function_args_info
operator|.
name|fprs
decl_stmt|;
name|int
name|max_fpr
init|=
name|min_fpr
operator|+
name|cfun
operator|->
name|va_list_fpr_size
decl_stmt|;
if|if
condition|(
name|max_fpr
operator|>
name|FP_ARG_NUM_REG
condition|)
name|max_fpr
operator|=
name|FP_ARG_NUM_REG
expr_stmt|;
comment|/* ??? This is currently required to ensure proper location 	     of the fpr save slots within the va_list save area.  */
if|if
condition|(
name|TARGET_PACKED_STACK
condition|)
name|min_fpr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min_fpr
init|;
name|i
operator|<
name|max_fpr
condition|;
name|i
operator|++
control|)
name|cfun_set_fpr_bit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|16
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
operator|+
literal|16
index|]
condition|)
name|cfun_set_fpr_bit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill cfun->machine with info about frame of current function.  */
end_comment

begin_function
specifier|static
name|void
name|s390_frame_info
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cfun_frame_layout
operator|.
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|cfun_frame_layout
operator|.
name|frame_size
operator|>
literal|0x7fff0000
condition|)
name|fatal_error
argument_list|(
literal|"total size of local variables exceeds architecture limit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_PACKED_STACK
condition|)
block|{
name|cfun_frame_layout
operator|.
name|backchain_offset
operator|=
literal|0
expr_stmt|;
name|cfun_frame_layout
operator|.
name|f0_offset
operator|=
literal|16
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|cfun_frame_layout
operator|.
name|f4_offset
operator|=
name|cfun_frame_layout
operator|.
name|f0_offset
operator|+
literal|2
operator|*
literal|8
expr_stmt|;
name|cfun_frame_layout
operator|.
name|f8_offset
operator|=
operator|-
name|cfun_frame_layout
operator|.
name|high_fprs
operator|*
literal|8
expr_stmt|;
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|=
operator|(
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_BACKCHAIN
condition|)
comment|/* kernel stack layout */
block|{
name|cfun_frame_layout
operator|.
name|backchain_offset
operator|=
operator|(
name|STACK_POINTER_OFFSET
operator|-
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|=
operator|(
name|cfun_frame_layout
operator|.
name|backchain_offset
operator|-
operator|(
name|STACK_POINTER_REGNUM
operator|-
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|+
literal|1
operator|)
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|cfun_frame_layout
operator|.
name|f4_offset
operator|=
operator|(
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|-
literal|8
operator|*
operator|(
name|cfun_fpr_bit_p
argument_list|(
literal|2
argument_list|)
operator|+
name|cfun_fpr_bit_p
argument_list|(
literal|3
argument_list|)
operator|)
operator|)
expr_stmt|;
name|cfun_frame_layout
operator|.
name|f0_offset
operator|=
operator|(
name|cfun_frame_layout
operator|.
name|f4_offset
operator|-
literal|8
operator|*
operator|(
name|cfun_fpr_bit_p
argument_list|(
literal|0
argument_list|)
operator|+
name|cfun_fpr_bit_p
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* On 31 bit we have to care about alignment of the 	     floating point regs to provide fastest access.  */
name|cfun_frame_layout
operator|.
name|f0_offset
operator|=
operator|(
operator|(
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|&
operator|~
operator|(
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|8
operator|*
operator|(
name|cfun_fpr_bit_p
argument_list|(
literal|0
argument_list|)
operator|+
name|cfun_fpr_bit_p
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|cfun_frame_layout
operator|.
name|f4_offset
operator|=
operator|(
name|cfun_frame_layout
operator|.
name|f0_offset
operator|-
literal|8
operator|*
operator|(
name|cfun_fpr_bit_p
argument_list|(
literal|2
argument_list|)
operator|+
name|cfun_fpr_bit_p
argument_list|(
literal|3
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
comment|/* no backchain */
block|{
name|cfun_frame_layout
operator|.
name|f4_offset
operator|=
operator|(
name|STACK_POINTER_OFFSET
operator|-
literal|8
operator|*
operator|(
name|cfun_fpr_bit_p
argument_list|(
literal|2
argument_list|)
operator|+
name|cfun_fpr_bit_p
argument_list|(
literal|3
argument_list|)
operator|)
operator|)
expr_stmt|;
name|cfun_frame_layout
operator|.
name|f0_offset
operator|=
operator|(
name|cfun_frame_layout
operator|.
name|f4_offset
operator|-
literal|8
operator|*
operator|(
name|cfun_fpr_bit_p
argument_list|(
literal|0
argument_list|)
operator|+
name|cfun_fpr_bit_p
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|=
name|cfun_frame_layout
operator|.
name|f0_offset
operator|-
name|cfun_gprs_save_area_size
expr_stmt|;
block|}
if|if
condition|(
name|current_function_is_leaf
operator|&&
operator|!
name|TARGET_TPF_PROFILING
operator|&&
name|cfun_frame_layout
operator|.
name|frame_size
operator|==
literal|0
operator|&&
operator|!
name|cfun_save_high_fprs_p
operator|&&
operator|!
name|current_function_calls_alloca
operator|&&
operator|!
name|current_function_stdarg
condition|)
return|return;
if|if
condition|(
operator|!
name|TARGET_PACKED_STACK
condition|)
name|cfun_frame_layout
operator|.
name|frame_size
operator|+=
operator|(
name|STACK_POINTER_OFFSET
operator|+
name|current_function_outgoing_args_size
operator|+
name|cfun_frame_layout
operator|.
name|high_fprs
operator|*
literal|8
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TARGET_BACKCHAIN
condition|)
name|cfun_frame_layout
operator|.
name|frame_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
comment|/* No alignment trouble here because f8-f15 are only saved under  	 64 bit.  */
name|cfun_frame_layout
operator|.
name|f8_offset
operator|=
operator|(
name|MIN
argument_list|(
name|MIN
argument_list|(
name|cfun_frame_layout
operator|.
name|f0_offset
argument_list|,
name|cfun_frame_layout
operator|.
name|f4_offset
argument_list|)
argument_list|,
name|cfun_frame_layout
operator|.
name|gprs_offset
argument_list|)
operator|-
name|cfun_frame_layout
operator|.
name|high_fprs
operator|*
literal|8
operator|)
expr_stmt|;
name|cfun_frame_layout
operator|.
name|frame_size
operator|+=
name|cfun_frame_layout
operator|.
name|high_fprs
operator|*
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cfun_fpr_bit_p
argument_list|(
name|i
argument_list|)
condition|)
name|cfun_frame_layout
operator|.
name|frame_size
operator|+=
literal|8
expr_stmt|;
name|cfun_frame_layout
operator|.
name|frame_size
operator|+=
name|cfun_gprs_save_area_size
expr_stmt|;
comment|/* If under 31 bit an odd number of gprs has to be saved we have to adjust 	 the frame size to sustain 8 byte alignment of stack frames.  */
name|cfun_frame_layout
operator|.
name|frame_size
operator|=
operator|(
operator|(
name|cfun_frame_layout
operator|.
name|frame_size
operator|+
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|cfun_frame_layout
operator|.
name|frame_size
operator|+=
name|current_function_outgoing_args_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate frame layout.  Fills in register and frame data for the current    function in cfun->machine.  This routine can be called multiple times;    it will re-do the complete frame layout every time.  */
end_comment

begin_function
specifier|static
name|void
name|s390_init_frame_layout
parameter_list|(
name|void
parameter_list|)
block|{
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
name|int
name|base_used
decl_stmt|;
name|int
name|clobbered_regs
index|[
literal|16
index|]
decl_stmt|;
comment|/* On S/390 machines, we may need to perform branch splitting, which      will require both base and return address register.  We have no      choice but to assume we're going to need them until right at the      end of the machine dependent reorg phase.  */
if|if
condition|(
operator|!
name|TARGET_CPU_ZARCH
condition|)
name|cfun
operator|->
name|machine
operator|->
name|split_branches_pending_p
operator|=
name|true
expr_stmt|;
do|do
block|{
name|frame_size
operator|=
name|cfun_frame_layout
operator|.
name|frame_size
expr_stmt|;
comment|/* Try to predict whether we'll need the base register.  */
name|base_used
operator|=
name|cfun
operator|->
name|machine
operator|->
name|split_branches_pending_p
operator|||
name|current_function_uses_const_pool
operator|||
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|frame_size
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_K
argument_list|(
name|frame_size
argument_list|)
operator|)
expr_stmt|;
comment|/* Decide which register to use as literal pool base.  In small 	 leaf functions, try to use an unused call-clobbered register 	 as base register to avoid save/restore overhead.  */
if|if
condition|(
operator|!
name|base_used
condition|)
name|cfun
operator|->
name|machine
operator|->
name|base_reg
operator|=
name|NULL_RTX
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_is_leaf
operator|&&
operator|!
name|regs_ever_live
index|[
literal|5
index|]
condition|)
name|cfun
operator|->
name|machine
operator|->
name|base_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|5
argument_list|)
expr_stmt|;
else|else
name|cfun
operator|->
name|machine
operator|->
name|base_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGNUM
argument_list|)
expr_stmt|;
name|s390_register_info
argument_list|(
name|clobbered_regs
argument_list|)
expr_stmt|;
name|s390_frame_info
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|frame_size
operator|!=
name|cfun_frame_layout
operator|.
name|frame_size
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Update frame layout.  Recompute actual register save data based on    current info and update regs_ever_live for the special registers.    May be called multiple times, but may never cause *more* registers    to be saved than s390_init_frame_layout allocated room for.  */
end_comment

begin_function
specifier|static
name|void
name|s390_update_frame_layout
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|clobbered_regs
index|[
literal|16
index|]
decl_stmt|;
name|s390_register_info
argument_list|(
name|clobbered_regs
argument_list|)
expr_stmt|;
name|regs_ever_live
index|[
name|BASE_REGNUM
index|]
operator|=
name|clobbered_regs
index|[
name|BASE_REGNUM
index|]
expr_stmt|;
name|regs_ever_live
index|[
name|RETURN_REGNUM
index|]
operator|=
name|clobbered_regs
index|[
name|RETURN_REGNUM
index|]
expr_stmt|;
name|regs_ever_live
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
name|clobbered_regs
index|[
name|STACK_POINTER_REGNUM
index|]
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
condition|)
name|regs_ever_live
index|[
name|REGNO
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if it is legal to put a value with MODE into REGNO.  */
end_comment

begin_function
name|bool
name|s390_hard_regno_mode_ok
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
condition|)
block|{
case|case
name|FP_REGS
case|:
if|if
condition|(
name|REGNO_PAIR_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|DImode
condition|)
return|return
name|true
return|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_VECTOR_FLOAT
condition|)
return|return
name|true
return|;
block|}
break|break;
case|case
name|ADDR_REGS
case|:
if|if
condition|(
name|FRAME_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|mode
operator|==
name|Pmode
condition|)
return|return
name|true
return|;
comment|/* fallthrough */
case|case
name|GENERAL_REGS
case|:
if|if
condition|(
name|REGNO_PAIR_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
operator|||
operator|(
name|mode
operator|!=
name|TFmode
operator|&&
name|mode
operator|!=
name|TCmode
operator|&&
name|mode
operator|!=
name|TDmode
operator|)
condition|)
return|return
name|true
return|;
block|}
break|break;
case|case
name|CC_REGS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
name|true
return|;
break|break;
case|case
name|ACCESS_REGS
case|:
if|if
condition|(
name|REGNO_PAIR_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|Pmode
condition|)
return|return
name|true
return|;
block|}
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if register OLD_REG can be renamed to register NEW_REG.  */
end_comment

begin_function
name|bool
name|s390_hard_regno_rename_ok
parameter_list|(
name|unsigned
name|int
name|old_reg
parameter_list|,
name|unsigned
name|int
name|new_reg
parameter_list|)
block|{
comment|/* Once we've decided upon a register to use as base register, it must       no longer be used for any other purpose.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
condition|)
if|if
condition|(
name|REGNO
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
argument_list|)
operator|==
name|old_reg
operator|||
name|REGNO
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
argument_list|)
operator|==
name|new_reg
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Maximum number of registers to represent a value of mode MODE    in a register of class CLASS.  */
end_comment

begin_function
name|bool
name|s390_class_max_nregs
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|FP_REGS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
return|return
literal|2
operator|*
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
operator|+
literal|8
operator|-
literal|1
operator|)
operator|/
literal|8
operator|)
return|;
else|else
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|8
operator|-
literal|1
operator|)
operator|/
literal|8
return|;
case|case
name|ACCESS_REGS
case|:
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|4
operator|-
literal|1
operator|)
operator|/
literal|4
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Return true if register FROM can be eliminated via register TO.  */
end_comment

begin_function
name|bool
name|s390_can_eliminate
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
comment|/* On zSeries machines, we have not marked the base register as fixed.      Instead, we have an elimination rule BASE_REGNUM -> BASE_REGNUM.      If a function requires the base register, we say here that this      elimination cannot be performed.  This will cause reload to free      up the base register (as if it were fixed).  On the other hand,      if the current function does *not* require the base register, we      say here the elimination succeeds, which in turn allows reload      to allocate the base register for any other purpose.  */
if|if
condition|(
name|from
operator|==
name|BASE_REGNUM
operator|&&
name|to
operator|==
name|BASE_REGNUM
condition|)
block|{
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|s390_init_frame_layout
argument_list|()
expr_stmt|;
return|return
name|cfun
operator|->
name|machine
operator|->
name|base_reg
operator|==
name|NULL_RTX
return|;
block|}
return|return
name|false
return|;
block|}
comment|/* Everything else must point into the stack frame.  */
name|gcc_assert
argument_list|(
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|||
name|from
operator|==
name|RETURN_ADDRESS_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Make sure we actually saved the return address.  */
if|if
condition|(
name|from
operator|==
name|RETURN_ADDRESS_POINTER_REGNUM
condition|)
if|if
condition|(
operator|!
name|current_function_calls_eh_return
operator|&&
operator|!
name|current_function_stdarg
operator|&&
operator|!
name|cfun_frame_layout
operator|.
name|save_return_addr_p
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return offset between register FROM and TO initially after prolog.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|s390_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* ??? Why are we called for non-eliminable pairs?  */
if|if
condition|(
operator|!
name|s390_can_eliminate
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|FRAME_POINTER_REGNUM
case|:
name|offset
operator|=
operator|(
name|get_frame_size
argument_list|()
operator|+
name|STACK_POINTER_OFFSET
operator|+
name|current_function_outgoing_args_size
operator|)
expr_stmt|;
break|break;
case|case
name|ARG_POINTER_REGNUM
case|:
name|s390_init_frame_layout
argument_list|()
expr_stmt|;
name|offset
operator|=
name|cfun_frame_layout
operator|.
name|frame_size
operator|+
name|STACK_POINTER_OFFSET
expr_stmt|;
break|break;
case|case
name|RETURN_ADDRESS_POINTER_REGNUM
case|:
name|s390_init_frame_layout
argument_list|()
expr_stmt|;
name|index
operator|=
name|RETURN_REGNUM
operator|-
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
expr_stmt|;
name|gcc_assert
argument_list|(
name|index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cfun_frame_layout
operator|.
name|frame_size
operator|+
name|cfun_frame_layout
operator|.
name|gprs_offset
expr_stmt|;
name|offset
operator|+=
name|index
operator|*
name|UNITS_PER_WORD
expr_stmt|;
break|break;
case|case
name|BASE_REGNUM
case|:
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Emit insn to save fpr REGNUM at offset OFFSET relative    to register BASE.  Return generated insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_fpr
parameter_list|(
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|16
operator|&&
name|regnum
operator|<=
operator|(
literal|16
operator|+
name|FP_ARG_NUM_REG
operator|)
condition|)
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regnum
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit insn to restore fpr REGNUM from offset OFFSET relative    to register BASE.  Return generated insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|restore_fpr
parameter_list|(
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate insn to save registers FIRST to LAST into    the register save area located at offset OFFSET    relative to register BASE.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_gprs
parameter_list|(
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|int
name|i
decl_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Special-case single register.  */
if|if
condition|(
name|first
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_movdi
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_movsi
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|insn
return|;
block|}
name|insn
operator|=
name|gen_store_multiple
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|<=
literal|6
operator|&&
name|current_function_stdarg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|mem
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|+
name|i
operator|<=
literal|6
condition|)
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* We need to set the FRAME_RELATED flag on all SETs      inside the store-multiple pattern.       However, we must not emit DWARF records for registers 2..5      if they are stored for use by variable arguments ...       ??? Unfortunately, it is not enough to simply not the      FRAME_RELATED flags for those SETs, because the first SET      of the PARALLEL is always treated as if it had the flag      set, even if it does not.  Therefore we emit a new pattern      without those registers as REG_FRAME_RELATED_EXPR note.  */
if|if
condition|(
name|first
operator|>=
literal|6
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|>=
literal|6
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
operator|(
literal|6
operator|-
name|first
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_store_multiple
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|6
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
literal|6
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|note
operator|=
name|PATTERN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|note
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Generate insn to restore registers FIRST to LAST from    the register save area located at offset OFFSET    relative to register BASE.  */
end_comment

begin_function
specifier|static
name|rtx
name|restore_gprs
parameter_list|(
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|insn
decl_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Special-case single register.  */
if|if
condition|(
name|first
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_movdi
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_movsi
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
name|insn
operator|=
name|gen_load_multiple
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return insn sequence to load the GOT register.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|got_symbol
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|s390_load_got
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insns
decl_stmt|;
if|if
condition|(
operator|!
name|got_symbol
condition|)
block|{
name|got_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|got_symbol
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|got_symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|offset
decl_stmt|;
name|offset
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|got_symbol
argument_list|)
argument_list|,
name|UNSPEC_LTREL_OFFSET
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_LTREL_BASE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|insns
return|;
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|s390_emit_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|rtx
name|temp_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|next_fpr
init|=
literal|0
decl_stmt|;
comment|/* Complete frame layout.  */
name|s390_update_frame_layout
argument_list|()
expr_stmt|;
comment|/* Annotate all constant pool references to let the scheduler know      they implicitly use the base register.  */
name|push_topmost_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|annotate_constant_pool_refs
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
comment|/* Choose best register to use for temp use within prologue.      See below for why TPF must use the register 1.  */
if|if
condition|(
operator|!
name|has_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
operator|&&
operator|!
name|current_function_is_leaf
operator|&&
operator|!
name|TARGET_TPF_PROFILING
condition|)
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
else|else
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Save call saved gprs.  */
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|insn
operator|=
name|save_gprs
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|+
name|UNITS_PER_WORD
operator|*
operator|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|-
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|)
argument_list|,
name|cfun_frame_layout
operator|.
name|first_save_gpr
argument_list|,
name|cfun_frame_layout
operator|.
name|last_save_gpr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Dummy insn to mark literal pool slot.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
condition|)
name|emit_insn
argument_list|(
name|gen_main_pool
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|base_reg
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cfun_frame_layout
operator|.
name|f0_offset
expr_stmt|;
comment|/* Save f0 and f2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfun_fpr_bit_p
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|,
name|i
operator|+
literal|16
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_PACKED_STACK
condition|)
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Save f4 and f6.  */
name|offset
operator|=
name|cfun_frame_layout
operator|.
name|f4_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfun_fpr_bit_p
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|insn
operator|=
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|,
name|i
operator|+
literal|16
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
comment|/* If f4 and f6 are call clobbered they are saved due to stdargs and 	     therefore are not frame related.  */
if|if
condition|(
operator|!
name|call_really_used_regs
index|[
name|i
operator|+
literal|16
index|]
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_PACKED_STACK
condition|)
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_PACKED_STACK
operator|&&
name|cfun_save_high_fprs_p
operator|&&
name|cfun_frame_layout
operator|.
name|f8_offset
operator|+
name|cfun_frame_layout
operator|.
name|high_fprs
operator|*
literal|8
operator|>
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|cfun_frame_layout
operator|.
name|f8_offset
operator|+
operator|(
name|cfun_frame_layout
operator|.
name|high_fprs
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>
literal|7
operator|&&
name|offset
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|cfun_fpr_bit_p
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|insn
operator|=
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|,
name|i
operator|+
literal|16
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|offset
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>=
name|cfun_frame_layout
operator|.
name|f8_offset
condition|)
name|next_fpr
operator|=
name|i
operator|+
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_PACKED_STACK
condition|)
name|next_fpr
operator|=
name|cfun_save_high_fprs_p
condition|?
literal|31
else|:
literal|0
expr_stmt|;
comment|/* Decrement stack pointer.  */
if|if
condition|(
name|cfun_frame_layout
operator|.
name|frame_size
operator|>
literal|0
condition|)
block|{
name|rtx
name|frame_off
init|=
name|GEN_INT
argument_list|(
operator|-
name|cfun_frame_layout
operator|.
name|frame_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_stack_size
condition|)
block|{
name|HOST_WIDE_INT
name|stack_check_mask
init|=
operator|(
operator|(
name|s390_stack_size
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|s390_stack_guard
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|rtx
name|t
init|=
name|gen_rtx_AND
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|stack_check_mask
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|gen_cmpdi
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
name|gen_cmpsi
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_conditional_trap
argument_list|(
name|gen_rtx_EQ
argument_list|(
name|CCmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|CC_REGNUM
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s390_warn_framesize
operator|>
literal|0
operator|&&
name|cfun_frame_layout
operator|.
name|frame_size
operator|>=
name|s390_warn_framesize
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"frame size of %qs is "
name|HOST_WIDE_INT_PRINT_DEC
literal|" bytes"
argument_list|,
name|current_function_name
argument_list|()
argument_list|,
name|cfun_frame_layout
operator|.
name|frame_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s390_warn_dynamicstack_p
operator|&&
name|cfun
operator|->
name|calls_alloca
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qs uses dynamic stack allocation"
argument_list|,
name|current_function_name
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Save incoming stack pointer into temp reg.  */
if|if
condition|(
name|TARGET_BACKCHAIN
operator|||
name|next_fpr
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|temp_reg
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Subtract frame size from stack pointer.  */
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|)
condition|)
block|{
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|)
condition|)
name|frame_off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_constant_pool_refs
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|cfun_frame_layout
operator|.
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set backchain.  */
if|if
condition|(
name|TARGET_BACKCHAIN
condition|)
block|{
if|if
condition|(
name|cfun_frame_layout
operator|.
name|backchain_offset
condition|)
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun_frame_layout
operator|.
name|backchain_offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|addr
argument_list|,
name|temp_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we support asynchronous exceptions (e.g. for Java), 	 we need to make sure the backchain pointer is set up 	 before any possibly trapping memory access.  */
if|if
condition|(
name|TARGET_BACKCHAIN
operator|&&
name|flag_non_call_exceptions
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save fprs 8 - 15 (64 bit ABI).  */
if|if
condition|(
name|cfun_save_high_fprs_p
operator|&&
name|next_fpr
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|temp_reg
argument_list|,
name|GEN_INT
argument_list|(
name|cfun_frame_layout
operator|.
name|f8_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<=
name|next_fpr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cfun_fpr_bit_p
argument_list|(
name|i
operator|-
literal|16
argument_list|)
condition|)
block|{
name|rtx
name|addr
init|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun_frame_layout
operator|.
name|frame_size
operator|+
name|cfun_frame_layout
operator|.
name|f8_offset
operator|+
name|offset
argument_list|)
decl_stmt|;
name|insn
operator|=
name|save_fpr
argument_list|(
name|temp_reg
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set frame pointer, if needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set up got pointer, if needed.  */
if|if
condition|(
name|flag_pic
operator|&&
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
block|{
name|rtx
name|insns
init|=
name|s390_load_got
argument_list|()
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|annotate_constant_pool_refs
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_TPF_PROFILING
condition|)
block|{
comment|/* Generate a BAS instruction to serve as a function 	 entry intercept to facilitate the use of tracing 	 algorithms located at the branch target.  */
name|emit_insn
argument_list|(
name|gen_prologue_tpf
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Emit a blockage here so that all code 	 lies between the profiling mechanisms.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand the epilogue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|s390_emit_epilogue
parameter_list|(
name|bool
name|sibcall
parameter_list|)
block|{
name|rtx
name|frame_pointer
decl_stmt|,
name|return_reg
decl_stmt|;
name|int
name|area_bottom
decl_stmt|,
name|area_top
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|next_offset
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_TPF_PROFILING
condition|)
block|{
comment|/* Generate a BAS instruction to serve as a function 	 entry intercept to facilitate the use of tracing 	 algorithms located at the branch target.  */
comment|/* Emit a blockage here so that all code          lies between the profiling mechanisms.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_epilogue_tpf
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Check whether to use frame or stack pointer for restore.  */
name|frame_pointer
operator|=
operator|(
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
operator|)
expr_stmt|;
name|s390_frame_area
argument_list|(
operator|&
name|area_bottom
argument_list|,
operator|&
name|area_top
argument_list|)
expr_stmt|;
comment|/* Check whether we can access the register save area.      If not, increment the frame pointer as required.  */
if|if
condition|(
name|area_top
operator|<=
name|area_bottom
condition|)
block|{
comment|/* Nothing to restore.  */
block|}
elseif|else
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|cfun_frame_layout
operator|.
name|frame_size
operator|+
name|area_bottom
argument_list|)
operator|&&
name|DISP_IN_RANGE
argument_list|(
name|cfun_frame_layout
operator|.
name|frame_size
operator|+
name|area_top
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* Area is in range.  */
name|offset
operator|=
name|cfun_frame_layout
operator|.
name|frame_size
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|insn
decl_stmt|,
name|frame_off
decl_stmt|;
name|offset
operator|=
name|area_bottom
operator|<
literal|0
condition|?
operator|-
name|area_bottom
else|:
literal|0
expr_stmt|;
name|frame_off
operator|=
name|GEN_INT
argument_list|(
name|cfun_frame_layout
operator|.
name|frame_size
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|)
condition|)
block|{
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|frame_pointer
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|)
condition|)
name|frame_off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|frame_pointer
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_constant_pool_refs
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore call saved fprs.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|cfun_save_high_fprs_p
condition|)
block|{
name|next_offset
operator|=
name|cfun_frame_layout
operator|.
name|f8_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfun_fpr_bit_p
argument_list|(
name|i
operator|-
literal|16
argument_list|)
condition|)
block|{
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|next_offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|next_offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|next_offset
operator|=
name|cfun_frame_layout
operator|.
name|f4_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|18
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfun_fpr_bit_p
argument_list|(
name|i
operator|-
literal|16
argument_list|)
condition|)
block|{
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|next_offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|next_offset
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_PACKED_STACK
condition|)
name|next_offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Return register.  */
name|return_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
comment|/* Restore call saved gprs.  */
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for global register and save them 	 to stack location from where they get restored.  */
for|for
control|(
name|i
operator|=
name|cfun_frame_layout
operator|.
name|first_restore_gpr
init|;
name|i
operator|<=
name|cfun_frame_layout
operator|.
name|last_restore_gpr
condition|;
name|i
operator|++
control|)
block|{
comment|/* These registers are special and need to be 	     restored in any case.  */
if|if
condition|(
name|i
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|i
operator|==
name|RETURN_REGNUM
operator|||
name|i
operator|==
name|BASE_REGNUM
operator|||
operator|(
name|flag_pic
operator|&&
name|i
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|+
operator|(
name|i
operator|-
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sibcall
condition|)
block|{
comment|/* Fetch return address from stack before load multiple, 	     this will do good for scheduling.  */
if|if
condition|(
name|cfun_frame_layout
operator|.
name|save_return_addr_p
operator|||
operator|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|<
name|BASE_REGNUM
operator|&&
name|cfun_frame_layout
operator|.
name|last_restore_gpr
operator|>
name|RETURN_REGNUM
operator|)
condition|)
block|{
name|int
name|return_regnum
init|=
name|find_unused_clobbered_reg
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|return_regnum
condition|)
name|return_regnum
operator|=
literal|4
expr_stmt|;
name|return_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|return_regnum
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|+
operator|(
name|RETURN_REGNUM
operator|-
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|restore_gprs
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|cfun_frame_layout
operator|.
name|gprs_offset
operator|+
operator|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|-
name|cfun_frame_layout
operator|.
name|first_save_gpr_slot
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|,
name|cfun_frame_layout
operator|.
name|first_restore_gpr
argument_list|,
name|cfun_frame_layout
operator|.
name|last_restore_gpr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sibcall
condition|)
block|{
comment|/* Return to caller.  */
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|return_reg
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the size in bytes of a function argument of    type TYPE and/or mode MODE.  At least one of TYPE or    MODE must be specified.  */
end_comment

begin_function
specifier|static
name|int
name|s390_function_arg_size
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
condition|)
return|return
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
return|;
comment|/* No type info available for some library calls ...  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
comment|/* If we have neither type nor mode, abort */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if a function argument of type TYPE and mode MODE    is to be passed in a floating-point register, if available.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_function_arg_float
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
condition|)
return|return
name|false
return|;
comment|/* Soft-float changes the ABI: no floating-point registers are used.  */
if|if
condition|(
name|TARGET_SOFT_FLOAT
condition|)
return|return
name|false
return|;
comment|/* No type info available for some library calls ...  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|SDmode
operator|||
name|mode
operator|==
name|DDmode
return|;
comment|/* The ABI says that record types with a single member are treated      just like that member would be.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|,
name|single
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|single
operator|==
name|NULL_TREE
condition|)
name|single
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
block|}
if|if
condition|(
name|single
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
else|else
name|type
operator|=
name|single
expr_stmt|;
block|}
return|return
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
return|;
block|}
end_function

begin_comment
comment|/* Return true if a function argument of type TYPE and mode MODE    is to be passed in an integer register, or a pair of integer    registers, if available.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_function_arg_integer
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
condition|)
return|return
name|false
return|;
comment|/* No type info available for some library calls ...  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
operator|(
name|TARGET_SOFT_FLOAT
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|)
return|;
comment|/* We accept small integral (and similar) types.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
operator|(
name|TARGET_SOFT_FLOAT
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
condition|)
return|return
name|true
return|;
comment|/* We also accept structs of size 1, 2, 4, 8 that are not      passed in floating-point registers.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|exact_log2
argument_list|(
name|size
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|s390_function_arg_float
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if a function argument of type TYPE and mode MODE    is to be passed by reference.  The ABI specifies that only    structures of size 1, 2, 4, or 8 bytes are passed by value,    all other structures (and complex numbers) are passed by    reference.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
condition|)
return|return
name|true
return|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|exact_log2
argument_list|(
name|size
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument of mode MODE and    data type TYPE.  (TYPE is null for libcalls where that information    may not be available.).  The boolean NAMED specifies whether the    argument is a named argument (as opposed to an unnamed argument    matching an ellipsis).  */
end_comment

begin_function
name|void
name|s390_function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|s390_function_arg_float
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|cum
operator|->
name|fprs
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_integer
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|cum
operator|->
name|gprs
operator|+=
operator|(
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).     On S/390, we use general purpose registers 2 through 6 to    pass integer, pointer, and certain structure arguments, and    floating point registers 0 and 2 (0, 2, 4, and 6 on 64-bit)    to pass floating point arguments.  All remaining arguments    are pushed to the stack.  */
end_comment

begin_function
name|rtx
name|s390_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|s390_function_arg_float
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fprs
operator|+
literal|1
operator|>
name|FP_ARG_NUM_REG
condition|)
return|return
literal|0
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|fprs
operator|+
literal|16
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_integer
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|n_gprs
init|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|gprs
operator|+
name|n_gprs
operator|>
name|GP_ARG_NUM_REG
condition|)
return|return
literal|0
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|gprs
operator|+
literal|2
argument_list|)
return|;
block|}
comment|/* After the real arguments, expand_call calls us once again      with a void_type_node type.  Whatever we return here is      passed as operand 2 to the call expanders.       We don't need this feature ...  */
elseif|else
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
return|return
name|const0_rtx
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if return values of type TYPE should be returned    in a memory buffer whose address is passed by the caller as    hidden first argument.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fundecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We accept small integral (and similar) types.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|8
return|;
comment|/* Aggregates and similar constructs are always returned      in memory.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|true
return|;
comment|/* ??? We get called on all sorts of random stuff from      aggregate_value_p.  We can't abort, but it's not clear      what's safe to return.  Pretend it's a struct I guess.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define where to return a (scalar) value of type TYPE.    If TYPE is null, define where to return a (scalar)    value of mode MODE from a libcall.  */
end_comment

begin_function
name|rtx
name|s390_function_value
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|type
condition|)
block|{
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|mode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
literal|16
argument_list|)
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create and return the va_list datatype.     On S/390, va_list is an array type equivalent to        typedef struct __va_list_tag         {             long __gpr;             long __fpr;             void *__overflow_arg_area;             void *__reg_save_area;         } va_list[1];     where __gpr and __fpr hold the number of general purpose    or floating point arguments used up to now, respectively,    __overflow_arg_area points to the stack location of the    next argument passed on the stack, and __reg_save_area    always points to the start of the register area in the    call frame of the current function.  The function prologue    saves all registers used for argument passing into this    area if the function uses variable arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|s390_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
name|record
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__gpr"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__fpr"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|va_list_gpr_counter_field
operator|=
name|f_gpr
expr_stmt|;
name|va_list_fpr_counter_field
operator|=
name|f_fpr
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement va_start by filling the va_list structure VALIST.    STDARG_P is always true, and ignored.    NEXTARG points to the first anonymous stack argument.     The following global variables are used to initialize    the va_list structure:       current_function_args_info:        holds number of gprs and fprs used for named arguments.      current_function_arg_offset_rtx:        holds the offset of the first anonymous stack argument        (relative to the virtual arg pointer).  */
end_comment

begin_function
name|void
name|s390_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|int
name|off
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|gprs
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|fprs
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|va_list_gpr_size
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|n_gpr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|va_list_fpr_size
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|n_fpr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* Find the overflow area.  */
if|if
condition|(
name|n_gpr
operator|+
name|cfun
operator|->
name|va_list_gpr_size
operator|>
name|GP_ARG_NUM_REG
operator|||
name|n_fpr
operator|+
name|cfun
operator|->
name|va_list_fpr_size
operator|>
name|FP_ARG_NUM_REG
condition|)
block|{
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|current_function_arg_offset_rtx
argument_list|)
expr_stmt|;
name|off
operator|=
name|off
operator|<
literal|0
condition|?
literal|0
else|:
name|off
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: n_gpr = %d, n_fpr = %d off %d\n"
argument_list|,
operator|(
name|int
operator|)
name|n_gpr
argument_list|,
operator|(
name|int
operator|)
name|n_fpr
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* Find the register save area.  */
if|if
condition|(
operator|(
name|cfun
operator|->
name|va_list_gpr_size
operator|&&
name|n_gpr
operator|<
name|GP_ARG_NUM_REG
operator|)
operator|||
operator|(
name|cfun
operator|->
name|va_list_fpr_size
operator|&&
name|n_fpr
operator|<
name|FP_ARG_NUM_REG
operator|)
condition|)
block|{
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|return_address_pointer_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
name|RETURN_REGNUM
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement va_arg by updating the va_list structure    VALIST as required to retrieve an argument of type    TYPE, and returning that argument.     Generates code equivalent to:     if (integral value) {      if (size<= 4&& args.gpr< 5 ||          size> 4&& args.gpr< 4 )        ret = args.reg_save_area[args.gpr+8]      else        ret = *args.overflow_arg_area++;    } else if (float value) {      if (args.fgpr< 2)        ret = args.reg_save_area[args.fpr+64]      else        ret = *args.overflow_arg_area++;    } else if (aggregate value) {      if (args.gpr< 5)        ret = *args.reg_save_area[args.gpr]      else        ret = **args.overflow_arg_area++;    } */
end_comment

begin_function
specifier|static
name|tree
name|s390_gimplify_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|reg
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|;
name|int
name|indirect_p
decl_stmt|,
name|size
decl_stmt|,
name|n_reg
decl_stmt|,
name|sav_ofs
decl_stmt|,
name|sav_scale
decl_stmt|,
name|max_reg
decl_stmt|;
name|tree
name|lab_false
decl_stmt|,
name|lab_over
decl_stmt|,
name|addr
decl_stmt|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass_by_reference
argument_list|(
name|NULL
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: aggregate type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Aggregates are passed by reference.  */
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
comment|/* kernel stack layout on 31 bit: It is assumed here that no padding 	 will be added by s390_frame_info because for va_args always an even 	 number of gprs has to be saved r15-r2 = 14 regs.  */
name|sav_ofs
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|sav_scale
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|size
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|max_reg
operator|=
name|GP_ARG_NUM_REG
operator|-
name|n_reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_float
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: float type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* FP args go in FP registers, if present.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|fpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|16
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|sav_scale
operator|=
literal|8
expr_stmt|;
name|max_reg
operator|=
name|FP_ARG_NUM_REG
operator|-
name|n_reg
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: other type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise into GP registers.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
comment|/* kernel stack layout on 31 bit: It is assumed here that no padding 	 will be added by s390_frame_info because for va_args always an even 	 number of gprs has to be saved r15-r2 = 14 regs.  */
name|sav_ofs
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
condition|)
name|sav_ofs
operator|+=
name|UNITS_PER_WORD
operator|-
name|size
expr_stmt|;
name|sav_scale
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|max_reg
operator|=
name|GP_ARG_NUM_REG
operator|-
name|n_reg
expr_stmt|;
block|}
comment|/* Pull the value out of the saved registers ...  */
name|lab_false
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|lab_over
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|addr
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|addr
argument_list|)
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|max_reg
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|reg
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|u
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|size_int
argument_list|(
name|sav_ofs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|sav_scale
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_over
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* ... Otherwise out of the overflow area.  */
name|t
operator|=
name|ovf
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
condition|)
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|size_int
argument_list|(
name|UNITS_PER_WORD
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_expr
argument_list|(
operator|&
name|t
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|u
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|u
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|size_int
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_over
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* Increment register save count.  */
name|u
operator|=
name|build2
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|n_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|u
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
block|{
name|t
operator|=
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fold_convert
argument_list|(
name|t
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fold_convert
argument_list|(
name|t
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Builtins.  */
end_comment

begin_enum
enum|enum
name|s390_builtin
block|{
name|S390_BUILTIN_THREAD_POINTER
block|,
name|S390_BUILTIN_SET_THREAD_POINTER
block|,
name|S390_BUILTIN_max
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|unsigned
name|int
specifier|const
name|code_for_builtin_64
index|[
name|S390_BUILTIN_max
index|]
init|=
block|{
name|CODE_FOR_get_tp_64
block|,
name|CODE_FOR_set_tp_64
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
specifier|const
name|code_for_builtin_31
index|[
name|S390_BUILTIN_max
index|]
init|=
block|{
name|CODE_FOR_get_tp_31
block|,
name|CODE_FOR_set_tp_31
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|s390_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|ftype
decl_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
literal|"__builtin_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|S390_BUILTIN_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
literal|"__builtin_set_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|S390_BUILTIN_SET_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
define|#
directive|define
name|MAX_ARGS
value|2
name|unsigned
name|int
specifier|const
modifier|*
name|code_for_builtin
init|=
name|TARGET_64BIT
condition|?
name|code_for_builtin_64
else|:
name|code_for_builtin_31
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|op
index|[
name|MAX_ARGS
index|]
decl_stmt|,
name|pat
decl_stmt|;
name|int
name|arity
decl_stmt|;
name|bool
name|nonvoid
decl_stmt|;
if|if
condition|(
name|fcode
operator|>=
name|S390_BUILTIN_max
condition|)
name|internal_error
argument_list|(
literal|"bad builtin fcode"
argument_list|)
expr_stmt|;
name|icode
operator|=
name|code_for_builtin
index|[
name|fcode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
literal|0
condition|)
name|internal_error
argument_list|(
literal|"bad builtin fcode"
argument_list|)
expr_stmt|;
name|nonvoid
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
expr_stmt|;
for|for
control|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|arity
operator|=
literal|0
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|,
name|arity
operator|++
control|)
block|{
specifier|const
name|struct
name|insn_operand_data
modifier|*
name|insn_op
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|arity
operator|>
name|MAX_ARGS
condition|)
return|return
name|NULL_RTX
return|;
name|insn_op
operator|=
operator|&
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|arity
operator|+
name|nonvoid
index|]
expr_stmt|;
name|op
index|[
name|arity
index|]
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|insn_op
operator|->
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_op
operator|->
name|predicate
call|)
argument_list|(
name|op
index|[
name|arity
index|]
argument_list|,
name|insn_op
operator|->
name|mode
argument_list|)
condition|)
name|op
index|[
name|arity
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_op
operator|->
name|mode
argument_list|,
name|op
index|[
name|arity
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nonvoid
condition|)
block|{
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|arity
condition|)
block|{
case|case
literal|0
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|nonvoid
condition|)
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonvoid
condition|)
return|return
name|target
return|;
else|else
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Output assembly code for the trampoline template to    stdio stream FILE.     On S/390, we use gpr 1 internally in the trampoline code;    gpr 0 is used to hold the static chain.  */
end_comment

begin_function
name|void
name|s390_trampoline_template
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|rtx
name|op
index|[
literal|2
index|]
decl_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"basr\t%1,0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lmg\t%0,%1,14(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"br\t%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|TRAMPOLINE_SIZE
operator|-
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"basr\t%1,0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lm\t%0,%1,6(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"br\t%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|TRAMPOLINE_SIZE
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|s390_initialize_trampoline
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|)
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|16
else|:
literal|8
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|24
else|:
literal|12
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return rtx for 64-bit constant formed from the 32-bit subwords    LOW and HIGH, independent of the host word size.  */
end_comment

begin_function
name|rtx
name|s390_gen_rtx_const_DI
parameter_list|(
name|int
name|high
parameter_list|,
name|int
name|low
parameter_list|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|high
expr_stmt|;
name|val
operator|<<=
literal|32
expr_stmt|;
name|val
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|low
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|32
return|return
name|immed_double_const
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|low
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|high
argument_list|,
name|DImode
argument_list|)
return|;
else|#
directive|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output assembler code to FILE to increment profiler label # LABELNO    for profiling a function entry.  */
end_comment

begin_function
name|void
name|s390_function_profiler
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|labelno
parameter_list|)
block|{
name|rtx
name|op
index|[
literal|7
index|]
decl_stmt|;
name|char
name|label
index|[
literal|128
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"# function profiler \n"
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|op
index|[
literal|1
index|]
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|op
index|[
literal|3
index|]
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_mcount"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|UNSPEC_PLT
argument_list|)
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"stg\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"larl\t%2,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"brasl\t%0,%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lg\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bras\t%2,%l6"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,0(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%2,4(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%0,%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bras\t%2,%l6"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%4-%l5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3-%l5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lr\t%0,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%0,0(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%2,4(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%0,%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Encode symbol attributes (local vs. global, tls model) of a SYMBOL_REF    into its SYMBOL_REF_FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|s390_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
comment|/* If a variable has a forced alignment to< 2 bytes, mark it with      SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|<
literal|16
condition|)
name|SYMBOL_REF_FLAGS
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator||=
name|SYMBOL_FLAG_ALIGN1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output thunk to FILE that implements a C++ virtual function call (with    multiple inheritance) to FUNCTION.  The thunk adjusts the this pointer    by DELTA, and unless VCALL_OFFSET is zero, applies an additional adjustment    stored at VCALL_OFFSET in the vtable whose address is located at offset 0    relative to the resulting this pointer.  */
end_comment

begin_function
specifier|static
name|void
name|s390_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|op
index|[
literal|10
index|]
decl_stmt|;
name|int
name|nonlocal
init|=
literal|0
decl_stmt|;
comment|/* Operand 0 is the target function.  */
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|nonlocal
operator|=
literal|1
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|TARGET_64BIT
condition|?
name|UNSPEC_PLT
else|:
name|UNSPEC_GOT
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Operand 1 is the 'this' pointer.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|)
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Operand 2 is the delta.  */
name|op
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
comment|/* Operand 3 is the vcall_offset.  */
name|op
index|[
literal|3
index|]
operator|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
expr_stmt|;
comment|/* Operand 4 is the temporary register.  */
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Operands 5 to 8 can be used as labels.  */
name|op
index|[
literal|5
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|6
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|7
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|8
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Operand 9 can be used for temporary register.  */
name|op
index|[
literal|9
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Generate code.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* Setup literal pool pointer if required.  */
if|if
condition|(
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_K
argument_list|(
name|delta
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_Os
argument_list|(
name|delta
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|vcall_offset
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_K
argument_list|(
name|vcall_offset
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_Os
argument_list|(
name|vcall_offset
argument_list|)
operator|)
condition|)
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"larl\t%4,%5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* Add DELTA to this pointer.  */
if|if
condition|(
name|delta
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_J
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"la\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"lay\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_K
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"aghi\t%1,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_Os
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"agfi\t%1,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"agf\t%1,%6-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Perform vcall adjustment.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lg\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,%3(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_OK_FOR_K
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lghi\t%4,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_OK_FOR_Os
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lgfi\t%4,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|7
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"llgf\t%4,%7-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Jump to target.  */
name|output_asm_insn
argument_list|(
literal|"jg\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Output literal pool if required.  */
if|if
condition|(
name|op
index|[
literal|5
index|]
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|".align\t4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|6
index|]
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|7
index|]
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Setup base pointer if required.  */
if|if
condition|(
operator|!
name|vcall_offset
operator|||
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_K
argument_list|(
name|delta
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_Os
argument_list|(
name|delta
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_K
argument_list|(
name|vcall_offset
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_Os
argument_list|(
name|vcall_offset
argument_list|)
operator|)
condition|)
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%4,0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add DELTA to this pointer.  */
if|if
condition|(
name|delta
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_J
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"la\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"lay\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_K
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"ahi\t%1,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_Os
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"afi\t%1,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,%6-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Perform vcall adjustment.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_J
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"l\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,%3(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"l\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ay\t%1,%3(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_OK_FOR_K
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lhi\t%4,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_OK_FOR_Os
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"iilf\t%4,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|7
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,%7-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We had to clobber the base pointer register. 	     Re-setup the base pointer (with a different base).  */
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%4,0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Jump to target.  */
name|op
index|[
literal|8
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|"l\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nonlocal
condition|)
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* We cannot call through .plt, since .plt requires %r12 loaded.  */
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,%0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|op
index|[
literal|9
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%9,%8-4-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ar\t%4,%9"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"br\t%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Output literal pool.  */
name|output_asm_insn
argument_list|(
literal|".align\t4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal
operator|&&
name|flag_pic
operator|==
literal|2
condition|)
name|output_asm_insn
argument_list|(
literal|".long\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
block|}
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|8
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|".long\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|".long\t%0-%5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
literal|6
index|]
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|7
index|]
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|s390_valid_pointer_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|mode
operator|==
name|SImode
operator|||
operator|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether the given ARGUMENT_LIST would use a caller    saved register.  This is used to decide whether sibling call    optimization could be performed on the respective function    call.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_call_saved_register_used
parameter_list|(
name|tree
name|argument_list
parameter_list|)
block|{
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
name|tree
name|parameter
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|parm_rtx
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|cum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|argument_list
condition|)
block|{
name|parameter
operator|=
name|TREE_VALUE
argument_list|(
name|argument_list
argument_list|)
expr_stmt|;
name|argument_list
operator|=
name|TREE_CHAIN
argument_list|(
name|argument_list
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
comment|/* For an undeclared variable passed as parameter we will get 	 an ERROR_MARK node here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parameter
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|true
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass_by_reference
argument_list|(
operator|&
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|mode
operator|=
name|Pmode
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|parm_rtx
operator|=
name|s390_function_arg
argument_list|(
operator|&
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s390_function_arg_advance
argument_list|(
operator|&
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm_rtx
operator|&&
name|REG_P
argument_list|(
name|parm_rtx
argument_list|)
condition|)
block|{
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|parm_rtx
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|parm_rtx
argument_list|)
argument_list|)
condition|;
name|reg
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|reg
operator|+
name|REGNO
argument_list|(
name|parm_rtx
argument_list|)
index|]
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given call expression can be    turned into a sibling call.    DECL holds the declaration of the function to be called whereas    EXP is the call expression itself.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
parameter_list|)
block|{
comment|/* The TPF epilogue uses register 1.  */
if|if
condition|(
name|TARGET_TPF_PROFILING
condition|)
return|return
name|false
return|;
comment|/* The 31 bit PLT code uses register 12 (GOT pointer - caller saved)      which would have to be restored before the sibcall.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|flag_pic
operator|&&
name|decl
operator|&&
operator|!
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Register 6 on s390 is available as an argument register but unfortunately      "caller saved". This makes functions needing this register for arguments      not suitable for sibcalls.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|&&
name|s390_call_saved_register_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the fixed registers used for condition codes.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_fixed_condition_code_regs
parameter_list|(
name|unsigned
name|int
modifier|*
name|p1
parameter_list|,
name|unsigned
name|int
modifier|*
name|p2
parameter_list|)
block|{
operator|*
name|p1
operator|=
name|CC_REGNUM
expr_stmt|;
operator|*
name|p2
operator|=
name|INVALID_REGNUM
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is used by the call expanders of the machine description.    It emits the call insn itself together with the necessary operations    to adjust the target address and returns the emitted insn.    ADDR_LOCATION is the target address rtx    TLS_CALL the location of the thread-local symbol    RESULT_REG the register where the result of the call should be stored    RETADDR_REG the register where the return address should be stored                If this parameter is NULL_RTX the call is considered                to be a sibling call.  */
end_comment

begin_function
name|rtx
name|s390_emit_call
parameter_list|(
name|rtx
name|addr_location
parameter_list|,
name|rtx
name|tls_call
parameter_list|,
name|rtx
name|result_reg
parameter_list|,
name|rtx
name|retaddr_reg
parameter_list|)
block|{
name|bool
name|plt_call
init|=
name|false
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|call
decl_stmt|;
name|rtx
name|clobber
decl_stmt|;
name|rtvec
name|vec
decl_stmt|;
comment|/* Direct function calls need special treatment.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr_location
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* When calling a global routine in PIC mode, we must          replace the symbol itself with the PLT stub.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|addr_location
argument_list|)
condition|)
block|{
name|addr_location
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr_location
argument_list|)
argument_list|,
name|UNSPEC_PLT
argument_list|)
expr_stmt|;
name|addr_location
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr_location
argument_list|)
expr_stmt|;
name|plt_call
operator|=
name|true
expr_stmt|;
block|}
comment|/* Unless we can use the bras(l) insn, force the          routine address into a register.  */
if|if
condition|(
operator|!
name|TARGET_SMALL_EXEC
operator|&&
operator|!
name|TARGET_CPU_ZARCH
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|addr_location
operator|=
name|legitimize_pic_address
argument_list|(
name|addr_location
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|addr_location
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr_location
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If it is already an indirect call or the code above moved the      SYMBOL_REF to somewhere else make sure the address can be found in      register 1.  */
if|if
condition|(
name|retaddr_reg
operator|==
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|addr_location
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
operator|!
name|plt_call
condition|)
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|SIBCALL_REGNUM
argument_list|)
argument_list|,
name|addr_location
argument_list|)
expr_stmt|;
name|addr_location
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|SIBCALL_REGNUM
argument_list|)
expr_stmt|;
block|}
name|addr_location
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|addr_location
argument_list|)
expr_stmt|;
name|call
operator|=
name|gen_rtx_CALL
argument_list|(
name|VOIDmode
argument_list|,
name|addr_location
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_reg
operator|!=
name|NULL_RTX
condition|)
name|call
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|result_reg
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|retaddr_reg
operator|!=
name|NULL_RTX
condition|)
block|{
name|clobber
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|retaddr_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_call
operator|!=
name|NULL_RTX
condition|)
name|vec
operator|=
name|gen_rtvec
argument_list|(
literal|3
argument_list|,
name|call
argument_list|,
name|clobber
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|tls_call
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|call
argument_list|,
name|clobber
argument_list|)
expr_stmt|;
name|call
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|/* 31-bit PLT stubs and tls calls use the GOT register implicitly.  */
if|if
condition|(
operator|(
operator|!
name|TARGET_64BIT
operator|&&
name|plt_call
operator|)
operator|||
name|tls_call
operator|!=
name|NULL_RTX
condition|)
block|{
comment|/* s390_function_ok_for_sibcall should 	 have denied sibcalls in this case.  */
name|gcc_assert
argument_list|(
name|retaddr_reg
operator|!=
name|NULL_RTX
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Implement CONDITIONAL_REGISTER_USAGE.  */
end_comment

begin_function
name|void
name|s390_conditional_register_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|call_used_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|fixed_regs
index|[
name|BASE_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
name|call_used_regs
index|[
name|BASE_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
name|fixed_regs
index|[
name|RETURN_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
name|call_used_regs
index|[
name|RETURN_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_really_used_regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|18
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_really_used_regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_SOFT_FLOAT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|call_used_regs
index|[
name|i
index|]
operator|=
name|fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Corresponding function to eh_return expander.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|s390_tpf_eh_return_symbol
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|s390_emit_tpf_eh_return
parameter_list|(
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
if|if
condition|(
operator|!
name|s390_tpf_eh_return_symbol
condition|)
name|s390_tpf_eh_return_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__tpf_eh_return"
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|insn
operator|=
name|s390_emit_call
argument_list|(
name|s390_tpf_eh_return_symbol
argument_list|,
name|NULL_RTX
argument_list|,
name|reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|EH_RETURN_HANDLER_RTX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rework the prologue/epilogue to avoid saving/restoring    registers unnecessarily.  */
end_comment

begin_function
specifier|static
name|void
name|s390_optimize_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|new_insn
decl_stmt|,
name|next_insn
decl_stmt|;
comment|/* Do a final recompute of the frame-related data.  */
name|s390_update_frame_layout
argument_list|()
expr_stmt|;
comment|/* If all special registers are in fact used, there's nothing we      can do, so no point in walking the insn list.  */
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|<=
name|BASE_REGNUM
operator|&&
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|>=
name|BASE_REGNUM
operator|&&
operator|(
name|TARGET_CPU_ZARCH
operator|||
operator|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|<=
name|RETURN_REGNUM
operator|&&
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|>=
name|RETURN_REGNUM
operator|)
operator|)
condition|)
return|return;
comment|/* Search for prologue/epilogue insns and replace them.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
name|int
name|first
decl_stmt|,
name|last
decl_stmt|,
name|off
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|base
decl_stmt|,
name|offset
decl_stmt|;
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|store_multiple_operation
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|<
name|first
operator|||
name|cfun_frame_layout
operator|.
name|last_save_gpr
operator|>
name|last
operator|)
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
continue|continue;
if|if
condition|(
name|first
operator|>
name|BASE_REGNUM
operator|||
name|last
operator|<
name|BASE_REGNUM
condition|)
continue|continue;
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_insn
operator|=
name|save_gprs
argument_list|(
name|base
argument_list|,
name|off
operator|+
operator|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|-
name|first
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|,
name|cfun_frame_layout
operator|.
name|first_save_gpr
argument_list|,
name|cfun_frame_layout
operator|.
name|last_save_gpr
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_save_gpr
operator|==
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|BASE_REGNUM
operator|||
operator|(
operator|!
name|TARGET_CPU_ZARCH
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RETURN_REGNUM
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|first
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
continue|continue;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|load_multiple_operation
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|<
name|first
operator|||
name|cfun_frame_layout
operator|.
name|last_restore_gpr
operator|>
name|last
operator|)
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
continue|continue;
if|if
condition|(
name|first
operator|>
name|BASE_REGNUM
operator|||
name|last
operator|<
name|BASE_REGNUM
condition|)
continue|continue;
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_insn
operator|=
name|restore_gprs
argument_list|(
name|base
argument_list|,
name|off
operator|+
operator|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|-
name|first
operator|)
operator|*
name|UNITS_PER_WORD
argument_list|,
name|cfun_frame_layout
operator|.
name|first_restore_gpr
argument_list|,
name|cfun_frame_layout
operator|.
name|last_restore_gpr
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cfun_frame_layout
operator|.
name|first_restore_gpr
operator|==
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|BASE_REGNUM
operator|||
operator|(
operator|!
name|TARGET_CPU_ZARCH
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RETURN_REGNUM
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|first
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
continue|continue;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform machine-dependent processing.  */
end_comment

begin_function
specifier|static
name|void
name|s390_reorg
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|pool_overflow
init|=
name|false
decl_stmt|;
comment|/* Make sure all splits have been performed; splits after      machine_dependent_reorg might confuse insn length counts.  */
name|split_all_insns_noflow
argument_list|()
expr_stmt|;
comment|/* From here on decomposed literal pool addresses must be accepted.  */
name|cfun
operator|->
name|machine
operator|->
name|decomposed_literal_pool_addresses_ok_p
operator|=
name|true
expr_stmt|;
comment|/* Install the main literal pool and the associated base      register load insns.       In addition, there are two problematic situations we need      to correct:       - the literal pool might be> 4096 bytes in size, so that        some of its elements cannot be directly accessed       - a branch target might be> 64K away from the branch, so that        it is not possible to use a PC-relative instruction.       To fix those, we split the single literal pool into multiple      pool chunks, reloading the pool base register at various      points throughout the function to ensure it always points to      the pool chunk the following code expects, and / or replace      PC-relative branches by absolute branches.       However, the two problems are interdependent: splitting the      literal pool can move a branch further away from its target,      causing the 64K limit to overflow, and on the other hand,      replacing a PC-relative branch by an absolute branch means      we need to put the branch target address into the literal      pool, possibly causing it to overflow.       So, we loop trying to fix up both problems until we manage      to satisfy both conditions at the same time.  Note that the      loop is guaranteed to terminate as every pass of the loop      strictly decreases the total number of PC-relative branches      in the function.  (This is not completely true as there      might be branch-over-pool insns introduced by chunkify_start.      Those never need to be split however.)  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
init|=
name|NULL
decl_stmt|;
comment|/* Collect the literal pool.  */
if|if
condition|(
operator|!
name|pool_overflow
condition|)
block|{
name|pool
operator|=
name|s390_mainpool_start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pool
condition|)
name|pool_overflow
operator|=
name|true
expr_stmt|;
block|}
comment|/* If literal pool overflowed, start to chunkify it.  */
if|if
condition|(
name|pool_overflow
condition|)
name|pool
operator|=
name|s390_chunkify_start
argument_list|()
expr_stmt|;
comment|/* Split out-of-range branches.  If this has created new 	 literal pool entries, cancel current chunk list and 	 recompute it.  zSeries machines have large branch 	 instructions, so we never need to split a branch.  */
if|if
condition|(
operator|!
name|TARGET_CPU_ZARCH
operator|&&
name|s390_split_branches
argument_list|()
condition|)
block|{
if|if
condition|(
name|pool_overflow
condition|)
name|s390_chunkify_cancel
argument_list|(
name|pool
argument_list|)
expr_stmt|;
else|else
name|s390_mainpool_cancel
argument_list|(
name|pool
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we made it up to here, both conditions are satisfied. 	 Finish up literal pool related changes.  */
if|if
condition|(
name|pool_overflow
condition|)
name|s390_chunkify_finish
argument_list|(
name|pool
argument_list|)
expr_stmt|;
else|else
name|s390_mainpool_finish
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* We're done splitting branches.  */
name|cfun
operator|->
name|machine
operator|->
name|split_branches_pending_p
operator|=
name|false
expr_stmt|;
break|break;
block|}
comment|/* Generate out-of-pool execute target insns.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|label
decl_stmt|,
name|target
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|label
operator|=
name|s390_execute_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|label
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|label
operator|!=
name|const0_rtx
argument_list|)
expr_stmt|;
name|target
operator|=
name|emit_label
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|target
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|emit_insn
argument_list|(
name|s390_execute_target
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|target
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Try to optimize prologue and epilogue further.  */
name|s390_optimize_prologue
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\t.quad\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|s390_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OPEN_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OPEN_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CLOSE_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CLOSE_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DEFAULT_TARGET_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_DEFAULT_TARGET_FLAGS
value|(TARGET_DEFAULT | MASK_FUSED_MADD)
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HANDLE_OPTION
end_undef

begin_define
define|#
directive|define
name|TARGET_HANDLE_OPTION
value|s390_handle_option
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|s390_encode_section_info
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|s390_cannot_force_const_mem
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DELEGITIMIZE_ADDRESS
end_undef

begin_define
define|#
directive|define
name|TARGET_DELEGITIMIZE_ADDRESS
value|s390_delegitimize_address
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MEMORY
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MEMORY
value|s390_return_in_memory
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|s390_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|s390_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|s390_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_PRIORITY
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_PRIORITY
value|s390_adjust_priority
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|s390_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
value|s390_first_cycle_multipass_dfa_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_COPY_INSN_P
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_COPY_INSN_P
value|s390_cannot_copy_insn_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|s390_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|s390_address_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|s390_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VALID_POINTER_MODE
end_undef

begin_define
define|#
directive|define
name|TARGET_VALID_POINTER_MODE
value|s390_valid_pointer_mode
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BUILD_BUILTIN_VA_LIST
end_undef

begin_define
define|#
directive|define
name|TARGET_BUILD_BUILTIN_VA_LIST
value|s390_build_builtin_va_list
end_define

begin_undef
undef|#
directive|undef
name|TARGET_GIMPLIFY_VA_ARG_EXPR
end_undef

begin_define
define|#
directive|define
name|TARGET_GIMPLIFY_VA_ARG_EXPR
value|s390_gimplify_va_arg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_ARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_ARGS
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_RETURN
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_RETURN
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PASS_BY_REFERENCE
end_undef

begin_define
define|#
directive|define
name|TARGET_PASS_BY_REFERENCE
value|s390_pass_by_reference
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|s390_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FIXED_CONDITION_CODE_REGS
end_undef

begin_define
define|#
directive|define
name|TARGET_FIXED_CONDITION_CODE_REGS
value|s390_fixed_condition_code_regs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CC_MODES_COMPATIBLE
end_undef

begin_define
define|#
directive|define
name|TARGET_CC_MODES_COMPATIBLE
value|s390_cc_modes_compatible
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INVALID_WITHIN_DOLOOP
end_undef

begin_define
define|#
directive|define
name|TARGET_INVALID_WITHIN_DOLOOP
value|hook_constcharptr_rtx_null
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
value|s390_output_dwarf_dtprel
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_ALTERNATE_LONG_DOUBLE_MANGLING
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
end_undef

begin_define
define|#
directive|define
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
value|s390_mangle_fundamental_type
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_SCALAR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_SCALAR_MODE_SUPPORTED_P
value|s390_scalar_mode_supported_p
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-s390.h"
end_include

end_unit

