begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IBM S/390 and zSeries    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by Hartmut Penner (hpenner@de.ibm.com) and                   Ulrich Weigand (uweigand@de.ibm.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_comment
comment|/* Machine-specific symbol_ref flags.  */
end_comment

begin_define
define|#
directive|define
name|SYMBOL_FLAG_ALIGN1
value|(SYMBOL_FLAG_MACH_DEP<< 0)
end_define

begin_function_decl
specifier|static
name|bool
name|s390_assemble_integer
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_encode_section_info
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|s390_cannot_force_const_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|s390_delegitimize_address
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|s390_return_in_memory
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|s390_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|attr_type
name|s390_safe_attr_type
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_adjust_priority
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_first_cycle_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_sched_reorder2
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|s390_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_address_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_reorg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|s390_valid_pointer_mode
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|s390_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\t.quad\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|s390_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OPEN_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OPEN_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CLOSE_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CLOSE_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_SELECT_RTX_SECTION
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_SELECT_RTX_SECTION
value|s390_select_rtx_section
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|s390_encode_section_info
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|s390_cannot_force_const_mem
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DELEGITIMIZE_ADDRESS
end_undef

begin_define
define|#
directive|define
name|TARGET_DELEGITIMIZE_ADDRESS
value|s390_delegitimize_address
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MEMORY
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MEMORY
value|s390_return_in_memory
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|s390_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|s390_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|s390_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|s390_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_PRIORITY
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_PRIORITY
value|s390_adjust_priority
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|s390_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
value|s390_use_dfa_pipeline_interface
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
value|s390_first_cycle_multipass_dfa_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER2
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER2
value|s390_sched_reorder2
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|s390_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|s390_address_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|s390_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VALID_POINTER_MODE
end_undef

begin_define
define|#
directive|define
name|TARGET_VALID_POINTER_MODE
value|s390_valid_pointer_mode
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BUILD_BUILTIN_VA_LIST
end_undef

begin_define
define|#
directive|define
name|TARGET_BUILD_BUILTIN_VA_LIST
value|s390_build_builtin_va_list
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The alias set for prologue/epilogue register save/restore.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s390_sr_alias_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|s390_compare_op0
decl_stmt|,
name|s390_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to hold the components of a S/390 memory    address.  A legitimate address on S/390 is of the general    form           base + index + displacement    where any of the components is optional.     base and index are registers of the class ADDR_REGS,    displacement is an unsigned 12-bit immediate constant.  */
end_comment

begin_struct
struct|struct
name|s390_address
block|{
name|rtx
name|base
decl_stmt|;
name|rtx
name|indx
decl_stmt|;
name|rtx
name|disp
decl_stmt|;
name|int
name|pointer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Which cpu are we tuning for.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|s390_tune
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|processor_flags
name|s390_tune_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|s390_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|processor_flags
name|s390_arch_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings to hold which cpu and instruction set architecture  to use.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|s390_tune_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -mtune=<xxx> */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|s390_arch_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -march=<xxx> */
end_comment

begin_comment
comment|/* Define the structure for the machine field in struct function.  */
end_comment

begin_decl_stmt
name|struct
name|machine_function
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Set, if some of the fprs 8-15 need to be saved (64 bit abi).  */
name|int
name|save_fprs_p
decl_stmt|;
comment|/* Set if return address needs to be saved.  */
name|bool
name|save_return_addr_p
decl_stmt|;
comment|/* Number of first and last gpr to be saved, restored.  */
name|int
name|first_save_gpr
decl_stmt|;
name|int
name|first_restore_gpr
decl_stmt|;
name|int
name|last_save_gpr
decl_stmt|;
comment|/* Size of stack frame.  */
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
comment|/* Some local-dynamic TLS symbol name.  */
specifier|const
name|char
modifier|*
name|some_ld_name
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|s390_match_ccmode_set
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_branch_condition_mask
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|s390_branch_condition_mnemonic
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_mode
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|general_s_operand
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_short_displacement
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_decompose_address
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|s390_address
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_thread_pointer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_shift_count_operand
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reg_used_in_mem_p
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addr_generation_dependency_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_split_branches
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_constant_pool_ref
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_constant_pool_ref
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|find_ltrel_base
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_ltrel_base
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_optimize_prolog
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_unused_clobbered_reg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_frame_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|save_fpr
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|restore_fpr
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|save_gprs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|restore_gprs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s390_function_arg_size
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|s390_function_arg_float
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|s390_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Check whether integer displacement is in range.  */
end_comment

begin_define
define|#
directive|define
name|DISP_IN_RANGE
parameter_list|(
name|d
parameter_list|)
define|\
value|(TARGET_LONG_DISPLACEMENT? ((d)>= -524288&& (d)<= 524287) \                            : ((d)>= 0&& (d)<= 4095))
end_define

begin_comment
comment|/* Return true if SET either doesn't set the CC register, or else    the source and destination have matching CC modes and that    CC mode is at least as constrained as REQ_MODE.  */
end_comment

begin_function
specifier|static
name|int
name|s390_match_ccmode_set
parameter_list|(
name|rtx
name|set
parameter_list|,
name|enum
name|machine_mode
name|req_mode
parameter_list|)
block|{
name|enum
name|machine_mode
name|set_mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CC_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|set_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|set_mode
condition|)
block|{
case|case
name|CCSmode
case|:
case|case
name|CCSRmode
case|:
case|case
name|CCUmode
case|:
case|case
name|CCURmode
case|:
case|case
name|CCLmode
case|:
case|case
name|CCL1mode
case|:
case|case
name|CCL2mode
case|:
case|case
name|CCT1mode
case|:
case|case
name|CCT2mode
case|:
case|case
name|CCT3mode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|set_mode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCZmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCSmode
operator|&&
name|req_mode
operator|!=
name|CCUmode
operator|&&
name|req_mode
operator|!=
name|CCTmode
operator|&&
name|req_mode
operator|!=
name|CCSRmode
operator|&&
name|req_mode
operator|!=
name|CCURmode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCAPmode
case|:
case|case
name|CCANmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCAmode
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|set_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if every SET in INSN that sets the CC register    has source and destination with matching CC modes and that    CC mode is at least as constrained as REQ_MODE.    If REQ_MODE is VOIDmode, always return false.  */
end_comment

begin_function
name|int
name|s390_match_ccmode
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|machine_mode
name|req_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* s390_tm_ccmode returns VOIDmode to indicate failure.  */
if|if
condition|(
name|req_mode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
name|s390_match_ccmode_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|req_mode
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
condition|)
if|if
condition|(
operator|!
name|s390_match_ccmode_set
argument_list|(
name|set
argument_list|,
name|req_mode
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If a test-under-mask instruction can be used to implement    (compare (and ... OP1) OP2), return the CC mode required    to do that.  Otherwise, return VOIDmode.    MIXED is true if the instruction can distinguish between    CC1 and CC2 for mixed selected bits (TMxx), it is false    if the instruction cannot (TM).  */
end_comment

begin_function
name|enum
name|machine_mode
name|s390_tm_ccmode
parameter_list|(
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|int
name|mixed
parameter_list|)
block|{
name|int
name|bit0
decl_stmt|,
name|bit1
decl_stmt|;
comment|/* ??? Fixme: should work on CONST_DOUBLE as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|VOIDmode
return|;
comment|/* Selected bits all zero: CC0.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|CCTmode
return|;
comment|/* Selected bits all one: CC3.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|CCT3mode
return|;
comment|/* Exactly two bits selected, mixed zeroes and ones: CC1 or CC2.  */
if|if
condition|(
name|mixed
condition|)
block|{
name|bit1
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|bit0
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|^
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit0
operator|!=
operator|-
literal|1
operator|&&
name|bit1
operator|!=
operator|-
literal|1
condition|)
return|return
name|bit0
operator|>
name|bit1
condition|?
name|CCT1mode
else|:
name|CCT2mode
return|;
block|}
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Given a comparison code OP (EQ, NE, etc.) and the operands    OP0 and OP1 of a COMPARE, return the mode to be used for the    comparison.  */
end_comment

begin_function
name|enum
name|machine_mode
name|s390_select_ccmode
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
return|return
name|CCAPmode
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|CCLmode
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|AND
condition|)
block|{
comment|/* Check whether we can potentially do it via TM.  */
name|enum
name|machine_mode
name|ccmode
decl_stmt|;
name|ccmode
operator|=
name|s390_tm_ccmode
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccmode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* Relax CCTmode to CCZmode to allow fall-back to AND 		   if that turns out to be beneficial.  */
return|return
name|ccmode
operator|==
name|CCTmode
condition|?
name|CCZmode
else|:
name|ccmode
return|;
block|}
block|}
if|if
condition|(
name|register_operand
argument_list|(
name|op0
argument_list|,
name|HImode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|65535
operator|)
condition|)
return|return
name|CCT3mode
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op0
argument_list|,
name|QImode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
literal|255
operator|)
condition|)
return|return
name|CCT3mode
return|;
return|return
name|CCZmode
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|(
name|op0
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|CCANmode
return|;
else|else
return|return
name|CCAPmode
return|;
block|}
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|UNGE
case|:
case|case
name|UNGT
case|:
case|case
name|LTGT
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCSRmode
return|;
return|return
name|CCSmode
return|;
case|case
name|LTU
case|:
case|case
name|GEU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|CCL1mode
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCURmode
return|;
return|return
name|CCUmode
return|;
case|case
name|LEU
case|:
case|case
name|GTU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|CCL2mode
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|CCURmode
return|;
return|return
name|CCUmode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a valid comparison operator    for an ALC condition in mode MODE.  */
end_comment

begin_function
name|int
name|s390_alc_comparison
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|CC_REGNUM
operator|||
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CCL1mode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LTU
return|;
case|case
name|CCL2mode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LEU
return|;
case|case
name|CCUmode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|GTU
return|;
case|case
name|CCURmode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LTU
return|;
case|case
name|CCSmode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNGT
return|;
case|case
name|CCSRmode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNLT
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a valid comparison operator    for an SLB condition in mode MODE.  */
end_comment

begin_function
name|int
name|s390_slb_comparison
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|CC_REGNUM
operator|||
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CCL1mode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|GEU
return|;
case|case
name|CCL2mode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|GTU
return|;
case|case
name|CCUmode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LEU
return|;
case|case
name|CCURmode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|GEU
return|;
case|case
name|CCSmode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LE
return|;
case|case
name|CCSRmode
case|:
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|GE
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return branch condition mask to implement a branch    specified by CODE.  */
end_comment

begin_function
specifier|static
name|int
name|s390_branch_condition_mask
parameter_list|(
name|rtx
name|code
parameter_list|)
block|{
specifier|const
name|int
name|CC0
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
specifier|const
name|int
name|CC1
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
specifier|const
name|int
name|CC2
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
specifier|const
name|int
name|CC3
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|CC_REGNUM
operator|||
name|XEXP
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CCZmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCT1mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC1
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCT2mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC2
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCT3mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC3
return|;
case|case
name|NE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCLmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCL1mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|LTU
case|:
return|return
name|CC2
operator||
name|CC3
return|;
comment|/* carry */
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
comment|/* no carry */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCL2mode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|GTU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
comment|/* borrow */
case|case
name|LEU
case|:
return|return
name|CC2
operator||
name|CC3
return|;
comment|/* no borrow */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCUmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LTU
case|:
return|return
name|CC1
return|;
case|case
name|GTU
case|:
return|return
name|CC2
return|;
case|case
name|LEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCURmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC2
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LTU
case|:
return|return
name|CC2
return|;
case|case
name|GTU
case|:
return|return
name|CC1
return|;
case|case
name|LEU
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCAPmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|GT
case|:
return|return
name|CC2
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCANmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
return|;
case|case
name|GT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCSmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
return|;
case|case
name|GT
case|:
return|return
name|CC2
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|UNORDERED
case|:
return|return
name|CC3
return|;
case|case
name|ORDERED
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC2
return|;
case|case
name|UNEQ
case|:
return|return
name|CC0
operator||
name|CC3
return|;
case|case
name|UNLT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|UNGT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|UNLE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|UNGE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LTGT
case|:
return|return
name|CC1
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCSRmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC2
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC2
return|;
case|case
name|GT
case|:
return|return
name|CC1
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|UNORDERED
case|:
return|return
name|CC3
return|;
case|case
name|ORDERED
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC1
return|;
case|case
name|UNEQ
case|:
return|return
name|CC0
operator||
name|CC3
return|;
case|case
name|UNLT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|UNGT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|UNLE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|UNGE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|LTGT
case|:
return|return
name|CC2
operator||
name|CC1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If INV is false, return assembler mnemonic string to implement    a branch specified by CODE.  If INV is true, return mnemonic    for the corresponding inverted branch.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|s390_branch_condition_mnemonic
parameter_list|(
name|rtx
name|code
parameter_list|,
name|int
name|inv
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mnemonic
index|[
literal|16
index|]
init|=
block|{
name|NULL
block|,
literal|"o"
block|,
literal|"h"
block|,
literal|"nle"
block|,
literal|"l"
block|,
literal|"nhe"
block|,
literal|"lh"
block|,
literal|"ne"
block|,
literal|"e"
block|,
literal|"nlh"
block|,
literal|"he"
block|,
literal|"nl"
block|,
literal|"le"
block|,
literal|"nh"
block|,
literal|"no"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|mask
init|=
name|s390_branch_condition_mask
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|inv
condition|)
name|mask
operator|^=
literal|15
expr_stmt|;
if|if
condition|(
name|mask
operator|<
literal|1
operator|||
name|mask
operator|>
literal|14
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|mnemonic
index|[
name|mask
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the part of op which has a value different from def.    The size of the part is determined by mode.    Use this function only if you already know that op really     contains such a part.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|s390_extract_part
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|def
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
literal|0
decl_stmt|;
name|int
name|max_parts
init|=
name|HOST_BITS_PER_WIDE_INT
operator|/
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|part_bits
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|part_mask
init|=
operator|(
literal|1
operator|<<
name|part_bits
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
name|part_bits
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
name|part_mask
operator|)
operator|!=
operator|(
name|def
operator|&
name|part_mask
operator|)
condition|)
return|return
name|value
operator|&
name|part_mask
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If OP is an integer constant of mode MODE with exactly one    part of mode PART_MODE unequal to DEF, return the number of that    part. Otherwise, return -1.  */
end_comment

begin_function
name|int
name|s390_single_part
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|part_mode
parameter_list|,
name|int
name|def
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
literal|0
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|part_mode
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|part_mask
init|=
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|part_mode
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
name|GET_MODE_BITSIZE
argument_list|(
name|part_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
name|part_mask
operator|)
operator|!=
operator|(
name|def
operator|&
name|part_mask
operator|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|n_parts
operator|-
literal|1
operator|-
name|part
return|;
block|}
end_function

begin_comment
comment|/* Check whether we can (and want to) split a double-word    move in mode MODE from SRC to DST into two single-word    moves, moving the subword FIRST_SUBWORD first.  */
end_comment

begin_function
name|bool
name|s390_split_ok_p
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|first_subword
parameter_list|)
block|{
comment|/* Floating point registers cannot be split.  */
if|if
condition|(
name|FP_REG_P
argument_list|(
name|src
argument_list|)
operator|||
name|FP_REG_P
argument_list|(
name|dst
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We don't need to split if operands are directly accessible.  */
if|if
condition|(
name|s_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
operator|||
name|s_operand
argument_list|(
name|dst
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Non-offsettable memory references cannot be split.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|src
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Moving the first subword must not clobber a register      needed to move the second subword.  */
if|if
condition|(
name|register_operand
argument_list|(
name|dst
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|subreg
init|=
name|operand_subword
argument_list|(
name|dst
argument_list|,
name|first_subword
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|subreg
argument_list|,
name|src
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Change optimizations to be performed, depending on the    optimization level.     LEVEL is the optimization level specified; 2 if `-O2' is    specified, 1 if `-O' is specified, and 0 if neither is specified.     SIZE is nonzero if `-Os' is specified and zero otherwise.  */
end_comment

begin_function
name|void
name|optimization_options
parameter_list|(
name|int
name|level
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* ??? There are apparently still problems with -fcaller-saves.  */
name|flag_caller_saves
operator|=
literal|0
expr_stmt|;
comment|/* By default, always emit DWARF-2 unwind info.  This allows debugging      without maintaining a stack frame back-chain.  */
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|override_options
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
struct|struct
name|pta
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* processor name or nickname.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
name|enum
name|processor_flags
name|flags
decl_stmt|;
block|}
decl|const
name|processor_alias_table
index|[]
init|=
block|{
block|{
literal|"g5"
block|,
name|PROCESSOR_9672_G5
block|,
name|PF_IEEE_FLOAT
block|}
block|,
block|{
literal|"g6"
block|,
name|PROCESSOR_9672_G6
block|,
name|PF_IEEE_FLOAT
block|}
block|,
block|{
literal|"z900"
block|,
name|PROCESSOR_2064_Z900
block|,
name|PF_IEEE_FLOAT
operator||
name|PF_ZARCH
block|}
block|,
block|{
literal|"z990"
block|,
name|PROCESSOR_2084_Z990
block|,
name|PF_IEEE_FLOAT
operator||
name|PF_ZARCH
operator||
name|PF_LONG_DISPLACEMENT
block|}
block|,     }
struct|;
name|int
specifier|const
name|pta_size
init|=
name|ARRAY_SIZE
argument_list|(
name|processor_alias_table
argument_list|)
decl_stmt|;
comment|/* Acquire a unique set number for our register saves and restores.  */
name|s390_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
comment|/* Set up function hooks.  */
name|init_machine_status
operator|=
name|s390_init_machine_status
expr_stmt|;
comment|/* Architecture mode defaults according to ABI.  */
if|if
condition|(
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_ZARCH
operator|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|target_flags
operator||=
name|MASK_ZARCH
expr_stmt|;
else|else
name|target_flags
operator|&=
operator|~
name|MASK_ZARCH
expr_stmt|;
block|}
comment|/* Determine processor architectural level.  */
if|if
condition|(
operator|!
name|s390_arch_string
condition|)
name|s390_arch_string
operator|=
name|TARGET_ZARCH
condition|?
literal|"z900"
else|:
literal|"g5"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s390_arch_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|s390_arch
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
name|s390_arch_flags
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"Unknown cpu used in -march=%s."
argument_list|,
name|s390_arch_string
argument_list|)
expr_stmt|;
comment|/* Determine processor to tune for.  */
if|if
condition|(
operator|!
name|s390_tune_string
condition|)
block|{
name|s390_tune
operator|=
name|s390_arch
expr_stmt|;
name|s390_tune_flags
operator|=
name|s390_arch_flags
expr_stmt|;
name|s390_tune_string
operator|=
name|s390_arch_string
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s390_tune_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|s390_tune
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
name|s390_tune_flags
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"Unknown cpu used in -mtune=%s."
argument_list|,
name|s390_tune_string
argument_list|)
expr_stmt|;
block|}
comment|/* Sanity checks.  */
if|if
condition|(
name|TARGET_ZARCH
operator|&&
operator|!
operator|(
name|s390_arch_flags
operator|&
name|PF_ZARCH
operator|)
condition|)
name|error
argument_list|(
literal|"z/Architecture mode not supported on %s."
argument_list|,
name|s390_arch_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|TARGET_ZARCH
condition|)
name|error
argument_list|(
literal|"64-bit ABI not supported in ESA/390 mode."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map for smallest class containing reg regno.  */
end_comment

begin_decl_stmt
specifier|const
name|enum
name|reg_class
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
name|GENERAL_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|ADDR_REGS
block|,
name|NO_REGS
block|,
name|ADDR_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return attribute type of insn.  */
end_comment

begin_function
specifier|static
name|enum
name|attr_type
name|s390_safe_attr_type
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_type
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|TYPE_NONE
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP a (const_int 0) operand.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|const0_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is constant.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|consttable_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the mode of operand OP matches MODE.    If MODE is set to VOIDmode, set it to the mode of OP.  */
end_comment

begin_function
specifier|static
name|int
name|check_mode
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|*
name|mode
operator|==
name|VOIDmode
condition|)
operator|*
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
operator|*
name|mode
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP a valid operand for the LARL instruction.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|larl_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|check_mode
argument_list|(
name|op
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow labels and local symbols.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
operator|(
operator|(
name|SYMBOL_REF_FLAGS
argument_list|(
name|op
argument_list|)
operator|&
name|SYMBOL_FLAG_ALIGN1
operator|)
operator|==
literal|0
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
comment|/* Everything else must have a CONST, so strip it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow adding *even* in-range constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|32
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
operator|-
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
literal|32
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Labels and local symbols allowed here as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
operator|(
operator|(
name|SYMBOL_REF_FLAGS
argument_list|(
name|op
argument_list|)
operator|&
name|SYMBOL_FLAG_ALIGN1
operator|)
operator|==
literal|0
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
comment|/* Now we must have a @GOTENT offset or @PLT stub      or an @INDNTPOFF TLS offset.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTENT
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_PLT
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_INDNTPOFF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper routine to implement s_operand and s_imm_operand.    OP is the current operation.    MODE is the current operation mode.    ALLOW_IMMEDIATE specifies whether immediate operands should    be accepted or not.  */
end_comment

begin_function
specifier|static
name|int
name|general_s_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|allow_immediate
parameter_list|)
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
comment|/* Call general_operand first, so that we don't have to      check for many special cases.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Just like memory_operand, allow (subreg (mem ...))      after reload.  */
if|if
condition|(
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Constants are OK as s-operand if ALLOW_IMMEDIATE 	 is true and we are still before reload.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
operator|!
name|allow_immediate
operator|||
name|reload_completed
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
comment|/* Memory operands are OK unless they already use an 	 index register.  */
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
return|return
literal|0
return|;
comment|/* Do not allow literal pool references unless ALLOW_IMMEDIATE  	   is true.  This prevents compares between two literal pool  	   entries from being accepted.  */
if|if
condition|(
operator|!
name|allow_immediate
operator|&&
name|addr
operator|.
name|base
operator|&&
name|REGNO
argument_list|(
name|addr
operator|.
name|base
argument_list|)
operator|==
name|BASE_REGISTER
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid S-type operand.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|general_s_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid S-type operand or an immediate    operand that can be addressed as S-type operand by forcing    it into the literal pool.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s_imm_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|general_s_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP a valid shift count operand.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|shift_count_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|check_mode
argument_list|(
name|op
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We can have an integer constant, an address register,      or a sum of the two.  Note that reload already checks      that any register present is an address register, so      we just check for any register here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* Unfortunately we have to reject constants that are invalid      for an address, or else reload will get confused.  */
if|if
condition|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|offset
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if DISP is a valid short displacement.  */
end_comment

begin_function
specifier|static
name|int
name|s390_short_displacement
parameter_list|(
name|rtx
name|disp
parameter_list|)
block|{
comment|/* No displacement is OK.  */
if|if
condition|(
operator|!
name|disp
condition|)
return|return
literal|1
return|;
comment|/* Integer displacement in range.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|disp
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|disp
argument_list|)
operator|<
literal|4096
return|;
comment|/* GOT offset is not OK, the GOT can be large.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
condition|)
return|return
literal|0
return|;
comment|/* All other symbolic constants are literal pool references,      which are OK as the literal pool must be small.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid operand for a C constraint.  */
end_comment

begin_function
name|int
name|s390_extra_constraint_str
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|str
index|[
literal|0
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_LONG_DISPLACEMENT
condition|)
block|{
if|if
condition|(
operator|!
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_LONG_DISPLACEMENT
condition|)
block|{
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
name|TARGET_LONG_DISPLACEMENT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|TARGET_LONG_DISPLACEMENT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* Any invalid address here will be fixed up by reload, 	 so accept it for the most generic constraint.  */
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|TARGET_LONG_DISPLACEMENT
condition|)
block|{
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|TARGET_LONG_DISPLACEMENT
condition|)
return|return
literal|0
return|;
comment|/* Any invalid address here will be fixed up by reload, 	 so accept it for the most generic constraint.  */
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
name|s390_short_displacement
argument_list|(
name|addr
operator|.
name|disp
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'Y'
case|:
return|return
name|shift_count_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if VALUE matches the constraint STR.  */
end_comment

begin_function
name|int
name|s390_const_ok_for_constraint_p
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|,
name|int
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|part_mode
decl_stmt|;
name|int
name|def
decl_stmt|;
name|unsigned
name|char
name|part
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|str
index|[
literal|0
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'I'
case|:
return|return
operator|(
name|unsigned
name|int
operator|)
name|value
operator|<
literal|256
return|;
case|case
literal|'J'
case|:
return|return
operator|(
name|unsigned
name|int
operator|)
name|value
operator|<
literal|4096
return|;
case|case
literal|'K'
case|:
return|return
name|value
operator|>=
operator|-
literal|32768
operator|&&
name|value
operator|<
literal|32768
return|;
case|case
literal|'L'
case|:
return|return
operator|(
name|TARGET_LONG_DISPLACEMENT
condition|?
operator|(
name|value
operator|>=
operator|-
literal|524288
operator|&&
name|value
operator|<=
literal|524287
operator|)
else|:
operator|(
name|value
operator|>=
literal|0
operator|&&
name|value
operator|<=
literal|4095
operator|)
operator|)
return|;
case|case
literal|'M'
case|:
return|return
name|value
operator|==
literal|2147483647
return|;
case|case
literal|'N'
case|:
name|part
operator|=
name|str
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'H'
case|:
name|part_mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|part_mode
operator|=
name|QImode
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|str
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'H'
case|:
name|mode
operator|=
name|HImode
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|str
index|[
literal|4
index|]
condition|)
block|{
case|case
literal|'0'
case|:
name|def
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|def
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|part_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s390_single_part
argument_list|(
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|,
name|mode
argument_list|,
name|part_mode
argument_list|,
name|def
argument_list|)
operator|!=
name|part
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
operator|*
name|total
operator|=
literal|1000
expr_stmt|;
else|else
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST_INT
case|:
comment|/* Force_const_mem does not work out of reload, because the 	 saveable_obstack is set to reload_obstack, which does not 	 live long enough.  Because of this we cannot use force_const_mem 	 in addsi3.  This leads to problems with gen_add2_insn with a 	 constant greater than a short. Because of that we give an 	 addition of greater constants a cost of 3 (reload1.c 10096).  */
comment|/* ??? saveable_obstack no longer exists.  */
if|if
condition|(
name|outer_code
operator|==
name|PLUS
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>
literal|32767
operator|||
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
operator|-
literal|32768
operator|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|PLUS
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|MINUS
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|33
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the cost of an address rtx ADDR.  */
end_comment

begin_function
specifier|static
name|int
name|s390_address_cost
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
condition|)
return|return
literal|1000
return|;
return|return
name|ad
operator|.
name|indx
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid operand for the BRAS instruction.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|bras_sym_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* Allow SYMBOL_REFs.  */
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
comment|/* Allow @PLT stubs.  */
if|if
condition|(
name|code
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_PLT
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If OP is a SYMBOL_REF of a thread-local symbol, return its TLS mode,    otherwise return 0.  */
end_comment

begin_function
name|int
name|tls_symbolic_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if OP is a load multiple operation.  It is known to be a    PARALLEL and the first section will be tested.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|elt_mode
decl_stmt|;
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elt_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check, is base, or base + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_addr
argument_list|)
operator|==
name|REG
condition|)
name|off
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|src_addr
operator|==
name|frame_pointer_rtx
operator|||
name|src_addr
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|elt_mode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|elt_mode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|off
operator|+
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|elt_mode
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a store multiple operation.  It is known to be a    PARALLEL and the first section will be tested.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|elt_mode
decl_stmt|;
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elt_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check, is base, or base + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest_addr
argument_list|)
operator|==
name|REG
condition|)
name|off
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest_addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|dest_addr
operator|==
name|frame_pointer_rtx
operator|||
name|dest_addr
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|elt_mode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|elt_mode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|off
operator|+
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|elt_mode
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP contains a symbol reference */
end_comment

begin_function
name|int
name|symbolic_reference_mentioned_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP contains a reference to a thread-local symbol.  */
end_comment

begin_function
name|int
name|tls_symbolic_reference_mentioned_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|tls_symbolic_operand
argument_list|(
name|op
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|tls_symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|tls_symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a legitimate general operand when    generating PIC code.  It is given that flag_pic is on    and that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|legitimate_pic_operand_p
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|)
block|{
comment|/* Accept all non-symbolic constants.  */
if|if
condition|(
operator|!
name|SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Reject everything else; must be handled      via emit_symbolic_move.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the constant value OP is a legitimate general operand.    It is given that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|legitimate_constant_p
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|)
block|{
comment|/* Accept all non-symbolic constants.  */
if|if
condition|(
operator|!
name|SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Accept immediate LARL operands.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
operator|&&
name|larl_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Thread-local symbols are never legal constants.  This is      so that emit_call knows that computing such addresses      might require a function call.  */
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* In the PIC case, symbolic constants must *not* be      forced into the literal pool.  We accept them here,      so that they will be handled by emit_symbolic_move.  */
if|if
condition|(
name|flag_pic
condition|)
return|return
literal|1
return|;
comment|/* All remaining non-PIC symbolic constants are      forced into the literal pool.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine if it's legal to put X into the constant pool.  This    is not possible if X contains the address of a symbol that is    not constant (TLS) or not known at final link time (PIC).  */
end_comment

begin_function
specifier|static
name|bool
name|s390_cannot_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
comment|/* Accept all non-symbolic constants.  */
return|return
name|false
return|;
case|case
name|LABEL_REF
case|:
comment|/* Labels are OK iff we are non-PIC.  */
return|return
name|flag_pic
operator|!=
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* 'Naked' TLS symbol references are never OK,          non-TLS symbols are OK iff we are non-PIC.  */
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|flag_pic
operator|!=
literal|0
return|;
case|case
name|CONST
case|:
return|return
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
return|return
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|s390_cannot_force_const_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Only lt-relative or GOT-relative UNSPECs are OK.  */
case|case
name|UNSPEC_LTREL_OFFSET
case|:
case|case
name|UNSPEC_GOT
case|:
case|case
name|UNSPEC_GOTOFF
case|:
case|case
name|UNSPEC_PLTOFF
case|:
case|case
name|UNSPEC_TLSGD
case|:
case|case
name|UNSPEC_TLSLDM
case|:
case|case
name|UNSPEC_NTPOFF
case|:
case|case
name|UNSPEC_DTPOFF
case|:
case|case
name|UNSPEC_GOTNTPOFF
case|:
case|case
name|UNSPEC_INDNTPOFF
case|:
return|return
name|false
return|;
default|default:
return|return
name|true
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if the constant value OP is a legitimate general    operand during and after reload.  The difference to    legitimate_constant_p is that this function will not accept    a constant that would need to be forced to the literal pool    before it can be used as operand.  */
end_comment

begin_function
name|int
name|legitimate_reload_constant_p
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|)
block|{
comment|/* Accept la(y) operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Accept l(g)hi operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Accept lliXX operands.  */
if|if
condition|(
name|TARGET_ZARCH
operator|&&
name|s390_single_part
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
name|HImode
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Accept larl operands.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
operator|&&
name|larl_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Everything else cannot be handled without reload.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx OP being reloaded into a reg required to be in class CLASS,    return the class of reg to actually use.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_preferred_reload_class
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
comment|/* This can happen if a floating point constant is being      reloaded into an integer register.  Leave well alone.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|class
operator|!=
name|FP_REGS
condition|)
return|return
name|class
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Constants we cannot reload must be forced into the 	 literal pool.  */
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
if|if
condition|(
name|legitimate_reload_constant_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|class
return|;
else|else
return|return
name|NO_REGS
return|;
comment|/* If a symbolic constant or a PLUS is reloaded, 	 it is most likely being used as an address, so 	 prefer ADDR_REGS.  If 'class' is not a superset 	 of ADDR_REGS, e.g. FP_REGS, reject this reload.  */
case|case
name|PLUS
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|ADDR_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
else|else
return|return
name|NO_REGS
return|;
default|default:
break|break;
block|}
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* Return the register class of a scratch register needed to    load IN into a register of class CLASS in MODE.     We need a temporary when loading a PLUS expression which    is not a legitimate operand of the LOAD ADDRESS instruction.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_secondary_input_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
if|if
condition|(
name|s390_plus_operand
argument_list|(
name|in
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return the register class of a scratch register needed to    store a register of class CLASS in MODE into OUT:     We need a temporary when storing a double-word to a    non-offsettable memory address.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_secondary_output_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|out
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TARGET_64BIT
condition|?
name|mode
operator|==
name|TImode
else|:
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|)
operator|&&
name|reg_classes_intersect_p
argument_list|(
name|GENERAL_REGS
argument_list|,
name|class
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|out
argument_list|)
operator|&&
operator|!
name|s_operand
argument_list|(
name|out
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a PLUS that is not a legitimate    operand for the LA instruction.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s390_plus_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|check_mode
argument_list|(
name|op
argument_list|,
operator|&
name|mode
argument_list|)
operator|||
name|mode
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|legitimate_la_operand_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Generate code to load SRC, which is PLUS that is not a    legitimate operand for the LA instruction, into TARGET.    SCRATCH may be used as scratch register.  */
end_comment

begin_function
name|void
name|s390_expand_plus_operand
parameter_list|(
specifier|register
name|rtx
name|target
parameter_list|,
specifier|register
name|rtx
name|src
parameter_list|,
specifier|register
name|rtx
name|scratch
parameter_list|)
block|{
name|rtx
name|sum1
decl_stmt|,
name|sum2
decl_stmt|;
name|struct
name|s390_address
name|ad
decl_stmt|;
comment|/* src must be a PLUS; get its two operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|Pmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check if any of the two operands is already scheduled      for replacement by reload.  This can happen e.g. when      float registers occur in an address.  */
name|sum1
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum1
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
comment|/* If the address is already strictly valid, there's nothing to do.  */
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|src
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|)
operator|||
operator|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
operator|)
condition|)
block|{
comment|/* Otherwise, one of the operands cannot be an address register;          we reload its value into the scratch register.  */
if|if
condition|(
name|true_regnum
argument_list|(
name|sum1
argument_list|)
operator|<
literal|1
operator|||
name|true_regnum
argument_list|(
name|sum1
argument_list|)
operator|>
literal|15
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|sum1
argument_list|)
expr_stmt|;
name|sum1
operator|=
name|scratch
expr_stmt|;
block|}
if|if
condition|(
name|true_regnum
argument_list|(
name|sum2
argument_list|)
operator|<
literal|1
operator|||
name|true_regnum
argument_list|(
name|sum2
argument_list|)
operator|>
literal|15
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|scratch
expr_stmt|;
block|}
comment|/* According to the way these invalid addresses are generated          in reload.c, it should never happen (at least on s390) that          *neither* of the PLUS components, after find_replacements          was applied, is an address register.  */
if|if
condition|(
name|sum1
operator|==
name|scratch
operator|&&
name|sum2
operator|==
name|scratch
condition|)
block|{
name|debug_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|src
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum1
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the LOAD ADDRESS pattern.  Note that reload of PLUS      is only ever performed on addresses, so we can mark the      sum as legitimate for LA in any case.  */
name|s390_load_address
argument_list|(
name|target
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decompose a RTL expression ADDR for a memory address into    its components, returned in OUT.     Returns 0 if ADDR is not a valid memory address, nonzero    otherwise.  If OUT is NULL, don't return the components,    but check for validity only.     Note: Only addresses in canonical form are recognized.    LEGITIMIZE_ADDRESS should convert non-canonical forms to the    canonical form so that they will be recognized.  */
end_comment

begin_function
specifier|static
name|int
name|s390_decompose_address
parameter_list|(
specifier|register
name|rtx
name|addr
parameter_list|,
name|struct
name|s390_address
modifier|*
name|out
parameter_list|)
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|indx
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|disp
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|pointer
init|=
name|FALSE
decl_stmt|;
name|int
name|base_ptr
init|=
name|FALSE
decl_stmt|;
name|int
name|indx_ptr
init|=
name|FALSE
decl_stmt|;
comment|/* Decompose address into base + index + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|UNSPEC
condition|)
block|{
name|indx
operator|=
name|op0
expr_stmt|;
comment|/* index + base */
name|base
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|op0
expr_stmt|;
comment|/* base + displacement */
name|disp
operator|=
name|op1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index + base + disp */
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Validate base register.  */
if|if
condition|(
name|base
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_LTREL_BASE
condition|)
return|return
name|FALSE
return|;
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|BASE_REGISTER
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|flag_pic
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
name|pointer
operator|=
name|base_ptr
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Validate index register.  */
if|if
condition|(
name|indx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|indx
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_LTREL_BASE
condition|)
return|return
name|FALSE
return|;
name|indx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|BASE_REGISTER
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|flag_pic
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
name|pointer
operator|=
name|indx_ptr
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Prefer to use pointer as base, not index.  */
if|if
condition|(
name|base
operator|&&
name|indx
operator|&&
operator|!
name|base_ptr
operator|&&
operator|(
name|indx_ptr
operator|||
operator|(
operator|!
name|REG_POINTER
argument_list|(
name|base
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|indx
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|indx
expr_stmt|;
name|indx
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Validate displacement.  */
if|if
condition|(
name|disp
condition|)
block|{
comment|/* Allow integer constant in range.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* If the argument pointer is involved, the displacement will change 	     later anyway as the argument pointer gets eliminated.  This could 	     make a valid displacement invalid, but it is more likely to make 	     an invalid displacement valid, because we sometimes access the 	     register save area via negative offsets to the arg pointer. 	     Thus we don't check the displacement for validity here.  If after 	     elimination the displacement turns out to be invalid after all, 	     this is fixed up by reload in any case.  */
if|if
condition|(
name|base
operator|!=
name|arg_pointer_rtx
operator|&&
name|indx
operator|!=
name|arg_pointer_rtx
condition|)
block|{
if|if
condition|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|disp
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* In the small-PIC case, the linker converts @GOT          and @GOTNTPOFF offsets to possible displacements.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
operator|||
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTNTPOFF
operator|)
condition|)
block|{
if|if
condition|(
name|flag_pic
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Accept chunkfied literal pool symbol references.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Likewise if a constant offset is present.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We can convert literal pool addresses to          displacements by basing them off the base register.  */
else|else
block|{
comment|/* In some cases, we can accept an additional              small constant offset.  Split these off here.  */
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now we must have a literal pool address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|disp
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we have an offset, make sure it does not              exceed the size of the constant pool entry.  */
if|if
condition|(
name|offset
operator|&&
name|offset
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|disp
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Either base or index must be free to              hold the base register.  */
if|if
condition|(
name|base
operator|&&
name|indx
condition|)
return|return
name|FALSE
return|;
comment|/* Convert the address.  */
if|if
condition|(
name|base
condition|)
name|indx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|disp
argument_list|)
argument_list|,
name|UNSPEC_LTREL_OFFSET
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|disp
operator|=
name|plus_constant
argument_list|(
name|disp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|indx
condition|)
name|pointer
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|out
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|out
operator|->
name|indx
operator|=
name|indx
expr_stmt|;
name|out
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|out
operator|->
name|pointer
operator|=
name|pointer
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ADDR is a valid memory address.    STRICT specifies whether strict register checking applies.  */
end_comment

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|register
name|rtx
name|addr
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strict
condition|)
block|{
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REG_OK_FOR_INDEX_NONSTRICT_P
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the LA instruction.    In 31-bit, we need to prove that the result is used as an    address, as LA performs only a 31-bit addition.  */
end_comment

begin_function
name|int
name|legitimate_la_operand_p
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|)
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|addr
operator|.
name|pointer
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the LA instruction,    and we prefer to use LA over addition to compute it.  */
end_comment

begin_function
name|int
name|preferred_la_operand_p
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|)
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
operator|!
name|addr
operator|.
name|pointer
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|addr
operator|.
name|pointer
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
name|addr
operator|.
name|base
operator|&&
name|REG_P
argument_list|(
name|addr
operator|.
name|base
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|addr
operator|.
name|base
argument_list|)
operator|)
operator|||
operator|(
name|addr
operator|.
name|indx
operator|&&
name|REG_P
argument_list|(
name|addr
operator|.
name|indx
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|addr
operator|.
name|indx
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Emit a forced load-address operation to load SRC into DST.    This will use the LOAD ADDRESS instruction even in situations    where legitimate_la_operand_p (SRC) returns false.  */
end_comment

begin_function
name|void
name|s390_load_address
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_move_insn
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_force_la_31
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are two types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references, constant pool addresses, and code labels       compute the address as an offset from the GOT, whose base is in       the PIC reg.  Static data objects have SYMBOL_FLAG_LOCAL set to       differentiate them from global data objects.  The returned       address is the PIC reg + an unspec constant.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
block|{
comment|/* This is a local symbol.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
operator|&&
name|larl_operand
argument_list|(
name|addr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
comment|/* Access local symbols PC-relative via LARL.              This is the same as in the non-PIC case, so it is              handled automatically ...  */
block|}
else|else
block|{
comment|/* Access local symbols relative to the GOT.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
comment|/* Assume GOT offset< 4k.  This is handled the same way              in both 31- and 64-bit code (@GOT).  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOT
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we determine the position              of the GOT entry via a PC-relative LARL (@GOTENT).  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTENT
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* If the GOT offset might be>= 4k, we have to load it              from the literal pool (@GOT).  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOT
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If someone moved a GOT-relative UNSPEC                      out of the literal pool, force them back in.  */
case|case
name|UNSPEC_GOTOFF
case|:
case|case
name|UNSPEC_PLTOFF
case|:
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
break|break;
comment|/* @GOT is OK as is if small.  */
case|case
name|UNSPEC_GOT
case|:
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
break|break;
comment|/* @GOTENT is OK as is.  */
case|case
name|UNSPEC_GOTENT
case|:
break|break;
comment|/* @PLT is OK as is on 64-bit, must be converted to                      GOT-relative @PLTOFF on 31-bit.  */
case|case
name|UNSPEC_PLT
case|:
if|if
condition|(
operator|!
name|TARGET_CPU_ZARCH
condition|)
block|{
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_PLTOFF
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
break|break;
comment|/* Everything else cannot happen.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check first to see if this is a constant offset              from a local symbol reference.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op0
argument_list|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|TARGET_CPU_ZARCH
operator|&&
name|larl_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
condition|)
block|{
comment|/* LARL can't handle odd offsets, so emit a                          pair of LARL and LA.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|even
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
decl_stmt|;
name|op0
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|even
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the offset is even, we can just use LARL.                          This will happen automatically.  */
block|}
block|}
else|else
block|{
comment|/* Access local symbols relative to the GOT.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op0
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
comment|/* Now, check whether it is a GOT relative symbol plus offset              that was pulled out of the literal pool.  Force it back in.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XINT
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTOFF
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, compute the sum.  */
else|else
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST
condition|)
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_operand
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Load the thread pointer into a register.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_thread_pointer
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|tp
decl_stmt|;
name|tp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TP
argument_list|)
expr_stmt|;
name|tp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|mark_reg_pointer
argument_list|(
name|tp
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for the tls_get_offset function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|s390_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|s390_tls_get_offset
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s390_tls_symbol
condition|)
name|s390_tls_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__tls_get_offset"
argument_list|)
expr_stmt|;
return|return
name|s390_tls_symbol
return|;
block|}
end_function

begin_comment
comment|/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute    this (thread-local) address.  REG may be used as temporary.  */
end_comment

begin_function
specifier|static
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|,
name|tls_call
decl_stmt|,
name|temp
decl_stmt|,
name|base
decl_stmt|,
name|r2
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
switch|switch
condition|(
name|tls_symbolic_operand
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|r2
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tls_call
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLSGD
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|tls_call
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_call_value_tls
argument_list|(
name|r2
argument_list|,
name|tls_call
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_NTPOFF
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|,
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|r2
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tls_call
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLDM
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|tls_call
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_call_value_tls
argument_list|(
name|r2
argument_list|,
name|tls_call
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLSLDM_NTPOFF
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|,
name|r2
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_DTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
comment|/* Assume GOT offset< 4k.  This is handled the same way 	       in both 31- and 64-bit code.  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we determine the position 	       of the GOT entry via a PC-relative LARL.  */
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_INDNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we have to load it 	       from the literal pool.  */
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|new
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLS_LOAD
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In position-dependent code, load the absolute address of 	       the GOT entry from the literal pool.  */
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_INDNTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|temp
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|new
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_TLS_LOAD
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_NTPOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|get_thread_pointer
argument_list|()
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|s390_load_address
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
switch|switch
condition|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_INDNTPOFF
case|:
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
name|new
operator|=
name|addr
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* for now ... */
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].  */
end_comment

begin_function
name|void
name|emit_symbolic_move
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|temp
init|=
name|no_new_pseudos
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_tls_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address X    to be legitimate.  If we find one, return the new, valid address.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE is the mode of the operand pointed to by X.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
specifier|register
name|rtx
name|x
parameter_list|,
specifier|register
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|TLS_SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|legitimize_tls_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
if|if
condition|(
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
block|}
name|x
operator|=
name|eliminate_constant_term
argument_list|(
name|x
argument_list|,
operator|&
name|constant_term
argument_list|)
expr_stmt|;
comment|/* Optimize loading of large displacements by splitting them      into the multiple of 4K and the rest; this allows the      former to be CSE'd if possible.       Don't do this if the displacement is added to a register      pointing into the stack frame, as the offsets will      change later anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|constant_term
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|TARGET_LONG_DISPLACEMENT
operator|&&
operator|!
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REGNO_PTR_FRAME_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|lower
init|=
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
operator|&
literal|0xfff
decl_stmt|;
name|HOST_WIDE_INT
name|upper
init|=
name|INTVAL
argument_list|(
name|constant_term
argument_list|)
operator|^
name|lower
decl_stmt|;
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|GEN_INT
argument_list|(
name|upper
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|constant_term
operator|=
name|GEN_INT
argument_list|(
name|lower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constant_term
operator|!=
name|const0_rtx
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|constant_term
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Emit code to move LEN bytes from DST to SRC.  */
end_comment

begin_function
name|void
name|s390_expand_movstr
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|len
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_movstr_short
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MVCLE
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movstr_long
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dst_addr
decl_stmt|,
name|src_addr
decl_stmt|,
name|count
decl_stmt|,
name|blocks
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|Pmode
expr_stmt|;
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dst_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|count
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|count
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|count
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dst_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|src_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|VOIDmode
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|src
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|count
argument_list|,
name|constm1_rtx
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|count
condition|)
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_exit_loop_top_cond
argument_list|(
literal|0
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|blocks
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movstr_short
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
literal|255
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|dst_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dst_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|src_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|src_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|blocks
argument_list|,
name|constm1_rtx
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movstr_short
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to clear LEN bytes at DST.  */
end_comment

begin_function
name|void
name|s390_expand_clrstr
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|len
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_clrstr_short
argument_list|(
name|dst
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_MVCLE
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_clrstr_long
argument_list|(
name|dst
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dst_addr
decl_stmt|,
name|src_addr
decl_stmt|,
name|count
decl_stmt|,
name|blocks
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|Pmode
expr_stmt|;
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dst_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|count
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|count
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|count
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dst_addr
argument_list|,
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|VOIDmode
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|count
argument_list|,
name|constm1_rtx
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|count
condition|)
name|emit_move_insn
argument_list|(
name|count
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashr_optab
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|expand_exit_loop_top_cond
argument_list|(
literal|0
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|blocks
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_clrstr_short
argument_list|(
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|255
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s390_load_address
argument_list|(
name|dst_addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dst_addr
argument_list|,
name|GEN_INT
argument_list|(
literal|256
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|add_optab
argument_list|,
name|blocks
argument_list|,
name|constm1_rtx
argument_list|,
name|blocks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|blocks
condition|)
name|emit_move_insn
argument_list|(
name|blocks
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_clrstr_short
argument_list|(
name|dst
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to compare LEN bytes at OP0 with those at OP1,    and return the result in TARGET.  */
end_comment

begin_function
name|void
name|s390_expand_cmpmem
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|len
parameter_list|)
block|{
name|rtx
function_decl|(
modifier|*
name|gen_result
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|DImode
condition|?
name|gen_cmpint_di
operator|:
name|gen_cmpint_si
function_decl|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|protect_from_queue
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|len
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|<=
literal|256
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|>
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_cmpmem_short
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|len
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_result
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if (TARGET_MVCLE) */
block|{
name|emit_insn
argument_list|(
name|gen_cmpmem_long
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_result
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Deactivate for now as profile code cannot cope with      CC being live across basic block boundaries.  */
block|else     {       rtx addr0, addr1, count, blocks, temp;       rtx end_label = gen_label_rtx ();       enum machine_mode mode;       tree type;        mode = GET_MODE (len);       if (mode == VOIDmode)         mode = Pmode;        type = lang_hooks.types.type_for_mode (mode, 1);       if (!type)         abort ();        addr0 = gen_reg_rtx (Pmode);       addr1 = gen_reg_rtx (Pmode);       count = gen_reg_rtx (mode);       blocks = gen_reg_rtx (mode);        convert_move (count, len, 1);       emit_cmp_and_jump_insns (count, const0_rtx, 			       EQ, NULL_RTX, mode, 1, end_label);        emit_move_insn (addr0, force_operand (XEXP (op0, 0), NULL_RTX));       emit_move_insn (addr1, force_operand (XEXP (op1, 0), NULL_RTX));       op0 = change_address (op0, VOIDmode, addr0);       op1 = change_address (op1, VOIDmode, addr1);        temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1, 0);       if (temp != count)         emit_move_insn (count, temp);        temp = expand_binop (mode, ashr_optab, count, GEN_INT (8), blocks, 1, 0);       if (temp != blocks)         emit_move_insn (blocks, temp);        expand_start_loop (1);       expand_exit_loop_top_cond (0, build (NE_EXPR, type, 					   make_tree (type, blocks), 					   make_tree (type, const0_rtx)));        emit_insn (gen_cmpmem_short (op0, op1, GEN_INT (255)));       temp = gen_rtx_NE (VOIDmode, gen_rtx_REG (CCSmode, 33), const0_rtx);       temp = gen_rtx_IF_THEN_ELSE (VOIDmode, temp, 			gen_rtx_LABEL_REF (VOIDmode, end_label), pc_rtx);       temp = gen_rtx_SET (VOIDmode, pc_rtx, temp);       emit_jump_insn (temp);        s390_load_address (addr0, 			 gen_rtx_PLUS (Pmode, addr0, GEN_INT (256)));       s390_load_address (addr1, 			 gen_rtx_PLUS (Pmode, addr1, GEN_INT (256)));        temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1, 0);       if (temp != blocks)         emit_move_insn (blocks, temp);        expand_end_loop ();        emit_insn (gen_cmpmem_short (op0, op1,  				   convert_to_mode (Pmode, count, 1)));       emit_label (end_label);        emit_insn (gen_result (target));     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_function
name|void
name|s390_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|fputs
argument_list|(
literal|"\t.long\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
literal|"\t.quad\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@DTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the name of slightly smaller debug output, and to cater to    general assembler losage, recognize various UNSPEC sequences    and turn them back into a direct symbol reference.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_delegitimize_address
parameter_list|(
name|rtx
name|orig_x
parameter_list|)
block|{
name|rtx
name|x
init|=
name|orig_x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|orig_x
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
block|{
name|y
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
condition|)
return|return
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTENT
condition|)
return|return
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
return|return
name|orig_x
return|;
block|}
end_function

begin_comment
comment|/* Output shift count operand OP to stdio stream FILE.  */
end_comment

begin_function
specifier|static
name|void
name|print_shift_count_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|op
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
comment|/* We can have an integer constant, an address register,      or a sum of the two.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|op
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|ADDR_REGS
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Shift counts are truncated to the low six bits anyway.  */
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|offset
operator|&
literal|63
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in local-dynamic base patterns.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|get_pool_constant
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|tls_symbolic_operand
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output symbolic constant X in assembler syntax to    stdio stream FILE.  */
end_comment

begin_function
name|void
name|s390_output_symbolic_const
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|SYMBOL_REF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand (1)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOTENT
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTENT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOT
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_PLT
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_PLTOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLTOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TLSGD
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@TLSGD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TLSLDM
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@TLSLDM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_DTPOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@DTPOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_NTPOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@NTPOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTNTPOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTNTPOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_INDNTPOFF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@INDNTPOFF"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand (2)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"UNKNOWN in s390_output_symbolic_const !?"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output address operand ADDR in assembler syntax to    stdio stream FILE.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|)
operator|||
operator|(
name|ad
operator|.
name|indx
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"Cannot decompose address."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
name|ad
operator|.
name|indx
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s,%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output operand X in assembler syntax to stdio stream FILE.    CODE specified the format flag.  The following format flags    are recognized:      'C': print opcode suffix for branch condition.     'D': print opcode suffix for inverse branch condition.     'J': print tls_load/tls_gdcall/tls_ldcall suffix     'O': print only the displacement of a memory reference.     'R': print only the base register of a memory reference.     'N': print the second word of a DImode operand.     'M': print the second word of a TImode operand.     'Y': print shift count operand.      'b': print integer X as if it's an unsigned byte.     'x': print integer X as if it's an unsigned word.     'h': print integer X as if it's a signed word.     'i': print the first nonzero HImode part of X.     'j': print the first HImode part unequal to 0xffff of X.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'C'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|s390_branch_condition_mnemonic
argument_list|(
name|x
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|s390_branch_condition_mnemonic
argument_list|(
name|x
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_load:"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSGD
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_gdcall:"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLSLDM
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
literal|":tls_ldcall:"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|)
operator|||
name|ad
operator|.
name|indx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'R'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|)
operator|||
operator|(
name|ad
operator|.
name|base
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|ad
operator|.
name|base
argument_list|)
operator|)
operator|||
name|ad
operator|.
name|indx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'N'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|print_shift_count_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'x'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'i'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|s390_extract_part
argument_list|(
name|x
argument_list|,
name|HImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'j'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|s390_extract_part
argument_list|(
name|x
argument_list|,
name|HImode
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'x'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"UNKNOWN in print_operand !?"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Target hook for assembling integer objects.  We need to define it    here to work a round a bug in some versions of GAS, which couldn't    handle values smaller than INT_MIN when printed in decimal.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
name|aligned_p
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
name|INT_MIN
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.quad\t"
name|HOST_WIDE_INT_PRINT_HEX
literal|"\n"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if register REGNO is used  for forming    a memory address in expression X.  */
end_comment

begin_function
specifier|static
name|int
name|reg_used_in_mem_p
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if expression DEP_RTX sets an address register    used by instruction INSN to address memory.  */
end_comment

begin_function
specifier|static
name|int
name|addr_generation_dependency_p
parameter_list|(
name|rtx
name|dep_rtx
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|target
decl_stmt|,
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|INSN
condition|)
name|dep_rtx
operator|=
name|PATTERN
argument_list|(
name|dep_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
condition|)
block|{
name|target
operator|=
name|SET_DEST
argument_list|(
name|dep_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|target
operator|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|SUBREG
condition|)
name|target
operator|=
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_safe_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_LA
condition|)
block|{
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|get_attr_atype
argument_list|(
name|insn
argument_list|)
operator|==
name|ATYPE_AGEN
condition|)
return|return
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1, if dep_insn sets register used in insn in the agen unit.  */
end_comment

begin_function
name|int
name|s390_agen_dep_p
parameter_list|(
name|rtx
name|dep_insn
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|dep_rtx
init|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
operator|&&
name|addr_generation_dependency_p
argument_list|(
name|dep_rtx
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr_generation_dependency_p
argument_list|(
name|XVECEXP
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the modified cost of the dependency of instruction INSN    on instruction DEP_INSN through the link LINK.  COST is the    default cost of that dependency.     Data dependencies are all handled without delay.  However, if a    register is modified and subsequently used as base or index    register of a memory reference, at least 4 cycles need to pass    between setting and using the register to avoid pipeline stalls.    An exception is the LA instruction. An address generated by LA can    be used by introducing only a one cycle stall on the pipeline.  */
end_comment

begin_function
specifier|static
name|int
name|s390_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|rtx
name|dep_rtx
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If the dependence is an anti-dependence, there is no cost.  For an      output dependence, there is sometimes a cost, but it doesn't seem      worth handling those few cases.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
comment|/* DFA based scheduling checks address dependency in md file.  */
if|if
condition|(
name|s390_use_dfa_pipeline_interface
argument_list|()
condition|)
block|{
comment|/* Operand forward in case of lr, load and la.  */
if|if
condition|(
name|s390_tune
operator|==
name|PROCESSOR_2084_Z990
operator|&&
name|cost
operator|==
literal|1
operator|&&
operator|(
name|s390_safe_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LA
operator|||
name|s390_safe_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LR
operator|||
name|s390_safe_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LOAD
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|cost
return|;
block|}
name|dep_rtx
operator|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
operator|&&
name|addr_generation_dependency_p
argument_list|(
name|dep_rtx
argument_list|,
name|insn
argument_list|)
condition|)
name|cost
operator|+=
operator|(
name|s390_safe_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LA
operator|)
condition|?
literal|1
else|:
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr_generation_dependency_p
argument_list|(
name|XVECEXP
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
name|cost
operator|+=
operator|(
name|s390_safe_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LA
operator|)
condition|?
literal|1
else|:
literal|4
expr_stmt|;
block|}
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* A C statement (sans semicolon) to update the integer scheduling priority    INSN_PRIORITY (INSN).  Increase the priority to execute the INSN earlier,    reduce the priority to execute INSN later.  Do not define this macro if    you do not need to adjust the scheduling priorities of insns.     A STD instruction should be scheduled earlier,    in order to use the bypass.  */
end_comment

begin_function
specifier|static
name|int
name|s390_adjust_priority
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|priority
return|;
if|if
condition|(
name|s390_tune
operator|!=
name|PROCESSOR_2084_Z990
condition|)
return|return
name|priority
return|;
switch|switch
condition|(
name|s390_safe_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_FSTORED
case|:
case|case
name|TYPE_FSTORES
case|:
name|priority
operator|=
name|priority
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|TYPE_STORE
case|:
name|priority
operator|=
name|priority
operator|<<
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|priority
return|;
block|}
end_function

begin_comment
comment|/* The number of instructions that can be issued per cycle.  */
end_comment

begin_function
specifier|static
name|int
name|s390_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|s390_tune
operator|==
name|PROCESSOR_2084_Z990
condition|)
return|return
literal|3
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If the following function returns TRUE, we will use the the DFA    insn scheduler.  */
end_comment

begin_function
specifier|static
name|int
name|s390_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|s390_tune
operator|==
name|PROCESSOR_2064_Z900
operator|||
name|s390_tune
operator|==
name|PROCESSOR_2084_Z990
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390_first_cycle_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|s390_use_dfa_pipeline_interface
argument_list|()
condition|?
literal|4
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called after issuing each insn.    Triggers default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|s390_sched_reorder2
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
modifier|*
name|ready
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|pn_ready
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|clock_var
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|s390_issue_rate
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Split all branches that exceed the maximum distance.    Returns true if this created a new literal pool entry.  */
end_comment

begin_function
specifier|static
name|int
name|s390_split_branches
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|temp_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
decl_stmt|;
name|int
name|new_literal
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|,
name|tmp
decl_stmt|,
name|target
decl_stmt|;
name|rtx
modifier|*
name|label
decl_stmt|;
comment|/* We need correct insn addresses.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Find all branches that exceed 64KB, and split them.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|!=
name|pc_rtx
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
else|else
continue|continue;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|<=
literal|4
condition|)
continue|continue;
comment|/* We are going to use the return register as scratch register, 	 make sure it will be saved/restored by the prologue/epilogue.  */
name|cfun
operator|->
name|machine
operator|->
name|save_return_addr_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|new_literal
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
operator|*
name|label
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|temp_reg
expr_stmt|;
block|}
else|else
block|{
name|new_literal
operator|=
literal|1
expr_stmt|;
name|target
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
operator|*
name|label
argument_list|)
argument_list|,
name|UNSPEC_LTREL_OFFSET
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|target
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|target
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_LTREL_BASE
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
name|label
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|new_literal
return|;
block|}
end_function

begin_comment
comment|/* Find a literal pool symbol referenced in RTX X, and store    it at REF.  Will abort if X contains references to more than    one such pool symbol; multiple references to the same symbol    are allowed, however.     The rtx pointed to by REF must be initialized to NULL_RTX    by the caller before calling this routine.  */
end_comment

begin_function
specifier|static
name|void
name|find_constant_pool_ref
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|ref
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Ignore LTREL_BASE references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_BASE
condition|)
return|return;
comment|/* Likewise POOL_ENTRY insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_POOL_ENTRY
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|ref
operator|==
name|NULL_RTX
condition|)
operator|*
name|ref
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ref
operator|!=
name|x
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|find_constant_pool_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_constant_pool_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace every reference to the literal pool symbol REF    in X by the address ADDR.  Fix up MEMs as required.  */
end_comment

begin_function
specifier|static
name|void
name|replace_constant_pool_ref
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|rtx
name|ref
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
operator|*
name|x
operator|==
name|ref
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Literal pool references can only occur inside a MEM ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|memref
init|=
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|memref
operator|==
name|ref
condition|)
block|{
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|ref
condition|)
block|{
name|HOST_WIDE_INT
name|off
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* ... or a load-address type pattern.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|addrref
init|=
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|addrref
operator|==
name|ref
condition|)
block|{
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addrref
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|ref
condition|)
block|{
name|HOST_WIDE_INT
name|off
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|replace_constant_pool_ref
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_constant_pool_ref
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check whether X contains an UNSPEC_LTREL_BASE.    Return its constant pool symbol if found, NULL_RTX otherwise.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_ltrel_base
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_BASE
condition|)
return|return
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|fnd
init|=
name|find_ltrel_base
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|fnd
init|=
name|find_ltrel_base
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
block|}
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Replace any occurrence of UNSPEC_LTREL_BASE in X with BASE.  */
end_comment

begin_function
specifier|static
name|void
name|replace_ltrel_base
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|rtx
name|base
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
operator|*
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_BASE
condition|)
block|{
operator|*
name|x
operator|=
name|base
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|replace_ltrel_base
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_ltrel_base
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We keep a list of constants which we have to add to internal    constant tables in the middle of large functions.  */
end_comment

begin_define
define|#
directive|define
name|NR_C_MODES
value|7
end_define

begin_decl_stmt
name|enum
name|machine_mode
name|constant_modes
index|[
name|NR_C_MODES
index|]
init|=
block|{
name|TImode
block|,
name|DFmode
block|,
name|DImode
block|,
name|SFmode
block|,
name|SImode
block|,
name|HImode
block|,
name|QImode
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|constant
block|{
name|struct
name|constant
modifier|*
name|next
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|constant_pool
block|{
name|struct
name|constant_pool
modifier|*
name|next
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|rtx
name|pool_insn
decl_stmt|;
name|bitmap
name|insns
decl_stmt|;
name|struct
name|constant
modifier|*
name|constants
index|[
name|NR_C_MODES
index|]
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_mainpool_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_mainpool_finish
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|,
name|rtx
name|base_reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_mainpool_cancel
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_chunkify_start
parameter_list|(
name|rtx
name|base_reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_chunkify_finish
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|,
name|rtx
name|base_reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_chunkify_cancel
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_start_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_end_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_add_pool_insn
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_find_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_add_constant
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|s390_find_constant
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|s390_dump_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_alloc_pool
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s390_free_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create new constant pool covering instructions starting at INSN    and chain it to the end of POOL_LIST.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_start_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
modifier|*
name|pool_list
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|pool
operator|=
name|s390_alloc_pool
argument_list|()
expr_stmt|;
name|pool
operator|->
name|first_insn
operator|=
name|insn
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|pool_list
init|;
operator|*
name|prev
condition|;
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|prev
operator|=
name|pool
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* End range of instructions covered by POOL at INSN and emit    placeholder insn representing the pool.  */
end_comment

begin_function
specifier|static
name|void
name|s390_end_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pool_size
init|=
name|GEN_INT
argument_list|(
name|pool
operator|->
name|size
operator|+
literal|8
comment|/* alignment slop */
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|pool_size
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the list of insns covered by POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_add_pool_insn
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|bitmap_set_bit
argument_list|(
name|pool
operator|->
name|insns
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return pool out of POOL_LIST that covers INSN.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_find_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool_list
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|pool_list
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|pool
operator|->
name|insns
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
break|break;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* Add constant VAL of mode MODE to the constant pool POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_add_constant
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|val
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constant_modes
index|[
name|i
index|]
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NR_C_MODES
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|val
argument_list|,
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
operator|(
expr|struct
name|constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|c
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
expr_stmt|;
name|pool
operator|->
name|constants
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|pool
operator|->
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find constant VAL of mode MODE in the constant pool POOL.    Return an RTX describing the distance from the start of    the pool to the location of the new constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_find_constant
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|val
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constant_modes
index|[
name|i
index|]
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NR_C_MODES
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|val
argument_list|,
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|c
operator|->
name|label
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dump out the constants in POOL.  If REMOTE_LABEL is true,    do not emit the pool base label.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_dump_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|bool
name|remote_label
parameter_list|)
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Pool start insn switches to proper section      and guarantees necessary alignment.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_start_64
argument_list|()
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_start_31
argument_list|()
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_label
condition|)
block|{
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Dump constants in descending alignment requirement order,      ensuring proper alignment for every constant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
comment|/* Convert UNSPEC_LTREL_OFFSET unspecs to pool-relative references.  */
name|rtx
name|value
init|=
name|c
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_OFFSET
operator|&&
name|XVECLEN
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
condition|)
block|{
name|value
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_label_after
argument_list|(
name|c
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|gen_rtx_UNSPEC_VOLATILE
argument_list|(
name|constant_modes
index|[
name|i
index|]
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
argument_list|,
name|UNSPECV_POOL_ENTRY
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|value
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Pool end insn switches back to previous section      and guarantees necessary alignment.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_end_64
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_end_31
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Remove placeholder insn.  */
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Allocate new constant_pool structure.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_alloc_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pool
operator|=
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
name|pool
operator|->
name|constants
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pool
operator|->
name|first_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|pool
operator|->
name|insns
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|pool
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* Free all memory used by POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_free_pool
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constant
modifier|*
name|c
init|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|struct
name|constant
modifier|*
name|next
init|=
name|c
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|next
expr_stmt|;
block|}
block|}
name|BITMAP_XFREE
argument_list|(
name|pool
operator|->
name|insns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Collect main literal pool.  Return NULL on overflow.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_mainpool_start
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|pool
operator|=
name|s390_alloc_pool
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_MAIN_POOL
condition|)
block|{
if|if
condition|(
name|pool
operator|->
name|pool_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
name|rtx
name|constant
init|=
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
decl_stmt|;
name|s390_add_constant
argument_list|(
name|pool
argument_list|,
name|constant
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|pool
operator|->
name|pool_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|size
operator|>=
literal|4096
condition|)
block|{
comment|/* We're going to chunkify the pool, so remove the main 	 pool placeholder insn.  */
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|s390_free_pool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* POOL holds the main literal pool as collected by s390_mainpool_start.    Modify the current function to output the pool constants as well as    the pool register setup instruction.  BASE_REG is the register to    be used as pool base register.  */
end_comment

begin_function
specifier|static
name|void
name|s390_mainpool_finish
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|base_reg
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* If the pool is empty, we're done.  */
if|if
condition|(
name|pool
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|s390_free_pool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We need correct insn addresses.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* On zSeries, we use a LARL to load the pool register.  The pool is      located in the .rodata section, so we emit it after the function.  */
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|insn
operator|=
name|gen_main_base_64
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|const0_rtx
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_dump_pool
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* On S/390, if the total size of the function's code plus literal pool      does not exceed 4096 bytes, we use BASR to set up a function base      pointer, and emit the literal pool at the end of the function.  */
elseif|else
if|if
condition|(
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
argument_list|)
operator|+
name|pool
operator|->
name|size
operator|+
literal|8
comment|/* alignment slop */
operator|<
literal|4096
condition|)
block|{
name|insn
operator|=
name|gen_main_base_31_small
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|const0_rtx
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_dump_pool
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we emit an inline literal pool and use BASR to branch      over it, setting up the pool register at the same time.  */
else|else
block|{
name|rtx
name|pool_end
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|insn
operator|=
name|gen_main_base_31_large
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|,
name|pool_end
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pool
operator|->
name|pool_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool
argument_list|(
name|const0_rtx
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|pool
operator|->
name|pool_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool_end
argument_list|,
name|pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_dump_pool
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Replace all literal pool references.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|replace_ltrel_base
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|base_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
name|addr
operator|=
name|s390_find_constant
argument_list|(
name|pool
argument_list|,
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|replace_constant_pool_ref
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pool_ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Free the pool.  */
name|s390_free_pool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* POOL holds the main literal pool as collected by s390_mainpool_start.    We have decided we cannot use this pool, so revert all changes    to the current function that were done by s390_mainpool_start.  */
end_comment

begin_function
specifier|static
name|void
name|s390_mainpool_cancel
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool
parameter_list|)
block|{
comment|/* We didn't actually change the instruction stream, so simply      free the pool memory.  */
name|s390_free_pool
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Chunkify the literal pool.  BASE_REG is to be used as pool    register.  */
end_comment

begin_define
define|#
directive|define
name|S390_POOL_CHUNK_MIN
value|0xc00
end_define

begin_define
define|#
directive|define
name|S390_POOL_CHUNK_MAX
value|0xe00
end_define

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_chunkify_start
parameter_list|(
name|rtx
name|base_reg
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|,
modifier|*
name|pool_list
init|=
name|NULL
decl_stmt|;
name|int
name|extra_size
init|=
literal|0
decl_stmt|;
name|bitmap
name|far_labels
decl_stmt|;
name|rtx
name|pending_ltrel
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
function_decl|(
modifier|*
name|gen_reload_base
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
init|=
name|TARGET_CPU_ZARCH
condition|?
name|gen_reload_base_64
operator|:
name|gen_reload_base_31
function_decl|;
comment|/* We need correct insn addresses.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Scan all insns and move literals to pool chunks.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Check for pending LTREL_BASE.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|ltrel_base
init|=
name|find_ltrel_base
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ltrel_base
condition|)
block|{
if|if
condition|(
name|ltrel_base
operator|==
name|pending_ltrel
condition|)
name|pending_ltrel
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
name|rtx
name|constant
init|=
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|curr_pool
condition|)
name|curr_pool
operator|=
name|s390_start_pool
argument_list|(
operator|&
name|pool_list
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|s390_add_constant
argument_list|(
name|curr_pool
argument_list|,
name|constant
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|s390_add_pool_insn
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't split the pool chunk between a LTREL_OFFSET load 		 and the corresponding LTREL_BASE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|constant
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|constant
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LTREL_OFFSET
condition|)
block|{
if|if
condition|(
name|pending_ltrel
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pending_ltrel
operator|=
name|pool_ref
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|curr_pool
condition|)
name|s390_add_pool_insn
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* An LTREL_BASE must follow within the same basic block.  */
if|if
condition|(
name|pending_ltrel
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|curr_pool
operator|||
name|INSN_ADDRESSES_SIZE
argument_list|()
operator|<=
operator|(
name|size_t
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|||
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
if|if
condition|(
name|curr_pool
operator|->
name|size
operator|<
name|S390_POOL_CHUNK_MAX
condition|)
continue|continue;
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|chunk_size
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|curr_pool
operator|->
name|first_insn
argument_list|)
argument_list|)
operator|+
name|extra_size
decl_stmt|;
comment|/* We will later have to insert base register reload insns. 	     Those will have an effect on code size, which we need to 	     consider here.  This calculation makes rather pessimistic 	     worst-case assumptions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|extra_size
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|<
name|S390_POOL_CHUNK_MIN
operator|&&
name|curr_pool
operator|->
name|size
operator|<
name|S390_POOL_CHUNK_MIN
condition|)
continue|continue;
comment|/* Pool chunks can only be inserted after BARRIERs ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
name|extra_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ... so if we don't find one in time, create one.  */
elseif|else
if|if
condition|(
operator|(
name|chunk_size
operator|>
name|S390_POOL_CHUNK_MAX
operator|||
name|curr_pool
operator|->
name|size
operator|>
name|S390_POOL_CHUNK_MAX
operator|)
condition|)
block|{
name|rtx
name|label
decl_stmt|,
name|jump
decl_stmt|,
name|barrier
decl_stmt|;
comment|/* We can insert the barrier only after a 'real' insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
continue|continue;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Don't separate LTREL_BASE from the corresponding 		 LTREL_OFFSET load.  */
if|if
condition|(
name|pending_ltrel
condition|)
continue|continue;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|jump
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|barrier
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
name|extra_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|curr_pool
condition|)
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_ltrel
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find all labels that are branched into      from an insn belonging to a different chunk.  */
name|far_labels
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Labels marked with LABEL_PRESERVE_P can be target 	 of non-local jumps, so we have to mark them. 	 The same holds for named labels.  	 Don't do that, however, if it is the label before 	 a jump table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|||
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|vec_insn
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|vec_pat
init|=
name|vec_insn
operator|&&
name|GET_CODE
argument_list|(
name|vec_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|PATTERN
argument_list|(
name|vec_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
if|if
condition|(
operator|!
name|vec_pat
operator|||
operator|!
operator|(
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a direct jump (conditional or unconditional) 	 or a casesi jump, check all potential targets.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
if|if
condition|(
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|label
argument_list|)
operator|!=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
comment|/* Find the jump table used by this casesi jump.  */
name|rtx
name|vec_label
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|vec_insn
init|=
name|next_real_insn
argument_list|(
name|vec_label
argument_list|)
decl_stmt|;
name|rtx
name|vec_pat
init|=
name|vec_insn
operator|&&
name|GET_CODE
argument_list|(
name|vec_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|PATTERN
argument_list|(
name|vec_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|vec_pat
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|diff_p
init|=
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|vec_pat
argument_list|,
name|diff_p
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|vec_pat
argument_list|,
name|diff_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|label
argument_list|)
operator|!=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Insert base register reload insns before every pool.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|base_reg
argument_list|,
name|curr_pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|curr_pool
operator|->
name|first_insn
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Insert base register reload insns at every far label.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|bitmap_bit_p
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
init|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_XFREE
argument_list|(
name|far_labels
argument_list|)
expr_stmt|;
comment|/* Recompute insn addresses.  */
name|init_insn_lengths
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|pool_list
return|;
block|}
end_function

begin_comment
comment|/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.    After we have decided to use this list, finish implementing    all changes to the current function as required.  BASE_REG is    to be used as pool base register.  */
end_comment

begin_function
specifier|static
name|void
name|s390_chunkify_finish
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool_list
parameter_list|,
name|rtx
name|base_reg
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Replace all literal pool references.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|replace_ltrel_base
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|base_reg
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curr_pool
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
name|addr
operator|=
name|s390_find_constant
argument_list|(
name|curr_pool
argument_list|,
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|replace_constant_pool_ref
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pool_ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Dump out all literal pools.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
name|s390_dump_pool
argument_list|(
name|curr_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Free pool list.  */
while|while
condition|(
name|pool_list
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|next
init|=
name|pool_list
operator|->
name|next
decl_stmt|;
name|s390_free_pool
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
name|pool_list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.    We have decided we cannot use this list, so revert all changes    to the current function that were done by s390_chunkify_start.  */
end_comment

begin_function
specifier|static
name|void
name|s390_chunkify_cancel
parameter_list|(
name|struct
name|constant_pool
modifier|*
name|pool_list
parameter_list|)
block|{
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Remove all pool placeholder insns.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
block|{
comment|/* Did we insert an extra barrier?  Remove it.  */
name|rtx
name|barrier
init|=
name|PREV_INSN
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
decl_stmt|;
name|rtx
name|jump
init|=
name|barrier
condition|?
name|PREV_INSN
argument_list|(
name|barrier
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|rtx
name|label
init|=
name|NEXT_INSN
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|jump
operator|&&
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|barrier
operator|&&
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|==
name|BARRIER
operator|&&
name|label
operator|&&
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
condition|)
block|{
name|remove_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|curr_pool
operator|->
name|pool_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Remove all base register reload insns.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
control|)
block|{
name|rtx
name|next_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_RELOAD_BASE
condition|)
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next_insn
expr_stmt|;
block|}
comment|/* Free pool list.  */
while|while
condition|(
name|pool_list
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|next
init|=
name|pool_list
operator|->
name|next
decl_stmt|;
name|s390_free_pool
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
name|pool_list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output to FILE the constant pool entry EXP in mode MODE    with alignment ALIGN.  */
end_comment

begin_function
name|void
name|s390_output_pool_entry
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|exp
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_FLOAT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|r
argument_list|,
name|mode
argument_list|,
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|fputs
argument_list|(
name|integer_asm_op
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assemble_integer
argument_list|(
name|exp
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rework the prolog/epilog to avoid saving/restoring    registers unnecessarily.  BASE_USED specifies whether    the literal pool base register needs to be saved.  */
end_comment

begin_function
specifier|static
name|void
name|s390_optimize_prolog
parameter_list|(
name|bool
name|base_used
parameter_list|)
block|{
name|int
name|save_first
decl_stmt|,
name|save_last
decl_stmt|,
name|restore_first
decl_stmt|,
name|restore_last
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|new_insn
decl_stmt|,
name|next_insn
decl_stmt|;
comment|/* Recompute regs_ever_live data for special registers.  */
name|regs_ever_live
index|[
name|BASE_REGISTER
index|]
operator|=
name|base_used
expr_stmt|;
name|regs_ever_live
index|[
name|RETURN_REGNUM
index|]
operator|=
name|cfun
operator|->
name|machine
operator|->
name|save_return_addr_p
expr_stmt|;
name|regs_ever_live
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|>
literal|0
expr_stmt|;
comment|/* Find first and last gpr to be saved.  */
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|!
name|global_regs
index|[
name|i
index|]
operator|||
name|i
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|i
operator|==
name|RETURN_REGNUM
operator|||
name|i
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|i
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|j
index|]
condition|)
if|if
condition|(
operator|!
name|global_regs
index|[
name|j
index|]
operator|||
name|j
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|j
operator|==
name|RETURN_REGNUM
operator|||
name|j
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|j
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|16
condition|)
block|{
comment|/* Nothing to save/restore.  */
name|save_first
operator|=
name|restore_first
operator|=
operator|-
literal|1
expr_stmt|;
name|save_last
operator|=
name|restore_last
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Save/restore from i to j.  */
name|save_first
operator|=
name|restore_first
operator|=
name|i
expr_stmt|;
name|save_last
operator|=
name|restore_last
operator|=
name|j
expr_stmt|;
block|}
comment|/* Varargs functions need to save gprs 2 to 6.  */
if|if
condition|(
name|current_function_stdarg
condition|)
block|{
name|save_first
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|save_last
operator|<
literal|6
condition|)
name|save_last
operator|=
literal|6
expr_stmt|;
block|}
comment|/* If all special registers are in fact used, there's nothing we      can do, so no point in walking the insn list.  */
if|if
condition|(
name|i
operator|<=
name|BASE_REGISTER
operator|&&
name|j
operator|>=
name|BASE_REGISTER
operator|&&
operator|(
name|TARGET_CPU_ZARCH
operator|||
operator|(
name|i
operator|<=
name|RETURN_REGNUM
operator|&&
name|j
operator|>=
name|RETURN_REGNUM
operator|)
operator|)
condition|)
return|return;
comment|/* Search for prolog/epilog insns and replace them.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
name|int
name|first
decl_stmt|,
name|last
decl_stmt|,
name|off
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|base
decl_stmt|,
name|offset
decl_stmt|;
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|store_multiple_operation
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|first
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|first
operator|>
name|BASE_REGISTER
operator|||
name|last
operator|<
name|BASE_REGISTER
condition|)
continue|continue;
if|if
condition|(
name|save_first
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_insn
operator|=
name|save_gprs
argument_list|(
name|base
argument_list|,
name|off
argument_list|,
name|save_first
argument_list|,
name|save_last
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|BASE_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|BASE_REGISTER
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|save_first
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_insn
operator|=
name|save_gprs
argument_list|(
name|base
argument_list|,
name|off
argument_list|,
name|save_first
argument_list|,
name|save_last
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|load_multiple_operation
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|set
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
operator|+
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|first
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|first
operator|>
name|BASE_REGISTER
operator|||
name|last
operator|<
name|BASE_REGISTER
condition|)
continue|continue;
if|if
condition|(
name|restore_first
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_insn
operator|=
name|restore_gprs
argument_list|(
name|base
argument_list|,
name|off
argument_list|,
name|restore_first
argument_list|,
name|restore_last
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|BASE_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|base
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|-
name|BASE_REGISTER
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|off
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|restore_first
operator|!=
operator|-
literal|1
condition|)
block|{
name|new_insn
operator|=
name|restore_gprs
argument_list|(
name|base
argument_list|,
name|off
argument_list|,
name|restore_first
argument_list|,
name|restore_last
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|new_insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform machine-dependent processing.  */
end_comment

begin_function
specifier|static
name|void
name|s390_reorg
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|base_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
decl_stmt|;
name|bool
name|base_used
init|=
name|false
decl_stmt|;
name|bool
name|pool_overflow
init|=
name|false
decl_stmt|;
comment|/* Make sure all splits have been performed; splits after      machine_dependent_reorg might confuse insn length counts.  */
name|split_all_insns_noflow
argument_list|()
expr_stmt|;
comment|/* In small leaf functions, try to use an unused call-clobbered      register as base register to avoid save/restore overhead.  */
if|if
condition|(
name|current_function_is_leaf
operator|&&
operator|!
name|regs_ever_live
index|[
literal|5
index|]
condition|)
name|base_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Install the main literal pool and the associated base      register load insns.       In addition, there are two problematic situations we need       to correct:       - the literal pool might be> 4096 bytes in size, so that        some of its elements cannot be directly accessed       - a branch target might be> 64K away from the branch, so that        it is not possible to use a PC-relative instruction.       To fix those, we split the single literal pool into multiple      pool chunks, reloading the pool base register at various      points throughout the function to ensure it always points to      the pool chunk the following code expects, and / or replace      PC-relative branches by absolute branches.       However, the two problems are interdependent: splitting the      literal pool can move a branch further away from its target,      causing the 64K limit to overflow, and on the other hand,      replacing a PC-relative branch by an absolute branch means      we need to put the branch target address into the literal      pool, possibly causing it to overflow.       So, we loop trying to fix up both problems until we manage      to satisfy both conditions at the same time.  Note that the      loop is guaranteed to terminate as every pass of the loop      strictly decreases the total number of PC-relative branches      in the function.  (This is not completely true as there      might be branch-over-pool insns introduced by chunkify_start.      Those never need to be split however.)  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
init|=
name|NULL
decl_stmt|;
comment|/* Collect the literal pool.  */
if|if
condition|(
operator|!
name|pool_overflow
condition|)
block|{
name|pool
operator|=
name|s390_mainpool_start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pool
condition|)
name|pool_overflow
operator|=
name|true
expr_stmt|;
block|}
comment|/* If literal pool overflowed, start to chunkify it.  */
if|if
condition|(
name|pool_overflow
condition|)
name|pool
operator|=
name|s390_chunkify_start
argument_list|(
name|base_reg
argument_list|)
expr_stmt|;
comment|/* Split out-of-range branches.  If this has created new 	 literal pool entries, cancel current chunk list and 	 recompute it.  zSeries machines have large branch 	 instructions, so we never need to split a branch.  */
if|if
condition|(
operator|!
name|TARGET_CPU_ZARCH
operator|&&
name|s390_split_branches
argument_list|()
condition|)
block|{
if|if
condition|(
name|pool_overflow
condition|)
name|s390_chunkify_cancel
argument_list|(
name|pool
argument_list|)
expr_stmt|;
else|else
name|s390_mainpool_cancel
argument_list|(
name|pool
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we made it up to here, both conditions are satisfied. 	 Finish up literal pool related changes.  */
if|if
condition|(
operator|(
name|pool_overflow
operator|||
name|pool
operator|->
name|size
operator|>
literal|0
operator|)
operator|&&
name|REGNO
argument_list|(
name|base_reg
argument_list|)
operator|==
name|BASE_REGISTER
condition|)
name|base_used
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|pool_overflow
condition|)
name|s390_chunkify_finish
argument_list|(
name|pool
argument_list|,
name|base_reg
argument_list|)
expr_stmt|;
else|else
name|s390_mainpool_finish
argument_list|(
name|pool
argument_list|,
name|base_reg
argument_list|)
expr_stmt|;
break|break;
block|}
name|s390_optimize_prolog
argument_list|(
name|base_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an RTL expression representing the value of the return address    for the frame COUNT steps up from the current frame.  FRAME is the    frame pointer of that frame.  */
end_comment

begin_function
name|rtx
name|s390_return_addr_rtx
parameter_list|(
name|int
name|count
parameter_list|,
name|rtx
name|frame
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* Without backchain, we fail for all but the current frame.  */
if|if
condition|(
operator|!
name|TARGET_BACKCHAIN
operator|&&
name|count
operator|>
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* For the current frame, we need to make sure the initial      value of RETURN_REGNUM is actually saved.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|cfun
operator|->
name|machine
operator|->
name|save_return_addr_p
operator|=
name|true
expr_stmt|;
comment|/* To retrieve the return address we read the stack slot where the      corresponding RETURN_REGNUM value was saved.  */
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame
argument_list|,
name|RETURN_REGNUM
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find first call clobbered register unsused in a function.    This could be used as base register in a leaf function    or for holding the return address before epilogue.  */
end_comment

begin_function
specifier|static
name|int
name|find_unused_clobbered_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill FRAME with info about frame of current function.  */
end_comment

begin_function
specifier|static
name|void
name|s390_frame_info
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|HOST_WIDE_INT
name|fsize
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|fsize
operator|>
literal|0x7fff0000
condition|)
name|fatal_error
argument_list|(
literal|"Total size of local variables exceeds architecture limit."
argument_list|)
expr_stmt|;
comment|/* fprs 8 - 15 are caller saved for 64 Bit ABI.  */
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|=
name|fsize
operator|+
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
operator|*
literal|64
expr_stmt|;
comment|/* Does function need to setup frame and save area.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|||
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|>
literal|0
operator|||
name|current_function_calls_alloca
operator|||
name|current_function_stdarg
condition|)
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|+=
name|STARTING_FRAME_OFFSET
expr_stmt|;
comment|/* If we use the return register, we'll need to make sure      it is going to be saved/restored.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|||
name|regs_ever_live
index|[
name|RETURN_REGNUM
index|]
condition|)
name|cfun
operator|->
name|machine
operator|->
name|save_return_addr_p
operator|=
literal|1
expr_stmt|;
comment|/* Find first and last gpr to be saved.  Note that at this point,      we assume the base register and -on S/390- the return register      always need to be saved.  This is done because the usage of these      register might change even after the prolog was emitted.      If it turns out later that we really don't need them, the      prolog/epilog code is modified again.  */
name|regs_ever_live
index|[
name|BASE_REGISTER
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_CPU_ZARCH
operator|||
name|cfun
operator|->
name|machine
operator|->
name|save_return_addr_p
condition|)
name|regs_ever_live
index|[
name|RETURN_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|>
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
if|if
condition|(
operator|!
name|global_regs
index|[
name|i
index|]
operator|||
name|i
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|i
operator|==
name|RETURN_REGNUM
operator|||
name|i
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|i
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|j
index|]
condition|)
if|if
condition|(
operator|!
name|global_regs
index|[
name|j
index|]
operator|||
name|j
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|j
operator|==
name|RETURN_REGNUM
operator|||
name|j
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|j
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
break|break;
comment|/* Save / Restore from gpr i to j.  */
name|cfun
operator|->
name|machine
operator|->
name|first_save_gpr
operator|=
name|i
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|=
name|i
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
operator|=
name|j
expr_stmt|;
comment|/* Varargs functions need to save gprs 2 to 6.  */
if|if
condition|(
name|current_function_stdarg
condition|)
name|cfun
operator|->
name|machine
operator|->
name|first_save_gpr
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return offset between argument pointer and frame pointer    initially after prologue.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|s390_arg_frame_offset
parameter_list|(
name|void
parameter_list|)
block|{
name|HOST_WIDE_INT
name|fsize
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
name|int
name|save_fprs_p
decl_stmt|,
name|i
decl_stmt|;
comment|/* fprs 8 - 15 are caller saved for 64 Bit ABI.  */
name|save_fprs_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|save_fprs_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|fsize
operator|=
name|fsize
operator|+
name|save_fprs_p
operator|*
literal|64
expr_stmt|;
comment|/* Does function need to setup frame and save area.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|||
name|fsize
operator|>
literal|0
operator|||
name|current_function_calls_alloca
operator|||
name|current_function_stdarg
condition|)
name|fsize
operator|+=
name|STARTING_FRAME_OFFSET
expr_stmt|;
return|return
name|fsize
operator|+
name|STACK_POINTER_OFFSET
return|;
block|}
end_function

begin_comment
comment|/* Emit insn to save fpr REGNUM at offset OFFSET relative    to register BASE.  Return generated insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_fpr
parameter_list|(
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regnum
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit insn to restore fpr REGNUM from offset OFFSET relative    to register BASE.  Return generated insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|restore_fpr
parameter_list|(
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate insn to save registers FIRST to LAST into    the register save area located at offset OFFSET    relative to register BASE.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_gprs
parameter_list|(
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|int
name|i
decl_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
name|first
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
comment|/* Special-case single register.  */
if|if
condition|(
name|first
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_movdi
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_movsi
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|insn
return|;
block|}
name|insn
operator|=
name|gen_store_multiple
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to set the FRAME_RELATED flag on all SETs      inside the store-multiple pattern.       However, we must not emit DWARF records for registers 2..5      if they are stored for use by variable arguments ...       ??? Unfortunately, it is not enough to simply not the the      FRAME_RELATED flags for those SETs, because the first SET      of the PARALLEL is always treated as if it had the flag      set, even if it does not.  Therefore we emit a new pattern      without those registers as REG_FRAME_RELATED_EXPR note.  */
if|if
condition|(
name|first
operator|>=
literal|6
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|>=
literal|6
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|6
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_store_multiple
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|6
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
literal|6
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|note
operator|=
name|PATTERN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|note
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Generate insn to restore registers FIRST to LAST from    the register save area located at offset OFFSET    relative to register BASE.  */
end_comment

begin_function
specifier|static
name|rtx
name|restore_gprs
parameter_list|(
name|rtx
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|insn
decl_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
name|first
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
comment|/* Special-case single register.  */
if|if
condition|(
name|first
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|gen_movdi
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_movsi
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
name|insn
operator|=
name|gen_load_multiple
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|first
argument_list|)
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit code to load the GOT register.  If MAYBE_DEAD is true,    annotate generated insns with REG_MAYBE_DEAD notes.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|got_symbol
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|s390_load_got
parameter_list|(
name|int
name|maybe_dead
parameter_list|)
block|{
if|if
condition|(
operator|!
name|got_symbol
condition|)
block|{
name|got_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|got_symbol
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
block|{
name|rtx
name|insn
init|=
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|got_symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|maybe_dead
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|offset
decl_stmt|,
name|insn
decl_stmt|;
name|offset
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|got_symbol
argument_list|)
argument_list|,
name|UNSPEC_LTREL_OFFSET
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|maybe_dead
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_LTREL_BASE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|maybe_dead
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|s390_emit_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|rtx
name|temp_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Compute frame_info.  */
name|s390_frame_info
argument_list|()
expr_stmt|;
comment|/* Choose best register to use for temp use within prologue.      See below for why TPF must use the register 1.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|&&
operator|!
name|TARGET_TPF
condition|)
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
else|else
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Save call saved gprs.  */
name|insn
operator|=
name|save_gprs
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|first_save_gpr
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Dummy insn to mark literal pool slot.  */
name|emit_insn
argument_list|(
name|gen_main_pool
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Save fprs for variable args.  */
if|if
condition|(
name|current_function_stdarg
condition|)
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
operator|(
name|TARGET_64BIT
condition|?
literal|20
else|:
literal|18
operator|)
condition|;
name|i
operator|++
control|)
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|16
operator|*
name|UNITS_PER_WORD
operator|+
literal|8
operator|*
operator|(
name|i
operator|-
literal|16
operator|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Save fprs 4 and 6 if used (31 bit ABI).  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
for|for
control|(
name|i
operator|=
literal|18
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|insn
operator|=
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|16
operator|*
name|UNITS_PER_WORD
operator|+
literal|8
operator|*
operator|(
name|i
operator|-
literal|16
operator|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Decrement stack pointer.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|>
literal|0
condition|)
block|{
name|rtx
name|frame_off
init|=
name|GEN_INT
argument_list|(
operator|-
name|cfun
operator|->
name|machine
operator|->
name|frame_size
argument_list|)
decl_stmt|;
comment|/* Save incoming stack pointer into temp reg.  */
if|if
condition|(
name|TARGET_BACKCHAIN
operator|||
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|temp_reg
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Subtract frame size from stack pointer.  */
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|)
condition|)
block|{
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
name|frame_off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|cfun
operator|->
name|machine
operator|->
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set backchain.  */
if|if
condition|(
name|TARGET_BACKCHAIN
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|addr
argument_list|,
name|temp_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we support asynchronous exceptions (e.g. for Java), 	 we need to make sure the backchain pointer is set up 	 before any possibly trapping memory access.  */
if|if
condition|(
name|TARGET_BACKCHAIN
operator|&&
name|flag_non_call_exceptions
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|VOIDmode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save fprs 8 - 15 (64 bit ABI).  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|temp_reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|rtx
name|addr
init|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|-
literal|64
operator|+
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|)
decl_stmt|;
name|insn
operator|=
name|save_fpr
argument_list|(
name|temp_reg
argument_list|,
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set frame pointer, if needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set up got pointer, if needed.  */
if|if
condition|(
name|flag_pic
operator|&&
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|s390_load_got
argument_list|(
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_TPF
condition|)
block|{
comment|/* Generate a BAS instruction to serve as a function 	 entry intercept to facilitate the use of tracing 	 algorithms located at the branch target.  	 This must use register 1.  */
name|rtx
name|addr
decl_stmt|;
name|rtx
name|unkn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|addr
operator|=
name|GEN_INT
argument_list|(
literal|0xfe0
argument_list|)
expr_stmt|;
name|unkn
operator|=
name|CONST0_RTX
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|link
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_call_exp
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|unkn
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit a blockage here so that all code 	 lies between the profiling mechanisms.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand the epilogue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|s390_emit_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|frame_pointer
decl_stmt|,
name|return_reg
decl_stmt|;
name|int
name|area_bottom
decl_stmt|,
name|area_top
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_TPF
condition|)
block|{
comment|/* Generate a BAS instruction to serve as a function 	 entry intercept to facilitate the use of tracing 	 algorithms located at the branch target.  	 This must use register 1.  */
name|rtx
name|addr
decl_stmt|;
name|rtx
name|unkn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|addr
operator|=
name|GEN_INT
argument_list|(
literal|0xfe6
argument_list|)
expr_stmt|;
name|unkn
operator|=
name|CONST0_RTX
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|link
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Emit a blockage here so that all code          lies between the profiling mechanisms.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_call_exp
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|unkn
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check whether to use frame or stack pointer for restore.  */
name|frame_pointer
operator|=
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
expr_stmt|;
comment|/* Compute which parts of the save area we need to access.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|area_bottom
operator|=
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|area_top
operator|=
operator|(
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
operator|+
literal|1
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
block|{
name|area_bottom
operator|=
name|INT_MAX
expr_stmt|;
name|area_top
operator|=
name|INT_MIN
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
condition|)
block|{
if|if
condition|(
name|area_bottom
operator|>
operator|-
literal|64
condition|)
name|area_bottom
operator|=
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|area_top
operator|<
literal|0
condition|)
name|area_top
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|18
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|area_bottom
operator|>
literal|16
operator|*
name|UNITS_PER_WORD
operator|+
literal|8
operator|*
operator|(
name|i
operator|-
literal|16
operator|)
condition|)
name|area_bottom
operator|=
literal|16
operator|*
name|UNITS_PER_WORD
operator|+
literal|8
operator|*
operator|(
name|i
operator|-
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|area_top
operator|<
literal|16
operator|*
name|UNITS_PER_WORD
operator|+
literal|8
operator|*
operator|(
name|i
operator|-
literal|16
operator|)
operator|+
literal|8
condition|)
name|area_top
operator|=
literal|16
operator|*
name|UNITS_PER_WORD
operator|+
literal|8
operator|*
operator|(
name|i
operator|-
literal|16
operator|)
operator|+
literal|8
expr_stmt|;
block|}
block|}
comment|/* Check whether we can access the register save area.      If not, increment the frame pointer as required.  */
if|if
condition|(
name|area_top
operator|<=
name|area_bottom
condition|)
block|{
comment|/* Nothing to restore.  */
block|}
elseif|else
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|+
name|area_bottom
argument_list|)
operator|&&
name|DISP_IN_RANGE
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|+
name|area_top
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* Area is in range.  */
name|offset
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame_size
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|insn
decl_stmt|,
name|frame_off
decl_stmt|;
name|offset
operator|=
name|area_bottom
operator|<
literal|0
condition|?
operator|-
name|area_bottom
else|:
literal|0
expr_stmt|;
name|frame_off
operator|=
name|GEN_INT
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|)
condition|)
block|{
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|frame_pointer
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
name|frame_off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|frame_pointer
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore call saved fprs.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|save_fprs_p
condition|)
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|-
literal|64
operator|+
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|18
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
literal|16
operator|*
name|UNITS_PER_WORD
operator|+
literal|8
operator|*
operator|(
name|i
operator|-
literal|16
operator|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Return register.  */
name|return_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
comment|/* Restore call saved gprs.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for global register and save them 	 to stack location from where they get restored.  */
for|for
control|(
name|i
operator|=
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
init|;
name|i
operator|<=
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
condition|;
name|i
operator|++
control|)
block|{
comment|/* These registers are special and need to be 	     restored in any case.  */
if|if
condition|(
name|i
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|i
operator|==
name|RETURN_REGNUM
operator|||
name|i
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|i
operator|==
operator|(
name|int
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|i
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fetch return address from stack before load multiple, 	 this will do good for scheduling.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|save_return_addr_p
operator|||
operator|(
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
operator|<
name|BASE_REGISTER
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
operator|>
name|RETURN_REGNUM
operator|)
condition|)
block|{
name|int
name|return_regnum
init|=
name|find_unused_clobbered_reg
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|return_regnum
condition|)
name|return_regnum
operator|=
literal|4
expr_stmt|;
name|return_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|return_regnum
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|RETURN_REGNUM
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* ??? As references to the base register are not made 	 explicit in insn RTX code, we have to add a barrier here 	 to prevent incorrect scheduling.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|insn
operator|=
name|restore_gprs
argument_list|(
name|frame_pointer
argument_list|,
name|offset
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|first_restore_gpr
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|last_save_gpr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Return to caller.  */
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|return_reg
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size in bytes of a function argument of    type TYPE and/or mode MODE.  At least one of TYPE or    MODE must be specified.  */
end_comment

begin_function
specifier|static
name|int
name|s390_function_arg_size
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
condition|)
return|return
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
return|;
comment|/* No type info available for some library calls ...  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
comment|/* If we have neither type nor mode, abort */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if a function argument of type TYPE and mode MODE    is to be passed in a floating-point register, if available.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_function_arg_float
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
condition|)
return|return
name|false
return|;
comment|/* Soft-float changes the ABI: no floating-point registers are used.  */
if|if
condition|(
name|TARGET_SOFT_FLOAT
condition|)
return|return
name|false
return|;
comment|/* No type info available for some library calls ...  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
return|;
comment|/* The ABI says that record types with a single member are treated      just like that member would be.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|,
name|single
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|single
operator|==
name|NULL_TREE
condition|)
name|single
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
block|}
if|if
condition|(
name|single
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
else|else
name|type
operator|=
name|single
expr_stmt|;
block|}
return|return
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
return|;
block|}
end_function

begin_comment
comment|/* Return true if a function argument of type TYPE and mode MODE    is to be passed in an integer register, or a pair of integer    registers, if available.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_function_arg_integer
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
condition|)
return|return
name|false
return|;
comment|/* No type info available for some library calls ...  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
operator|(
name|TARGET_SOFT_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|)
return|;
comment|/* We accept small integral (and similar) types.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
operator|(
name|TARGET_SOFT_FLOAT
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
condition|)
return|return
name|true
return|;
comment|/* We also accept structs of size 1, 2, 4, 8 that are not      passed in floating-point registers.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|exact_log2
argument_list|(
name|size
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|s390_function_arg_float
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if a function argument of type TYPE and mode MODE    is to be passed by reference.  The ABI specifies that only    structures of size 1, 2, 4, or 8 bytes are passed by value,    all other structures (and complex numbers) are passed by    reference.  */
end_comment

begin_function
name|int
name|s390_function_arg_pass_by_reference
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|8
condition|)
return|return
name|true
return|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|exact_log2
argument_list|(
name|size
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument of mode MODE and    data type TYPE.  (TYPE is null for libcalls where that information    may not be available.).  The boolean NAMED specifies whether the    argument is a named argument (as opposed to an unnamed argument    matching an ellipsis).  */
end_comment

begin_function
name|void
name|s390_function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|cum
operator|->
name|gprs
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_float
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|cum
operator|->
name|fprs
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_integer
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|cum
operator|->
name|gprs
operator|+=
operator|(
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).     On S/390, we use general purpose registers 2 through 6 to    pass integer, pointer, and certain structure arguments, and    floating point registers 0 and 2 (0, 2, 4, and 6 on 64-bit)    to pass floating point arguments.  All remaining arguments    are pushed to the stack.  */
end_comment

begin_function
name|rtx
name|s390_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s390_function_arg_float
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fprs
operator|+
literal|1
operator|>
operator|(
name|TARGET_64BIT
condition|?
literal|4
else|:
literal|2
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|cum
operator|->
name|fprs
operator|+
literal|16
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_integer
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|n_gprs
init|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|gprs
operator|+
name|n_gprs
operator|>
literal|5
condition|)
return|return
literal|0
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|cum
operator|->
name|gprs
operator|+
literal|2
argument_list|)
return|;
block|}
comment|/* After the real arguments, expand_call calls us once again      with a void_type_node type.  Whatever we return here is      passed as operand 2 to the call expanders.       We don't need this feature ...  */
elseif|else
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
return|return
name|const0_rtx
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if return values of type TYPE should be returned    in a memory buffer whose address is passed by the caller as    hidden first argument.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fundecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We accept small integral (and similar) types.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|8
return|;
comment|/* Aggregates and similar constructs are always returned      in memory.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|true
return|;
comment|/* ??? We get called on all sorts of random stuff from      aggregate_value_p.  We can't abort, but it's not clear      what's safe to return.  Pretend it's a struct I guess.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Define where to return a (scalar) value of type TYPE.    If TYPE is null, define where to return a (scalar)    value of mode MODE from a libcall.  */
end_comment

begin_function
name|rtx
name|s390_function_value
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|type
condition|)
block|{
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|mode
operator|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|8
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
literal|16
argument_list|)
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create and return the va_list datatype.     On S/390, va_list is an array type equivalent to        typedef struct __va_list_tag         {             long __gpr;             long __fpr;             void *__overflow_arg_area;             void *__reg_save_area;         } va_list[1];     where __gpr and __fpr hold the number of general purpose    or floating point arguments used up to now, respectively,    __overflow_arg_area points to the stack location of the    next argument passed on the stack, and __reg_save_area    always points to the start of the register area in the    call frame of the current function.  The function prologue    saves all registers used for argument passing into this    area if the function uses variable arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|s390_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
name|record
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__gpr"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__fpr"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement va_start by filling the va_list structure VALIST.    STDARG_P is always true, and ignored.    NEXTARG points to the first anonymous stack argument.     The following global variables are used to initialize    the va_list structure:       current_function_args_info:        holds number of gprs and fprs used for named arguments.      current_function_arg_offset_rtx:        holds the offset of the first anonymous stack argument        (relative to the virtual arg pointer).  */
end_comment

begin_function
name|void
name|s390_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|int
name|off
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|gprs
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|fprs
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|n_gpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|n_fpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the overflow area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|current_function_arg_offset_rtx
argument_list|)
expr_stmt|;
name|off
operator|=
name|off
operator|<
literal|0
condition|?
literal|0
else|:
name|off
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: n_gpr = %d, n_fpr = %d off %d\n"
argument_list|,
operator|(
name|int
operator|)
name|n_gpr
argument_list|,
operator|(
name|int
operator|)
name|n_fpr
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|off
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the register save area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|STACK_POINTER_OFFSET
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg by updating the va_list structure    VALIST as required to retrieve an argument of type    TYPE, and returning that argument.     Generates code equivalent to:     if (integral value) {      if (size<= 4&& args.gpr< 5 ||          size> 4&& args.gpr< 4 )        ret = args.reg_save_area[args.gpr+8]      else        ret = *args.overflow_arg_area++;    } else if (float value) {      if (args.fgpr< 2)        ret = args.reg_save_area[args.fpr+64]      else        ret = *args.overflow_arg_area++;    } else if (aggregate value) {      if (args.gpr< 5)        ret = *args.reg_save_area[args.gpr]      else        ret = **args.overflow_arg_area++;    } */
end_comment

begin_function
name|rtx
name|s390_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|reg
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|;
name|int
name|indirect_p
decl_stmt|,
name|size
decl_stmt|,
name|n_reg
decl_stmt|,
name|sav_ofs
decl_stmt|,
name|sav_scale
decl_stmt|,
name|max_reg
decl_stmt|;
name|rtx
name|lab_false
decl_stmt|,
name|lab_over
decl_stmt|,
name|addr_rtx
decl_stmt|,
name|r
decl_stmt|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: aggregate type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Aggregates are passed by reference.  */
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|sav_scale
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|size
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|max_reg
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_float
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: float type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* FP args go in FP registers, if present.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|fpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|16
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|sav_scale
operator|=
literal|8
expr_stmt|;
comment|/* TARGET_64BIT has up to 4 parameter in fprs */
name|max_reg
operator|=
name|TARGET_64BIT
condition|?
literal|3
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: other type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise into GP registers.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|sav_ofs
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
condition|)
name|sav_ofs
operator|+=
name|UNITS_PER_WORD
operator|-
name|size
expr_stmt|;
name|sav_scale
operator|=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|n_reg
operator|>
literal|1
condition|)
name|max_reg
operator|=
literal|3
expr_stmt|;
else|else
name|max_reg
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Pull the value out of the saved registers ...  */
name|lab_false
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab_over
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|reg
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|max_reg
argument_list|)
argument_list|,
name|GT
argument_list|,
name|const1_rtx
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav_ofs
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|build_int_2
argument_list|(
name|sav_ofs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|sav
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|long_integer_type_node
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|sav_scale
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab_over
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab_false
argument_list|)
expr_stmt|;
comment|/* ... Otherwise out of the overflow area.  */
name|t
operator|=
name|save_expr
argument_list|(
name|ovf
argument_list|)
expr_stmt|;
comment|/* In 64 BIT for each argument on stack, a full 64 bit slot is allocated.  */
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|UNITS_PER_WORD
operator|-
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|save_expr
argument_list|(
name|ovf
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab_over
argument_list|)
expr_stmt|;
comment|/* If less than max_regs a registers are retrieved out      of register save area, increment.  */
name|u
operator|=
name|build
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|n_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|u
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
block|{
name|r
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|r
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|addr_rtx
return|;
block|}
end_function

begin_comment
comment|/* Builtins.  */
end_comment

begin_enum
enum|enum
name|s390_builtin
block|{
name|S390_BUILTIN_THREAD_POINTER
block|,
name|S390_BUILTIN_SET_THREAD_POINTER
block|,
name|S390_BUILTIN_max
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|unsigned
name|int
specifier|const
name|code_for_builtin_64
index|[
name|S390_BUILTIN_max
index|]
init|=
block|{
name|CODE_FOR_get_tp_64
block|,
name|CODE_FOR_set_tp_64
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
specifier|const
name|code_for_builtin_31
index|[
name|S390_BUILTIN_max
index|]
init|=
block|{
name|CODE_FOR_get_tp_31
block|,
name|CODE_FOR_set_tp_31
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|s390_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|ftype
decl_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|S390_BUILTIN_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_set_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|S390_BUILTIN_SET_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
define|#
directive|define
name|MAX_ARGS
value|2
name|unsigned
name|int
specifier|const
modifier|*
name|code_for_builtin
init|=
name|TARGET_64BIT
condition|?
name|code_for_builtin_64
else|:
name|code_for_builtin_31
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|op
index|[
name|MAX_ARGS
index|]
decl_stmt|,
name|pat
decl_stmt|;
name|int
name|arity
decl_stmt|;
name|bool
name|nonvoid
decl_stmt|;
if|if
condition|(
name|fcode
operator|>=
name|S390_BUILTIN_max
condition|)
name|internal_error
argument_list|(
literal|"bad builtin fcode"
argument_list|)
expr_stmt|;
name|icode
operator|=
name|code_for_builtin
index|[
name|fcode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
literal|0
condition|)
name|internal_error
argument_list|(
literal|"bad builtin fcode"
argument_list|)
expr_stmt|;
name|nonvoid
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
expr_stmt|;
for|for
control|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|,
name|arity
operator|=
literal|0
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|,
name|arity
operator|++
control|)
block|{
specifier|const
name|struct
name|insn_operand_data
modifier|*
name|insn_op
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|arity
operator|>
name|MAX_ARGS
condition|)
return|return
name|NULL_RTX
return|;
name|insn_op
operator|=
operator|&
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|arity
operator|+
name|nonvoid
index|]
expr_stmt|;
name|op
index|[
name|arity
index|]
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|insn_op
operator|->
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_op
operator|->
name|predicate
call|)
argument_list|(
name|op
index|[
name|arity
index|]
argument_list|,
name|insn_op
operator|->
name|mode
argument_list|)
condition|)
name|op
index|[
name|arity
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_op
operator|->
name|mode
argument_list|,
name|op
index|[
name|arity
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nonvoid
condition|)
block|{
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|arity
condition|)
block|{
case|case
literal|0
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|nonvoid
condition|)
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonvoid
condition|)
return|return
name|target
return|;
else|else
return|return
name|const0_rtx
return|;
block|}
end_function

begin_comment
comment|/* Output assembly code for the trampoline template to    stdio stream FILE.     On S/390, we use gpr 1 internally in the trampoline code;    gpr 0 is used to hold the static chain.  */
end_comment

begin_function
name|void
name|s390_trampoline_template
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"larl\t%s,0f\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lg\t%s,0(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lg\t%s,8(%s)\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"br\t%s\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0:\t.quad\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".quad\t0\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"basr\t%s,0\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l\t%s,10(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l\t%s,14(%s)\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"br\t%s\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".long\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".long\t0\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|s390_initialize_trampoline
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|)
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|20
else|:
literal|12
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|28
else|:
literal|16
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return rtx for 64-bit constant formed from the 32-bit subwords    LOW and HIGH, independent of the host word size.  */
end_comment

begin_function
name|rtx
name|s390_gen_rtx_const_DI
parameter_list|(
name|int
name|high
parameter_list|,
name|int
name|low
parameter_list|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|high
expr_stmt|;
name|val
operator|<<=
literal|32
expr_stmt|;
name|val
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|low
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|32
return|return
name|immed_double_const
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|low
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|high
argument_list|,
name|DImode
argument_list|)
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output assembler code to FILE to increment profiler label # LABELNO    for profiling a function entry.  */
end_comment

begin_function
name|void
name|s390_function_profiler
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|labelno
parameter_list|)
block|{
name|rtx
name|op
index|[
literal|7
index|]
decl_stmt|;
name|char
name|label
index|[
literal|128
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"# function profiler \n"
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|op
index|[
literal|1
index|]
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|op
index|[
literal|3
index|]
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_mcount"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|UNSPEC_PLT
argument_list|)
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"stg\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"larl\t%2,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"brasl\t%0,%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lg\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bras\t%2,%l6"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,0(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%2,4(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%0,%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bras\t%2,%l6"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%4-%l5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3-%l5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lr\t%0,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%0,0(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%2,4(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%0,%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Select section for constant in constant pool.  In 32-bit mode,    constants go in the function section; in 64-bit mode in .rodata.  */
end_comment

begin_function
specifier|static
name|void
name|s390_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_CPU_ZARCH
condition|)
name|readonly_data_section
argument_list|()
expr_stmt|;
else|else
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encode symbol attributes (local vs. global, tls model) of a SYMBOL_REF    into its SYMBOL_REF_FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|s390_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
comment|/* If a variable has a forced alignment to< 2 bytes, mark it with      SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL operand.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|<
literal|16
condition|)
name|SYMBOL_REF_FLAGS
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator||=
name|SYMBOL_FLAG_ALIGN1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output thunk to FILE that implements a C++ virtual function call (with    multiple inheritance) to FUNCTION.  The thunk adjusts the this pointer    by DELTA, and unless VCALL_OFFSET is zero, applies an additional adjustment    stored at VCALL_OFFSET in the vtable whose address is located at offset 0    relative to the resulting this pointer.  */
end_comment

begin_function
specifier|static
name|void
name|s390_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|op
index|[
literal|10
index|]
decl_stmt|;
name|int
name|nonlocal
init|=
literal|0
decl_stmt|;
comment|/* Operand 0 is the target function.  */
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|nonlocal
operator|=
literal|1
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|TARGET_64BIT
condition|?
name|UNSPEC_PLT
else|:
name|UNSPEC_GOT
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Operand 1 is the 'this' pointer.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|)
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Operand 2 is the delta.  */
name|op
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
comment|/* Operand 3 is the vcall_offset.  */
name|op
index|[
literal|3
index|]
operator|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
expr_stmt|;
comment|/* Operand 4 is the temporary register.  */
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Operands 5 to 8 can be used as labels.  */
name|op
index|[
literal|5
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|6
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|7
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|op
index|[
literal|8
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Operand 9 can be used for temporary register.  */
name|op
index|[
literal|9
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Generate code.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* Setup literal pool pointer if required.  */
if|if
condition|(
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|delta
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|vcall_offset
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
operator|)
condition|)
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"larl\t%4,%5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* Add DELTA to this pointer.  */
if|if
condition|(
name|delta
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|delta
argument_list|,
literal|'J'
argument_list|,
literal|"J"
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"la\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"lay\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|delta
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"aghi\t%1,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"agf\t%1,%6-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Perform vcall adjustment.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lg\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,%3(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lghi\t%4,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|7
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"llgf\t%4,%7-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ag\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Jump to target.  */
name|output_asm_insn
argument_list|(
literal|"jg\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Output literal pool if required.  */
if|if
condition|(
name|op
index|[
literal|5
index|]
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|".align\t4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|6
index|]
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|7
index|]
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Setup base pointer if required.  */
if|if
condition|(
operator|!
name|vcall_offset
operator|||
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|delta
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
operator|&&
operator|!
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
operator|)
condition|)
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%4,0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add DELTA to this pointer.  */
if|if
condition|(
name|delta
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|delta
argument_list|,
literal|'J'
argument_list|,
literal|"J"
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"la\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|delta
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"lay\t%1,%2(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|delta
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"ahi\t%1,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,%6-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Perform vcall adjustment.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'J'
argument_list|,
literal|"J"
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lg\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,%3(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DISP_IN_RANGE
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lg\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ay\t%1,%3(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_OK_FOR_CONSTRAINT_P
argument_list|(
name|vcall_offset
argument_list|,
literal|'K'
argument_list|,
literal|"K"
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"lhi\t%4,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|7
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,%7-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,0(%1)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%1,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We had to clobber the base pointer register. 	     Re-setup the base pointer (with a different base).  */
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%4,0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Jump to target.  */
name|op
index|[
literal|8
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|"l\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nonlocal
condition|)
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* We cannot call through .plt, since .plt requires %r12 loaded.  */
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,%0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|op
index|[
literal|9
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%9,%8-4-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%4,%8-%5(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ar\t%4,%9"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%4,0(%4)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"br\t%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Output literal pool.  */
name|output_asm_insn
argument_list|(
literal|".align\t4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal
operator|&&
name|flag_pic
operator|==
literal|2
condition|)
name|output_asm_insn
argument_list|(
literal|".long\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonlocal
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
block|}
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|8
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|".long\t%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|".long\t%0-%5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
literal|6
index|]
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
literal|7
index|]
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|bool
name|s390_valid_pointer_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|mode
operator|==
name|SImode
operator|||
operator|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to allocate a 'struct machine_function'.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|s390_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-s390.h"
end_include

end_unit

