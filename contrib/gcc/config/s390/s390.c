begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IBM S/390 and zSeries    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Hartmut Penner (hpenner@de.ibm.com) and                   Ulrich Weigand (uweigand@de.ibm.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_decl_stmt
specifier|static
name|bool
name|s390_assemble_integer
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_adjust_priority
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\t.quad\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|s390_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|s390_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|s390_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OPEN_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OPEN_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CLOSE_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CLOSE_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|s390_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_PRIORITY
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_PRIORITY
value|s390_adjust_priority
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The alias set for prologue/epilogue register save/restore.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s390_sr_alias_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function count for creating unique internal labels in a compile unit.  */
end_comment

begin_decl_stmt
name|int
name|s390_function_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|s390_compare_op0
decl_stmt|,
name|s390_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to hold the components of a S/390 memory    address.  A legitimate address on S/390 is of the general    form           base + index + displacement    where any of the components is optional.     base and index are registers of the class ADDR_REGS,    displacement is an unsigned 12-bit immediate constant.  */
end_comment

begin_struct
struct|struct
name|s390_address
block|{
name|rtx
name|base
decl_stmt|;
name|rtx
name|indx
decl_stmt|;
name|rtx
name|disp
decl_stmt|;
name|int
name|pointer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure containing information for prologue and epilogue.  */
end_comment

begin_struct
struct|struct
name|s390_frame
block|{
name|int
name|frame_pointer_p
decl_stmt|;
name|int
name|return_reg_saved_p
decl_stmt|;
name|int
name|save_fprs_p
decl_stmt|;
name|int
name|first_save_gpr
decl_stmt|;
name|int
name|first_restore_gpr
decl_stmt|;
name|int
name|last_save_gpr
decl_stmt|;
name|int
name|arg_frame_offset
decl_stmt|;
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|s390_match_ccmode_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_branch_condition_mask
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s390_branch_condition_mnemonic
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_mode
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|general_s_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_decompose_address
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|s390_address
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_used_in_mem_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addr_generation_dependency_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_split_branches
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_constant_pool_ref
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_constant_pool_ref
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_chunkify_pool
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|save_fprs_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_unused_clobbered_reg
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_frame_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|s390_frame
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|save_fpr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|restore_fpr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s390_function_arg_size
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if SET either doesn't set the CC register, or else    the source and destination have matching CC modes and that     CC mode is at least as constrained as REQ_MODE.  */
end_comment

begin_function
specifier|static
name|int
name|s390_match_ccmode_set
parameter_list|(
name|set
parameter_list|,
name|req_mode
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|enum
name|machine_mode
name|req_mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|set_mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CC_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|set_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|set_mode
condition|)
block|{
case|case
name|CCSmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCSmode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCUmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCUmode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCLmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCLmode
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCZmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCSmode
operator|&&
name|req_mode
operator|!=
name|CCUmode
operator|&&
name|req_mode
operator|!=
name|CCTmode
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|set_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if every SET in INSN that sets the CC register     has source and destination with matching CC modes and that     CC mode is at least as constrained as REQ_MODE.  */
end_comment

begin_function
name|int
name|s390_match_ccmode
parameter_list|(
name|insn
parameter_list|,
name|req_mode
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|machine_mode
name|req_mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
return|return
name|s390_match_ccmode_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|req_mode
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
condition|)
if|if
condition|(
operator|!
name|s390_match_ccmode_set
argument_list|(
name|set
argument_list|,
name|req_mode
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a comparison code OP (EQ, NE, etc.) and the operands     OP0 and OP1 of a COMPARE, return the mode to be used for the     comparison.  */
end_comment

begin_function
name|enum
name|machine_mode
name|s390_select_ccmode
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NEG
condition|)
return|return
name|CCLmode
return|;
return|return
name|CCZmode
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|UNGE
case|:
case|case
name|UNGT
case|:
case|case
name|LTGT
case|:
return|return
name|CCSmode
return|;
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
return|return
name|CCUmode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return branch condition mask to implement a branch     specified by CODE.  */
end_comment

begin_function
specifier|static
name|int
name|s390_branch_condition_mask
parameter_list|(
name|code
parameter_list|)
name|rtx
name|code
decl_stmt|;
block|{
specifier|const
name|int
name|CC0
init|=
literal|1
operator|<<
literal|3
decl_stmt|;
specifier|const
name|int
name|CC1
init|=
literal|1
operator|<<
literal|2
decl_stmt|;
specifier|const
name|int
name|CC2
init|=
literal|1
operator|<<
literal|1
decl_stmt|;
specifier|const
name|int
name|CC3
init|=
literal|1
operator|<<
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|CC_REGNUM
operator|||
name|XEXP
argument_list|(
name|code
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|code
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CCZmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCLmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|UNORDERED
case|:
return|return
name|CC2
operator||
name|CC3
return|;
comment|/* carry */
case|case
name|ORDERED
case|:
return|return
name|CC0
operator||
name|CC1
return|;
comment|/* no carry */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCUmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LTU
case|:
return|return
name|CC1
return|;
case|case
name|GTU
case|:
return|return
name|CC2
return|;
case|case
name|LEU
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GEU
case|:
return|return
name|CC0
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CCSmode
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC0
return|;
case|case
name|NE
case|:
return|return
name|CC1
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LT
case|:
return|return
name|CC1
return|;
case|case
name|GT
case|:
return|return
name|CC2
return|;
case|case
name|LE
case|:
return|return
name|CC0
operator||
name|CC1
return|;
case|case
name|GE
case|:
return|return
name|CC0
operator||
name|CC2
return|;
case|case
name|UNORDERED
case|:
return|return
name|CC3
return|;
case|case
name|ORDERED
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC2
return|;
case|case
name|UNEQ
case|:
return|return
name|CC0
operator||
name|CC3
return|;
case|case
name|UNLT
case|:
return|return
name|CC1
operator||
name|CC3
return|;
case|case
name|UNGT
case|:
return|return
name|CC2
operator||
name|CC3
return|;
case|case
name|UNLE
case|:
return|return
name|CC0
operator||
name|CC1
operator||
name|CC3
return|;
case|case
name|UNGE
case|:
return|return
name|CC0
operator||
name|CC2
operator||
name|CC3
return|;
case|case
name|LTGT
case|:
return|return
name|CC1
operator||
name|CC2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If INV is false, return assembler mnemonic string to implement     a branch specified by CODE.  If INV is true, return mnemonic     for the corresponding inverted branch.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|s390_branch_condition_mnemonic
parameter_list|(
name|code
parameter_list|,
name|inv
parameter_list|)
name|rtx
name|code
decl_stmt|;
name|int
name|inv
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|mnemonic
index|[
literal|16
index|]
init|=
block|{
name|NULL
block|,
literal|"o"
block|,
literal|"h"
block|,
literal|"nle"
block|,
literal|"l"
block|,
literal|"nhe"
block|,
literal|"lh"
block|,
literal|"ne"
block|,
literal|"e"
block|,
literal|"nlh"
block|,
literal|"he"
block|,
literal|"nl"
block|,
literal|"le"
block|,
literal|"nh"
block|,
literal|"no"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|mask
init|=
name|s390_branch_condition_mask
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|inv
condition|)
name|mask
operator|^=
literal|15
expr_stmt|;
if|if
condition|(
name|mask
operator|<
literal|1
operator|||
name|mask
operator|>
literal|14
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|mnemonic
index|[
name|mask
index|]
return|;
block|}
end_function

begin_comment
comment|/* If OP is an integer constant of mode MODE with exactly one    HImode subpart unequal to DEF, return the number of that     subpart.  As a special case, all HImode subparts of OP are    equal to DEF, return zero.  Otherwise, return -1.  */
end_comment

begin_function
name|int
name|s390_single_hi
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|def
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|def
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|def
operator|&
literal|0xffff
argument_list|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|n_parts
operator|-
literal|1
operator|-
name|part
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|16
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|def
operator|&
literal|0xffff
argument_list|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|n_parts
operator|-
literal|1
operator|-
name|part
operator|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Extract the HImode part number PART from integer     constant OP of mode MODE.  */
end_comment

begin_function
name|int
name|s390_extract_hi
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|part
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|part
operator|<
literal|0
operator|||
name|part
operator|>=
name|n_parts
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|part
operator|=
name|n_parts
operator|-
literal|1
operator|-
name|part
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|value
operator|>>
operator|(
literal|16
operator|*
name|part
operator|)
operator|)
operator|&
literal|0xffff
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
if|if
condition|(
name|part
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|16
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|,
name|part
operator|-=
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|16
expr_stmt|;
return|return
operator|(
operator|(
name|value
operator|>>
operator|(
literal|16
operator|*
name|part
operator|)
operator|)
operator|&
literal|0xffff
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If OP is an integer constant of mode MODE with exactly one    QImode subpart unequal to DEF, return the number of that     subpart.  As a special case, all QImode subparts of OP are    equal to DEF, return zero.  Otherwise, return -1.  */
end_comment

begin_function
name|int
name|s390_single_qi
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|def
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|def
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|def
operator|&
literal|0xff
argument_list|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|n_parts
operator|-
literal|1
operator|-
name|part
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|part
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|8
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
call|(
name|unsigned
call|)
argument_list|(
name|def
operator|&
literal|0xff
argument_list|)
condition|)
block|{
if|if
condition|(
name|part
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|part
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|part
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|n_parts
operator|-
literal|1
operator|-
name|part
operator|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Extract the QImode part number PART from integer     constant OP of mode MODE.  */
end_comment

begin_function
name|int
name|s390_extract_qi
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|part
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|int
name|n_parts
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|<
literal|0
operator|||
name|part
operator|>=
name|n_parts
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|part
operator|=
name|n_parts
operator|-
literal|1
operator|-
name|part
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|value
operator|>>
operator|(
literal|8
operator|*
name|part
operator|)
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
if|if
condition|(
name|part
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|8
condition|)
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|,
name|part
operator|-=
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|8
expr_stmt|;
return|return
operator|(
operator|(
name|value
operator|>>
operator|(
literal|8
operator|*
name|part
operator|)
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change optimizations to be performed, depending on the     optimization level.     LEVEL is the optimization level specified; 2 if `-O2' is    specified, 1 if `-O' is specified, and 0 if neither is specified.     SIZE is non-zero if `-Os' is specified and zero otherwise.  */
end_comment

begin_function
name|void
name|optimization_options
parameter_list|(
name|level
parameter_list|,
name|size
parameter_list|)
name|int
name|level
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
comment|/* When optimizing, enable use of BRCT instruction.  */
if|if
condition|(
name|level
operator|>=
literal|1
condition|)
name|flag_branch_on_count_reg
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|override_options
parameter_list|()
block|{
comment|/* Acquire a unique set number for our register saves and restores.  */
name|s390_sr_alias_set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map for smallest class containing reg regno.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
name|GENERAL_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|ADDR_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|ADDR_REGS
block|,
name|NO_REGS
block|,
name|ADDR_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if OP a (const_int 0) operand.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|const0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is constant.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|consttable_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the mode of operand OP matches MODE.    If MODE is set to VOIDmode, set it to the mode of OP.  */
end_comment

begin_function
specifier|static
name|int
name|check_mode
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|mode
operator|==
name|VOIDmode
condition|)
operator|*
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
operator|*
name|mode
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP a valid operand for the LARL instruction.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|larl_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|check_mode
argument_list|(
name|op
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow labels and local symbols.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Everything else must have a CONST, so strip it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow adding *even* constants.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Labels and local symbols allowed here as well.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Now we must have a @GOTENT offset or @PLT stub.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
literal|111
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
literal|113
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid FP-Register.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|fp_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|check_mode
argument_list|(
name|op
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|REG
operator|&&
name|REGNO_OK_FOR_FP_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper routine to implement s_operand and s_imm_operand.    OP is the current operation.    MODE is the current operation mode.    ALLOW_IMMEDIATE specifies whether immediate operands should    be accepted or not.  */
end_comment

begin_function
specifier|static
name|int
name|general_s_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|allow_immediate
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|allow_immediate
decl_stmt|;
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
comment|/* Call general_operand first, so that we don't have to      check for many special cases.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Just like memory_operand, allow (subreg (mem ...))      after reload.  */
if|if
condition|(
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Constants that we are sure will be forced to the          literal pool in reload are OK as s-operand.  Note 	 that we cannot call s390_preferred_reload_class here 	 because it might not be known yet at this point  	 whether the current function is a leaf or not.  */
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
operator|!
name|allow_immediate
operator|||
name|reload_completed
condition|)
break|break;
if|if
condition|(
operator|!
name|legitimate_reload_constant_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
literal|1
return|;
break|break;
comment|/* Memory operands are OK unless they already use an 	 index register.  */
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
name|FALSE
argument_list|)
operator|&&
operator|!
name|addr
operator|.
name|indx
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid S-type operand.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|general_s_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid S-type operand or an immediate     operand that can be addressed as S-type operand by forcing     it into the literal pool.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s_imm_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|general_s_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid operand for the BRAS instruction.    OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|bras_sym_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* Allow SYMBOL_REFs.  */
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
comment|/* Allow @PLT stubs.  */
if|if
condition|(
name|code
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|113
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if OP is a load multiple operation.  It is known to be a    PARALLEL and the first section will be tested.     OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check, is base, or base + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_addr
argument_list|)
operator|==
name|REG
condition|)
name|off
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|src_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|src_addr
operator|==
name|frame_pointer_rtx
operator|||
name|src_addr
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|Pmode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|Pmode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|off
operator|+
name|i
operator|*
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a store multiple operation.  It is known to be a    PARALLEL and the first section will be tested.     OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check, is base, or base + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest_addr
argument_list|)
operator|==
name|REG
condition|)
name|off
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest_addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|dest_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|dest_addr
operator|==
name|frame_pointer_rtx
operator|||
name|dest_addr
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|Pmode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|Pmode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|off
operator|+
name|i
operator|*
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP contains a symbol reference */
end_comment

begin_function
name|int
name|symbolic_reference_mentioned_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a legitimate general operand when     generating PIC code.  It is given that flag_pic is on     and that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|legitimate_pic_operand_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
comment|/* Accept all non-symbolic constants.  */
if|if
condition|(
operator|!
name|SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Reject everything else; must be handled       via emit_pic_move.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the constant value OP is a legitimate general operand.    It is given that OP satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|legitimate_constant_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
comment|/* Accept all non-symbolic constants.  */
if|if
condition|(
operator|!
name|SYMBOLIC_CONST
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* In the PIC case, symbolic constants must *not* be      forced into the literal pool.  We accept them here,      so that they will be handled by emit_pic_move.  */
if|if
condition|(
name|flag_pic
condition|)
return|return
literal|1
return|;
comment|/* Even in the non-PIC case, we can accept immediate      LARL operands here.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|larl_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
return|;
comment|/* All remaining non-PIC symbolic constants are      forced into the literal pool.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the constant value OP is a legitimate general    operand during and after reload.  The difference to     legitimate_constant_p is that this function will not accept    a constant that would need to be forced to the literal pool    before it can be used as operand.  */
end_comment

begin_function
name|int
name|legitimate_reload_constant_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
comment|/* Accept l(g)hi operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Accept lliXX operands.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|s390_single_hi
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Accept larl operands.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|larl_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If reload is completed, and we do not already have a      literal pool, and OP must be forced to the literal       pool, then something must have gone wrong earlier.      We *cannot* force the constant any more, because the      prolog generation already decided we don't need to       set up the base register.  */
if|if
condition|(
name|reload_completed
operator|&&
operator|!
name|regs_ever_live
index|[
name|BASE_REGISTER
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Everything else cannot be handled without reload.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx OP being reloaded into a reg required to be in class CLASS,    return the class of reg to actually use.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_preferred_reload_class
parameter_list|(
name|op
parameter_list|,
name|class
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
comment|/* This can happen if a floating point constant is being      reloaded into an integer register.  Leave well alone.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|class
operator|!=
name|FP_REGS
condition|)
return|return
name|class
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Constants we cannot reload must be forced into the 	 literal pool.  For constants we *could* handle directly, 	 it might still be preferable to put them in the pool and 	 use a memory-to-memory instruction.  	 However, try to avoid needlessly allocating a literal 	 pool in a routine that wouldn't otherwise need any. 	 Heuristically, we assume that 64-bit leaf functions 	 typically don't need a literal pool, all others do.  */
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
if|if
condition|(
operator|!
name|legitimate_reload_constant_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|current_function_is_leaf
condition|)
return|return
name|class
return|;
return|return
name|NO_REGS
return|;
comment|/* If a symbolic constant or a PLUS is reloaded, 	 it is most likely being used as an address, so 	 prefer ADDR_REGS.  If 'class' is not a superset 	 of ADDR_REGS, e.g. FP_REGS, reject this reload.  */
case|case
name|PLUS
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|ADDR_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
else|else
return|return
name|NO_REGS
return|;
default|default:
break|break;
block|}
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* Return the register class of a scratch register needed to    load IN into a register of class CLASS in MODE.     We need a temporary when loading a PLUS expression which    is not a legitimate operand of the LOAD ADDRESS instruction.  */
end_comment

begin_function
name|enum
name|reg_class
name|s390_secondary_input_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
if|if
condition|(
name|s390_plus_operand
argument_list|(
name|in
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|ADDR_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a PLUS that is not a legitimate    operand for the LA instruction.     OP is the current operation.    MODE is the current operation mode.  */
end_comment

begin_function
name|int
name|s390_plus_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|check_mode
argument_list|(
name|op
argument_list|,
operator|&
name|mode
argument_list|)
operator|||
name|mode
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|legitimate_la_operand_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Generate code to load SRC, which is PLUS that is not a    legitimate operand for the LA instruction, into TARGET.    SCRATCH may be used as scratch register.  */
end_comment

begin_function
name|void
name|s390_expand_plus_operand
parameter_list|(
name|target
parameter_list|,
name|src
parameter_list|,
name|scratch_in
parameter_list|)
specifier|register
name|rtx
name|target
decl_stmt|;
specifier|register
name|rtx
name|src
decl_stmt|;
specifier|register
name|rtx
name|scratch_in
decl_stmt|;
block|{
name|rtx
name|sum1
decl_stmt|,
name|sum2
decl_stmt|,
name|scratch
decl_stmt|;
comment|/* ??? reload apparently does not ensure that the scratch register      and the target do not overlap.  We absolutely require this to be      the case, however.  Therefore the reload_in[sd]i patterns ask for      a double-sized scratch register, and if one part happens to be      equal to the target, we use the other one.  */
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|scratch_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|scratch
argument_list|,
name|target
argument_list|)
condition|)
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|scratch_in
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* src must be a PLUS; get its two operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|Pmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Check if any of the two operands is already scheduled      for replacement by reload.  This can happen e.g. when      float registers occur in an address.  */
name|sum1
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the two operands is equal to the target,      make it the first one.  If one is a constant, make      it the second one.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|sum2
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|sum1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tem
init|=
name|sum2
decl_stmt|;
name|sum2
operator|=
name|sum1
expr_stmt|;
name|sum1
operator|=
name|tem
expr_stmt|;
block|}
comment|/* If the first operand is not an address register,      we reload it into the target.  */
if|if
condition|(
name|true_regnum
argument_list|(
name|sum1
argument_list|)
operator|<
literal|1
operator|||
name|true_regnum
argument_list|(
name|sum1
argument_list|)
operator|>
literal|15
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|sum1
argument_list|)
expr_stmt|;
name|sum1
operator|=
name|target
expr_stmt|;
block|}
comment|/* Likewise for the second operand.  However, take      care not to clobber the target if we already used      it for the first operand.  Use the scratch instead.      Also, allow an immediate offset if it is in range.  */
if|if
condition|(
operator|(
name|true_regnum
argument_list|(
name|sum2
argument_list|)
operator|<
literal|1
operator|||
name|true_regnum
argument_list|(
name|sum2
argument_list|)
operator|>
literal|15
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|sum2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|sum2
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|sum2
argument_list|)
operator|<
literal|4096
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|sum1
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|target
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
name|sum2
operator|=
name|scratch
expr_stmt|;
block|}
block|}
comment|/* Emit the LOAD ADDRESS pattern.  Note that reload of PLUS      is only ever performed on addresses, so we can mark the      sum as legitimate for LA in any case.  */
name|src
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|sum1
argument_list|,
name|sum2
argument_list|)
expr_stmt|;
name|src
operator|=
name|legitimize_la_operand
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decompose a RTL expression ADDR for a memory address into    its components, returned in OUT.  The boolean STRICT     specifies whether strict register checking applies.    Returns 0 if ADDR is not a valid memory address, nonzero    otherwise.  If OUT is NULL, don't return the components,    but check for validity only.     Note: Only addresses in canonical form are recognized.    LEGITIMIZE_ADDRESS should convert non-canonical forms to the    canonical form so that they will be recognized.  */
end_comment

begin_function
specifier|static
name|int
name|s390_decompose_address
parameter_list|(
name|addr
parameter_list|,
name|out
parameter_list|,
name|strict
parameter_list|)
specifier|register
name|rtx
name|addr
decl_stmt|;
name|struct
name|s390_address
modifier|*
name|out
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|indx
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|disp
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|pointer
init|=
name|FALSE
decl_stmt|;
comment|/* Decompose address into base + index + displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|UNSPEC
condition|)
block|{
name|indx
operator|=
name|op0
expr_stmt|;
comment|/* index + base */
name|base
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|op0
expr_stmt|;
comment|/* base + displacement */
name|disp
operator|=
name|op1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index + base + disp */
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Validate base register.  */
if|if
condition|(
name|base
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
operator|!=
literal|101
condition|)
return|return
name|FALSE
return|;
name|base
operator|=
name|XVECEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|base
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|base
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|BASE_REGISTER
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Validate index register.  */
if|if
condition|(
name|indx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|indx
argument_list|,
literal|1
argument_list|)
operator|!=
literal|101
condition|)
return|return
name|FALSE
return|;
name|indx
operator|=
name|XVECEXP
argument_list|(
name|indx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|Pmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|indx
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|indx
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|BASE_REGISTER
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
operator|(
name|reload_completed
operator|||
name|reload_in_progress
operator|)
operator|&&
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|REGNO
argument_list|(
name|indx
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Validate displacement.  */
if|if
condition|(
name|disp
condition|)
block|{
comment|/* Allow integer constant in range.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|disp
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|disp
argument_list|)
operator|>=
literal|4096
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* In the small-PIC case, the linker converts @GOT12           offsets to possible displacements.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|110
condition|)
block|{
if|if
condition|(
name|flag_pic
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Accept chunkfied literal pool symbol references.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Likewise if a constant offset is present.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We can convert literal pool addresses to           displacements by basing them off the base register.  */
else|else
block|{
comment|/* In some cases, we can accept an additional              small constant offset.  Split these off here.  */
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now we must have a literal pool address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|disp
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* In 64-bit PIC mode we cannot accept symbolic               constants in the constant pool.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|get_pool_constant
argument_list|(
name|disp
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we have an offset, make sure it does not              exceed the size of the constant pool entry.  */
if|if
condition|(
name|offset
operator|&&
name|offset
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|disp
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Either base or index must be free to               hold the base register.  */
if|if
condition|(
name|base
operator|&&
name|indx
condition|)
return|return
name|FALSE
return|;
comment|/* Convert the address.  */
if|if
condition|(
name|base
condition|)
name|indx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|disp
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|disp
operator|=
name|plus_constant
argument_list|(
name|disp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|indx
condition|)
name|pointer
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|out
condition|)
block|{
name|out
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|out
operator|->
name|indx
operator|=
name|indx
expr_stmt|;
name|out
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|out
operator|->
name|pointer
operator|=
name|pointer
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ADDR is a valid memory address.    STRICT specifies whether strict register checking applies.  */
end_comment

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|,
name|strict
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
return|return
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|,
name|strict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the LA instruction.    In 31-bit, we need to prove that the result is used as an    address, as LA performs only a 31-bit addition.  */
end_comment

begin_function
name|int
name|legitimate_la_operand_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|addr
operator|.
name|pointer
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return a modified variant of OP that is guaranteed to    be accepted by legitimate_la_operand_p.  */
end_comment

begin_function
name|rtx
name|legitimize_la_operand
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
name|struct
name|s390_address
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|addr
argument_list|,
name|FALSE
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|addr
operator|.
name|pointer
condition|)
return|return
name|op
return|;
if|if
condition|(
operator|!
name|addr
operator|.
name|base
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
operator|.
name|base
argument_list|)
argument_list|,
literal|101
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|indx
condition|)
name|op
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|,
name|addr
operator|.
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|disp
condition|)
name|op
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|,
name|addr
operator|.
name|disp
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are two types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references, constant pool addresses, and code labels       compute the address as an offset from the GOT, whose base is in       the PIC reg.  Static data objects have SYMBOL_REF_FLAG set to       differentiate them from global data objects.  The returned       address is the PIC reg + an unspec constant.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|SYMBOL_REF_FLAG
argument_list|(
name|addr
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This is a local symbol.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* Access local symbols PC-relative via LARL.                This is the same as in the non-PIC case, so it is               handled automatically ...  */
block|}
else|else
block|{
comment|/* Access local symbols relative to the literal pool.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|base
argument_list|)
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|1
condition|)
block|{
comment|/* Assume GOT offset< 4k.  This is handled the same way              in both 31- and 64-bit code (@GOT12).  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|110
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* If the GOT offset might be>= 4k, we determine the position              of the GOT entry via a PC-relative LARL (@GOTENT).  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|111
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* If the GOT offset might be>= 4k, we have to load it               from the literal pool (@GOT).  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|112
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If someone moved an @GOT or lt-relative UNSPEC                      out of the literal pool, force them back in.  */
case|case
literal|100
case|:
case|case
literal|112
case|:
case|case
literal|114
case|:
name|new
operator|=
name|force_const_mem
argument_list|(
name|SImode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
break|break;
comment|/* @GOTENT is OK as is.  */
case|case
literal|111
case|:
break|break;
comment|/* @PLT is OK as is on 64-bit, must be converted to                      lt-relative PLT on 31-bit.  */
case|case
literal|113
case|:
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|114
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|base
argument_list|)
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
break|break;
comment|/* Everything else cannot happen.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check first to see if this is a constant offset               from a local symbol reference.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|SYMBOL_REF_FLAG
argument_list|(
name|op0
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op0
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
condition|)
block|{
comment|/* LARL can't handle odd offsets, so emit a                           pair of LARL and LA.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|4096
condition|)
block|{
name|int
name|even
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
decl_stmt|;
name|op0
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|even
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the offset is even, we can just use LARL.                          This will happen automatically.  */
block|}
block|}
else|else
block|{
comment|/* Access local symbols relative to the literal pool.  */
name|rtx
name|temp
init|=
name|reg
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|addr
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op0
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|force_const_mem
argument_list|(
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|base
argument_list|)
argument_list|,
literal|101
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
comment|/* Now, check whether it is an LT-relative symbol plus offset              that was pulled out of the literal pool.  Force it back in.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|!=
literal|100
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|SImode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, compute the sum.  */
else|else
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST
condition|)
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_operand
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].  */
end_comment

begin_function
name|void
name|emit_pic_move
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|no_new_pseudos
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address X    to be legitimate.  If we find one, return the new, valid address.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE is the mode of the operand pointed to by X.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|x
parameter_list|,
name|oldx
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
if|if
condition|(
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
block|}
name|x
operator|=
name|eliminate_constant_term
argument_list|(
name|x
argument_list|,
operator|&
name|constant_term
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constant_term
operator|!=
name|const0_rtx
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|constant_term
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* In the name of slightly smaller debug output, and to cater to    general assembler losage, recognize various UNSPEC sequences    and turn them back into a direct symbol reference.  */
end_comment

begin_function
name|rtx
name|s390_simplify_dwarf_addr
parameter_list|(
name|orig_x
parameter_list|)
name|rtx
name|orig_x
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|orig_x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|orig_x
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
block|{
name|y
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
literal|110
condition|)
return|return
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|==
literal|111
condition|)
return|return
name|XVECEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
return|return
name|orig_x
return|;
block|}
end_function

begin_comment
comment|/* Output symbolic constant X in assembler syntax to     stdio stream FILE.  */
end_comment

begin_function
name|void
name|s390_output_symbolic_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|SYMBOL_REF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand (1)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|100
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-.LT%X"
argument_list|,
name|s390_function_count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|110
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOT12"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|111
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTENT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|112
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|113
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|114
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLT-.LT%X"
argument_list|,
name|s390_function_count
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand (2)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"UNKNOWN in s390_output_symbolic_const !?"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output address operand ADDR in assembler syntax to     stdio stream FILE.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
operator|!
name|s390_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|ad
argument_list|,
name|TRUE
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"Cannot decompose address."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
operator|&&
name|ad
operator|.
name|indx
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s,%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|indx
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output operand X in assembler syntax to stdio stream FILE.      CODE specified the format flag.  The following format flags     are recognized:      'C': print opcode suffix for branch condition.     'D': print opcode suffix for inverse branch condition.     'O': print only the displacement of a memory reference.     'R': print only the base register of a memory reference.     'N': print the second word of a DImode operand.     'M': print the second word of a TImode operand.      'b': print integer X as if it's an unsigned byte.     'x': print integer X as if it's an unsigned word.     'h': print integer X as if it's a signed word.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'C'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|s390_branch_condition_mnemonic
argument_list|(
name|x
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|s390_branch_condition_mnemonic
argument_list|(
name|x
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|,
name|TRUE
argument_list|)
operator|||
name|ad
operator|.
name|indx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|disp
condition|)
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|ad
operator|.
name|disp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'R'
case|:
block|{
name|struct
name|s390_address
name|ad
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|s390_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|,
name|TRUE
argument_list|)
operator|||
name|ad
operator|.
name|indx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ad
operator|.
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ad
operator|.
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'N'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
name|s390_output_symbolic_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'x'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'x'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"UNKNOWN in print_operand !?"
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Target hook for assembling integer objects.  We need to define it    here to work a round a bug in some versions of GAS, which couldn't    handle values smaller than INT_MIN when printed in decimal.  */
end_comment

begin_function
specifier|static
name|bool
name|s390_assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|aligned_p
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
name|aligned_p
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
name|INT_MIN
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.quad\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DEBUG_SCHED
value|0
end_define

begin_comment
comment|/* Returns true if register REGNO is used  for forming     a memory address in expression X.  */
end_comment

begin_function
specifier|static
name|int
name|reg_used_in_mem_p
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns true if expression DEP_RTX sets an address register    used by instruction INSN to address memory.  */
end_comment

begin_function
specifier|static
name|int
name|addr_generation_dependency_p
parameter_list|(
name|dep_rtx
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|dep_rtx
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|target
decl_stmt|,
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
condition|)
block|{
name|target
operator|=
name|SET_DEST
argument_list|(
name|dep_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_LA
condition|)
block|{
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
if|if
condition|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
return|return
name|refers_to_regno_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
literal|1
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|get_attr_atype
argument_list|(
name|insn
argument_list|)
operator|==
name|ATYPE_MEM
condition|)
return|return
name|reg_used_in_mem_p
argument_list|(
name|regno
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the modified cost of the dependency of instruction INSN    on instruction DEP_INSN through the link LINK.  COST is the     default cost of that dependency.     Data dependencies are all handled without delay.  However, if a    register is modified and subsequently used as base or index     register of a memory reference, at least 4 cycles need to pass    between setting and using the register to avoid pipeline stalls.      An exception is the LA instruction. An address generated by LA can    be used by introducing only a one cycle stall on the pipeline.  */
end_comment

begin_function
specifier|static
name|int
name|s390_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|rtx
name|dep_rtx
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If the dependence is an anti-dependence, there is no cost.  For an      output dependence, there is sometimes a cost, but it doesn't seem      worth handling those few cases.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|dep_rtx
operator|=
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|addr_generation_dependency_p
argument_list|(
name|dep_rtx
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|cost
operator|+=
operator|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LA
operator|)
condition|?
literal|1
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|DEBUG_SCHED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\nAddress dependency detected: cost %d\n"
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_rtx
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr_generation_dependency_p
argument_list|(
name|XVECEXP
argument_list|(
name|dep_rtx
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|cost
operator|+=
operator|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_LA
operator|)
condition|?
literal|1
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|DEBUG_SCHED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\nAddress dependency detected: cost %d\n"
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* A C statement (sans semicolon) to update the integer scheduling priority    INSN_PRIORITY (INSN).  Reduce the priority to execute the INSN earlier,    increase the priority to execute INSN later.  Do not define this macro if    you do not need to adjust the scheduling priorities of insns.      A LA instruction maybe scheduled later, since the pipeline bypasses the    calculated value.  */
end_comment

begin_function
specifier|static
name|int
name|s390_adjust_priority
parameter_list|(
name|insn
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|priority
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|priority
return|;
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|TYPE_LA
case|:
if|if
condition|(
name|priority
operator|>=
literal|0
operator|&&
name|priority
operator|<
literal|0x01000000
condition|)
name|priority
operator|<<=
literal|3
expr_stmt|;
break|break;
case|case
name|TYPE_LM
case|:
comment|/* LM in epilogue should never be scheduled. This 	 is due to literal access done in function body. 	 The usage of register 13 is not mentioned explicitly, 	 leading to scheduling 'LM' accross this instructions.         */
name|priority
operator|=
literal|0x7fffffff
expr_stmt|;
break|break;
block|}
return|return
name|priority
return|;
block|}
end_function

begin_comment
comment|/* Split all branches that exceed the maximum distance.  */
end_comment

begin_function
specifier|static
name|void
name|s390_split_branches
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|temp_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|,
name|label
decl_stmt|,
name|target
decl_stmt|,
name|jump
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* In 64-bit mode we can jump +- 4GB.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return;
comment|/* Find all branches that exceed 64KB, and split them.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
else|else
continue|continue;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|==
literal|4
condition|)
continue|continue;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|target
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|label
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|target
operator|=
name|force_const_mem
argument_list|(
name|SImode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|jump
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
expr_stmt|;
name|jump
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|jump
argument_list|,
name|temp_reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|jump
operator|=
name|temp_reg
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|jump
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|jump
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
else|else
name|jump
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pc_rtx
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|target
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_jump_insn_before
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|jump
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find a literal pool symbol referenced in RTX X, and store     it at REF.  Will abort if X contains references to more than     one such pool symbol; multiple references to the same symbol    are allowed, however.      The rtx pointed to by REF must be initialized to NULL_RTX     by the caller before calling this routine.  */
end_comment

begin_function
specifier|static
name|void
name|find_constant_pool_ref
parameter_list|(
name|x
parameter_list|,
name|ref
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|ref
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|ref
operator|==
name|NULL_RTX
condition|)
operator|*
name|ref
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ref
operator|!=
name|x
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|find_constant_pool_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_constant_pool_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace every reference to the literal pool symbol REF    in X by the address ADDR.  Fix up MEMs as required.  */
end_comment

begin_function
specifier|static
name|void
name|replace_constant_pool_ref
parameter_list|(
name|x
parameter_list|,
name|ref
parameter_list|,
name|addr
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|rtx
name|ref
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
operator|*
name|x
operator|==
name|ref
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Literal pool references can only occur inside a MEM ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|memref
init|=
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|memref
operator|==
name|ref
condition|)
block|{
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|memref
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|ref
condition|)
block|{
name|HOST_WIDE_INT
name|off
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|x
operator|=
name|replace_equiv_address
argument_list|(
operator|*
name|x
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* ... or a load-address type pattern.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|addrref
init|=
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|addrref
operator|==
name|ref
condition|)
block|{
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addrref
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|ref
condition|)
block|{
name|HOST_WIDE_INT
name|off
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addrref
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|SET_SRC
argument_list|(
operator|*
name|x
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|replace_constant_pool_ref
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_constant_pool_ref
argument_list|(
operator|&
name|XVECEXP
argument_list|(
operator|*
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* We keep a list of constants we which we have to add to internal    constant tables in the middle of large functions.  */
end_comment

begin_define
define|#
directive|define
name|NR_C_MODES
value|6
end_define

begin_decl_stmt
name|enum
name|machine_mode
name|constant_modes
index|[
name|NR_C_MODES
index|]
init|=
block|{
name|DFmode
block|,
name|DImode
block|,
name|SFmode
block|,
name|SImode
block|,
name|HImode
block|,
name|QImode
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
function_decl|(
modifier|*
name|gen_consttable
index|[
name|NR_C_MODES
index|]
function_decl|)
parameter_list|(
name|rtx
parameter_list|)
init|=
block|{
name|gen_consttable_df
operator|,
function_decl|gen_consttable_di
operator|,
function_decl|gen_consttable_sf
operator|,
function_decl|gen_consttable_si
operator|,
function_decl|gen_consttable_hi
operator|,
function_decl|gen_consttable_qi
end_function_decl

begin_struct
unit|};
struct|struct
name|constant
block|{
name|struct
name|constant
modifier|*
name|next
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|constant_pool
block|{
name|struct
name|constant_pool
modifier|*
name|next
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|struct
name|constant
modifier|*
name|constants
index|[
name|NR_C_MODES
index|]
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_start_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_end_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_find_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|s390_add_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|s390_dump_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s390_free_pool
name|PARAMS
argument_list|(
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create new constant pool covering instructions starting at INSN    and chain it to the end of POOL_LIST.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_start_pool
parameter_list|(
name|pool_list
parameter_list|,
name|insn
parameter_list|)
name|struct
name|constant_pool
modifier|*
modifier|*
name|pool_list
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pool
operator|=
operator|(
expr|struct
name|constant_pool
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
name|pool
operator|->
name|constants
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pool
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pool
operator|->
name|first_insn
operator|=
name|insn
expr_stmt|;
name|pool
operator|->
name|last_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|pool
operator|->
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|pool_list
init|;
operator|*
name|prev
condition|;
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|prev
operator|=
name|pool
expr_stmt|;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* End range of instructions covered by POOL at INSN.  */
end_comment

begin_function
specifier|static
name|void
name|s390_end_pool
parameter_list|(
name|pool
parameter_list|,
name|insn
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|pool
operator|->
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return pool out of POOL_LIST that covers INSN.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_pool
modifier|*
name|s390_find_pool
parameter_list|(
name|pool_list
parameter_list|,
name|insn
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool_list
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|addr
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|pool
operator|=
name|pool_list
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
if|if
condition|(
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|pool
operator|->
name|first_insn
argument_list|)
argument_list|)
operator|<=
name|addr
operator|&&
operator|(
name|pool
operator|->
name|last_insn
operator|==
name|NULL_RTX
operator|||
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|pool
operator|->
name|last_insn
argument_list|)
argument_list|)
operator|>
name|addr
operator|)
condition|)
break|break;
return|return
name|pool
return|;
block|}
end_function

begin_comment
comment|/* Add constant VAL of mode MODE to the constant pool POOL.    Return an RTX describing the distance from the start of    the pool to the location of the new constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_add_pool
parameter_list|(
name|pool
parameter_list|,
name|val
parameter_list|,
name|mode
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constant_modes
index|[
name|i
index|]
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NR_C_MODES
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|val
argument_list|,
name|c
operator|->
name|value
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
operator|(
expr|struct
name|constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|c
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
expr_stmt|;
name|pool
operator|->
name|constants
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|pool
operator|->
name|size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|c
operator|->
name|label
argument_list|)
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Dump out the constants in POOL.  */
end_comment

begin_function
specifier|static
name|rtx
name|s390_dump_pool
parameter_list|(
name|pool
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Select location to put literal pool.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
else|else
name|insn
operator|=
name|pool
operator|->
name|last_insn
condition|?
name|pool
operator|->
name|last_insn
else|:
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Pool start insn switches to proper section       and guarantees necessary alignment.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_start_64
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_start_31
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|pool
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Dump constants in descending alignment requirement order,      ensuring proper alignment for every constant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|c
operator|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
name|insn
operator|=
name|emit_label_after
argument_list|(
name|c
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
argument|gen_consttable[i] (c->value)
argument_list|,
argument|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Pool end insn switches back to previous section       and guarantees necessary alignment.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_end_64
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_pool_end_31
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Free all memory used by POOL.  */
end_comment

begin_function
specifier|static
name|void
name|s390_free_pool
parameter_list|(
name|pool
parameter_list|)
name|struct
name|constant_pool
modifier|*
name|pool
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_C_MODES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constant
modifier|*
name|c
init|=
name|pool
operator|->
name|constants
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|struct
name|constant
modifier|*
name|next
init|=
name|c
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|next
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used in s390.md for branch length calculation.  */
end_comment

begin_decl_stmt
name|int
name|s390_pool_overflow
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chunkify the literal pool if required.  */
end_comment

begin_define
define|#
directive|define
name|S390_POOL_CHUNK_MIN
value|0xc00
end_define

begin_define
define|#
directive|define
name|S390_POOL_CHUNK_MAX
value|0xe00
end_define

begin_function
specifier|static
name|void
name|s390_chunkify_pool
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|base_reg
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|TARGET_64BIT
condition|?
name|BASE_REGISTER
else|:
name|RETURN_REGNUM
argument_list|)
decl_stmt|;
name|struct
name|constant_pool
modifier|*
name|curr_pool
init|=
name|NULL
decl_stmt|,
modifier|*
name|pool_list
init|=
name|NULL
decl_stmt|;
name|int
name|extra_size
init|=
literal|0
decl_stmt|;
name|bitmap
name|far_labels
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Do we need to chunkify the literal pool?  */
if|if
condition|(
name|get_pool_size
argument_list|()
operator|<
name|S390_POOL_CHUNK_MAX
condition|)
return|return;
comment|/* Scan all insns and move literals to pool chunks.      Replace all occurrances of literal pool references      by explicit references to pool chunk entries.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|rtx
name|addr
decl_stmt|,
name|pool_ref
init|=
name|NULL_RTX
decl_stmt|;
name|find_constant_pool_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|pool_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_ref
condition|)
block|{
if|if
condition|(
operator|!
name|curr_pool
condition|)
name|curr_pool
operator|=
name|s390_start_pool
argument_list|(
operator|&
name|pool_list
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|addr
operator|=
name|s390_add_pool
argument_list|(
name|curr_pool
argument_list|,
name|get_pool_constant
argument_list|(
name|pool_ref
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
name|pool_ref
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|replace_constant_pool_ref
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pool_ref
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|curr_pool
operator|||
name|INSN_ADDRESSES_SIZE
argument_list|()
operator|<=
operator|(
name|size_t
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|||
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|curr_pool
operator|->
name|size
operator|<
name|S390_POOL_CHUNK_MAX
condition|)
continue|continue;
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|chunk_size
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|-
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|curr_pool
operator|->
name|first_insn
argument_list|)
argument_list|)
operator|+
name|extra_size
decl_stmt|;
comment|/* We will later have to insert base register reload insns. 	     Those will have an effect on code size, which we need to 	     consider here.  This calculation makes rather pessimistic 	     worst-case assumptions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|extra_size
operator|+=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|extra_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|<
name|S390_POOL_CHUNK_MIN
operator|&&
name|curr_pool
operator|->
name|size
operator|<
name|S390_POOL_CHUNK_MIN
condition|)
continue|continue;
comment|/* Pool chunks can only be inserted after BARRIERs ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
name|extra_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ... so if we don't find one in time, create one.  */
elseif|else
if|if
condition|(
operator|(
name|chunk_size
operator|>
name|S390_POOL_CHUNK_MAX
operator|||
name|curr_pool
operator|->
name|size
operator|>
name|S390_POOL_CHUNK_MAX
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|)
block|{
name|int
name|addr
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|label
decl_stmt|,
name|jump
decl_stmt|,
name|barrier
decl_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|jump
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|barrier
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s390_end_pool
argument_list|(
name|curr_pool
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|curr_pool
operator|=
name|NULL
expr_stmt|;
name|extra_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Dump out all literal pools.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
name|s390_dump_pool
argument_list|(
name|curr_pool
argument_list|)
expr_stmt|;
comment|/* Find all labels that are branched into       from an insn belonging to a different chunk.  */
name|far_labels
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Labels marked with LABEL_PRESERVE_P can be target 	 of non-local jumps, so we have to mark them. 	 The same holds for named labels.  	 Don't do that, however, if it is the label before 	 a jump table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|||
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|vec_insn
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|vec_pat
init|=
name|vec_insn
operator|&&
name|GET_CODE
argument_list|(
name|vec_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|PATTERN
argument_list|(
name|vec_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
if|if
condition|(
operator|!
name|vec_pat
operator|||
operator|!
operator|(
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a direct jump (conditional or unconditional) 	 or a casesi jump, check all potential targets.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label
condition|)
block|{
if|if
condition|(
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|label
argument_list|)
operator|!=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
comment|/* Find the jump table used by this casesi jump.  */
name|rtx
name|vec_label
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|vec_insn
init|=
name|next_real_insn
argument_list|(
name|vec_label
argument_list|)
decl_stmt|;
name|rtx
name|vec_pat
init|=
name|vec_insn
operator|&&
name|GET_CODE
argument_list|(
name|vec_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|PATTERN
argument_list|(
name|vec_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|vec_pat
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|diff_p
init|=
name|GET_CODE
argument_list|(
name|vec_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|vec_pat
argument_list|,
name|diff_p
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|vec_pat
argument_list|,
name|diff_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|label
argument_list|)
operator|!=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Insert base register reload insns before every pool.  */
for|for
control|(
name|curr_pool
operator|=
name|pool_list
init|;
name|curr_pool
condition|;
name|curr_pool
operator|=
name|curr_pool
operator|->
name|next
control|)
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|pool_ref
init|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|curr_pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|rtx
name|new_insn
init|=
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|base_reg
argument_list|,
name|pool_ref
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|curr_pool
operator|->
name|first_insn
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|base_reg
argument_list|,
name|curr_pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|curr_pool
operator|->
name|first_insn
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Insert base register reload insns at every far label.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|bitmap_bit_p
argument_list|(
name|far_labels
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
init|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|pool_ref
init|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|rtx
name|new_insn
init|=
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|base_reg
argument_list|,
name|pool_ref
argument_list|)
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Insert base register reload insns after every call if necessary.  */
if|if
condition|(
name|REGNO
argument_list|(
name|base_reg
argument_list|)
operator|==
name|RETURN_REGNUM
condition|)
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
init|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base2
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Recompute insn addresses.  */
name|s390_pool_overflow
operator|=
literal|1
expr_stmt|;
name|init_insn_lengths
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|s390_pool_overflow
operator|=
literal|0
expr_stmt|;
comment|/* Insert base register reload insns after far branches.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|>=
literal|12
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|pool
init|=
name|s390_find_pool
argument_list|(
name|pool_list
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
name|rtx
name|new_insn
init|=
name|gen_reload_base
argument_list|(
name|base_reg
argument_list|,
name|pool
operator|->
name|label
argument_list|)
decl_stmt|;
name|INSN_ADDRESSES_NEW
argument_list|(
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free all memory.  */
while|while
condition|(
name|pool_list
condition|)
block|{
name|struct
name|constant_pool
modifier|*
name|next
init|=
name|pool_list
operator|->
name|next
decl_stmt|;
name|s390_free_pool
argument_list|(
name|pool_list
argument_list|)
expr_stmt|;
name|pool_list
operator|=
name|next
expr_stmt|;
block|}
name|BITMAP_XFREE
argument_list|(
name|far_labels
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Index of constant pool chunk that is currently being processed.    Set to -1 before function output has started.  */
end_comment

begin_decl_stmt
name|int
name|s390_pool_count
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of current constant pool.  */
end_comment

begin_decl_stmt
name|int
name|s390_nr_constants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output main constant pool to stdio stream FILE.  */
end_comment

begin_function
name|void
name|s390_output_constant_pool
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
comment|/* Output constant pool.  */
if|if
condition|(
name|s390_nr_constants
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlarl\t%s,.LT%X\n"
argument_list|,
name|reg_names
index|[
name|BASE_REGISTER
index|]
argument_list|,
name|s390_function_count
argument_list|)
expr_stmt|;
name|readonly_data_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbras\t%s,.LTN%X\n"
argument_list|,
name|reg_names
index|[
name|BASE_REGISTER
index|]
argument_list|,
name|s390_function_count
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".LT%X:\n"
argument_list|,
name|s390_function_count
argument_list|)
expr_stmt|;
name|s390_pool_count
operator|=
literal|0
expr_stmt|;
name|output_constant_pool
argument_list|(
name|current_function_name
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|s390_pool_count
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".LTN%X:\n"
argument_list|,
name|s390_function_count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if floating point registers need to be saved.  */
end_comment

begin_function
specifier|static
name|int
name|save_fprs_p
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<=
literal|31
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|==
literal|1
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find first call clobbered register unsused in a function.    This could be used as base register in a leaf function    or for holding the return address before epilogue.  */
end_comment

begin_function
specifier|static
name|int
name|find_unused_clobbered_reg
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill FRAME with info about frame of current function.  */
end_comment

begin_function
specifier|static
name|void
name|s390_frame_info
parameter_list|(
name|frame
parameter_list|)
name|struct
name|s390_frame
modifier|*
name|frame
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|HOST_WIDE_INT
name|fsize
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
if|if
condition|(
name|fsize
operator|>
literal|0x7fff0000
condition|)
name|fatal_error
argument_list|(
literal|"Total size of local variables exceeds architecture limit."
argument_list|)
expr_stmt|;
comment|/* fprs 8 - 15 are caller saved for 64 Bit ABI.  */
name|frame
operator|->
name|save_fprs_p
operator|=
name|save_fprs_p
argument_list|()
expr_stmt|;
name|frame
operator|->
name|frame_size
operator|=
name|fsize
operator|+
name|frame
operator|->
name|save_fprs_p
operator|*
literal|64
expr_stmt|;
comment|/* Does function need to setup frame and save area.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|||
name|frame
operator|->
name|frame_size
operator|>
literal|0
operator|||
name|current_function_calls_alloca
operator|||
name|current_function_stdarg
operator|||
name|current_function_varargs
condition|)
name|frame
operator|->
name|frame_size
operator|+=
name|STARTING_FRAME_OFFSET
expr_stmt|;
comment|/* If we need to allocate a frame, the stack pointer is changed.  */
if|if
condition|(
name|frame
operator|->
name|frame_size
operator|>
literal|0
condition|)
name|regs_ever_live
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If the literal pool might overflow, the return register might      be used as temp literal pointer.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|get_pool_size
argument_list|()
operator|>=
name|S390_POOL_CHUNK_MAX
operator|/
literal|2
condition|)
name|regs_ever_live
index|[
name|RETURN_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If there is (possibly) any pool entry, we need to       load base register.  */
if|if
condition|(
name|get_pool_size
argument_list|()
operator|||
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|frame
operator|->
name|frame_size
argument_list|,
literal|'K'
argument_list|)
operator|||
operator|(
operator|!
name|TARGET_64BIT
operator|&&
name|current_function_uses_pic_offset_table
operator|)
condition|)
name|regs_ever_live
index|[
name|BASE_REGISTER
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If we need the GOT pointer, remember to save/restore it.  */
if|if
condition|(
name|current_function_uses_pic_offset_table
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Frame pointer needed.   */
name|frame
operator|->
name|frame_pointer_p
operator|=
name|frame_pointer_needed
expr_stmt|;
comment|/* Find first and last gpr to be saved.  */
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|16
condition|)
block|{
comment|/* Nothing to save / restore.  */
name|frame
operator|->
name|first_save_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|frame
operator|->
name|first_restore_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|frame
operator|->
name|last_save_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|frame
operator|->
name|return_reg_saved_p
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Save / Restore from gpr i to j.  */
name|frame
operator|->
name|first_save_gpr
operator|=
name|i
expr_stmt|;
name|frame
operator|->
name|first_restore_gpr
operator|=
name|i
expr_stmt|;
name|frame
operator|->
name|last_save_gpr
operator|=
name|j
expr_stmt|;
name|frame
operator|->
name|return_reg_saved_p
operator|=
operator|(
name|j
operator|>=
name|RETURN_REGNUM
operator|&&
name|i
operator|<=
name|RETURN_REGNUM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_stdarg
operator|||
name|current_function_varargs
condition|)
block|{
comment|/* Varargs function need to save from gpr 2 to gpr 15.  */
name|frame
operator|->
name|first_save_gpr
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return offset between argument pointer and frame pointer     initially after prologue.  */
end_comment

begin_function
name|int
name|s390_arg_frame_offset
parameter_list|()
block|{
name|struct
name|s390_frame
name|frame
decl_stmt|;
comment|/* Compute frame_info.  */
name|s390_frame_info
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return
name|frame
operator|.
name|frame_size
operator|+
name|STACK_POINTER_OFFSET
return|;
block|}
end_function

begin_comment
comment|/* Emit insn to save fpr REGNUM at offset OFFSET relative    to register BASE.  Return generated insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|save_fpr
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|regnum
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regnum
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit insn to restore fpr REGNUM from offset OFFSET relative    to register BASE.  Return generated insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|restore_fpr
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|regnum
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
return|return
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output the function prologue assembly code to the     stdio stream FILE.  The local frame size is passed    in LSIZE.  */
end_comment

begin_function
name|void
name|s390_function_prologue
parameter_list|(
name|file
parameter_list|,
name|lsize
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|lsize
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|s390_chunkify_pool
argument_list|()
expr_stmt|;
name|s390_split_branches
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the function epilogue assembly code to the     stdio stream FILE.  The local frame size is passed    in LSIZE.  */
end_comment

begin_function
name|void
name|s390_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|lsize
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|lsize
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|current_function_uses_pic_offset_table
operator|=
literal|0
expr_stmt|;
name|s390_function_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|s390_emit_prologue
parameter_list|()
block|{
name|struct
name|s390_frame
name|frame
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|rtx
name|temp_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Compute frame_info.  */
name|s390_frame_info
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* Choose best register to use for temp use within prologue.  */
if|if
condition|(
name|frame
operator|.
name|return_reg_saved_p
operator|&&
operator|!
name|has_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
operator|&&
name|get_pool_size
argument_list|()
operator|<
name|S390_POOL_CHUNK_MAX
operator|/
literal|2
condition|)
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
else|else
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Save call saved gprs.  */
if|if
condition|(
name|frame
operator|.
name|first_save_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame
operator|.
name|first_save_gpr
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|.
name|first_save_gpr
operator|!=
name|frame
operator|.
name|last_save_gpr
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_store_multiple
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|frame
operator|.
name|first_save_gpr
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|last_save_gpr
operator|-
name|frame
operator|.
name|first_save_gpr
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to set the FRAME_RELATED flag on all SETs 	     inside the store-multiple pattern.  	     However, we must not emit DWARF records for registers 2..5 	     if they are stored for use by variable arguments ...    	     ??? Unfortunately, it is not enough to simply not the the 	     FRAME_RELATED flags for those SETs, because the first SET 	     of the PARALLEL is always treated as if it had the flag 	     set, even if it does not.  Therefore we emit a new pattern 	     without those registers as REG_FRAME_RELATED_EXPR note.  */
if|if
condition|(
name|frame
operator|.
name|first_save_gpr
operator|>=
literal|6
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|.
name|last_save_gpr
operator|>=
literal|6
condition|)
block|{
name|rtx
name|note
decl_stmt|,
name|naddr
decl_stmt|;
name|naddr
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|6
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_store_multiple
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|naddr
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|6
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|last_save_gpr
operator|-
literal|6
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|note
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|frame
operator|.
name|first_save_gpr
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Dump constant pool and set constant pool register (13).  */
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_lit
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Save fprs for variable args.  */
if|if
condition|(
name|current_function_stdarg
operator|||
name|current_function_varargs
condition|)
block|{
comment|/* Save fpr 0 and 2.  */
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|32
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|24
argument_list|,
literal|17
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* Save fpr 4 and 6.  */
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|16
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|8
argument_list|,
literal|19
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save fprs 4 and 6 if used (31 bit ABI).  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
comment|/* Save fpr 4 and 6.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|18
index|]
condition|)
block|{
name|insn
operator|=
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|16
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|19
index|]
condition|)
block|{
name|insn
operator|=
name|save_fpr
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|STACK_POINTER_OFFSET
operator|-
literal|8
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Decrement stack pointer.  */
if|if
condition|(
name|frame
operator|.
name|frame_size
operator|>
literal|0
condition|)
block|{
name|rtx
name|frame_off
init|=
name|GEN_INT
argument_list|(
operator|-
name|frame
operator|.
name|frame_size
argument_list|)
decl_stmt|;
comment|/* Save incoming stack pointer into temp reg.  */
if|if
condition|(
name|TARGET_BACKCHAIN
operator|||
name|frame
operator|.
name|save_fprs_p
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|temp_reg
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Substract frame size from stack pointer.  */
name|frame_off
operator|=
name|GEN_INT
argument_list|(
operator|-
name|frame
operator|.
name|frame_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
operator|-
name|frame
operator|.
name|frame_size
argument_list|,
literal|'K'
argument_list|)
condition|)
name|frame_off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|frame
operator|.
name|frame_size
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set backchain.  */
if|if
condition|(
name|TARGET_BACKCHAIN
condition|)
block|{
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|addr
argument_list|,
name|temp_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save fprs 8 - 15 (64 bit ABI).  */
if|if
condition|(
name|frame
operator|.
name|save_fprs_p
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|temp_reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
block|{
name|rtx
name|addr
init|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame
operator|.
name|frame_size
operator|-
literal|64
operator|+
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|)
decl_stmt|;
name|insn
operator|=
name|save_fpr
argument_list|(
name|temp_reg
argument_list|,
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set frame pointer, if needed.  */
if|if
condition|(
name|frame
operator|.
name|frame_pointer_p
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set up got pointer, if needed.  */
if|if
condition|(
name|current_function_uses_pic_offset_table
condition|)
block|{
name|rtx
name|got_symbol
init|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
decl_stmt|;
name|SYMBOL_REF_FLAG
argument_list|(
name|got_symbol
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_movdi
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|got_symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It can happen that the GOT pointer isn't really needed ...  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|got_symbol
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|got_symbol
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|got_symbol
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|got_symbol
argument_list|)
expr_stmt|;
name|got_symbol
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|got_symbol
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|got_symbol
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BASE_REGISTER
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Expand the epilogue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|s390_emit_epilogue
parameter_list|()
block|{
name|struct
name|s390_frame
name|frame
decl_stmt|;
name|rtx
name|frame_pointer
decl_stmt|,
name|return_reg
decl_stmt|;
name|int
name|area_bottom
decl_stmt|,
name|area_top
decl_stmt|,
name|offset
decl_stmt|;
name|rtvec
name|p
decl_stmt|;
comment|/* Compute frame_info.  */
name|s390_frame_info
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* Check whether to use frame or stack pointer for restore.  */
name|frame_pointer
operator|=
name|frame
operator|.
name|frame_pointer_p
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
expr_stmt|;
comment|/* Compute which parts of the save area we need to access.  */
if|if
condition|(
name|frame
operator|.
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|area_bottom
operator|=
name|frame
operator|.
name|first_restore_gpr
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|area_top
operator|=
operator|(
name|frame
operator|.
name|last_save_gpr
operator|+
literal|1
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
block|{
name|area_bottom
operator|=
name|INT_MAX
expr_stmt|;
name|area_top
operator|=
name|INT_MIN
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|frame
operator|.
name|save_fprs_p
condition|)
block|{
if|if
condition|(
name|area_bottom
operator|>
operator|-
literal|64
condition|)
name|area_bottom
operator|=
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|area_top
operator|<
literal|0
condition|)
name|area_top
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
literal|18
index|]
condition|)
block|{
if|if
condition|(
name|area_bottom
operator|>
name|STACK_POINTER_OFFSET
operator|-
literal|16
condition|)
name|area_bottom
operator|=
name|STACK_POINTER_OFFSET
operator|-
literal|16
expr_stmt|;
if|if
condition|(
name|area_top
operator|<
name|STACK_POINTER_OFFSET
operator|-
literal|8
condition|)
name|area_top
operator|=
name|STACK_POINTER_OFFSET
operator|-
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|19
index|]
condition|)
block|{
if|if
condition|(
name|area_bottom
operator|>
name|STACK_POINTER_OFFSET
operator|-
literal|8
condition|)
name|area_bottom
operator|=
name|STACK_POINTER_OFFSET
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|area_top
operator|<
name|STACK_POINTER_OFFSET
condition|)
name|area_top
operator|=
name|STACK_POINTER_OFFSET
expr_stmt|;
block|}
block|}
comment|/* Check whether we can access the register save area.        If not, increment the frame pointer as required.  */
if|if
condition|(
name|area_top
operator|<=
name|area_bottom
condition|)
block|{
comment|/* Nothing to restore.  */
block|}
elseif|else
if|if
condition|(
name|frame
operator|.
name|frame_size
operator|+
name|area_bottom
operator|>=
literal|0
operator|&&
name|frame
operator|.
name|frame_size
operator|+
name|area_top
operator|<=
literal|4096
condition|)
block|{
comment|/* Area is in range.  */
name|offset
operator|=
name|frame
operator|.
name|frame_size
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|insn
decl_stmt|,
name|frame_off
decl_stmt|;
name|offset
operator|=
name|area_bottom
operator|<
literal|0
condition|?
operator|-
name|area_bottom
else|:
literal|0
expr_stmt|;
name|frame_off
operator|=
name|GEN_INT
argument_list|(
name|frame
operator|.
name|frame_size
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|frame_off
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
name|frame_off
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|frame_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|frame_pointer
argument_list|,
name|frame_off
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore call saved fprs.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|frame
operator|.
name|save_fprs_p
condition|)
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|-
literal|64
operator|+
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|8
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
literal|18
index|]
operator|&&
operator|!
name|global_regs
index|[
literal|18
index|]
condition|)
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|STACK_POINTER_OFFSET
operator|-
literal|16
argument_list|,
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|19
index|]
operator|&&
operator|!
name|global_regs
index|[
literal|19
index|]
condition|)
name|restore_fpr
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|STACK_POINTER_OFFSET
operator|-
literal|8
argument_list|,
literal|19
argument_list|)
expr_stmt|;
block|}
comment|/* Return register.  */
name|return_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
comment|/* Restore call saved gprs.  */
if|if
condition|(
name|frame
operator|.
name|first_restore_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|rtx
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for global register and save them  	 to stack location from where they get restored.  */
for|for
control|(
name|i
operator|=
name|frame
operator|.
name|first_restore_gpr
init|;
name|i
operator|<=
name|frame
operator|.
name|last_save_gpr
condition|;
name|i
operator|++
control|)
block|{
comment|/* These registers are special and need to be  	     restored in any case.  */
if|if
condition|(
name|i
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|i
operator|==
name|RETURN_REGNUM
operator|||
name|i
operator|==
name|BASE_REGISTER
operator|||
operator|(
name|flag_pic
operator|&&
name|i
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|i
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fetch return address from stack before load multiple, 	 this will do good for scheduling.  */
if|if
condition|(
name|frame
operator|.
name|last_save_gpr
operator|>=
name|RETURN_REGNUM
operator|&&
name|frame
operator|.
name|first_restore_gpr
operator|<
name|RETURN_REGNUM
condition|)
block|{
name|int
name|return_regnum
init|=
name|find_unused_clobbered_reg
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|return_regnum
condition|)
name|return_regnum
operator|=
literal|4
expr_stmt|;
name|return_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|return_regnum
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|RETURN_REGNUM
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* ??? As references to the base register are not made 	 explicit in insn RTX code, we have to add a barrier here 	 to prevent incorrect scheduling.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer
argument_list|,
name|offset
operator|+
name|frame
operator|.
name|first_restore_gpr
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|addr
argument_list|,
name|s390_sr_alias_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|.
name|first_restore_gpr
operator|!=
name|frame
operator|.
name|last_save_gpr
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_load_multiple
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|frame
operator|.
name|first_restore_gpr
argument_list|)
argument_list|,
name|addr
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|last_save_gpr
operator|-
name|frame
operator|.
name|first_restore_gpr
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|frame
operator|.
name|first_restore_gpr
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return to caller.  */
name|p
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|return_reg
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size in bytes of a function argument of     type TYPE and/or mode MODE.  At least one of TYPE or    MODE must be specified.  */
end_comment

begin_function
specifier|static
name|int
name|s390_function_arg_size
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
condition|)
return|return
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
return|;
comment|/* No type info available for some library calls ...  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
comment|/* If we have neither type nor mode, abort */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if a function argument of type TYPE and mode MODE    is to be passed by reference.  The ABI specifies that only    structures of size 1, 2, 4, or 8 bytes are passed by value,    all other structures (and complex numbers) are passed by    reference.  */
end_comment

begin_function
name|int
name|s390_function_arg_pass_by_reference
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|size
operator|!=
literal|1
operator|&&
name|size
operator|!=
literal|2
operator|&&
name|size
operator|!=
literal|4
operator|&&
name|size
operator|!=
literal|8
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument of mode MODE and    data type TYPE.  (TYPE is null for libcalls where that information    may not be available.).  The boolean NAMED specifies whether the    argument is a named argument (as opposed to an unnamed argument    matching an ellipsis).  */
end_comment

begin_function
name|void
name|s390_function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_SOFT_FLOAT
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|SFmode
operator|)
condition|)
block|{
name|cum
operator|->
name|fprs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|cum
operator|->
name|gprs
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|cum
operator|->
name|gprs
operator|+=
operator|(
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).       On S/390, we use general purpose registers 2 through 6 to    pass integer, pointer, and certain structure arguments, and    floating point registers 0 and 2 (0, 2, 4, and 6 on 64-bit)    to pass floating point arguments.  All remaining arguments    are pushed to the stack.  */
end_comment

begin_function
name|rtx
name|s390_function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TARGET_SOFT_FLOAT
operator|&&
operator|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|SFmode
operator|)
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|fprs
operator|+
literal|1
operator|>
operator|(
name|TARGET_64BIT
condition|?
literal|4
else|:
literal|2
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|cum
operator|->
name|fprs
operator|+
literal|16
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|size
init|=
name|s390_function_arg_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|n_gprs
init|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|cum
operator|->
name|gprs
operator|+
name|n_gprs
operator|>
literal|5
condition|)
return|return
literal|0
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|cum
operator|->
name|gprs
operator|+
literal|2
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create and return the va_list datatype.     On S/390, va_list is an array type equivalent to        typedef struct __va_list_tag         {             long __gpr;             long __fpr;             void *__overflow_arg_area;             void *__reg_save_area;                      } va_list[1];     where __gpr and __fpr hold the number of general purpose    or floating point arguments used up to now, respectively,    __overflow_arg_area points to the stack location of the     next argument passed on the stack, and __reg_save_area    always points to the start of the register area in the    call frame of the current function.  The function prologue    saves all registers used for argument passing into this    area if the function uses variable arguments.  */
end_comment

begin_function
name|tree
name|s390_build_va_list
parameter_list|()
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
name|record
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__gpr"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__fpr"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement va_start by filling the va_list structure VALIST.    STDARG_P is true if implementing __builtin_stdarg_va_start,    false if implementing __builtin_varargs_va_start.  NEXTARG    points to the first anonymous stack argument.     The following global variables are used to initialize    the va_list structure:       current_function_args_info:        holds number of gprs and fprs used for named arguments.      current_function_arg_offset_rtx:        holds the offset of the first anonymous stack argument        (relative to the virtual arg pointer).  */
end_comment

begin_function
name|void
name|s390_va_start
parameter_list|(
name|stdarg_p
parameter_list|,
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|int
name|stdarg_p
decl_stmt|;
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|int
name|off
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|gprs
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|fprs
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|n_gpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|n_fpr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the overflow area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|current_function_arg_offset_rtx
argument_list|)
expr_stmt|;
name|off
operator|=
name|off
operator|<
literal|0
condition|?
literal|0
else|:
name|off
expr_stmt|;
if|if
condition|(
operator|!
name|stdarg_p
condition|)
name|off
operator|=
name|off
operator|>
literal|0
condition|?
name|off
operator|-
name|UNITS_PER_WORD
else|:
name|off
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: n_gpr = %d, n_fpr = %d off %d\n"
argument_list|,
operator|(
name|int
operator|)
name|n_gpr
argument_list|,
operator|(
name|int
operator|)
name|n_fpr
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|off
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the register save area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|STACK_POINTER_OFFSET
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg by updating the va_list structure     VALIST as required to retrieve an argument of type    TYPE, and returning that argument.         Generates code equivalent to:        if (integral value) {      if (size<= 4&& args.gpr< 5 ||          size> 4&& args.gpr< 4 )         ret = args.reg_save_area[args.gpr+8]      else        ret = *args.overflow_arg_area++;    } else if (float value) {      if (args.fgpr< 2)        ret = args.reg_save_area[args.fpr+64]      else        ret = *args.overflow_arg_area++;    } else if (aggregate value) {      if (args.gpr< 5)        ret = *args.reg_save_area[args.gpr]      else        ret = **args.overflow_arg_area++;    } */
end_comment

begin_function
name|rtx
name|s390_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|reg
decl_stmt|,
name|t
decl_stmt|,
name|u
decl_stmt|;
name|int
name|indirect_p
decl_stmt|,
name|size
decl_stmt|,
name|n_reg
decl_stmt|,
name|sav_ofs
decl_stmt|,
name|sav_scale
decl_stmt|,
name|max_reg
decl_stmt|;
name|rtx
name|lab_false
decl_stmt|,
name|lab_over
decl_stmt|,
name|addr_rtx
decl_stmt|,
name|r
decl_stmt|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: aggregate type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Aggregates are passed by reference.  */
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|sav_scale
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|size
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|max_reg
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TARGET_SOFT_FLOAT
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: float type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* FP args go in FP registers, if present.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|fpr
expr_stmt|;
name|n_reg
operator|=
literal|1
expr_stmt|;
name|sav_ofs
operator|=
literal|16
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|sav_scale
operator|=
literal|8
expr_stmt|;
comment|/* TARGET_64BIT has up to 4 parameter in fprs */
name|max_reg
operator|=
name|TARGET_64BIT
condition|?
literal|3
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_arg: other type"
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise into GP registers.  */
name|indirect_p
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|gpr
expr_stmt|;
name|n_reg
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|sav_ofs
operator|=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|sav_ofs
operator|+=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SImode
condition|?
literal|4
else|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|HImode
condition|?
literal|6
else|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|QImode
condition|?
literal|7
else|:
literal|0
expr_stmt|;
else|else
name|sav_ofs
operator|+=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|HImode
condition|?
literal|2
else|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|QImode
condition|?
literal|3
else|:
literal|0
expr_stmt|;
name|sav_scale
operator|=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|n_reg
operator|>
literal|1
condition|)
name|max_reg
operator|=
literal|3
expr_stmt|;
else|else
name|max_reg
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Pull the value out of the saved registers ...  */
name|lab_false
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab_over
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|reg
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|max_reg
argument_list|)
argument_list|,
name|GT
argument_list|,
name|const1_rtx
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav_ofs
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|build_int_2
argument_list|(
name|sav_ofs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|sav
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|long_integer_type_node
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|sav_scale
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab_over
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab_false
argument_list|)
expr_stmt|;
comment|/* ... Otherwise out of the overflow area.  */
name|t
operator|=
name|save_expr
argument_list|(
name|ovf
argument_list|)
expr_stmt|;
comment|/* In 64 BIT for each argument on stack, a full 64 bit slot is allocated.  */
if|if
condition|(
name|size
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|UNITS_PER_WORD
operator|-
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|save_expr
argument_list|(
name|ovf
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab_over
argument_list|)
expr_stmt|;
comment|/* If less than max_regs a registers are retrieved out       of register save area, increment.  */
name|u
operator|=
name|build
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|build_int_2
argument_list|(
name|n_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|u
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|u
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
block|{
name|r
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|r
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|addr_rtx
return|;
block|}
end_function

begin_comment
comment|/* Output assembly code for the trampoline template to    stdio stream FILE.     On S/390, we use gpr 1 internally in the trampoline code;    gpr 0 is used to hold the static chain.  */
end_comment

begin_function
name|void
name|s390_trampoline_template
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"larl\t%s,0f\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lg\t%s,0(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lg\t%s,8(%s)\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"br\t%s\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0:\t.quad\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".quad\t0\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"basr\t%s,0\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l\t%s,10(%s)\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l\t%s,14(%s)\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"br\t%s\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".long\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".long\t0\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|s390_initialize_trampoline
parameter_list|(
name|addr
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|rtx
name|fnaddr
decl_stmt|;
name|rtx
name|cxt
decl_stmt|;
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|20
else|:
literal|12
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
literal|28
else|:
literal|16
operator|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return rtx for 64-bit constant formed from the 32-bit subwords    LOW and HIGH, independent of the host word size.  */
end_comment

begin_function
name|rtx
name|s390_gen_rtx_const_DI
parameter_list|(
name|high
parameter_list|,
name|low
parameter_list|)
name|int
name|high
decl_stmt|;
name|int
name|low
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|high
expr_stmt|;
name|val
operator|<<=
literal|32
expr_stmt|;
name|val
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|low
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|32
return|return
name|immed_double_const
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|low
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|high
argument_list|,
name|DImode
argument_list|)
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output assembler code to FILE to increment profiler label # LABELNO    for profiling a function entry.  */
end_comment

begin_function
name|void
name|s390_function_profiler
parameter_list|(
name|file
parameter_list|,
name|labelno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|rtx
name|op
index|[
literal|7
index|]
decl_stmt|;
name|char
name|label
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
literal|"%sP%d"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"# function profiler \n"
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|RETURN_REGNUM
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|op
index|[
literal|1
index|]
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAG
argument_list|(
name|op
index|[
literal|3
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_mcount"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op
index|[
literal|4
index|]
argument_list|)
argument_list|,
literal|113
argument_list|)
expr_stmt|;
name|op
index|[
literal|4
index|]
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|op
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"stg\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"larl\t%2,%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"brasl\t%0,%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lg\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bras\t%2,%l6"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%4"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,0(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%2,4(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%0,%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|5
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|op
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bras\t%2,%l6"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%4-%l5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".long\t%3-%l5"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|op
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lr\t%0,%2"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%0,0(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"a\t%2,4(%2)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"basr\t%0,%0"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"l\t%0,%1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

