begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for generic Darwin as target machine for GNU C compiler.    Copyright (C) 1989, 1990, 1991, 1992, 1993, 2000, 2001    Free Software Foundation, Inc.    Contributed by Apple Computer Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"darwin-protos.h"
end_include

begin_decl_stmt
specifier|extern
name|void
name|machopic_output_stub
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|machopic_data_defined_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|func_name_maybe_scoped
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_non_lazy_ptrs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_stubs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|name_needs_quotes
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|!
name|ISIDNUM
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * flag_pic = 1 ... generate only indirections  * flag_pic = 2 ... generate indirections and pure code  */
end_comment

begin_comment
comment|/* This module assumes that (const (symbol_ref "foo")) is a legal pic    reference, which will not be changed.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|machopic_defined_list
decl_stmt|;
end_decl_stmt

begin_function
name|enum
name|machopic_addr_class
name|machopic_classify_ident
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
decl_stmt|;
name|int
name|lprefix
init|=
operator|(
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'&'
operator|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'"'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'L'
operator|)
operator|)
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'O'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'B'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'J'
operator|&&
name|name
index|[
literal|4
index|]
operator|==
literal|'C'
operator|&&
name|name
index|[
literal|5
index|]
operator|==
literal|'_'
operator|)
operator|)
decl_stmt|;
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'!'
condition|)
block|{
comment|/* Here if no special encoding to be found.  */
if|if
condition|(
name|lprefix
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|5
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|len
operator|-
literal|5
argument_list|,
literal|"$stub"
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|>
literal|6
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|len
operator|-
literal|6
argument_list|,
literal|"$stub\""
argument_list|)
operator|)
condition|)
return|return
name|MACHOPIC_DEFINED_FUNCTION
return|;
return|return
name|MACHOPIC_DEFINED_DATA
return|;
block|}
for|for
control|(
name|temp
operator|=
name|machopic_defined_list
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
block|}
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|ident
argument_list|)
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
return|return
name|MACHOPIC_UNDEFINED
return|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
return|return
name|MACHOPIC_DEFINED_FUNCTION
return|;
comment|/* It is possible that someone is holding a "stale" name, which has      since been defined.  See if there is a "defined" name (i.e,      different from NAME only in having a '!D_' or a '!T_' instead of      a '!d_' or '!t_' prefix) in the identifier hash tables.  If so, say      that this identifier is defined.  */
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
name|new_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new_name
index|[
literal|1
index|]
operator|=
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
condition|?
literal|'D'
else|:
literal|'T'
expr_stmt|;
if|if
condition|(
name|maybe_get_identifier
argument_list|(
name|new_name
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
condition|?
name|MACHOPIC_DEFINED_DATA
else|:
name|MACHOPIC_DEFINED_FUNCTION
return|;
block|}
for|for
control|(
name|temp
operator|=
name|machopic_defined_list
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
return|return
name|MACHOPIC_DEFINED_FUNCTION
return|;
else|else
return|return
name|MACHOPIC_DEFINED_DATA
return|;
block|}
block|}
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
block|{
if|if
condition|(
name|lprefix
condition|)
return|return
name|MACHOPIC_DEFINED_FUNCTION
return|;
else|else
return|return
name|MACHOPIC_UNDEFINED_FUNCTION
return|;
block|}
else|else
block|{
if|if
condition|(
name|lprefix
condition|)
return|return
name|MACHOPIC_DEFINED_DATA
return|;
else|else
return|return
name|MACHOPIC_UNDEFINED_DATA
return|;
block|}
block|}
end_function

begin_function
name|enum
name|machopic_addr_class
name|machopic_classify_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|machopic_classify_ident
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|machopic_ident_defined_p
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
switch|switch
condition|(
name|machopic_classify_ident
argument_list|(
name|ident
argument_list|)
condition|)
block|{
case|case
name|MACHOPIC_UNDEFINED
case|:
case|case
name|MACHOPIC_UNDEFINED_DATA
case|:
case|case
name|MACHOPIC_UNDEFINED_FUNCTION
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|machopic_data_defined_p
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
switch|switch
condition|(
name|machopic_classify_ident
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|MACHOPIC_DEFINED_DATA
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|machopic_name_defined_p
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|machopic_ident_defined_p
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|machopic_define_ident
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|machopic_ident_defined_p
argument_list|(
name|ident
argument_list|)
condition|)
name|machopic_defined_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|machopic_defined_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|machopic_define_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|machopic_define_ident
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a static to make inline functions work.  The rtx    representing the PIC base symbol always points to here. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|function_base
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_pic_label_num
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|machopic_function_base_name
parameter_list|()
block|{
specifier|static
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|current_name
decl_stmt|;
name|current_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|current_name
condition|)
block|{
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
comment|/* Save mucho space and time.  Some of the C++ mangled names are over 	 700 characters long!  Note that we produce a label containing a '-' 	 if the function we're compiling is an Objective-C method, as evinced 	 by the incredibly scientific test below.  This is because code in 	 rs6000.c makes the same ugly test when loading the PIC reg.  */
operator|++
name|current_pic_label_num
expr_stmt|;
if|if
condition|(
operator|*
name|current_name
operator|==
literal|'+'
operator|||
operator|*
name|current_name
operator|==
literal|'-'
condition|)
name|sprintf
argument_list|(
name|function_base
argument_list|,
literal|"*\"L-%d$pb\""
argument_list|,
name|current_pic_label_num
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|function_base
argument_list|,
literal|"*L%d$pb"
argument_list|,
name|current_pic_label_num
argument_list|)
expr_stmt|;
name|name
operator|=
name|current_name
expr_stmt|;
block|}
return|return
name|function_base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|machopic_non_lazy_pointers
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a non-lazy pointer name corresponding to the given name,    either by finding it in our list of pointer names, or by generating    a new one.  */
end_comment

begin_function
name|char
modifier|*
name|machopic_non_lazy_ptr_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|temp_name
decl_stmt|;
name|tree
name|temp
decl_stmt|,
name|ident
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_non_lazy_pointers
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
block|}
name|STRIP_NAME_ENCODING
argument_list|(
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Try again, but comparing names this time.  */
for|for
control|(
name|temp
operator|=
name|machopic_non_lazy_pointers
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|temp_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|temp_name
argument_list|,
name|temp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
block|}
block|}
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|tree
name|ptr_name
decl_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"&L"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"$non_lazy_ptr"
argument_list|)
expr_stmt|;
name|ptr_name
operator|=
name|get_identifier
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|machopic_non_lazy_pointers
operator|=
name|tree_cons
argument_list|(
name|ptr_name
argument_list|,
name|ident
argument_list|,
name|machopic_non_lazy_pointers
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|machopic_non_lazy_pointers
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|ptr_name
argument_list|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|machopic_stubs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make sure the GC knows about our homemade lists.  */
end_comment

begin_function
name|void
name|machopic_add_gc_roots
parameter_list|()
block|{
name|ggc_add_tree_root
argument_list|(
operator|&
name|machopic_defined_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|machopic_non_lazy_pointers
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|machopic_stubs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name of the stub corresponding to the given name,    generating a new stub name if necessary.  */
end_comment

begin_function
name|char
modifier|*
name|machopic_stub_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|temp
decl_stmt|,
name|ident
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_stubs
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
name|tname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|tname
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
comment|/* A library call name might not be section-encoded yet, so try 	 it against a stripped name.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'!'
operator|&&
name|tname
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|tname
operator|+
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
block|}
name|STRIP_NAME_ENCODING
argument_list|(
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|tree
name|ptr_name
decl_stmt|;
name|int
name|needs_quotes
init|=
name|name_needs_quotes
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_quotes
condition|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"&\"L"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"&L"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|strcat
argument_list|(
name|buffer
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_quotes
condition|)
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"$stub\""
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"$stub"
argument_list|)
expr_stmt|;
name|ptr_name
operator|=
name|get_identifier
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|machopic_stubs
operator|=
name|tree_cons
argument_list|(
name|ptr_name
argument_list|,
name|ident
argument_list|,
name|machopic_stubs
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|machopic_stubs
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|ptr_name
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|machopic_validate_stub_or_non_lazy_ptr
parameter_list|(
name|name
parameter_list|,
name|validate_stub
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|validate_stub
decl_stmt|;
block|{
name|char
modifier|*
name|real_name
decl_stmt|;
name|tree
name|temp
decl_stmt|,
name|ident
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|,
name|id2
decl_stmt|;
for|for
control|(
name|temp
operator|=
operator|(
name|validate_stub
condition|?
name|machopic_stubs
else|:
name|machopic_non_lazy_pointers
operator|)
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|ident
operator|==
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
comment|/* Mark both the stub or non-lazy pointer as well as the 	     original symbol as being referenced.  */
name|TREE_USED
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|real_name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|id2
operator|=
name|maybe_get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id2
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id2
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Transform ORIG, which may be any data source, to the corresponding    source using indirections.  */
end_comment

begin_function
name|rtx
name|machopic_indirect_data_reference
parameter_list|(
name|orig
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|rtx
name|ptr_ref
init|=
name|orig
decl_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|machopic_data_defined_p
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|rtx
name|pic_base
init|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
decl_stmt|;
name|rtx
name|offset
init|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|orig
argument_list|,
name|pic_base
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
name|rtx
name|hi_sum_reg
init|=
name|reg
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|orig
operator|=
name|reg
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_lo_sum
argument_list|)
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|orig
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|orig
return|;
block|}
name|ptr_ref
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|machopic_non_lazy_ptr_name
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|ptr_ref
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|ptr_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ptr_ref
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|result
decl_stmt|;
comment|/* legitimize both operands of the PLUS */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|orig
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|orig
return|;
if|if
condition|(
name|MACHOPIC_PURE
operator|&&
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST_INT
condition|)
name|result
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|base
argument_list|)
operator|&&
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MACHOPIC_JUST_INDIRECT
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|ptr_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* When the target is i386, this code prevents crashes due to the      compiler's ignorance on how to move the PIC base register to      other registers.  (The reload phase sometimes introduces such      insns.)  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
ifdef|#
directive|ifdef
name|I386
comment|/* Prevent the same register from being erroneously used 	      as both the base and index registers.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
endif|#
directive|endif
operator|&&
name|reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|ptr_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|reg
expr_stmt|;
block|}
return|return
name|ptr_ref
return|;
block|}
end_function

begin_comment
comment|/* Transform TARGET (a MEM), which is a function call target, to the    corresponding symbol_stub if necessary.  Return a new MEM.  */
end_comment

begin_function
name|rtx
name|machopic_indirect_call_target
parameter_list|(
name|target
parameter_list|)
name|rtx
name|target
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|target
return|;
if|if
condition|(
name|MACHOPIC_INDIRECT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If the name is already defined, we need do nothing.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
return|return
name|target
return|;
if|if
condition|(
operator|!
name|machopic_name_defined_p
argument_list|(
name|name
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|stub_name
init|=
name|machopic_stub_name
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|mode
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
name|rtx
name|machopic_legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|,
name|reg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|pic_ref
init|=
name|orig
decl_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_PURE
condition|)
return|return
name|orig
return|;
comment|/* First handle a simple SYMBOL_REF or LABEL_REF */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
condition|)
block|{
comment|/* addr(foo) =&func+(foo-func) */
name|rtx
name|pic_base
decl_stmt|;
name|orig
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|orig
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|orig
argument_list|)
return|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
name|pic_base
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_lo_sum
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|offset
init|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pic_base
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
comment|/* Generating a new reg may expose opportunities for 		 common subexpression elimination.  */
name|rtx
name|hi_sum_reg
init|=
operator|(
name|reload_in_progress
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
operator|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_lo_sum */
block|{
name|rtx
name|pic
init|=
name|pic_offset_table_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic
argument_list|)
expr_stmt|;
name|pic
operator|=
name|reg
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|emit_insn (gen_rtx (USE, VOIDmode, 				  gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM)));
endif|#
directive|endif
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic
argument_list|,
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pic_base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_lo_sum
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|offset
init|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|orig
argument_list|,
name|pic_base
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
name|rtx
name|hi_sum_reg
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
block|}
name|hi_sum_reg
operator|=
name|reg
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
comment|/*  HAVE_lo_sum  */
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|REG
condition|)
block|{
return|return
name|orig
return|;
block|}
else|else
block|{
name|rtx
name|pic
init|=
name|pic_offset_table_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic
argument_list|)
expr_stmt|;
name|pic
operator|=
name|reg
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|emit_insn (gen_rtx (USE, VOIDmode, 				      pic_offset_table_rtx));
endif|#
directive|endif
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic
argument_list|,
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|orig
argument_list|,
name|pic_base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic_ref
argument_list|)
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
else|else
block|{
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|pic_ref
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|pic_ref
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|orig
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
operator|!=
name|pic_offset_table_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|int
name|is_complex
init|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
decl_stmt|;
name|base
operator|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|orig
operator|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
operator|(
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|pic_ref
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|is_complex
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|base
argument_list|)
operator|&&
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg
operator|&&
name|is_complex
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
block|}
comment|/* Likewise, should we set special REG_NOTEs here?  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|rtx
name|addr
init|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|addr
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|addr
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
block|}
return|return
name|pic_ref
return|;
block|}
end_function

begin_function
name|void
name|machopic_finish
parameter_list|(
name|asm_out_file
parameter_list|)
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
block|{
name|tree
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_stubs
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|stub_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|stub
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|temp
argument_list|)
condition|)
continue|continue;
comment|/* If the symbol is actually defined, we don't need a stub.  */
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|sym_name
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
continue|continue;
name|STRIP_NAME_ENCODING
argument_list|(
name|sym_name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|sym
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|strcpy
argument_list|(
name|sym
argument_list|,
name|sym_name
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|strcpy
argument_list|(
name|sym
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
else|else
name|sym
index|[
literal|0
index|]
operator|=
literal|'_'
operator|,
name|strcpy
argument_list|(
name|sym
operator|+
literal|1
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|stub
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|stub_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|stub_name
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|strcpy
argument_list|(
name|stub
argument_list|,
name|stub_name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|stub
index|[
literal|0
index|]
operator|=
literal|'_'
operator|,
name|strcpy
argument_list|(
name|stub
operator|+
literal|1
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
name|machopic_output_stub
argument_list|(
name|asm_out_file
argument_list|,
name|sym
argument_list|,
name|stub
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|temp
operator|=
name|machopic_non_lazy_pointers
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
name|char
modifier|*
name|sym_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|lazy_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|tree decl = lookup_name_darwin (TREE_VALUE (temp));
endif|#
directive|endif
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|temp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|machopic_ident_defined_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
if|#
directive|if
literal|0
comment|/* add back when we have private externs */
condition||| (decl&& DECL_PRIVATE_EXTERN (decl))
endif|#
directive|endif
condition|)
block|{
name|data_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|lazy_name
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|sym_name
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|machopic_nl_symbol_ptr_section
argument_list|()
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|lazy_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.indirect_symbol "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|machopic_operand_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
if|if
condition|(
name|MACHOPIC_JUST_INDIRECT
condition|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|machopic_name_defined_p
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|machopic_name_defined_p
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|machopic_name_defined_p
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|#
directive|if
literal|0
comment|/*def TARGET_TOC*/
comment|/* i.e., PowerPC */
comment|/* Without this statement, the compiler crashes while compiling enquire.c      when targetting PowerPC.  It is not known why this code is not needed      when targetting other processors.  */
block|else if (GET_CODE (op) == SYMBOL_REF&& (machopic_classify_name (XSTR (op, 0)) 	       == MACHOPIC_DEFINED_FUNCTION))     {       return 1;     }
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function records whether a given name corresponds to a defined    or undefined function or variable, for machopic_classify_ident to    use later.  */
end_comment

begin_function
name|void
name|darwin_encode_section_info
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|char
name|code
init|=
literal|'\0'
decl_stmt|;
name|int
name|defined
init|=
literal|0
decl_stmt|;
name|rtx
name|sym_ref
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_str
decl_stmt|;
name|char
modifier|*
name|new_str
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|new_len
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|)
operator|)
condition|)
name|defined
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|code
operator|=
operator|(
name|defined
condition|?
literal|'T'
else|:
literal|'t'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|code
operator|=
operator|(
name|defined
condition|?
literal|'D'
else|:
literal|'d'
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'\0'
condition|)
return|return;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|orig_str
operator|=
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|orig_str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|orig_str
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* Already encoded; see if we need to change it.  */
if|if
condition|(
name|code
operator|==
name|orig_str
index|[
literal|1
index|]
condition|)
return|return;
comment|/* Yes, tweak a copy of the name and put it in a new string.  */
name|new_str
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_str
argument_list|,
name|orig_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new_str
index|[
literal|1
index|]
operator|=
name|code
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|new_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the encoding.  */
name|new_len
operator|=
name|len
operator|+
literal|4
expr_stmt|;
name|new_str
operator|=
name|alloca
argument_list|(
name|new_len
argument_list|)
expr_stmt|;
name|new_str
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|new_str
index|[
literal|1
index|]
operator|=
name|code
expr_stmt|;
name|new_str
index|[
literal|2
index|]
operator|=
literal|'_'
expr_stmt|;
name|new_str
index|[
literal|3
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
name|new_str
operator|+
literal|4
argument_list|,
name|orig_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_alloc_string
argument_list|(
name|new_str
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
block|}
comment|/* The non-lazy pointer list may have captured references to the      old encoded name, change them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|update_non_lazy_ptrs
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|update_stubs
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the list of non-lazy pointers and update any recorded names whose    stripped name matches the argument.  */
end_comment

begin_function
specifier|static
name|void
name|update_non_lazy_ptrs
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|name1
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_non_lazy_pointers
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
name|char
modifier|*
name|sym_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sym_name
operator|==
literal|'!'
condition|)
block|{
name|STRIP_NAME_ENCODING
argument_list|(
name|name2
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|=
name|name
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Function NAME is being defined, and its label has just been output.    If there's already a reference to a stub for this function, we can    just emit the stub label now and we don't bother emitting the stub later. */
end_comment

begin_function
name|void
name|machopic_output_possible_stub_label
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|temp
decl_stmt|;
comment|/* Ensure we're looking at a section-encoded name.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'!'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|!=
literal|'t'
operator|&&
name|name
index|[
literal|1
index|]
operator|!=
literal|'T'
operator|)
condition|)
return|return;
for|for
control|(
name|temp
operator|=
name|machopic_stubs
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|sym_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|sym_name
index|[
literal|1
index|]
operator|==
literal|'T'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
operator|+
literal|2
argument_list|,
name|sym_name
operator|+
literal|2
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Avoid generating a stub for this.  */
name|TREE_USED
argument_list|(
name|temp
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scan the list of stubs and update any recorded names whose    stripped name matches the argument.  */
end_comment

begin_function
specifier|static
name|void
name|update_stubs
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|name1
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|machopic_stubs
init|;
name|temp
operator|!=
name|NULL_TREE
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
block|{
name|char
modifier|*
name|sym_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sym_name
operator|==
literal|'!'
condition|)
block|{
name|STRIP_NAME_ENCODING
argument_list|(
name|name2
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|=
name|name
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|machopic_asm_out_constructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|flag_pic
condition|)
name|mod_init_section
argument_list|()
expr_stmt|;
else|else
name|constructor_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".reference .constructors_used\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|machopic_asm_out_destructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|flag_pic
condition|)
name|mod_term_section
argument_list|()
expr_stmt|;
else|else
name|destructor_section
argument_list|()
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".reference .destructors_used\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

