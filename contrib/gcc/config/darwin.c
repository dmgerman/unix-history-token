begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for generic Darwin as target machine for GNU C compiler.    Copyright (C) 1989, 1990, 1991, 1992, 1993, 2000, 2001, 2002, 2003, 2004,    2005    Free Software Foundation, Inc.    Contributed by Apple Computer Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* Darwin supports a feature called fix-and-continue, which is used    for rapid turn around debugging.  When code is compiled with the    -mfix-and-continue flag, two changes are made to the generated code    that allow the system to do things that it would normally not be    able to do easily.  These changes allow gdb to load in    recompilation of a translation unit that has been changed into a    running program and replace existing functions and methods of that    translation unit with versions of those functions and methods    from the newly compiled translation unit.  The new functions access    the existing static symbols from the old translation unit, if the    symbol existed in the unit to be replaced, and from the new    translation unit, otherwise.     The changes are to insert 5 nops at the beginning of all functions    and to use indirection to get at static symbols.  The 5 nops    are required by consumers of the generated code.  Currently, gdb    uses this to patch in a jump to the overriding function, this    allows all uses of the old name to forward to the replacement,    including existing function pointers and virtual methods.  See    rs6000_emit_prologue for the code that handles the nop insertions.     The added indirection allows gdb to redirect accesses to static    symbols from the newly loaded translation unit to the existing    symbol, if any.  @code{static} symbols are special and are handled by    setting the second word in the .non_lazy_symbol_pointer data    structure to symbol.  See indirect_data for the code that handles    the extra indirection, and machopic_output_indirection and its use    of MACHO_SYMBOL_STATIC for the code that handles @code{static}    symbol indirection.  */
end_comment

begin_comment
comment|/* Section names.  */
end_comment

begin_decl_stmt
name|section
modifier|*
name|darwin_sections
index|[
name|NUM_DARWIN_SECTIONS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we're setting __attribute__ ((ms_struct)).  */
end_comment

begin_decl_stmt
name|int
name|darwin_ms_struct
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A get_unnamed_section callback used to switch to an ObjC section.    DIRECTIVE is as for output_section_asm_op.  */
end_comment

begin_function
specifier|static
name|void
name|output_objc_section_asm_op
parameter_list|(
specifier|const
name|void
modifier|*
name|directive
parameter_list|)
block|{
specifier|static
name|bool
name|been_here
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|been_here
condition|)
block|{
specifier|static
specifier|const
name|enum
name|darwin_section_enum
name|tomark
index|[]
init|=
block|{
comment|/* written, cold -> hot */
name|objc_cat_cls_meth_section
block|,
name|objc_cat_inst_meth_section
block|,
name|objc_string_object_section
block|,
name|objc_constant_string_object_section
block|,
name|objc_selector_refs_section
block|,
name|objc_selector_fixup_section
block|,
name|objc_cls_refs_section
block|,
name|objc_class_section
block|,
name|objc_meta_class_section
block|,
comment|/* shared, hot -> cold */
name|objc_cls_meth_section
block|,
name|objc_inst_meth_section
block|,
name|objc_protocol_section
block|,
name|objc_class_names_section
block|,
name|objc_meth_var_types_section
block|,
name|objc_meth_var_names_section
block|,
name|objc_category_section
block|,
name|objc_class_vars_section
block|,
name|objc_instance_vars_section
block|,
name|objc_module_info_section
block|,
name|objc_symbols_section
block|}
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|been_here
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|tomark
argument_list|)
condition|;
name|i
operator|++
control|)
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|tomark
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|output_section_asm_op
argument_list|(
name|directive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_ASM_INIT_SECTIONS.  */
end_comment

begin_function
name|void
name|darwin_init_sections
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|DEF_SECTION
parameter_list|(
name|NAME
parameter_list|,
name|FLAGS
parameter_list|,
name|DIRECTIVE
parameter_list|,
name|OBJC
parameter_list|)
define|\
value|darwin_sections[NAME] =					\     get_unnamed_section (FLAGS, (OBJC				\ 				 ? output_objc_section_asm_op	\ 				 : output_section_asm_op),	\ 			 "\t" DIRECTIVE);
include|#
directive|include
file|"config/darwin-sections.def"
undef|#
directive|undef
name|DEF_SECTION
name|readonly_data_section
operator|=
name|darwin_sections
index|[
name|const_section
index|]
expr_stmt|;
name|exception_section
operator|=
name|darwin_sections
index|[
name|darwin_exception_section
index|]
expr_stmt|;
name|eh_frame_section
operator|=
name|darwin_sections
index|[
name|darwin_eh_frame_section
index|]
expr_stmt|;
block|}
end_function

begin_function
name|int
name|name_needs_quotes
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|!
name|ISIDNUM
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if SYM_REF can be used without an indirection.  */
end_comment

begin_function
specifier|static
name|int
name|machopic_symbol_defined_p
parameter_list|(
name|rtx
name|sym_ref
parameter_list|)
block|{
if|if
condition|(
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
operator|&
name|MACHO_SYMBOL_FLAG_DEFINED
condition|)
return|return
name|true
return|;
comment|/* If a symbol references local and is not an extern to this      file, then the symbol might be able to declared as defined.  */
if|if
condition|(
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|sym_ref
argument_list|)
operator|&&
operator|!
name|SYMBOL_REF_EXTERNAL_P
argument_list|(
name|sym_ref
argument_list|)
condition|)
block|{
comment|/* If the symbol references a variable and the variable is a 	 common symbol, then this symbol is not defined.  */
if|if
condition|(
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
operator|&
name|MACHO_SYMBOL_FLAG_VARIABLE
condition|)
block|{
name|tree
name|decl
init|=
name|SYMBOL_REF_DECL
argument_list|(
name|sym_ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
return|return
name|true
return|;
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* This module assumes that (const (symbol_ref "foo")) is a legal pic    reference, which will not be changed.  */
end_comment

begin_function
name|enum
name|machopic_addr_class
name|machopic_classify_symbol
parameter_list|(
name|rtx
name|sym_ref
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|bool
name|function_p
decl_stmt|;
name|flags
operator|=
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
expr_stmt|;
name|function_p
operator|=
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|sym_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|machopic_symbol_defined_p
argument_list|(
name|sym_ref
argument_list|)
condition|)
return|return
operator|(
name|function_p
condition|?
name|MACHOPIC_DEFINED_FUNCTION
else|:
name|MACHOPIC_DEFINED_DATA
operator|)
return|;
else|else
return|return
operator|(
name|function_p
condition|?
name|MACHOPIC_UNDEFINED_FUNCTION
else|:
name|MACHOPIC_UNDEFINED_DATA
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_FIX_AND_CONTINUE
end_ifndef

begin_define
define|#
directive|define
name|TARGET_FIX_AND_CONTINUE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indicate when fix-and-continue style code generation is being used    and when a reference to data should be indirected so that it can be    rebound in a new translation unit to reference the original instance    of that data.  Symbol names that are for code generation local to    the translation unit are bound to the new translation unit;    currently this means symbols that begin with L or _OBJC_;    otherwise, we indicate that an indirect reference should be made to    permit the runtime to rebind new instances of the translation unit    to the original instance of the data.  */
end_comment

begin_function
specifier|static
name|int
name|indirect_data
parameter_list|(
name|rtx
name|sym_ref
parameter_list|)
block|{
name|int
name|lprefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* If we aren't generating fix-and-continue code, don't do anything special.  */
if|if
condition|(
name|TARGET_FIX_AND_CONTINUE
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, all symbol except symbols that begin with L or _OBJC_      are indirected.  Symbols that begin with L and _OBJC_ are always      bound to the current translation unit as they are used for      generated local data of the translation unit.  */
name|name
operator|=
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lprefix
operator|=
operator|(
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'&'
operator|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'"'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'L'
operator|)
operator|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
return|return
operator|!
name|lprefix
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|machopic_data_defined_p
parameter_list|(
name|rtx
name|sym_ref
parameter_list|)
block|{
if|if
condition|(
name|indirect_data
argument_list|(
name|sym_ref
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|machopic_classify_symbol
argument_list|(
name|sym_ref
argument_list|)
condition|)
block|{
case|case
name|MACHOPIC_DEFINED_DATA
case|:
case|case
name|MACHOPIC_DEFINED_FUNCTION
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|machopic_define_symbol
parameter_list|(
name|rtx
name|mem
parameter_list|)
block|{
name|rtx
name|sym_ref
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
operator||=
name|MACHO_SYMBOL_FLAG_DEFINED
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|char
operator|*
name|function_base
expr_stmt|;
end_expr_stmt

begin_function
specifier|const
name|char
modifier|*
name|machopic_function_base_name
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* if dynamic-no-pic is on, we should not get here */
name|gcc_assert
argument_list|(
operator|!
name|MACHO_DYNAMIC_NO_PIC_P
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_base
operator|==
name|NULL
condition|)
name|function_base
operator|=
operator|(
name|char
operator|*
operator|)
name|ggc_alloc_string
argument_list|(
literal|"<pic base>"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"<pic base>"
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|function_base
return|;
block|}
end_function

begin_comment
comment|/* Return a SYMBOL_REF for the PIC function base.  */
end_comment

begin_function
name|rtx
name|machopic_function_base_sym
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|sym_ref
decl_stmt|;
name|sym_ref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
operator||=
operator|(
name|MACHO_SYMBOL_FLAG_VARIABLE
operator||
name|MACHO_SYMBOL_FLAG_DEFINED
operator|)
expr_stmt|;
return|return
name|sym_ref
return|;
block|}
end_function

begin_comment
comment|/* Return either ORIG or (const:P (minus:P ORIG PIC_BASE)), depending    on whether pic_base is NULL or not.  */
end_comment

begin_function
specifier|static
specifier|inline
name|rtx
name|gen_pic_offset
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|pic_base
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pic_base
condition|)
return|return
name|orig
return|;
else|else
return|return
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|,
name|pic_base
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
specifier|const
name|char
operator|*
name|function_base_func_name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|current_pic_label_num
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|machopic_output_function_base_name
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|current_name
decl_stmt|;
comment|/* If dynamic-no-pic is on, we should not get here.  */
name|gcc_assert
argument_list|(
operator|!
name|MACHO_DYNAMIC_NO_PIC_P
argument_list|)
expr_stmt|;
name|current_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_base_func_name
operator|!=
name|current_name
condition|)
block|{
operator|++
name|current_pic_label_num
expr_stmt|;
name|function_base_func_name
operator|=
name|current_name
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"L%011d$pb\""
argument_list|,
name|current_pic_label_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The suffix attached to non-lazy pointer symbols.  */
end_comment

begin_define
define|#
directive|define
name|NON_LAZY_POINTER_SUFFIX
value|"$non_lazy_ptr"
end_define

begin_comment
comment|/* The suffix attached to stub symbols.  */
end_comment

begin_define
define|#
directive|define
name|STUB_SUFFIX
value|"$stub"
end_define

begin_typedef
typedef|typedef
name|struct
name|machopic_indirection
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The SYMBOL_REF for the entity referenced.  */
name|rtx
name|symbol
block|;
comment|/* The name of the stub or non-lazy pointer.  */
specifier|const
name|char
modifier|*
name|ptr_name
block|;
comment|/* True iff this entry is for a stub (as opposed to a non-lazy      pointer).  */
name|bool
name|stub_p
block|;
comment|/* True iff this stub or pointer pointer has been referenced.  */
name|bool
name|used
block|; }
end_typedef

begin_expr_stmt
name|machopic_indirection
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A table mapping stub names and non-lazy pointer names to    SYMBOL_REFs for the stubbed-to and pointed-to entities.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct machopic_indirection))
argument_list|)
name|htab_t
name|machopic_indirections
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return a hash value for a SLOT in the indirections hash table.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|machopic_indirection_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|slot
parameter_list|)
block|{
specifier|const
name|machopic_indirection
modifier|*
name|p
init|=
operator|(
specifier|const
name|machopic_indirection
operator|*
operator|)
name|slot
decl_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|p
operator|->
name|ptr_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the KEY is the same as that associated with    SLOT.  */
end_comment

begin_function
specifier|static
name|int
name|machopic_indirection_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|slot
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
name|machopic_indirection
operator|*
operator|)
name|slot
operator|)
operator|->
name|ptr_name
argument_list|,
name|key
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the non-lazy pointer (if STUB_P is false) or    stub (if STUB_B is true) corresponding to the given name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|machopic_indirection_name
parameter_list|(
name|rtx
name|sym_ref
parameter_list|,
name|bool
name|stub_p
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|machopic_indirection
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|bool
name|saw_star
init|=
name|false
decl_stmt|;
name|bool
name|needs_quotes
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
init|=
name|user_label_prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|quote
init|=
literal|""
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|maybe_get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|tree
name|id_orig
init|=
name|id
decl_stmt|;
while|while
condition|(
name|IDENTIFIER_TRANSPARENT_ALIAS
argument_list|(
name|id
argument_list|)
condition|)
name|id
operator|=
name|TREE_CHAIN
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|id_orig
condition|)
block|{
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|saw_star
operator|=
name|true
expr_stmt|;
name|prefix
operator|=
literal|""
expr_stmt|;
operator|++
name|name
expr_stmt|;
operator|--
name|namelen
expr_stmt|;
block|}
name|needs_quotes
operator|=
name|name_needs_quotes
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_quotes
condition|)
block|{
name|quote
operator|=
literal|"\""
expr_stmt|;
block|}
if|if
condition|(
name|stub_p
condition|)
name|suffix
operator|=
name|STUB_SUFFIX
expr_stmt|;
else|else
name|suffix
operator|=
name|NON_LAZY_POINTER_SUFFIX
expr_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
literal|"&L"
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|namelen
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|2
operator|*
name|strlen
argument_list|(
name|quote
argument_list|)
operator|+
literal|1
comment|/* '\0' */
argument_list|)
expr_stmt|;
comment|/* Construct the name of the non-lazy pointer or stub.  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"&%sL%s%s%s%s"
argument_list|,
name|quote
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|,
name|suffix
argument_list|,
name|quote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|machopic_indirections
condition|)
name|machopic_indirections
operator|=
name|htab_create_ggc
argument_list|(
literal|37
argument_list|,
name|machopic_indirection_hash
argument_list|,
name|machopic_indirection_eq
argument_list|,
comment|/*htab_del=*/
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|machopic_indirections
argument_list|,
name|buffer
argument_list|,
name|htab_hash_string
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
block|{
name|p
operator|=
operator|(
name|machopic_indirection
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|(
name|machopic_indirection
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|machopic_indirection
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|symbol
operator|=
name|sym_ref
expr_stmt|;
name|p
operator|->
name|ptr_name
operator|=
name|xstrdup
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|p
operator|->
name|stub_p
operator|=
name|stub_p
expr_stmt|;
name|p
operator|->
name|used
operator|=
name|false
expr_stmt|;
operator|*
name|slot
operator|=
name|p
expr_stmt|;
block|}
return|return
name|p
operator|->
name|ptr_name
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the stub for the mcount function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|machopic_mcount_stub_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|symbol
init|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"*mcount"
argument_list|)
decl_stmt|;
return|return
name|machopic_indirection_name
argument_list|(
name|symbol
argument_list|,
comment|/*stub_p=*/
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If NAME is the name of a stub or a non-lazy pointer , mark the stub    or non-lazy pointer as used -- and mark the object to which the    pointer/stub refers as used as well, since the pointer/stub will    emit a reference to it.  */
end_comment

begin_function
name|void
name|machopic_validate_stub_or_non_lazy_ptr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|machopic_indirection
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
operator|(
name|machopic_indirection
operator|*
operator|)
operator|(
name|htab_find_with_hash
argument_list|(
name|machopic_indirections
argument_list|,
name|name
argument_list|,
name|htab_hash_string
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|!
name|p
operator|->
name|used
condition|)
block|{
specifier|const
name|char
modifier|*
name|real_name
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|p
operator|->
name|used
operator|=
name|true
expr_stmt|;
comment|/* Do what output_addr_const will do when we actually call it.  */
if|if
condition|(
name|SYMBOL_REF_DECL
argument_list|(
name|p
operator|->
name|symbol
argument_list|)
condition|)
name|mark_decl_referenced
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|p
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|real_name
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|XSTR
argument_list|(
name|p
operator|->
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|maybe_get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|mark_referenced
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Transform ORIG, which may be any data source, to the corresponding    source using indirections.  */
end_comment

begin_function
name|rtx
name|machopic_indirect_data_reference
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|ptr_ref
init|=
name|orig
decl_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|int
name|defined
init|=
name|machopic_data_defined_p
argument_list|(
name|orig
argument_list|)
decl_stmt|;
if|if
condition|(
name|defined
operator|&&
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* Create a new register for CSE opportunities.  */
name|rtx
name|hi_reg
init|=
operator|(
name|no_new_pseudos
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|hi_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_low
argument_list|(
name|reg
argument_list|,
name|hi_reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* some other cpu -- writeme!  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|defined
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_lo_sum
argument_list|)
name|rtx
name|pic_base
init|=
name|machopic_function_base_sym
argument_list|()
decl_stmt|;
name|rtx
name|offset
init|=
name|gen_pic_offset
argument_list|(
name|orig
argument_list|,
name|pic_base
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
name|rtx
name|hi_sum_reg
init|=
operator|(
name|no_new_pseudos
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|orig
operator|=
name|reg
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_lo_sum
argument_list|)
name|gcc_assert
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|orig
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|orig
return|;
block|}
name|ptr_ref
operator|=
operator|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|machopic_indirection_name
argument_list|(
name|orig
argument_list|,
comment|/*stub_p=*/
name|false
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|SYMBOL_REF_DATA
argument_list|(
name|ptr_ref
argument_list|)
operator|=
name|SYMBOL_REF_DATA
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|ptr_ref
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|ptr_ref
argument_list|)
expr_stmt|;
name|machopic_define_symbol
argument_list|(
name|ptr_ref
argument_list|)
expr_stmt|;
return|return
name|ptr_ref
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|result
decl_stmt|;
comment|/* legitimize both operands of the PLUS */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|orig
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|orig
return|;
if|if
condition|(
name|MACHOPIC_PURE
operator|&&
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST_INT
condition|)
name|result
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACHOPIC_JUST_INDIRECT
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|ptr_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* When the target is i386, this code prevents crashes due to the      compiler's ignorance on how to move the PIC base register to      other registers.  (The reload phase sometimes introduces such      insns.)  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
ifdef|#
directive|ifdef
name|I386
comment|/* Prevent the same register from being erroneously used 	      as both the base and index registers.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
endif|#
directive|endif
operator|&&
name|reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|ptr_ref
argument_list|,
literal|0
argument_list|)
operator|=
name|reg
expr_stmt|;
block|}
return|return
name|ptr_ref
return|;
block|}
end_function

begin_comment
comment|/* Transform TARGET (a MEM), which is a function call target, to the    corresponding symbol_stub if necessary.  Return a new MEM.  */
end_comment

begin_function
name|rtx
name|machopic_indirect_call_target
parameter_list|(
name|rtx
name|target
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|target
return|;
if|if
condition|(
name|MACHOPIC_INDIRECT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
operator|(
name|SYMBOL_REF_FLAGS
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&
name|MACHO_SYMBOL_FLAG_DEFINED
operator|)
condition|)
block|{
name|rtx
name|sym_ref
init|=
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|stub_name
init|=
name|machopic_indirection_name
argument_list|(
name|sym_ref
argument_list|,
comment|/*stub_p=*/
name|true
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|sym_ref
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|mode
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
name|SYMBOL_REF_DATA
argument_list|(
name|XEXP
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|SYMBOL_REF_DATA
argument_list|(
name|sym_ref
argument_list|)
expr_stmt|;
name|MEM_READONLY_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
name|rtx
name|machopic_legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|pic_ref
init|=
name|orig
decl_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
return|return
name|orig
return|;
comment|/* First handle a simple SYMBOL_REF or LABEL_REF */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
condition|)
block|{
comment|/* addr(foo) =&func+(foo-func) */
name|rtx
name|pic_base
decl_stmt|;
name|orig
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|orig
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|orig
argument_list|)
return|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
comment|/* if dynamic-no-pic we don't have a pic base  */
if|if
condition|(
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
name|pic_base
operator|=
name|NULL
expr_stmt|;
else|else
name|pic_base
operator|=
name|machopic_function_base_sym
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|reload_in_progress
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_lo_sum
if|if
condition|(
name|MACHO_DYNAMIC_NO_PIC_P
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* ppc  */
name|rtx
name|temp_reg
init|=
operator|(
name|no_new_pseudos
operator|)
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|asym
init|=
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_macho_high
argument_list|(
name|temp_reg
argument_list|,
name|asym
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|asym
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Some other CPU -- WriteMe! but right now there are no other platform that can use dynamic-no-pic  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pic_ref
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|offset
init|=
name|gen_pic_offset
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pic_base
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
comment|/* Generating a new reg may expose opportunities for 		 common subexpression elimination.  */
name|rtx
name|hi_sum_reg
init|=
name|no_new_pseudos
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|sum
decl_stmt|;
name|sum
operator|=
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACHO_DYNAMIC_NO_PIC_P
condition|)
name|sum
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|sum
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|pic_ref
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_lo_sum */
block|{
name|rtx
name|pic
init|=
name|pic_offset_table_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic
argument_list|)
expr_stmt|;
name|pic
operator|=
name|reg
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|emit_insn (gen_rtx_USE (VOIDmode, 				      gen_rtx_REG (Pmode, 						   PIC_OFFSET_TABLE_REGNUM)));
endif|#
directive|endif
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|REGNO
argument_list|(
name|pic
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic
argument_list|,
name|gen_pic_offset
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pic_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_lo_sum
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|rtx
name|offset
init|=
name|gen_pic_offset
argument_list|(
name|orig
argument_list|,
name|pic_base
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_TOC
argument_list|)
comment|/* i.e., PowerPC */
name|rtx
name|hi_sum_reg
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|reload_in_progress
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
name|hi_sum_reg
operator|=
name|reg
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
operator|(
name|MACHO_DYNAMIC_NO_PIC_P
operator|)
condition|?
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
else|:
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|hi_sum_reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
comment|/*  HAVE_lo_sum  */
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|orig
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
return|return
name|orig
return|;
block|}
else|else
block|{
name|rtx
name|pic
init|=
name|pic_offset_table_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic
argument_list|)
expr_stmt|;
name|pic
operator|=
name|reg
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|emit_insn (gen_rtx_USE (VOIDmode, 					  pic_offset_table_rtx));
endif|#
directive|endif
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|REGNO
argument_list|(
name|pic
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic
argument_list|,
name|gen_pic_offset
argument_list|(
name|orig
argument_list|,
name|pic_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pic_ref
argument_list|)
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
else|else
block|{
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|pic_ref
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|pic_ref
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|orig
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
operator|!=
name|pic_offset_table_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|int
name|is_complex
init|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
decl_stmt|;
name|base
operator|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|orig
operator|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
operator|(
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|pic_ref
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|is_complex
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&&
name|is_complex
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
block|}
comment|/* Likewise, should we set special REG_NOTEs here?  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|rtx
name|addr
init|=
name|machopic_legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|addr
operator|=
name|replace_equiv_address
argument_list|(
name|orig
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pic_ref
operator|=
name|reg
expr_stmt|;
block|}
return|return
name|pic_ref
return|;
block|}
end_function

begin_comment
comment|/* Output the stub or non-lazy pointer in *SLOT, if it has been used.    DATA is the FILE* for assembly output.  Called from    htab_traverse.  */
end_comment

begin_function
specifier|static
name|int
name|machopic_output_indirection
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|machopic_indirection
modifier|*
name|p
init|=
operator|*
operator|(
operator|(
name|machopic_indirection
operator|*
operator|*
operator|)
name|slot
operator|)
decl_stmt|;
name|FILE
modifier|*
name|asm_out_file
init|=
operator|(
name|FILE
operator|*
operator|)
name|data
decl_stmt|;
name|rtx
name|symbol
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr_name
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|used
condition|)
return|return
literal|1
return|;
name|symbol
operator|=
name|p
operator|->
name|symbol
expr_stmt|;
name|sym_name
operator|=
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr_name
operator|=
name|p
operator|->
name|ptr_name
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|stub_p
condition|)
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|stub
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|maybe_get_identifier
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|tree
name|id_orig
init|=
name|id
decl_stmt|;
while|while
condition|(
name|IDENTIFIER_TRANSPARENT_ALIAS
argument_list|(
name|id
argument_list|)
condition|)
name|id
operator|=
name|TREE_CHAIN
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|id_orig
condition|)
name|sym_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|sym
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|strcpy
argument_list|(
name|sym
argument_list|,
name|sym_name
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|strcpy
argument_list|(
name|sym
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sym
argument_list|,
literal|"%s%s"
argument_list|,
name|user_label_prefix
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|stub
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ptr_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|ptr_name
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|strcpy
argument_list|(
name|stub
argument_list|,
name|ptr_name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|stub
argument_list|,
literal|"%s%s"
argument_list|,
name|user_label_prefix
argument_list|,
name|ptr_name
argument_list|)
expr_stmt|;
name|machopic_output_stub
argument_list|(
name|asm_out_file
argument_list|,
name|sym
argument_list|,
name|stub
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|indirect_data
argument_list|(
name|symbol
argument_list|)
operator|&&
operator|(
name|machopic_symbol_defined_p
argument_list|(
name|symbol
argument_list|)
operator|||
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|symbol
argument_list|)
operator|)
condition|)
block|{
name|switch_to_section
argument_list|(
name|data_section
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|ptr_name
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|sym_name
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|init
init|=
name|const0_rtx
decl_stmt|;
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|machopic_nl_symbol_ptr_section
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.indirect_symbol "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Variables that are marked with MACHO_SYMBOL_STATIC need to 	 have their symbol name instead of 0 in the second entry of 	 the non-lazy symbol pointer data structure when they are 	 defined.  This allows the runtime to rebind newer instances 	 of the translation unit with the original instance of the 	 symbol.  */
if|if
condition|(
operator|(
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|&
name|MACHO_SYMBOL_STATIC
operator|)
operator|&&
name|machopic_symbol_defined_p
argument_list|(
name|symbol
argument_list|)
condition|)
name|init
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|init
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|machopic_finish
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|)
block|{
if|if
condition|(
name|machopic_indirections
condition|)
name|htab_traverse_noresize
argument_list|(
name|machopic_indirections
argument_list|,
name|machopic_output_indirection
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|machopic_operand_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
if|if
condition|(
name|MACHOPIC_JUST_INDIRECT
condition|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|machopic_symbol_defined_p
argument_list|(
name|op
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|machopic_symbol_defined_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|machopic_symbol_defined_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function records whether a given name corresponds to a defined    or undefined function or variable, for machopic_classify_ident to    use later.  */
end_comment

begin_function
name|void
name|darwin_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|sym_ref
decl_stmt|;
comment|/* Do the standard encoding things first.  */
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
operator||=
name|MACHO_SYMBOL_FLAG_VARIABLE
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"weakref"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|)
operator|)
condition|)
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
operator||=
name|MACHO_SYMBOL_FLAG_DEFINED
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
operator||=
name|MACHO_SYMBOL_STATIC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|darwin_mark_decl_preserved
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".no_dead_strip "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|machopic_reloc_rw_mask
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|MACHOPIC_INDIRECT
condition|?
literal|3
else|:
literal|0
return|;
block|}
end_function

begin_function
name|section
modifier|*
name|machopic_select_section
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|section
modifier|*
name|base_section
decl_stmt|;
name|bool
name|weak_p
init|=
operator|(
name|DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
name|DECL_WEAK
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|lookup_attribute
argument_list|(
literal|"weak"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
operator|!
name|lookup_attribute
argument_list|(
literal|"weak_import"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|reloc
operator|==
literal|1
condition|)
name|base_section
operator|=
operator|(
name|weak_p
condition|?
name|darwin_sections
index|[
name|text_unlikely_coal_section
index|]
else|:
name|unlikely_text_section
argument_list|()
operator|)
expr_stmt|;
else|else
name|base_section
operator|=
name|weak_p
condition|?
name|darwin_sections
index|[
name|text_coal_section
index|]
else|:
name|text_section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_readonly_section
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|)
condition|)
name|base_section
operator|=
name|weak_p
condition|?
name|darwin_sections
index|[
name|const_coal_section
index|]
else|:
name|darwin_sections
index|[
name|const_section
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|||
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
condition|)
name|base_section
operator|=
name|weak_p
condition|?
name|darwin_sections
index|[
name|const_data_coal_section
index|]
else|:
name|darwin_sections
index|[
name|const_data_section
index|]
expr_stmt|;
else|else
name|base_section
operator|=
name|weak_p
condition|?
name|darwin_sections
index|[
name|data_coal_section
index|]
else|:
name|data_section
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|&&
operator|(
operator|(
name|size_t
operator|)
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
operator|==
name|strlen
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
condition|)
return|return
name|darwin_sections
index|[
name|cstring_section
index|]
return|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|&&
name|flag_merge_constants
condition|)
block|{
name|tree
name|size
init|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|==
literal|4
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return
name|darwin_sections
index|[
name|literal4_section
index|]
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|==
literal|8
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return
name|darwin_sections
index|[
name|literal8_section
index|]
return|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|==
literal|16
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return
name|darwin_sections
index|[
name|literal16_section
index|]
return|;
else|else
return|return
name|base_section
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"__builtin_ObjCString"
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_next_runtime
condition|)
return|return
name|darwin_sections
index|[
name|objc_constant_string_object_section
index|]
return|;
else|else
return|return
name|darwin_sections
index|[
name|objc_string_object_section
index|]
return|;
block|}
else|else
return|return
name|base_section
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
literal|"_OBJC_"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_METHODS_"
argument_list|,
literal|20
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_cls_meth_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_INSTANCE_METHODS_"
argument_list|,
literal|23
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_inst_meth_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CATEGORY_CLASS_METHODS_"
argument_list|,
literal|20
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_cat_cls_meth_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CATEGORY_INSTANCE_METHODS_"
argument_list|,
literal|23
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_cat_inst_meth_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_VARIABLES_"
argument_list|,
literal|22
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_class_vars_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_INSTANCE_VARIABLES_"
argument_list|,
literal|25
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_instance_vars_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_PROTOCOLS_"
argument_list|,
literal|22
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_cat_cls_meth_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_NAME_"
argument_list|,
literal|17
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_class_names_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_METH_VAR_NAME_"
argument_list|,
literal|20
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_meth_var_names_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_METH_VAR_TYPE_"
argument_list|,
literal|20
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_meth_var_types_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_REFERENCES"
argument_list|,
literal|22
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_cls_refs_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CLASS_"
argument_list|,
literal|12
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_class_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_METACLASS_"
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_meta_class_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_CATEGORY_"
argument_list|,
literal|15
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_category_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_SELECTOR_REFERENCES"
argument_list|,
literal|25
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_selector_refs_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_SELECTOR_FIXUP"
argument_list|,
literal|20
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_selector_fixup_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_SYMBOLS"
argument_list|,
literal|13
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_symbols_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_MODULES"
argument_list|,
literal|13
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_module_info_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_IMAGE_INFO"
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_image_info_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_PROTOCOL_INSTANCE_METHODS_"
argument_list|,
literal|32
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_cat_inst_meth_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_PROTOCOL_CLASS_METHODS_"
argument_list|,
literal|29
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_cat_cls_meth_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_PROTOCOL_REFS_"
argument_list|,
literal|20
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_cat_cls_meth_section
index|]
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_PROTOCOL_"
argument_list|,
literal|15
argument_list|)
condition|)
return|return
name|darwin_sections
index|[
name|objc_protocol_section
index|]
return|;
else|else
return|return
name|base_section
return|;
block|}
else|else
return|return
name|base_section
return|;
block|}
end_function

begin_comment
comment|/* This can be called with address expressions as "rtx".    They must go in "const".  */
end_comment

begin_function
name|section
modifier|*
name|machopic_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
return|return
name|darwin_sections
index|[
name|literal8_section
index|]
return|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|4
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
return|return
name|darwin_sections
index|[
name|literal4_section
index|]
return|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|16
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
operator|)
condition|)
return|return
name|darwin_sections
index|[
name|literal16_section
index|]
return|;
elseif|else
if|if
condition|(
name|MACHOPIC_INDIRECT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
return|return
name|darwin_sections
index|[
name|const_data_section
index|]
return|;
else|else
return|return
name|darwin_sections
index|[
name|const_section
index|]
return|;
block|}
end_function

begin_function
name|void
name|machopic_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|mod_init_section
index|]
argument_list|)
expr_stmt|;
else|else
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|constructor_section
index|]
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".reference .constructors_used\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|machopic_asm_out_destructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|mod_term_section
index|]
argument_list|)
expr_stmt|;
else|else
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|destructor_section
index|]
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|symbol
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|POINTER_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MACHOPIC_INDIRECT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".reference .destructors_used\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|darwin_globalize_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_OBJC_"
argument_list|,
literal|6
argument_list|)
condition|)
name|default_globalize_label
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|darwin_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|darwin_unique_section
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Darwin does not use unique sections.  */
block|}
end_function

begin_comment
comment|/* Handle __attribute__ ((apple_kext_compatibility)).    This only applies to darwin kexts for 2.95 compatibility -- it shrinks the    vtable for classes with this attribute (and their descendants) by not    outputting the new 3.0 nondeleting destructor.  This means that such    objects CANNOT be allocated on the stack or as globals UNLESS they have    a completely empty `operator delete'.    Luckily, this fits in with the Darwin kext model.     This attribute also disables gcc3's potential overlaying of derived    class data members on the padding at the end of the base class.  */
end_comment

begin_function
name|tree
name|darwin_handle_kext_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
comment|/* APPLE KEXT stuff -- only applies with pure static C++ code.  */
if|if
condition|(
operator|!
name|TARGET_KEXTABI
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<%s%> 2.95 vtable-compatability attribute applies "
literal|"only when compiling a kext"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<%s%> 2.95 vtable-compatability attribute applies "
literal|"only to C++ classes"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "weak_import" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|darwin_handle_weak_import_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|declare_weak
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|no_dead_strip
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|lab
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".no_dead_strip %s\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a label for an FDE, making it global and/or weak if appropriate.    The third parameter is nonzero if this is for exception handling.    The fourth parameter is nonzero if this is just a placeholder for an    FDE that we are omitting. */
end_comment

begin_function
name|void
name|darwin_emit_unwind_label
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
parameter_list|,
name|int
name|for_eh
parameter_list|,
name|int
name|empty
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
name|char
modifier|*
name|lab
decl_stmt|;
name|bool
name|need_quotes
decl_stmt|;
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
name|base
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|need_quotes
operator|=
name|name_needs_quotes
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_eh
condition|)
return|return;
name|lab
operator|=
name|concat
argument_list|(
name|need_quotes
condition|?
literal|"\""
else|:
literal|""
argument_list|,
name|user_label_prefix
argument_list|,
name|base
argument_list|,
literal|".eh"
argument_list|,
name|need_quotes
condition|?
literal|"\""
else|:
literal|""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s %s\n"
argument_list|,
operator|(
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|!=
name|VISIBILITY_HIDDEN
condition|?
literal|".globl"
else|:
literal|".private_extern"
operator|)
argument_list|,
name|lab
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.weak_definition %s\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s = 0\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
comment|/* Mark the absolute .eh and .eh1 style labels as needed to 	 ensure that we don't dead code strip them and keep such 	 labels from another instantiation point until we can fix this 	 properly with group comdat support.  */
name|no_dead_strip
argument_list|(
name|file
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|long
name|except_table_label_num
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|darwin_emit_except_table_label
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|char
name|section_start_label
index|[
literal|30
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|section_start_label
argument_list|,
literal|"GCC_except_table"
argument_list|,
name|except_table_label_num
operator|++
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|section_start_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a PC-relative reference to a Mach-O non-lazy-symbol.  */
end_comment

begin_function
name|void
name|darwin_non_lazy_pcrel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|nlp_name
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|nlp_name
operator|=
name|machopic_indirection_name
argument_list|(
name|addr
argument_list|,
comment|/*stub_p=*/
name|false
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.long\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|nlp_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-."
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit an assembler directive to set visibility for a symbol.  The    only supported visibilities are VISIBILITY_DEFAULT and    VISIBILITY_HIDDEN; the latter corresponds to Darwin's "private    extern".  There is no MACH-O equivalent of ELF's    VISIBILITY_INTERNAL or VISIBILITY_PROTECTED. */
end_comment

begin_function
name|void
name|darwin_assemble_visibility
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|vis
parameter_list|)
block|{
if|if
condition|(
name|vis
operator|==
name|VISIBILITY_DEFAULT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|vis
operator|==
name|VISIBILITY_HIDDEN
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.private_extern "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"internal and protected visibility attributes "
literal|"not supported in this configuration; ignored"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a difference of two labels that will be an assembly time    constant if the two labels are local.  (.long lab1-lab2 will be    very different if lab1 is at the boundary between two sections; it    will be relocated according to the second section, not the first,    so one ends up with a difference between labels in different    sections, which is bad in the dwarf2 eh context for instance.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|darwin_dwarf_label_counter
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|darwin_asm_output_dwarf_delta
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|lab1
parameter_list|,
specifier|const
name|char
modifier|*
name|lab2
parameter_list|)
block|{
name|int
name|islocaldiff
init|=
operator|(
name|lab1
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|lab1
index|[
literal|1
index|]
operator|==
literal|'L'
operator|&&
name|lab2
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|lab2
index|[
literal|1
index|]
operator|==
literal|'L'
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|directive
init|=
operator|(
name|size
operator|==
literal|8
condition|?
literal|".quad"
else|:
literal|".long"
operator|)
decl_stmt|;
if|if
condition|(
name|islocaldiff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set L$set$%d,"
argument_list|,
name|darwin_dwarf_label_counter
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t"
argument_list|,
name|directive
argument_list|)
expr_stmt|;
name|assemble_name_raw
argument_list|(
name|file
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|assemble_name_raw
argument_list|(
name|file
argument_list|,
name|lab2
argument_list|)
expr_stmt|;
if|if
condition|(
name|islocaldiff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t%s L$set$%d"
argument_list|,
name|directive
argument_list|,
name|darwin_dwarf_label_counter
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output labels for the start of the DWARF sections if necessary.  */
end_comment

begin_function
name|void
name|darwin_file_start
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|debugnames
index|[]
init|=
block|{
name|DEBUG_FRAME_SECTION
block|,
name|DEBUG_INFO_SECTION
block|,
name|DEBUG_ABBREV_SECTION
block|,
name|DEBUG_ARANGES_SECTION
block|,
name|DEBUG_MACINFO_SECTION
block|,
name|DEBUG_LINE_SECTION
block|,
name|DEBUG_LOC_SECTION
block|,
name|DEBUG_PUBNAMES_SECTION
block|,
name|DEBUG_STR_SECTION
block|,
name|DEBUG_RANGES_SECTION
block|}
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|debugnames
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|namelen
decl_stmt|;
name|switch_to_section
argument_list|(
name|get_section
argument_list|(
name|debugnames
index|[
name|i
index|]
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|strncmp
argument_list|(
name|debugnames
index|[
name|i
index|]
argument_list|,
literal|"__DWARF,"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|strchr
argument_list|(
name|debugnames
index|[
name|i
index|]
operator|+
literal|8
argument_list|,
literal|','
argument_list|)
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strchr
argument_list|(
name|debugnames
index|[
name|i
index|]
operator|+
literal|8
argument_list|,
literal|','
argument_list|)
operator|-
operator|(
name|debugnames
index|[
name|i
index|]
operator|+
literal|8
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"Lsection%.*s:\n"
argument_list|,
name|namelen
argument_list|,
name|debugnames
index|[
name|i
index|]
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output an offset in a DWARF section on Darwin.  On Darwin, DWARF section    offsets are not represented using relocs in .o files; either the    section never leaves the .o file, or the linker or other tool is    responsible for parsing the DWARF and updating the offsets.  */
end_comment

begin_function
name|void
name|darwin_asm_output_dwarf_offset
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|lab
parameter_list|,
name|section
modifier|*
name|base
parameter_list|)
block|{
name|char
name|sname
index|[
literal|64
index|]
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|gcc_assert
argument_list|(
name|base
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_NAMED
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|strncmp
argument_list|(
name|base
operator|->
name|named
operator|.
name|name
argument_list|,
literal|"__DWARF,"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|strchr
argument_list|(
name|base
operator|->
name|named
operator|.
name|name
operator|+
literal|8
argument_list|,
literal|','
argument_list|)
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strchr
argument_list|(
name|base
operator|->
name|named
operator|.
name|name
operator|+
literal|8
argument_list|,
literal|','
argument_list|)
operator|-
operator|(
name|base
operator|->
name|named
operator|.
name|name
operator|+
literal|8
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|sname
argument_list|,
literal|"*Lsection%.*s"
argument_list|,
name|namelen
argument_list|,
name|base
operator|->
name|named
operator|.
name|name
operator|+
literal|8
argument_list|)
expr_stmt|;
name|darwin_asm_output_dwarf_delta
argument_list|(
name|file
argument_list|,
name|size
argument_list|,
name|lab
argument_list|,
name|sname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|darwin_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|machopic_finish
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|constructor_section
index|]
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|destructor_section
index|]
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.subsections_via_symbols\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO: Add a language hook for identifying if a decl is a vtable.  */
end_comment

begin_define
define|#
directive|define
name|DARWIN_VTABLE_P
parameter_list|(
name|DECL
parameter_list|)
value|0
end_define

begin_comment
comment|/* Cross-module name binding.  Darwin does not support overriding    functions at dynamic-link time, except for vtables in kexts.  */
end_comment

begin_function
name|bool
name|darwin_binds_local_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|default_binds_local_p_1
argument_list|(
name|decl
argument_list|,
name|TARGET_KEXTABI
operator|&&
name|DARWIN_VTABLE_P
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* See TARGET_ASM_OUTPUT_ANCHOR for why we can't do this yet.  */
end_comment

begin_comment
comment|/* The Darwin's implementation of TARGET_ASM_OUTPUT_ANCHOR.  Define the    anchor relative to ".", the current section position.  We cannot use    the default one because ASM_OUTPUT_DEF is wrong for Darwin.  */
end_comment

begin_endif
unit|void darwin_asm_output_anchor (rtx symbol) {   fprintf (asm_out_file, "\t.set\t");   assemble_name (asm_out_file, XSTR (symbol, 0));   fprintf (asm_out_file, ", . + " HOST_WIDE_INT_PRINT_DEC "\n", 	   SYMBOL_REF_BLOCK_OFFSET (symbol)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set the darwin specific attributes on TYPE.  */
end_comment

begin_function
name|void
name|darwin_set_default_type_attributes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|darwin_ms_struct
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"ms_struct"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* True, iff we're generating code for loadable kernel extentions.  */
end_comment

begin_function
name|bool
name|darwin_kextabi_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_apple_kext
return|;
block|}
end_function

begin_function
name|void
name|darwin_override_options
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|flag_apple_kext
operator|&&
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"command line option %<-fapple-kext%> is only valid for C++"
argument_list|)
expr_stmt|;
name|flag_apple_kext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_mkernel
operator|||
name|flag_apple_kext
condition|)
block|{
comment|/* -mkernel implies -fapple-kext for C++ */
if|if
condition|(
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
name|flag_apple_kext
operator|=
literal|1
expr_stmt|;
name|flag_no_common
operator|=
literal|1
expr_stmt|;
comment|/* No EH in kexts.  */
name|flag_exceptions
operator|=
literal|0
expr_stmt|;
comment|/* No -fnon-call-exceptions data in kexts.  */
name|flag_non_call_exceptions
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-darwin.h"
end_include

end_unit

