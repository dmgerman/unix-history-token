begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output routines for GCC for ARM.    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004  Free Software Foundation, Inc.    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)    and Martin Simmons (@harleqn.co.uk).    More major hacks by Richard Earnshaw (rearnsha@arm.com).     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_comment
comment|/* Forward definitions of types.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|minipool_node
name|Mnode
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|minipool_fixup
name|Mfix
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|arm_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward function declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|arm_add_gc_roots
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_gen_constant
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|bit_count
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_address_register_rtx_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_legitimate_index_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|thumb_base_register_rtx_p
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
specifier|static
name|int
name|thumb_index_register_rtx_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|const_ok_for_op
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|emit_multi_reg_push
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|emit_sfm
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
end_ifndef

begin_function_decl
specifier|static
name|bool
name|arm_assemble_integer
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|fp_const_from_val
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arm_cc
name|get_arm_condition_code
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_fpa_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|int_log2
parameter_list|(
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|is_jump_table
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|output_multi_immediate
parameter_list|(
name|rtx
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_multi_reg
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|shift_op
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|arm_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|number_of_first_bit_set
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_symbols_in_block
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thumb_exit
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thumb_pushpop
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|is_jump_table
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|get_jump_table_size
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_forward_ref
parameter_list|(
name|Mnode
modifier|*
parameter_list|,
name|Mnode
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mnode
modifier|*
name|add_minipool_forward_ref
parameter_list|(
name|Mfix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_backward_ref
parameter_list|(
name|Mnode
modifier|*
parameter_list|,
name|Mnode
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mnode
modifier|*
name|add_minipool_backward_ref
parameter_list|(
name|Mfix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|assign_minipool_offsets
parameter_list|(
name|Mfix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_print_value
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_minipool
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_barrier_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mfix
modifier|*
name|create_fix_barrier
parameter_list|(
name|Mfix
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_minipool_barrier
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_minipool_fix
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_reorg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|note_invalid_constants
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|current_file_function_operand
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg0_reg12_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|arm_isr_value
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|arm_compute_func_type
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|arm_handle_fndecl_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|arm_handle_isr_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thumb_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_comp_type_attributes
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_set_default_type_attributes
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_insns_for_constant
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_get_strip_length
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_internal_label
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_rtx_costs_1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_address_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_memory_load_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cirrus_insn_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cirrus_reorg
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|arm_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_init_iwmmxt_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|arm_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|arm_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|arm_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_function_decl
specifier|static
name|void
name|arm_elf_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_PE
end_ifndef

begin_function_decl
specifier|static
name|void
name|arm_encode_section_info
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
end_ifdef

begin_function_decl
specifier|static
name|void
name|aof_globalize_label
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_dump_imports
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_dump_pic_table
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_file_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_MERGE_DECL_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_MERGE_DECL_ATTRIBUTES
value|merge_dllimport_decl_attributes
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|arm_attribute_table
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_BYTE_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_BYTE_OP
value|"\tDCB\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\tDCW\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\tDCD\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_GLOBALIZE_LABEL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_GLOBALIZE_LABEL
value|aof_globalize_label
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|aof_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_END
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_END
value|aof_file_end
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|NULL
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|arm_assemble_integer
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|arm_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|arm_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_COMP_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_COMP_TYPE_ATTRIBUTES
value|arm_comp_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
value|arm_set_default_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|arm_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
value|arm_use_dfa_pipeline_interface
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_PE
end_ifdef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|arm_pe_encode_section_info
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|arm_encode_section_info
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_STRIP_NAME_ENCODING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRIP_NAME_ENCODING
value|arm_strip_name_encoding
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTERNAL_LABEL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTERNAL_LABEL
value|arm_internal_label
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|arm_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|arm_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|default_can_output_mi_thunk_no_vcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|arm_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|arm_address_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|arm_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|arm_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|arm_expand_builtin
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Obstack for minipool constant handling.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|minipool_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|minipool_startobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of insns skipped which    will be conditionalised if possible.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_insns_skipped
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we are currently building a constant table.  */
end_comment

begin_decl_stmt
name|int
name|making_const_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the information needed to generate branch insns.  This is    stored from the compare operation.  */
end_comment

begin_decl_stmt
name|rtx
name|arm_compare_op0
decl_stmt|,
name|arm_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What type of floating point are we tuning for?  */
end_comment

begin_decl_stmt
name|enum
name|fputype
name|arm_fpu_tune
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What type of floating point instructions are available?  */
end_comment

begin_decl_stmt
name|enum
name|fputype
name|arm_fpu_arch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What program mode is the cpu running in? 26-bit mode or 32-bit mode.  */
end_comment

begin_decl_stmt
name|enum
name|prog_mode_type
name|arm_prgmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by the -mfp=... option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|target_fp_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to parse -mstructure_size_boundary command line option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|structure_size_string
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_structure_size_boundary
init|=
name|DEFAULT_STRUCTURE_SIZE_BOUNDARY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit values used to identify processor capabilities.  */
end_comment

begin_define
define|#
directive|define
name|FL_CO_PROC
value|(1<< 0)
end_define

begin_comment
comment|/* Has external co-processor bus */
end_comment

begin_define
define|#
directive|define
name|FL_FAST_MULT
value|(1<< 1)
end_define

begin_comment
comment|/* Fast multiply */
end_comment

begin_define
define|#
directive|define
name|FL_MODE26
value|(1<< 2)
end_define

begin_comment
comment|/* 26-bit mode support */
end_comment

begin_define
define|#
directive|define
name|FL_MODE32
value|(1<< 3)
end_define

begin_comment
comment|/* 32-bit mode support */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH4
value|(1<< 4)
end_define

begin_comment
comment|/* Architecture rel 4 */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH5
value|(1<< 5)
end_define

begin_comment
comment|/* Architecture rel 5 */
end_comment

begin_define
define|#
directive|define
name|FL_THUMB
value|(1<< 6)
end_define

begin_comment
comment|/* Thumb aware */
end_comment

begin_define
define|#
directive|define
name|FL_LDSCHED
value|(1<< 7)
end_define

begin_comment
comment|/* Load scheduling necessary */
end_comment

begin_define
define|#
directive|define
name|FL_STRONG
value|(1<< 8)
end_define

begin_comment
comment|/* StrongARM */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH5E
value|(1<< 9)
end_define

begin_comment
comment|/* DSP extensions to v5 */
end_comment

begin_define
define|#
directive|define
name|FL_XSCALE
value|(1<< 10)
end_define

begin_comment
comment|/* XScale */
end_comment

begin_define
define|#
directive|define
name|FL_CIRRUS
value|(1<< 11)
end_define

begin_comment
comment|/* Cirrus/DSP.  */
end_comment

begin_define
define|#
directive|define
name|FL_IWMMXT
value|(1<< 29)
end_define

begin_comment
comment|/* XScale v2 or "Intel Wireless MMX technology".  */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH6J
value|(1<< 12)
end_define

begin_comment
comment|/* Architecture rel 6.  Adds 					 media instructions.  */
end_comment

begin_define
define|#
directive|define
name|FL_VFPV2
value|(1<< 13)
end_define

begin_comment
comment|/* Vector Floating Point V2.  */
end_comment

begin_comment
comment|/* The bits in this mask specify which    instructions we are allowed to generate.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|insn_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bits in this mask specify which instruction scheduling options should    be used.  Note - there is an overlap with the FL_FAST_MULT.  For some    hardware we want to be able to generate the multiply instructions, but to    tune as if they were not present in the architecture.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|tune_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following are used in the arm.md file as equivalents to bits    in the above two flag variables.  */
end_comment

begin_comment
comment|/* Nonzero if this is an "M" variant of the processor.  */
end_comment

begin_decl_stmt
name|int
name|arm_fast_multiply
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 4 extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch4
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 5 extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch5
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 5E extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch5e
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip can benefit from load scheduling.  */
end_comment

begin_decl_stmt
name|int
name|arm_ld_sched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is a StrongARM.  */
end_comment

begin_decl_stmt
name|int
name|arm_is_strong
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports Intel Wireless MMX technology.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch_iwmmxt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is an XScale.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch_xscale
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if tuning for XScale  */
end_comment

begin_decl_stmt
name|int
name|arm_tune_xscale
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is an ARM6 or an ARM7.  */
end_comment

begin_decl_stmt
name|int
name|arm_is_6_or_7
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is a Cirrus/DSP.  */
end_comment

begin_decl_stmt
name|int
name|arm_is_cirrus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating Thumb instructions.  */
end_comment

begin_decl_stmt
name|int
name|thumb_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we    must report the mode of the memory reference from PRINT_OPERAND to    PRINT_OPERAND_ADDRESS.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|output_memory_reference_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The register number to be used for the PIC offset register.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|arm_pic_register_string
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_pic_register
init|=
name|INVALID_REGNUM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 when a return insn is output, this means that the epilogue    is not needed.  */
end_comment

begin_decl_stmt
name|int
name|return_used_this_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 after arm_reorg has started.  Reset to start at the start of    the next function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|after_arm_reorg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of insns to be used when loading a constant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arm_constant_limit
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an explanation of these variables, see final_prescan_insn below.  */
end_comment

begin_decl_stmt
name|int
name|arm_ccfsm_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|arm_cond_code
name|arm_current_cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|arm_target_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_target_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The condition codes of the ARM, and the inverse function.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|arm_condition_codes
index|[]
init|=
block|{
literal|"eq"
block|,
literal|"ne"
block|,
literal|"cs"
block|,
literal|"cc"
block|,
literal|"mi"
block|,
literal|"pl"
block|,
literal|"vs"
block|,
literal|"vc"
block|,
literal|"hi"
block|,
literal|"ls"
block|,
literal|"ge"
block|,
literal|"lt"
block|,
literal|"gt"
block|,
literal|"le"
block|,
literal|"al"
block|,
literal|"nv"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
value|(strcmp (string1, string2) == 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialization code.  */
end_comment

begin_struct
struct|struct
name|processors
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|unsigned
name|long
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Not all of these give usefully different compilation alternatives,    but there is no simple way of generalizing them.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processors
name|all_cores
index|[]
init|=
block|{
comment|/* ARM Cores */
block|{
literal|"arm2"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"arm250"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"arm3"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"arm6"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm60"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm600"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm610"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm620"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
comment|/* arm7m doesn't exist on its own, but only with D, (and I), but      those don't alter the code, so arm7m is sometimes used.  */
block|{
literal|"arm7m"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
block|}
block|,
block|{
literal|"arm7d"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7dm"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
block|}
block|,
block|{
literal|"arm7di"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7dmi"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
block|}
block|,
block|{
literal|"arm70"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm700"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm700i"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm710"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm720"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm710c"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7100"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7500"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
comment|/* Doesn't have an external co-proc, but does have embedded fpa.  */
block|{
literal|"arm7500fe"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
comment|/* V4 Architecture Processors */
block|{
literal|"arm7tdmi"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"arm710t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"arm720t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"arm740t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"arm8"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm810"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm9"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm920"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm920t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm940t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm9tdmi"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm9e"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"ep9312"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_CIRRUS
block|}
block|,
block|{
literal|"strongarm"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
block|}
block|,
block|{
literal|"strongarm110"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
block|}
block|,
block|{
literal|"strongarm1100"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
block|}
block|,
block|{
literal|"strongarm1110"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
block|}
block|,
comment|/* V5 Architecture Processors */
block|{
literal|"arm10tdmi"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
operator||
name|FL_ARCH5
block|}
block|,
block|{
literal|"arm1020t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
operator||
name|FL_ARCH5
block|}
block|,
block|{
literal|"arm926ejs"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
block|}
block|,
block|{
literal|"arm1026ejs"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
block|}
block|,
block|{
literal|"xscale"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
operator||
name|FL_XSCALE
block|}
block|,
block|{
literal|"iwmmxt"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
operator||
name|FL_XSCALE
operator||
name|FL_IWMMXT
block|}
block|,
comment|/* V6 Architecture Processors */
block|{
literal|"arm1136js"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
operator||
name|FL_ARCH6J
block|}
block|,
block|{
literal|"arm1136jfs"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
operator||
name|FL_ARCH6J
operator||
name|FL_VFPV2
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processors
name|all_architectures
index|[]
init|=
block|{
comment|/* ARM Architectures */
block|{
literal|"armv2"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"armv2a"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"armv3"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"armv3m"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
block|}
block|,
block|{
literal|"armv4"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
block|}
block|,
comment|/* Strictly, FL_MODE26 is a permitted option for v4t, but there are no      implementations that support it, so we will leave it out for now.  */
block|{
literal|"armv4t"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"armv5"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
block|}
block|,
block|{
literal|"armv5t"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
block|}
block|,
block|{
literal|"armv5te"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
block|}
block|,
block|{
literal|"armv6j"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
operator||
name|FL_ARCH6J
block|}
block|,
block|{
literal|"ep9312"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_CIRRUS
block|}
block|,
block|{
literal|"iwmmxt"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
operator||
name|FL_XSCALE
operator||
name|FL_IWMMXT
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a magic structure.  The 'string' field is magically filled in    with a pointer to the value specified by the user on the command line    assuming that the user has specified such a value.  */
end_comment

begin_decl_stmt
name|struct
name|arm_cpu_select
name|arm_select
index|[]
init|=
block|{
comment|/* string	  name            processors  */
block|{
name|NULL
block|,
literal|"-mcpu="
block|,
name|all_cores
block|}
block|,
block|{
name|NULL
block|,
literal|"-march="
block|,
name|all_architectures
block|}
block|,
block|{
name|NULL
block|,
literal|"-mtune="
block|,
name|all_cores
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the number of bits set in VALUE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|bit_count
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|unsigned
name|long
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|value
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|value
operator|&=
name|value
operator|-
literal|1
expr_stmt|;
comment|/* Clear the least-significant set bit.  */
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Fix up any incompatible options that the user has specified.    This has now turned into a maze.  */
end_comment

begin_function
name|void
name|arm_override_options
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Set up the flags based on the cpu/architecture selected by the user.  */
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|arm_select
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|struct
name|arm_cpu_select
modifier|*
name|ptr
init|=
name|arm_select
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
name|NULL
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|struct
name|processors
modifier|*
name|sel
decl_stmt|;
for|for
control|(
name|sel
operator|=
name|ptr
operator|->
name|processors
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|ptr
operator|->
name|string
argument_list|,
name|sel
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
condition|)
name|tune_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
else|else
block|{
comment|/* If we have been given an architecture and a processor 		       make sure that they are compatible.  We only generate 		       a warning though, and we prefer the CPU over the 		       architecture.  */
if|if
condition|(
name|insn_flags
operator|!=
literal|0
operator|&&
operator|(
name|insn_flags
operator|^
name|sel
operator|->
name|flags
operator|)
condition|)
name|warning
argument_list|(
literal|"switch -mcpu=%s conflicts with -march= switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|)
expr_stmt|;
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|sel
operator|->
name|name
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the user did not specify a processor, choose one for them.  */
if|if
condition|(
name|insn_flags
operator|==
literal|0
condition|)
block|{
specifier|const
name|struct
name|processors
modifier|*
name|sel
decl_stmt|;
name|unsigned
name|int
name|sought
decl_stmt|;
specifier|static
specifier|const
struct|struct
name|cpu_default
block|{
specifier|const
name|int
name|cpu
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|}
name|cpu_defaults
index|[]
init|=
block|{
block|{
name|TARGET_CPU_arm2
block|,
literal|"arm2"
block|}
block|,
block|{
name|TARGET_CPU_arm6
block|,
literal|"arm6"
block|}
block|,
block|{
name|TARGET_CPU_arm610
block|,
literal|"arm610"
block|}
block|,
block|{
name|TARGET_CPU_arm710
block|,
literal|"arm710"
block|}
block|,
block|{
name|TARGET_CPU_arm7m
block|,
literal|"arm7m"
block|}
block|,
block|{
name|TARGET_CPU_arm7500fe
block|,
literal|"arm7500fe"
block|}
block|,
block|{
name|TARGET_CPU_arm7tdmi
block|,
literal|"arm7tdmi"
block|}
block|,
block|{
name|TARGET_CPU_arm8
block|,
literal|"arm8"
block|}
block|,
block|{
name|TARGET_CPU_arm810
block|,
literal|"arm810"
block|}
block|,
block|{
name|TARGET_CPU_arm9
block|,
literal|"arm9"
block|}
block|,
block|{
name|TARGET_CPU_strongarm
block|,
literal|"strongarm"
block|}
block|,
block|{
name|TARGET_CPU_xscale
block|,
literal|"xscale"
block|}
block|,
block|{
name|TARGET_CPU_ep9312
block|,
literal|"ep9312"
block|}
block|,
block|{
name|TARGET_CPU_iwmmxt
block|,
literal|"iwmmxt"
block|}
block|,
block|{
name|TARGET_CPU_arm926ej_s
block|,
literal|"arm926ej-s"
block|}
block|,
block|{
name|TARGET_CPU_arm1026ej_s
block|,
literal|"arm1026ej-s"
block|}
block|,
block|{
name|TARGET_CPU_arm1136j_s
block|,
literal|"arm1136j_s"
block|}
block|,
block|{
name|TARGET_CPU_arm1136jf_s
block|,
literal|"arm1136jf_s"
block|}
block|,
block|{
name|TARGET_CPU_generic
block|,
literal|"arm"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|cpu_default
modifier|*
name|def
decl_stmt|;
comment|/* Find the default.  */
for|for
control|(
name|def
operator|=
name|cpu_defaults
init|;
name|def
operator|->
name|name
condition|;
name|def
operator|++
control|)
if|if
condition|(
name|def
operator|->
name|cpu
operator|==
name|TARGET_CPU_DEFAULT
condition|)
break|break;
comment|/* Make sure we found the default CPU.  */
if|if
condition|(
name|def
operator|->
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the default CPU's flags.  */
for|for
control|(
name|sel
operator|=
name|all_cores
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|sel
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sel
operator|->
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
comment|/* Now check to see if the user has specified some command line 	 switch that require certain abilities from the cpu.  */
name|sought
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_INTERWORK
operator|||
name|TARGET_THUMB
condition|)
block|{
name|sought
operator||=
operator|(
name|FL_THUMB
operator||
name|FL_MODE32
operator|)
expr_stmt|;
comment|/* Force apcs-32 to be used for interworking.  */
name|target_flags
operator||=
name|ARM_FLAG_APCS_32
expr_stmt|;
comment|/* There are no ARM processors that support both APCS-26 and 	     interworking.  Therefore we force FL_MODE26 to be removed 	     from insn_flags here (if it was set), so that the search 	     below will always be able to find a compatible processor.  */
name|insn_flags
operator|&=
operator|~
name|FL_MODE26
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_APCS_32
condition|)
name|sought
operator||=
name|FL_MODE26
expr_stmt|;
if|if
condition|(
name|sought
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|sought
operator|&
name|insn_flags
operator|)
operator|!=
name|sought
operator|)
condition|)
block|{
comment|/* Try to locate a CPU type that supports all of the abilities 	     of the default CPU, plus the extra abilities requested by 	     the user.  */
for|for
control|(
name|sel
operator|=
name|all_cores
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
operator|(
name|sel
operator|->
name|flags
operator|&
name|sought
operator|)
operator|==
operator|(
name|sought
operator||
name|insn_flags
operator|)
condition|)
break|break;
if|if
condition|(
name|sel
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|current_bit_count
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|processors
modifier|*
name|best_fit
init|=
name|NULL
decl_stmt|;
comment|/* Ideally we would like to issue an error message here 		 saying that it was not possible to find a CPU compatible 		 with the default CPU, but which also supports the command 		 line options specified by the programmer, and so they 		 ought to use the -mcpu=<name> command line option to 		 override the default CPU type.  		 Unfortunately this does not work with multilibing.  We 		 need to be able to support multilibs for -mapcs-26 and for 		 -mthumb-interwork and there is no CPU that can support both 		 options.  Instead if we cannot find a cpu that has both the 		 characteristics of the default cpu and the given command line 		 options we scan the array again looking for a best match.  */
for|for
control|(
name|sel
operator|=
name|all_cores
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
operator|(
name|sel
operator|->
name|flags
operator|&
name|sought
operator|)
operator|==
name|sought
condition|)
block|{
name|unsigned
name|count
decl_stmt|;
name|count
operator|=
name|bit_count
argument_list|(
name|sel
operator|->
name|flags
operator|&
name|insn_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|current_bit_count
condition|)
block|{
name|best_fit
operator|=
name|sel
expr_stmt|;
name|current_bit_count
operator|=
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_fit
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|sel
operator|=
name|best_fit
expr_stmt|;
block|}
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
block|}
block|}
comment|/* If tuning has not been specified, tune for whichever processor or      architecture has been selected.  */
if|if
condition|(
name|tune_flags
operator|==
literal|0
condition|)
name|tune_flags
operator|=
name|insn_flags
expr_stmt|;
comment|/* Make sure that the processor choice does not conflict with any of the      other command line choices.  */
if|if
condition|(
name|TARGET_APCS_32
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_MODE32
operator|)
condition|)
block|{
comment|/* If APCS-32 was not the default then it must have been set by the 	 user, so issue a warning message.  If the user has specified 	 "-mapcs-32 -mcpu=arm2" then we loose here.  */
if|if
condition|(
operator|(
name|TARGET_DEFAULT
operator|&
name|ARM_FLAG_APCS_32
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"target CPU does not support APCS-32"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|ARM_FLAG_APCS_32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_APCS_32
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_MODE26
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"target CPU does not support APCS-26"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|ARM_FLAG_APCS_32
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_THUMB
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"target CPU does not support interworking"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|ARM_FLAG_INTERWORK
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_THUMB
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_THUMB
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"target CPU does not support THUMB instructions"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|ARM_FLAG_THUMB
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_APCS_32
condition|)
name|inform
argument_list|(
literal|"future releases of GCC will not support -mapcs-26"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_FRAME
operator|&&
name|TARGET_THUMB
condition|)
block|{
comment|/* warning ("ignoring -mapcs-frame because -mthumb was used"); */
name|target_flags
operator|&=
operator|~
name|ARM_FLAG_APCS_FRAME
expr_stmt|;
block|}
comment|/* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done      from here where no function is being compiled currently.  */
if|if
condition|(
operator|(
name|target_flags
operator|&
operator|(
name|THUMB_FLAG_LEAF_BACKTRACE
operator||
name|THUMB_FLAG_BACKTRACE
operator|)
operator|)
operator|&&
name|TARGET_ARM
condition|)
name|warning
argument_list|(
literal|"enabling backtrace support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
operator|&&
name|TARGET_CALLEE_INTERWORKING
condition|)
name|warning
argument_list|(
literal|"enabling callee interworking support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
operator|&&
name|TARGET_CALLER_INTERWORKING
condition|)
name|warning
argument_list|(
literal|"enabling caller interworking support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
comment|/* If interworking is enabled then APCS-32 must be selected as well.  */
if|if
condition|(
name|TARGET_INTERWORK
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_APCS_32
condition|)
name|warning
argument_list|(
literal|"interworking forces APCS-32 to be used"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|ARM_FLAG_APCS_32
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_APCS_STACK
operator|&&
operator|!
name|TARGET_APCS_FRAME
condition|)
block|{
name|warning
argument_list|(
literal|"-mapcs-stack-check incompatible with -mno-apcs-frame"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|ARM_FLAG_APCS_FRAME
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_POKE_FUNCTION_NAME
condition|)
name|target_flags
operator||=
name|ARM_FLAG_APCS_FRAME
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_REENT
operator|&&
name|flag_pic
condition|)
name|error
argument_list|(
literal|"-fpic and -mapcs-reent are incompatible"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_REENT
condition|)
name|warning
argument_list|(
literal|"APCS reentrant code not supported.  Ignored"
argument_list|)
expr_stmt|;
comment|/* If this target is normally configured to use APCS frames, warn if they      are turned off and debugging is turned on.  */
if|if
condition|(
name|TARGET_ARM
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
operator|!
name|TARGET_APCS_FRAME
operator|&&
operator|(
name|TARGET_DEFAULT
operator|&
name|ARM_FLAG_APCS_FRAME
operator|)
condition|)
name|warning
argument_list|(
literal|"-g with -mno-apcs-frame may not give sensible debugging"
argument_list|)
expr_stmt|;
comment|/* If stack checking is disabled, we can use r10 as the PIC register,      which keeps r9 available.  */
if|if
condition|(
name|flag_pic
condition|)
name|arm_pic_register
operator|=
name|TARGET_APCS_STACK
condition|?
literal|9
else|:
literal|10
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_FLOAT
condition|)
name|warning
argument_list|(
literal|"passing floating point arguments in fp regs not yet supported"
argument_list|)
expr_stmt|;
comment|/* Initialize boolean versions of the flags, for use in the arm.md file.  */
name|arm_fast_multiply
operator|=
operator|(
name|insn_flags
operator|&
name|FL_FAST_MULT
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch4
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH4
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch5
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH5
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch5e
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH5E
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch_xscale
operator|=
operator|(
name|insn_flags
operator|&
name|FL_XSCALE
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_ld_sched
operator|=
operator|(
name|tune_flags
operator|&
name|FL_LDSCHED
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_is_strong
operator|=
operator|(
name|tune_flags
operator|&
name|FL_STRONG
operator|)
operator|!=
literal|0
expr_stmt|;
name|thumb_code
operator|=
operator|(
name|TARGET_ARM
operator|==
literal|0
operator|)
expr_stmt|;
name|arm_is_6_or_7
operator|=
operator|(
operator|(
operator|(
name|tune_flags
operator|&
operator|(
name|FL_MODE26
operator||
name|FL_MODE32
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tune_flags
operator|&
name|FL_ARCH4
operator|)
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_tune_xscale
operator|=
operator|(
name|tune_flags
operator|&
name|FL_XSCALE
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_is_cirrus
operator|=
operator|(
name|tune_flags
operator|&
name|FL_CIRRUS
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch_iwmmxt
operator|=
operator|(
name|insn_flags
operator|&
name|FL_IWMMXT
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_IWMMXT
operator|&&
operator|(
operator|!
name|TARGET_ATPCS
operator|)
condition|)
name|target_flags
operator||=
name|ARM_FLAG_ATPCS
expr_stmt|;
if|if
condition|(
name|arm_is_cirrus
condition|)
block|{
name|arm_fpu_tune
operator|=
name|FPUTYPE_MAVERICK
expr_stmt|;
comment|/* Ignore -mhard-float if -mcpu=ep9312.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
condition|)
name|target_flags
operator|^=
name|ARM_FLAG_SOFT_FLOAT
expr_stmt|;
block|}
else|else
comment|/* Default value for floating point code... if no co-processor        bus, then schedule for emulated floating point.  Otherwise,        assume the user has an FPA.        Note: this does not prevent use of floating point instructions,        -msoft-float does that.  */
name|arm_fpu_tune
operator|=
operator|(
name|tune_flags
operator|&
name|FL_CO_PROC
operator|)
condition|?
name|FPUTYPE_FPA
else|:
name|FPUTYPE_FPA_EMU3
expr_stmt|;
if|if
condition|(
name|target_fp_name
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|target_fp_name
argument_list|,
literal|"2"
argument_list|)
condition|)
name|arm_fpu_arch
operator|=
name|FPUTYPE_FPA_EMU2
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|target_fp_name
argument_list|,
literal|"3"
argument_list|)
condition|)
name|arm_fpu_arch
operator|=
name|FPUTYPE_FPA_EMU3
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid floating point emulation option: -mfpe-%s"
argument_list|,
name|target_fp_name
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_fpu_arch
operator|=
name|FPUTYPE_DEFAULT
expr_stmt|;
if|if
condition|(
name|TARGET_FPE
condition|)
block|{
if|if
condition|(
name|arm_fpu_tune
operator|==
name|FPUTYPE_FPA_EMU3
condition|)
name|arm_fpu_tune
operator|=
name|FPUTYPE_FPA_EMU2
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_fpu_tune
operator|==
name|FPUTYPE_MAVERICK
condition|)
name|warning
argument_list|(
literal|"-mfpe switch not supported by ep9312 target cpu - ignored."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_fpu_tune
operator|!=
name|FPUTYPE_FPA
condition|)
name|arm_fpu_tune
operator|=
name|FPUTYPE_FPA_EMU2
expr_stmt|;
block|}
comment|/* For arm2/3 there is no need to do any scheduling if there is only      a floating point emulator, or we are doing software floating-point.  */
if|if
condition|(
operator|(
name|TARGET_SOFT_FLOAT
operator|||
name|arm_fpu_tune
operator|!=
name|FPUTYPE_FPA
operator|)
operator|&&
operator|(
name|tune_flags
operator|&
name|FL_MODE32
operator|)
operator|==
literal|0
condition|)
name|flag_schedule_insns
operator|=
name|flag_schedule_insns_after_reload
operator|=
literal|0
expr_stmt|;
name|arm_prgmode
operator|=
name|TARGET_APCS_32
condition|?
name|PROG_MODE_PROG32
else|:
name|PROG_MODE_PROG26
expr_stmt|;
if|if
condition|(
name|structure_size_string
operator|!=
name|NULL
condition|)
block|{
name|int
name|size
init|=
name|strtol
argument_list|(
name|structure_size_string
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|8
operator|||
name|size
operator|==
literal|32
condition|)
name|arm_structure_size_boundary
operator|=
name|size
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"structure size boundary can only be set to 8 or 32"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arm_pic_register_string
operator|!=
name|NULL
condition|)
block|{
name|int
name|pic_register
init|=
name|decode_reg_name
argument_list|(
name|arm_pic_register_string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|warning
argument_list|(
literal|"-mpic-register= is useless without -fpic"
argument_list|)
expr_stmt|;
comment|/* Prevent the user from choosing an obviously stupid PIC register.  */
elseif|else
if|if
condition|(
name|pic_register
operator|<
literal|0
operator|||
name|call_used_regs
index|[
name|pic_register
index|]
operator|||
name|pic_register
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|pic_register
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|pic_register
operator|>=
name|PC_REGNUM
condition|)
name|error
argument_list|(
literal|"unable to use '%s' for PIC register"
argument_list|,
name|arm_pic_register_string
argument_list|)
expr_stmt|;
else|else
name|arm_pic_register
operator|=
name|pic_register
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_THUMB
operator|&&
name|flag_schedule_insns
condition|)
block|{
comment|/* Don't warn since it's on by default in -O2.  */
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|optimize_size
condition|)
block|{
comment|/* There's some dispute as to whether this should be 1 or 2.  However, 	 experiments seem to show that in pathological cases a setting of 	 1 degrades less severely than a setting of 2.  This could change if 	 other parts of the compiler change their behavior.  */
name|arm_constant_limit
operator|=
literal|1
expr_stmt|;
comment|/* If optimizing for size, bump the number of instructions that we          are prepared to conditionally execute (even on a StrongARM).  */
name|max_insns_skipped
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
comment|/* For processors with load scheduling, it never costs more than          2 cycles to load a constant, and the load scheduler may well 	 reduce that to 1.  */
if|if
condition|(
name|tune_flags
operator|&
name|FL_LDSCHED
condition|)
name|arm_constant_limit
operator|=
literal|1
expr_stmt|;
comment|/* On XScale the longer latency of a load makes it more difficult          to achieve a good schedule, so it's faster to synthesize 	 constants that can be done in two insns.  */
if|if
condition|(
name|arm_tune_xscale
condition|)
name|arm_constant_limit
operator|=
literal|2
expr_stmt|;
comment|/* StrongARM has early execution of branches, so a sequence          that is worth skipping is shorter.  */
if|if
condition|(
name|arm_is_strong
condition|)
name|max_insns_skipped
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Register global variables with the garbage collector.  */
name|arm_add_gc_roots
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_add_gc_roots
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|minipool_obstack
argument_list|)
expr_stmt|;
name|minipool_startobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A table of known ARM exception types.    For use with the interrupt function attribute.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|arg
decl_stmt|;
specifier|const
name|unsigned
name|long
name|return_value
decl_stmt|;
block|}
name|isr_attribute_arg
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|isr_attribute_arg
name|isr_attribute_args
index|[]
init|=
block|{
block|{
literal|"IRQ"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"irq"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"FIQ"
block|,
name|ARM_FT_FIQ
block|}
block|,
block|{
literal|"fiq"
block|,
name|ARM_FT_FIQ
block|}
block|,
block|{
literal|"ABORT"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"abort"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"ABORT"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"abort"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"UNDEF"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"undef"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"SWI"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"swi"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
name|NULL
block|,
name|ARM_FT_NORMAL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns the (interrupt) function type of the current    function, or ARM_FT_UNKNOWN if the type cannot be determined.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_isr_value
parameter_list|(
name|tree
name|argument
parameter_list|)
block|{
specifier|const
name|isr_attribute_arg
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* No argument - default to IRQ.  */
if|if
condition|(
name|argument
operator|==
name|NULL_TREE
condition|)
return|return
name|ARM_FT_ISR
return|;
comment|/* Get the value of the argument.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
name|ARM_FT_UNKNOWN
return|;
name|arg
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check it against the list of known arguments.  */
for|for
control|(
name|ptr
operator|=
name|isr_attribute_args
init|;
name|ptr
operator|->
name|arg
operator|!=
name|NULL
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|arg
argument_list|,
name|ptr
operator|->
name|arg
argument_list|)
condition|)
return|return
name|ptr
operator|->
name|return_value
return|;
comment|/* An unrecognized interrupt type.  */
return|return
name|ARM_FT_UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* Computes the type of the current function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_func_type
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|type
init|=
name|ARM_FT_UNKNOWN
decl_stmt|;
name|tree
name|a
decl_stmt|;
name|tree
name|attr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Decide if the current function is volatile.  Such functions      never return, and many memory cycles can be saved by not storing      register values that will never be needed again.  This optimization      was added to speed up context switching in a kernel application.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|current_function_nothrow
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|type
operator||=
name|ARM_FT_VOLATILE
expr_stmt|;
if|if
condition|(
name|current_function_needs_context
condition|)
name|type
operator||=
name|ARM_FT_NESTED
expr_stmt|;
name|attr
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"naked"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL_TREE
condition|)
name|type
operator||=
name|ARM_FT_NAKED
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|eh_epilogue_sp_ofs
operator|!=
name|NULL_RTX
condition|)
name|type
operator||=
name|ARM_FT_EXCEPTION_HANDLER
expr_stmt|;
else|else
block|{
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
name|type
operator||=
name|TARGET_INTERWORK
condition|?
name|ARM_FT_INTERWORKED
else|:
name|ARM_FT_NORMAL
expr_stmt|;
else|else
name|type
operator||=
name|arm_isr_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Returns the type of the current function.  */
end_comment

begin_function
name|unsigned
name|long
name|arm_current_func_type
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|func_type
argument_list|)
operator|==
name|ARM_FT_UNKNOWN
condition|)
name|cfun
operator|->
name|machine
operator|->
name|func_type
operator|=
name|arm_compute_func_type
argument_list|()
expr_stmt|;
return|return
name|cfun
operator|->
name|machine
operator|->
name|func_type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if it is possible to return using a single instruction.      If SIBLING is non-null, this is a test for a return before a sibling    call.  SIBLING is the call insn, so we can examine its register usage.  */
end_comment

begin_function
name|int
name|use_return_insn
parameter_list|(
name|int
name|iscond
parameter_list|,
name|rtx
name|sibling
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|func_type
decl_stmt|;
name|unsigned
name|long
name|saved_int_regs
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|stack_adjust
decl_stmt|;
comment|/* Never use a return instruction before reload has run.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions and volatile functions need special      consideration.  */
if|if
condition|(
name|func_type
operator|&
operator|(
name|ARM_FT_VOLATILE
operator||
name|ARM_FT_NAKED
operator|)
condition|)
return|return
literal|0
return|;
comment|/* So do interrupt functions that use the frame pointer.  */
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|&&
name|frame_pointer_needed
condition|)
return|return
literal|0
return|;
name|stack_adjust
operator|=
name|arm_get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
expr_stmt|;
comment|/* As do variadic functions.  */
if|if
condition|(
name|current_function_pretend_args_size
operator|||
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
comment|/* Or if the function calls __builtin_eh_return () */
operator|||
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_EXCEPTION_HANDLER
comment|/* Or if the function calls alloca */
operator|||
name|current_function_calls_alloca
comment|/* Or if there is a stack adjustment.  However, if the stack pointer 	 is saved on the stack, we can use a pre-incrementing stack load.  */
operator|||
operator|!
operator|(
name|stack_adjust
operator|==
literal|0
operator|||
operator|(
name|frame_pointer_needed
operator|&&
name|stack_adjust
operator|==
literal|4
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|saved_int_regs
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
comment|/* Unfortunately, the insn         ldmib sp, {..., sp, ...}       triggers a bug on most SA-110 based devices, such that the stack      pointer won't be correctly restored if the instruction takes a      page fault.  We work around this problem by popping r3 along with      the other registers, since that is never slower than executing      another instruction.         We test for !arm_arch5 here, because code for any architecture      less than this could potentially be run on one of the buggy      chips.  */
if|if
condition|(
name|stack_adjust
operator|==
literal|4
operator|&&
operator|!
name|arm_arch5
condition|)
block|{
comment|/* Validate that r3 is a call-clobbered register (always true in 	 the default abi) ...  */
if|if
condition|(
operator|!
name|call_used_regs
index|[
literal|3
index|]
condition|)
return|return
literal|0
return|;
comment|/* ... that it isn't being used for a return value (always true 	 until we implement return-in-regs), or for a tail-call 	 argument ...  */
if|if
condition|(
name|sibling
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|sibling
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|find_regno_fusage
argument_list|(
name|sibling
argument_list|,
name|USE
argument_list|,
literal|3
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* ... and that there are no call-saved registers in r0-r2 	 (always true in the default ABI).  */
if|if
condition|(
name|saved_int_regs
operator|&
literal|0x7
condition|)
return|return
literal|0
return|;
block|}
comment|/* Can't be done if interworking with Thumb, and any registers have been      stacked.  */
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
name|saved_int_regs
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* On StrongARM, conditional returns are expensive if they aren't      taken and multiple registers have been stacked.  */
if|if
condition|(
name|iscond
operator|&&
name|arm_is_strong
condition|)
block|{
comment|/* Conditional return when just the LR is stored is a simple  	 conditional-load instruction, that's not expensive.  */
if|if
condition|(
name|saved_int_regs
operator|!=
literal|0
operator|&&
name|saved_int_regs
operator|!=
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
return|return
literal|0
return|;
block|}
comment|/* If there are saved registers but the LR isn't saved, then we need      two instructions for the return.  */
if|if
condition|(
name|saved_int_regs
operator|&&
operator|!
operator|(
name|saved_int_regs
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Can't be done if any of the FPA regs are pushed,      since this also requires an insn.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
condition|)
for|for
control|(
name|regno
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|regno
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
for|for
control|(
name|regno
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|regno
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if int I is a valid immediate ARM constant.  */
end_comment

begin_function
name|int
name|const_ok_for_arm
parameter_list|(
name|HOST_WIDE_INT
name|i
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xFF
decl_stmt|;
comment|/* For machines with>32 bit HOST_WIDE_INT, the bits above bit 31 must       be all zero, or all one.  */
if|if
condition|(
operator|(
name|i
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|i
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|!=
operator|(
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Fast return for 0 and powers of 2 */
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
do|do
block|{
if|if
condition|(
operator|(
name|i
operator|&
name|mask
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|>>
operator|(
literal|32
operator|-
literal|2
operator|)
operator|)
operator||
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
expr_stmt|;
block|}
do|while
condition|(
name|mask
operator|!=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xFF
condition|)
do|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if I is a valid constant for the operation CODE.  */
end_comment

begin_function
specifier|static
name|int
name|const_ok_for_op
parameter_list|(
name|HOST_WIDE_INT
name|i
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
return|return
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|-
name|i
argument_list|)
argument_list|)
return|;
case|case
name|MINUS
case|:
comment|/* Should only occur with (MINUS I reg) => rsb */
case|case
name|XOR
case|:
case|case
name|IOR
case|:
return|return
literal|0
return|;
case|case
name|AND
case|:
return|return
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|i
argument_list|)
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a sequence of insns to handle a large constant.    CODE is the code of the operation required, it can be any of SET, PLUS,    IOR, AND, XOR, MINUS;    MODE is the mode in which the operation is being performed;    VAL is the integer to operate on;    SOURCE is the other operand (a register, or a null-pointer for SET);    SUBTARGETS means it is safe to create scratch registers if that will    either produce a simpler sequence, or we will want to cse the values.    Return value is the number of insns emitted.  */
end_comment

begin_function
name|int
name|arm_split_constant
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|source
parameter_list|,
name|int
name|subtargets
parameter_list|)
block|{
if|if
condition|(
name|subtargets
operator|||
name|code
operator|==
name|SET
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|source
argument_list|)
operator|)
condition|)
block|{
comment|/* After arm_reorg has been called, we can't fix up expensive 	 constants by pushing them into memory so we must synthesize 	 them in-line, regardless of the cost.  This is only likely to 	 be more costly on chips that have load delay slots and we are 	 compiling without running the scheduler (so no splitting 	 occurred before the final instruction emission).  	 Ref: gcc -O1 -mcpu=strongarm gcc.c-torture/compile/980506-2.c       */
if|if
condition|(
operator|!
name|after_arm_reorg
operator|&&
operator|(
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|val
argument_list|,
name|target
argument_list|,
name|source
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|>
name|arm_constant_limit
operator|+
operator|(
name|code
operator|!=
name|SET
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
comment|/* Currently SET is the only monadic value for CODE, all 		 the rest are diadic.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|rtx
name|temp
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For MINUS, the value is subtracted from, since we never 		 have subtraction of a constant.  */
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
block|}
return|return
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|val
argument_list|,
name|target
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_insns_for_constant
parameter_list|(
name|HOST_WIDE_INT
name|remainder
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|HOST_WIDE_INT
name|temp1
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
do|do
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
operator|(
name|i
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
name|end
operator|=
name|i
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
literal|32
expr_stmt|;
name|temp1
operator|=
name|remainder
operator|&
operator|(
operator|(
literal|0x0ff
operator|<<
name|end
operator|)
operator||
operator|(
operator|(
name|i
operator|<
name|end
operator|)
condition|?
operator|(
literal|0xff
operator|>>
operator|(
literal|32
operator|-
name|end
operator|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|remainder
operator|&=
operator|~
name|temp1
expr_stmt|;
name|num_insns
operator|++
expr_stmt|;
name|i
operator|-=
literal|6
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|remainder
condition|)
do|;
return|return
name|num_insns
return|;
block|}
end_function

begin_comment
comment|/* As above, but extra parameter GENERATE which, if clear, suppresses    RTL generation.  */
end_comment

begin_function
specifier|static
name|int
name|arm_gen_constant
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|source
parameter_list|,
name|int
name|subtargets
parameter_list|,
name|int
name|generate
parameter_list|)
block|{
name|int
name|can_invert
init|=
literal|0
decl_stmt|;
name|int
name|can_negate
init|=
literal|0
decl_stmt|;
name|int
name|can_negate_initial
init|=
literal|0
decl_stmt|;
name|int
name|can_shift
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_bits_set
init|=
literal|0
decl_stmt|;
name|int
name|set_sign_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|clear_sign_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|clear_zero_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|set_zero_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|insns
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|remainder
init|=
name|val
operator|&
literal|0xffffffff
decl_stmt|;
comment|/* Find out which operations are safe for a given CODE.  Also do a quick      check for degenerate cases; these can occur when DImode operations      are split.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
name|can_invert
operator|=
literal|1
expr_stmt|;
name|can_shift
operator|=
literal|1
expr_stmt|;
name|can_negate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|can_negate
operator|=
literal|1
expr_stmt|;
name|can_negate_initial
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|remainder
operator|==
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|remainder
operator|==
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|can_invert
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|remainder
operator|==
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* We don't know how to handle this yet below.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|MINUS
case|:
comment|/* We treat MINUS as (val - source), since (source - val) is always 	 passed as (source + (-val)).  */
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|can_negate
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we can do it in one insn get out quickly.  */
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|val
argument_list|)
operator|||
operator|(
name|can_negate_initial
operator|&&
name|const_ok_for_arm
argument_list|(
operator|-
name|val
argument_list|)
operator|)
operator|||
operator|(
name|can_invert
operator|&&
name|const_ok_for_arm
argument_list|(
operator|~
name|val
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
operator|(
name|source
condition|?
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
else|:
name|GEN_INT
argument_list|(
name|val
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Calculate a few attributes that may be useful for specific      optimizations.  */
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|clear_sign_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_sign_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|31
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|clear_zero_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|31
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_zero_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
comment|/* See if we can do this by sign_extending a constant that is known 	 to be negative.  This is a good, way of doing it, since the shift 	 may well merge into a subsequent insn.  */
if|if
condition|(
name|set_sign_bit_copies
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|temp1
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
name|remainder
operator|<<
operator|(
name|set_sign_bit_copies
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
comment|/* For an inverted constant, we will need to set the low bits, 	     these will be shifted out of harm's way.  */
name|temp1
operator||=
operator|(
literal|1
operator|<<
operator|(
name|set_sign_bit_copies
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|const_ok_for_arm
argument_list|(
operator|~
name|temp1
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
block|}
comment|/* See if we can generate this by setting the bottom (or the top) 	 16 bits, and then shifting these into the other half of the 	 word.  We only look for the simplest cases, to do more would cost 	 too much.  Be careful, however, not to generate this when the 	 alternative would take fewer insns.  */
if|if
condition|(
name|val
operator|&
literal|0xffff0000
condition|)
block|{
name|temp1
operator|=
name|remainder
operator|&
literal|0xffff0000
expr_stmt|;
name|temp2
operator|=
name|remainder
operator|&
literal|0x0000ffff
expr_stmt|;
comment|/* Overlaps outside this range are best done using other methods.  */
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|temp2
operator||
operator|(
name|temp2
operator|<<
name|i
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
operator|==
name|remainder
operator|)
operator|&&
operator|!
name|const_ok_for_arm
argument_list|(
name|temp2
argument_list|)
condition|)
block|{
name|rtx
name|new_src
init|=
operator|(
name|subtargets
condition|?
operator|(
name|generate
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|NULL_RTX
operator|)
else|:
name|target
operator|)
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|temp2
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
name|generate
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insns
operator|+
literal|1
return|;
block|}
block|}
comment|/* Don't duplicate cases already considered.  */
for|for
control|(
name|i
operator|=
literal|17
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|temp1
operator||
operator|(
name|temp1
operator|>>
name|i
operator|)
operator|)
operator|==
name|remainder
operator|)
operator|&&
operator|!
name|const_ok_for_arm
argument_list|(
name|temp1
argument_list|)
condition|)
block|{
name|rtx
name|new_src
init|=
operator|(
name|subtargets
condition|?
operator|(
name|generate
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|NULL_RTX
operator|)
else|:
name|target
operator|)
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|temp1
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
name|generate
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insns
operator|+
literal|1
return|;
block|}
block|}
block|}
break|break;
case|case
name|IOR
case|:
case|case
name|XOR
case|:
comment|/* If we have IOR or XOR, and the constant can be loaded in a 	 single instruction, and we can find a temporary to put it in, 	 then this can be done in two instructions instead of 3-4.  */
if|if
condition|(
name|subtargets
comment|/* TARGET can't be NULL if SUBTARGETS is 0 */
operator|||
operator|(
name|reload_completed
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|val
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|sub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|XOR
condition|)
break|break;
if|if
condition|(
name|set_sign_bit_copies
operator|>
literal|8
operator|&&
operator|(
name|val
operator|&
operator|(
operator|-
literal|1
operator|<<
operator|(
literal|32
operator|-
name|set_sign_bit_copies
operator|)
operator|)
operator|)
operator|==
name|val
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
if|if
condition|(
name|set_zero_bit_copies
operator|>
literal|8
operator|&&
operator|(
name|remainder
operator|&
operator|(
operator|(
literal|1
operator|<<
name|set_zero_bit_copies
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|remainder
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|set_zero_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|temp1
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|val
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
name|sub
expr_stmt|;
if|if
condition|(
name|subtargets
condition|)
name|sub
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|3
return|;
block|}
break|break;
case|case
name|AND
case|:
comment|/* See if two shifts will do 2 or more insn's worth of work.  */
if|if
condition|(
name|clear_sign_bit_copies
operator|>=
literal|16
operator|&&
name|clear_sign_bit_copies
operator|<
literal|24
condition|)
block|{
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|(
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|clear_sign_bit_copies
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|remainder
operator||
name|shift_mask
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|targ
init|=
name|subtargets
condition|?
name|NULL_RTX
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|targ
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|clear_sign_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|new_src
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|insns
operator|+
literal|2
return|;
block|}
if|if
condition|(
name|clear_zero_bit_copies
operator|>=
literal|16
operator|&&
name|clear_zero_bit_copies
operator|<
literal|24
condition|)
block|{
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|(
literal|1
operator|<<
name|clear_zero_bit_copies
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|remainder
operator||
name|shift_mask
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|targ
init|=
name|subtargets
condition|?
name|NULL_RTX
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|targ
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|clear_zero_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|new_src
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|insns
operator|+
literal|2
return|;
block|}
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|num_bits_set
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|AND
operator|||
operator|(
name|can_invert
operator|&&
name|num_bits_set
operator|>
literal|16
operator|)
condition|)
name|remainder
operator|=
operator|(
operator|~
name|remainder
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|num_bits_set
operator|>
literal|16
condition|)
name|remainder
operator|=
operator|(
operator|-
name|remainder
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
else|else
block|{
name|can_invert
operator|=
literal|0
expr_stmt|;
name|can_negate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now try and find a way of doing the job in either two or three      instructions.      We start by looking for the largest block of zeros that are aligned on      a 2-bit boundary, we then fill up the temps, wrapping around to the      top of the word when we drop off the bottom.      In the worst case this code should produce no more than four insns.  */
block|{
name|int
name|best_start
init|=
literal|0
decl_stmt|;
name|int
name|best_consecutive_zeros
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|consecutive_zeros
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|i
operator|<
literal|32
operator|)
operator|&&
operator|!
operator|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
name|consecutive_zeros
operator|+=
literal|2
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|consecutive_zeros
operator|>
name|best_consecutive_zeros
condition|)
block|{
name|best_consecutive_zeros
operator|=
name|consecutive_zeros
expr_stmt|;
name|best_start
operator|=
name|i
operator|-
name|consecutive_zeros
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
block|}
comment|/* So long as it won't require any more insns to do so, it's        desirable to emit a small constant (in bits 0...9) in the last        insn.  This way there is more chance that it can be combined with        a later addressing insn to form a pre-indexed load or store        operation.  Consider:  	       *((volatile int *)0xe0000100) = 1; 	       *((volatile int *)0xe0000110) = 2;         We want this to wind up as:  		mov rA, #0xe0000000 		mov rB, #1 		str rB, [rA, #0x100] 		mov rB, #2 		str rB, [rA, #0x110]         rather than having to synthesize both large constants from scratch.         Therefore, we calculate how many insns would be required to emit        the constant starting from `best_start', and also starting from         zero (ie with bit 31 first to be output).  If `best_start' doesn't         yield a shorter sequence, we may as well use zero.  */
if|if
condition|(
name|best_start
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|best_start
operator|)
operator|<
name|remainder
operator|)
operator|&&
operator|(
name|count_insns_for_constant
argument_list|(
name|remainder
argument_list|,
literal|0
argument_list|)
operator|<=
name|count_insns_for_constant
argument_list|(
name|remainder
argument_list|,
name|best_start
argument_list|)
operator|)
condition|)
name|best_start
operator|=
literal|0
expr_stmt|;
comment|/* Now start emitting the insns.  */
name|i
operator|=
name|best_start
expr_stmt|;
do|do
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
operator|(
name|i
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
name|end
operator|=
name|i
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
literal|32
expr_stmt|;
name|temp1
operator|=
name|remainder
operator|&
operator|(
operator|(
literal|0x0ff
operator|<<
name|end
operator|)
operator||
operator|(
operator|(
name|i
operator|<
name|end
operator|)
condition|?
operator|(
literal|0xff
operator|>>
operator|(
literal|32
operator|-
name|end
operator|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|remainder
operator|&=
operator|~
name|temp1
expr_stmt|;
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
decl_stmt|,
name|temp1_rtx
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|MINUS
condition|)
block|{
name|new_src
operator|=
operator|(
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
operator|)
expr_stmt|;
if|if
condition|(
name|can_invert
operator|&&
name|code
operator|!=
name|MINUS
condition|)
name|temp1
operator|=
operator|~
name|temp1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remainder
operator|&&
name|subtargets
condition|)
name|new_src
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|new_src
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|can_invert
condition|)
name|temp1
operator|=
operator|~
name|temp1
expr_stmt|;
elseif|else
if|if
condition|(
name|can_negate
condition|)
name|temp1
operator|=
operator|-
name|temp1
expr_stmt|;
block|}
name|temp1
operator|=
name|trunc_int_for_mode
argument_list|(
name|temp1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|temp1_rtx
operator|=
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|temp1_rtx
operator|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|temp1_rtx
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
name|temp1_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|temp1_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|temp1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|can_invert
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|PLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|code
operator|=
name|PLUS
expr_stmt|;
name|insns
operator|++
expr_stmt|;
name|i
operator|-=
literal|6
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|remainder
condition|)
do|;
block|}
return|return
name|insns
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize a comparison so that we are more likely to recognize it.    This can be done for a few constant compares, where we can make the    immediate value easier to load.  */
end_comment

begin_function
name|enum
name|rtx_code
name|arm_canonicalize_comparison
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|op1
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
name|INTVAL
argument_list|(
operator|*
name|op1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
case|case
name|LE
case|:
if|if
condition|(
name|i
operator|!=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GT
condition|?
name|GE
else|:
name|LT
return|;
block|}
break|break;
case|case
name|GE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|i
operator|!=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GE
condition|?
name|GT
else|:
name|LE
return|;
block|}
break|break;
case|case
name|GTU
case|:
case|case
name|LEU
case|:
if|if
condition|(
name|i
operator|!=
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GTU
condition|?
name|GEU
else|:
name|LTU
return|;
block|}
break|break;
case|case
name|GEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GEU
condition|?
name|GTU
else|:
name|LEU
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Decide whether a type should be returned in memory (true)    or in a register (false).  This is called by the macro    RETURN_IN_MEMORY.  */
end_comment

begin_function
name|int
name|arm_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* All simple types are returned in registers.  */
return|return
literal|0
return|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ATPCS
condition|)
block|{
comment|/* ATPCS returns aggregate types in memory only if they are 	 larger than a word (or are variable size).  */
return|return
operator|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|UNITS_PER_WORD
operator|)
return|;
block|}
comment|/* For the arm-wince targets we choose to be compatible with Microsoft's      ARM and Thumb compilers, which always return aggregates in memory.  */
ifndef|#
directive|ifndef
name|ARM_WINCE
comment|/* All structures/unions bigger than one word are returned in memory.      Also catch the case where int_size_in_bytes returns -1.  In this case      the aggregate is either huge or of variable size, and in either case      we will want to return it via memory and not in a register.  */
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|UNITS_PER_WORD
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* For a struct the APCS says that we only return in a register 	 if the type is 'integer like' and every addressable element 	 has an offset of zero.  For practical purposes this means 	 that the structure can have at most one non bit-field element 	 and that this element must be the first one in the structure.  */
comment|/* Find the first field, ignoring non FIELD_DECL things which will 	 have been created by C++.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
continue|continue;
if|if
condition|(
name|field
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* An empty structure.  Allowed by an extension to ANSI C.  */
comment|/* Check that the first field is valid for returning in a register.  */
comment|/* ... Floats are not allowed */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ... Aggregates that are not themselves valid for returning in 	 a register are not allowed.  */
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Now check the remaining fields, if any.  Only bitfields are allowed, 	 since they are not addressable.  */
for|for
control|(
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* Unions can be returned in registers if every element is 	 integral, or can be returned in an integer register.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* not ARM_WINCE */
comment|/* Return all other types in memory.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Indicate whether or not words of a double are in big-endian order.  */
end_comment

begin_function
name|int
name|arm_float_words_big_endian
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_CIRRUS
condition|)
return|return
literal|0
return|;
comment|/* For FPA, float words are always big-endian.  For VFP, floats words      follow the memory system mode.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
condition|)
block|{
comment|/* FIXME: TARGET_HARD_FLOAT currently implies FPA.  */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TARGET_VFP
condition|)
return|return
operator|(
name|TARGET_BIG_END
condition|?
literal|1
else|:
literal|0
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is NULL.  */
end_comment

begin_function
name|void
name|arm_init_cumulative_args
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|pcum
parameter_list|,
name|tree
name|fntype
parameter_list|,
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* On the ARM, the offset starts at 0.  */
name|pcum
operator|->
name|nregs
operator|=
operator|(
operator|(
name|fntype
operator|&&
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|fntype
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|pcum
operator|->
name|iwmmxt_nregs
operator|=
literal|0
expr_stmt|;
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_NORMAL
expr_stmt|;
if|if
condition|(
name|TARGET_LONG_CALLS
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_LONG
expr_stmt|;
comment|/* Check for long call/short call attributes.  The attributes      override any command line option.  */
if|if
condition|(
name|fntype
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_LONG
expr_stmt|;
block|}
comment|/* Varargs vectors are treated the same as long long.      named_count avoids having to change the way arm handles 'named' */
name|pcum
operator|->
name|named_count
operator|=
literal|0
expr_stmt|;
name|pcum
operator|->
name|nargs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
name|fntype
condition|)
block|{
name|tree
name|fn_arg
decl_stmt|;
for|for
control|(
name|fn_arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
init|;
name|fn_arg
condition|;
name|fn_arg
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_arg
argument_list|)
control|)
name|pcum
operator|->
name|named_count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pcum
operator|->
name|named_count
condition|)
name|pcum
operator|->
name|named_count
operator|=
name|INT_MAX
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).  */
end_comment

begin_function
name|rtx
name|arm_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|pcum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|named
parameter_list|)
block|{
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
block|{
if|if
condition|(
name|VECTOR_MODE_SUPPORTED_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* varargs vectors are treated the same as long long. 	     named_count avoids having to change the way arm handles 'named' */
if|if
condition|(
name|pcum
operator|->
name|named_count
operator|<=
name|pcum
operator|->
name|nargs
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|pcum
operator|->
name|nregs
operator|==
literal|1
condition|)
name|pcum
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|pcum
operator|->
name|nregs
operator|<=
literal|2
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|pcum
operator|->
name|nregs
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
name|pcum
operator|->
name|iwmmxt_nregs
operator|<=
literal|9
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|pcum
operator|->
name|iwmmxt_nregs
operator|+
name|FIRST_IWMMXT_REGNUM
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|&&
name|pcum
operator|->
name|nregs
operator|&
literal|1
condition|)
name|pcum
operator|->
name|nregs
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
comment|/* Compute operand 2 of the call insn.  */
return|return
name|GEN_INT
argument_list|(
name|pcum
operator|->
name|call_cookie
argument_list|)
return|;
if|if
condition|(
operator|!
name|named
operator|||
name|pcum
operator|->
name|nregs
operator|>=
name|NUM_ARG_REGS
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|pcum
operator|->
name|nregs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Variable sized types are passed by reference.  This is a GCC    extension to the ARM ABI.  */
end_comment

begin_function
name|int
name|arm_function_arg_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
return|;
block|}
end_function

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|rtx
name|arm_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* Variable sized types are passed by reference.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|rtx
name|addr
init|=
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|ptr_mode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
name|IWMMXT_ALIGNMENT
condition|)
block|{
name|tree
name|minus_eight
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Maintain 64-bit alignment of the valist pointer by 	 constructing:   valist = ((valist + (8 - 1))& -8).  */
name|minus_eight
operator|=
name|build_int_2
argument_list|(
operator|-
operator|(
name|IWMMXT_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
operator|(
name|IWMMXT_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|minus_eight
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* This is to stop the combine pass optimizing 	 away the alignment adjustment.  */
name|mark_reg_pointer
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
block|}
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Encode the current state of the #pragma [no_]long_calls.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OFF
block|,
comment|/* No #pramgma [no_]long_calls is in effect.  */
name|LONG
block|,
comment|/* #pragma long_calls is in effect.  */
name|SHORT
comment|/* #pragma no_long_calls is in effect.  */
block|}
name|arm_pragma_enum
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|arm_pragma_enum
name|arm_pragma_long_calls
init|=
name|OFF
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|arm_pr_long_calls
parameter_list|(
name|struct
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arm_pragma_long_calls
operator|=
name|LONG
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_pr_no_long_calls
parameter_list|(
name|struct
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arm_pragma_long_calls
operator|=
name|SHORT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_pr_long_calls_off
parameter_list|(
name|struct
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arm_pragma_long_calls
operator|=
name|OFF
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|arm_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
comment|/* Function calls made to this symbol must be done indirectly, because      it may lie outside of the 26 bit addressing range of a normal function      call.  */
block|{
literal|"long_call"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
comment|/* Whereas these functions are always known to reside within the 26 bit      addressing range.  */
block|{
literal|"short_call"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
comment|/* Interrupt Service Routines have special prologue and epilogue requirements.  */
block|{
literal|"isr"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|arm_handle_isr_attribute
block|}
block|,
block|{
literal|"interrupt"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|arm_handle_isr_attribute
block|}
block|,
block|{
literal|"naked"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|arm_handle_fndecl_attribute
block|}
block|,
ifdef|#
directive|ifdef
name|ARM_PE
comment|/* ARM/PE has three new attributes:      interfacearm - ?      dllexport - for exporting a function/variable that will live in a dll      dllimport - for importing a function/variable from a dll       Microsoft allows multiple declspecs in one __declspec, separating      them with spaces.  We do NOT support this.  Instead, use __declspec      multiple times.   */
block|{
literal|"dllimport"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"dllexport"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"interfacearm"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|arm_handle_fndecl_attribute
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle an attribute requiring a FUNCTION_DECL;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_handle_fndecl_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "interrupt" or "isr" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_handle_isr_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* FIXME: the argument if any is checked for type attributes; 	 should it be checked for decl ones?  */
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|arm_isr_value
argument_list|(
name|args
argument_list|)
operator|==
name|ARM_FT_UNKNOWN
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|arm_isr_value
argument_list|(
name|args
argument_list|)
operator|!=
name|ARM_FT_UNKNOWN
condition|)
block|{
operator|*
name|node
operator|=
name|build_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_type_attribute_variant
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Possibly pass this attribute on from the type to a decl.  */
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
operator|)
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the attributes for two types are incompatible, 1 if they    are compatible, and 2 if they are nearly compatible (which causes a    warning to be generated).  */
end_comment

begin_function
specifier|static
name|int
name|arm_comp_type_attributes
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
comment|/* Check for mismatch of non-default calling convention.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
comment|/* Check for mismatched call attributes.  */
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|l2
operator|=
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|s1
operator|=
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|s2
operator|=
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
comment|/* Only bother to check if an attribute is defined.  */
if|if
condition|(
name|l1
operator||
name|l2
operator||
name|s1
operator||
name|s2
condition|)
block|{
comment|/* If one type has an attribute, the other must have the same attribute.  */
if|if
condition|(
operator|(
name|l1
operator|!=
name|l2
operator|)
operator|||
operator|(
name|s1
operator|!=
name|s2
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Disallow mixed attributes.  */
if|if
condition|(
operator|(
name|l1
operator|&
name|s2
operator|)
operator|||
operator|(
name|l2
operator|&
name|s1
operator|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check for mismatched ISR attribute.  */
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|l1
condition|)
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|l2
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|l2
condition|)
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|l1
operator|!=
name|l2
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  Encode long_call or short_call attribute by prefixing     symbol name in DECL with a special character FLAG.  */
end_comment

begin_function
name|void
name|arm_encode_call_attribute
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
comment|/* Do not allow weak functions to be treated as short call.  */
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|&&
name|flag
operator|==
name|SHORT_CALL_FLAG_CHAR
condition|)
return|return;
name|newstr
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|newstr
index|[
literal|0
index|]
operator|=
name|flag
expr_stmt|;
name|strcpy
argument_list|(
name|newstr
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|ggc_alloc_string
argument_list|(
name|newstr
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|newstr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Assigns default attributes to newly defined type.  This is used to     set short_call/long_call attributes for function types of     functions defined inside corresponding #pragma scopes.  */
end_comment

begin_function
specifier|static
name|void
name|arm_set_default_type_attributes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* Add __attribute__ ((long_call)) to all functions, when      inside #pragma long_calls or __attribute__ ((short_call)),      when inside #pragma no_long_calls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|type_attr_list
decl_stmt|,
name|attr_name
decl_stmt|;
name|type_attr_list
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_pragma_long_calls
operator|==
name|LONG
condition|)
name|attr_name
operator|=
name|get_identifier
argument_list|(
literal|"long_call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_pragma_long_calls
operator|==
name|SHORT
condition|)
name|attr_name
operator|=
name|get_identifier
argument_list|(
literal|"short_call"
argument_list|)
expr_stmt|;
else|else
return|return;
name|type_attr_list
operator|=
name|tree_cons
argument_list|(
name|attr_name
argument_list|,
name|NULL_TREE
argument_list|,
name|type_attr_list
argument_list|)
expr_stmt|;
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
operator|=
name|type_attr_list
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the operand is a SYMBOL_REF for a function known to be    defined within the current compilation unit.  If this cannot be    determined, then 0 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|current_file_function_operand
parameter_list|(
name|rtx
name|sym_ref
parameter_list|)
block|{
comment|/* This is a bit of a fib.  A function will have a short call flag      applied to its name if it has the short call attribute, or it has      already been defined within the current compilation unit.  */
if|if
condition|(
name|ENCODED_SHORT_CALL_ATTR_P
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The current function is always defined within the current compilation      unit.  if it s a weak definition however, then this may not be the real      definition of the function, and so we have to say no.  */
if|if
condition|(
name|sym_ref
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We cannot make the determination - default to returning 0.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if a 32 bit "long_call" should be generated for    this call.  We generate a long_call if the function:          a.  has an __attribute__((long call))      or b.  is within the scope of a #pragma long_calls      or c.  the -mlong-calls command line switch has been specified     However we do not generate a long call if the function:             d.  has an __attribute__ ((short_call))      or e.  is inside the scope of a #pragma no_long_calls      or f.  has an __attribute__ ((section))      or g.  is defined within the current compilation unit.        This function will be called by C fragments contained in the machine    description file.  CALL_REF and CALL_COOKIE correspond to the matched    rtl operands.  CALL_SYMBOL is used to distinguish between    two different callers of the function.  It is set to 1 in the    "call_symbol" and "call_symbol_value" patterns and to 0 in the "call"    and "call_value" patterns.  This is because of the difference in the    SYM_REFs passed by these patterns.  */
end_comment

begin_function
name|int
name|arm_is_longcall_p
parameter_list|(
name|rtx
name|sym_ref
parameter_list|,
name|int
name|call_cookie
parameter_list|,
name|int
name|call_symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|call_symbol
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|sym_ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|sym_ref
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|call_cookie
operator|&
name|CALL_SHORT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_LONG_CALLS
operator|&&
name|flag_function_sections
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_file_function_operand
argument_list|(
name|sym_ref
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|call_cookie
operator|&
name|CALL_LONG
operator|)
operator|||
name|ENCODED_LONG_CALL_ATTR_P
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TARGET_LONG_CALLS
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if it is ok to make a tail-call to DECL.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|call_type
init|=
name|TARGET_LONG_CALLS
condition|?
name|CALL_LONG
else|:
name|CALL_NORMAL
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|sibcall_blocked
condition|)
return|return
name|false
return|;
comment|/* Never tailcall something for which we have no decl, or if we      are in Thumb mode.  */
if|if
condition|(
name|decl
operator|==
name|NULL
operator|||
name|TARGET_THUMB
condition|)
return|return
name|false
return|;
comment|/* Get the calling method.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|call_type
operator|=
name|CALL_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|call_type
operator|=
name|CALL_LONG
expr_stmt|;
comment|/* Cannot tail-call to long calls, since these are out of range of      a branch instruction.  However, if not compiling PIC, we know      we can reach the symbol if it is in this compilation unit.  */
if|if
condition|(
name|call_type
operator|==
name|CALL_LONG
operator|&&
operator|(
name|flag_pic
operator|||
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* If we are interworking and the function is not declared static      then we can't tail-call it unless we know that it exists in this       compilation unit (since it might be a Thumb routine).  */
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Never tailcall from an ISR routine - it needs a special exit sequence.  */
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Everything else is ok.  */
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Addressing mode support functions.  */
end_comment

begin_comment
comment|/* Return nonzero if X is a legitimate immediate operand when compiling    for PIC.  */
end_comment

begin_function
name|int
name|legitimate_pic_operand_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|flag_pic
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
name|rtx
name|pic_ref
decl_stmt|,
name|address
decl_stmt|;
endif|#
directive|endif
name|rtx
name|insn
decl_stmt|;
name|int
name|subregs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|subregs
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
comment|/* The AOF assembler can generate relocations for these directly, and 	 understands that the PIC register has to be added into the offset.  */
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pic_load_addr_based
argument_list|(
name|reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|subregs
condition|)
name|address
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|address
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
name|emit_insn
argument_list|(
name|gen_pic_load_addr_arm
argument_list|(
name|address
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_pic_load_addr_thumb
argument_list|(
name|address
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|orig
argument_list|)
operator|)
operator|)
operator|&&
name|NEED_GOT_RELOC
condition|)
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
block|{
name|pic_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
comment|/* Put a REG_EQUAL note on this insn, so that it can be optimized 	 by loop.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|orig
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* The base register doesn't really matter, we only want to 	     test the index for the appropriate mode.  */
if|if
condition|(
operator|!
name|arm_legitimate_index_p
argument_list|(
name|mode
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|TARGET_SOFT_FLOAT
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|reg
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Generate code to load the PIC register.  PROLOGUE is true if    called from arm_expand_prologue (in which case we want the     generated insns at the start of the function);  false if called    by an exception receiver that needs the PIC register reloaded    (in which case the insns are just dumped at the current location).  */
end_comment

begin_function
name|void
name|arm_finalize_pic
parameter_list|(
name|int
name|prologue
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
name|rtx
name|l1
decl_stmt|,
name|pic_tmp
decl_stmt|,
name|pic_tmp2
decl_stmt|,
name|seq
decl_stmt|,
name|pic_rtx
decl_stmt|;
name|rtx
name|global_offset_table
decl_stmt|;
if|if
condition|(
name|current_function_uses_pic_offset_table
operator|==
literal|0
operator|||
name|TARGET_SINGLE_PIC_BASE
condition|)
return|return;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|abort
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|l1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|global_offset_table
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
comment|/* On the ARM the PC register contains 'dot + 8' at the time of the      addition, on the Thumb it is 'dot + 4'.  */
name|pic_tmp
operator|=
name|plus_constant
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|l1
argument_list|)
argument_list|,
name|TARGET_ARM
condition|?
literal|8
else|:
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_PCREL
condition|)
name|pic_tmp2
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|global_offset_table
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pic_tmp2
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|global_offset_table
argument_list|)
expr_stmt|;
name|pic_rtx
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|pic_tmp2
argument_list|,
name|pic_tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_pic_load_addr_arm
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pic_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_eight
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|l1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_pic_load_addr_thumb
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pic_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_four
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|l1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|prologue
condition|)
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Need to emit this whether or not we obey regdecls,      since setjmp/longjmp can cause life info to screw up.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AOF_ASSEMBLER */
block|}
end_function

begin_comment
comment|/* Return nonzero if X is valid as an ARM state addressing register.  */
end_comment

begin_function
specifier|static
name|int
name|arm_address_register_rtx_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_p
condition|)
return|return
name|ARM_REGNO_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|)
return|;
return|return
operator|(
name|regno
operator|<=
name|LAST_ARM_REGNUM
operator|||
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X is a valid ARM state address operand.  */
end_comment

begin_function
name|int
name|arm_legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
if|if
condition|(
name|arm_address_register_rtx_p
argument_list|(
name|x
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_DEC
condition|)
return|return
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_MODIFY
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|&&
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|arm_legitimate_index_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_p
argument_list|)
return|;
comment|/* After reload constants split into minipools will have addresses      from a LABEL_REF.  */
elseif|else
if|if
condition|(
name|reload_completed
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
operator|(
name|TARGET_SOFT_FLOAT
operator|&&
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|4
operator|||
name|val
operator|==
operator|-
literal|4
operator|||
name|val
operator|==
operator|-
literal|8
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|xop0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|xop0
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|arm_legitimate_index_p
argument_list|(
name|mode
argument_list|,
name|xop1
argument_list|,
name|strict_p
argument_list|)
operator|)
operator|||
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|xop1
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|arm_legitimate_index_p
argument_list|(
name|mode
argument_list|,
name|xop0
argument_list|,
name|strict_p
argument_list|)
operator|)
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* Reload currently can't handle MINUS, so disable this for now */
if|else if (GET_CODE (x) == MINUS)     {       rtx xop0 = XEXP (x, 0);       rtx xop1 = XEXP (x, 1);        return (arm_address_register_rtx_p (xop0, strict_p)&& arm_legitimate_index_p (mode, xop1, strict_p));     }
endif|#
directive|endif
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|symbol_mentioned_p
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_DEC
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|)
operator|&&
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INDEX is valid for an address index operand in    ARM state.  */
end_comment

begin_function
specifier|static
name|int
name|arm_legitimate_index_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|index
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
name|HOST_WIDE_INT
name|range
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
operator|(
name|code
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|<
literal|1024
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>
operator|-
literal|1024
operator|&&
operator|(
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
return|;
if|if
condition|(
name|TARGET_CIRRUS
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|mode
operator|==
name|DImode
operator|)
condition|)
return|return
operator|(
name|code
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|<
literal|255
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>
operator|-
literal|255
operator|)
return|;
if|if
condition|(
name|arm_address_register_rtx_p
argument_list|(
name|index
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
name|VALID_IWMMXT_REG_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
operator|(
name|code
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|<
literal|256
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>
operator|-
literal|256
operator|)
return|;
comment|/* XXX What about ldrsb?  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|&&
name|code
operator|==
name|MULT
operator|&&
operator|(
operator|!
name|arm_arch4
operator|||
operator|(
name|mode
operator|)
operator|!=
name|HImode
operator|)
condition|)
block|{
name|rtx
name|xiop0
init|=
name|XEXP
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xiop1
init|=
name|XEXP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|xiop0
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|power_of_two_operand
argument_list|(
name|xiop1
argument_list|,
name|SImode
argument_list|)
operator|)
operator|||
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|xiop1
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|power_of_two_operand
argument_list|(
name|xiop0
argument_list|,
name|SImode
argument_list|)
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|&&
operator|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|ROTATERT
operator|)
operator|&&
operator|(
operator|!
name|arm_arch4
operator|||
operator|(
name|mode
operator|)
operator|!=
name|HImode
operator|)
condition|)
block|{
name|rtx
name|op
init|=
name|XEXP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<=
literal|31
operator|)
return|;
block|}
comment|/* XXX For ARM v4 we may be doing a sign-extend operation during the      load, but that has a restricted addressing range and we are unable      to tell here whether that is the case.  To be safe we restrict all      loads to that range.  */
if|if
condition|(
name|arm_arch4
condition|)
name|range
operator|=
operator|(
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|QImode
operator|)
condition|?
literal|256
else|:
literal|4096
expr_stmt|;
else|else
name|range
operator|=
operator|(
name|mode
operator|==
name|HImode
operator|)
condition|?
literal|4095
else|:
literal|4096
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|<
name|range
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>
operator|-
name|range
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X is valid as a Thumb state base register.  */
end_comment

begin_function
specifier|static
name|int
name|thumb_base_register_rtx_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_p
condition|)
return|return
name|THUMB_REGNO_MODE_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
return|;
return|return
operator|(
name|regno
operator|<=
name|LAST_LO_REGNUM
operator|||
name|regno
operator|>
name|LAST_VIRTUAL_REGISTER
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
operator|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if x is a legitimate index register.  This is the case    for any base register that can access a QImode object.  */
end_comment

begin_function
specifier|inline
specifier|static
name|int
name|thumb_index_register_rtx_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
return|return
name|thumb_base_register_rtx_p
argument_list|(
name|x
argument_list|,
name|QImode
argument_list|,
name|strict_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if x is a legitimate Thumb-state address.      The AP may be eliminated to either the SP or the FP, so we use the    least common denominator, e.g. SImode, and offsets from 0 to 64.     ??? Verify whether the above is the right approach.     ??? Also, the FP may be eliminated to the SP, so perhaps that    needs special handling also.     ??? Look at how the mips16 port solves this problem.  It probably uses    better ways to solve some of these problems.     Although it is not incorrect, we don't accept QImode and HImode    addresses based on the frame pointer or arg pointer until the    reload pass starts.  This is so that eliminating such addresses    into stack based ones won't produce impossible code.  */
end_comment

begin_function
name|int
name|thumb_legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
comment|/* ??? Not clear if this is right.  Experiment.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
literal|4
operator|&&
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|x
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Accept any base register.  SP only in SImode or larger.  */
elseif|else
if|if
condition|(
name|thumb_base_register_rtx_p
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* This is PC relative data before arm_reorg runs.  */
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
return|return
literal|1
return|;
comment|/* This is PC relative data after arm_reorg runs.  */
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|reload_completed
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Post-inc indexing only supported for SImode and larger.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_INC
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|thumb_index_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* REG+REG address can be any two index registers.  */
comment|/* We disallow FRAME+REG addressing since we know that FRAME 	 will be replaced with STACK, and SP relative addressing only 	 permits SP+OFFSET.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|frame_pointer_rtx
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|!=
name|frame_pointer_rtx
operator|&&
name|thumb_index_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|thumb_index_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* REG+const has 5-7 bit offset for non-SP registers.  */
elseif|else
if|if
condition|(
operator|(
name|thumb_index_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|thumb_legitimate_offset_p
argument_list|(
name|mode
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* REG+const has 10 bit offset for SP, but only SImode and 	 larger is supported.  */
comment|/* ??? Should probably check for DI/DFmode overflow here 	 just like GO_IF_LEGITIMATE_OFFSET does.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|1024
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|4
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|symbol_mentioned_p
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if VAL can be used as an offset in a Thumb-state address    instruction of mode MODE.  */
end_comment

begin_function
name|int
name|thumb_legitimate_offset_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|val
operator|>=
literal|0
operator|&&
name|val
operator|<
literal|32
return|;
case|case
literal|2
case|:
return|return
name|val
operator|>=
literal|0
operator|&&
name|val
operator|<
literal|64
operator|&&
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
return|;
default|default:
return|return
operator|(
name|val
operator|>=
literal|0
operator|&&
operator|(
name|val
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|<=
literal|128
operator|&&
operator|(
name|val
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.  */
end_comment

begin_function
name|rtx
name|arm_legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|orig_x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|xop0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop0
argument_list|)
operator|&&
operator|!
name|symbol_mentioned_p
argument_list|(
name|xop0
argument_list|)
condition|)
name|xop0
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop1
argument_list|)
operator|&&
operator|!
name|symbol_mentioned_p
argument_list|(
name|xop1
argument_list|)
condition|)
name|xop1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARM_BASE_REGISTER_RTX_P
argument_list|(
name|xop0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|xop1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|n
decl_stmt|,
name|low_n
decl_stmt|;
name|rtx
name|base_reg
decl_stmt|,
name|val
decl_stmt|;
name|n
operator|=
name|INTVAL
argument_list|(
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
operator|(
name|TARGET_SOFT_FLOAT
operator|&&
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
name|low_n
operator|=
name|n
operator|&
literal|0x0f
expr_stmt|;
name|n
operator|&=
operator|~
literal|0x0f
expr_stmt|;
if|if
condition|(
name|low_n
operator|>
literal|4
condition|)
block|{
name|n
operator|+=
literal|16
expr_stmt|;
name|low_n
operator|-=
literal|16
expr_stmt|;
block|}
block|}
else|else
block|{
name|low_n
operator|=
operator|(
operator|(
name|mode
operator|)
operator|==
name|TImode
condition|?
literal|0
else|:
name|n
operator|>=
literal|0
condition|?
operator|(
name|n
operator|&
literal|0xfff
operator|)
else|:
operator|-
operator|(
operator|(
operator|-
name|n
operator|)
operator|&
literal|0xfff
operator|)
operator|)
expr_stmt|;
name|n
operator|-=
name|low_n
expr_stmt|;
block|}
name|base_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|,
name|GEN_INT
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|base_reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|low_n
operator|==
literal|0
condition|?
name|base_reg
else|:
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|base_reg
argument_list|,
name|GEN_INT
argument_list|(
name|low_n
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xop0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|xop1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
block|}
comment|/* XXX We don't allow MINUS any more -- see comment in      arm_legitimate_address_p ().  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
block|{
name|rtx
name|xop0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop0
argument_list|)
condition|)
name|xop0
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop1
argument_list|)
operator|&&
operator|!
name|symbol_mentioned_p
argument_list|(
name|xop1
argument_list|)
condition|)
name|xop1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|xop1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_MINUS
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
block|{
comment|/* We need to find and carefully transform any SYMBOL and LABEL 	 references; so go back to the original address expression.  */
name|rtx
name|new_x
init|=
name|legitimize_pic_address
argument_list|(
name|orig_x
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_x
operator|!=
name|orig_x
condition|)
name|x
operator|=
name|new_x
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|REG_OR_SUBREG_REG
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == REG							\    || (GET_CODE (X) == SUBREG&& GET_CODE (SUBREG_REG (X)) == REG))
end_define

begin_define
define|#
directive|define
name|REG_OR_SUBREG_RTX
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == REG ? (X) : SUBREG_REG (X))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COSTS_N_INSNS
end_ifndef

begin_define
define|#
directive|define
name|COSTS_N_INSNS
parameter_list|(
name|N
parameter_list|)
value|((N) * 4 - 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Worker routine for arm_rtx_costs.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|arm_rtx_costs_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|rtx_code
name|outer
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|subcode
decl_stmt|;
name|int
name|extra_cost
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|COMPARE
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|cycles
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|i
operator|>>=
literal|2
expr_stmt|;
name|cycles
operator|++
expr_stmt|;
block|}
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
operator|+
name|cycles
return|;
block|}
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|16
return|;
case|case
name|SET
case|:
return|return
operator|(
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|+
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|)
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|outer
operator|==
name|SET
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|thumb_shiftable_const
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
return|;
return|return
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|outer
operator|==
name|PLUS
operator|||
name|outer
operator|==
name|COMPARE
operator|)
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>
operator|-
literal|256
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|AND
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
operator|-
literal|256
condition|)
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|ASHIFT
operator|||
name|outer
operator|==
name|ASHIFTRT
operator|||
name|outer
operator|==
name|LSHIFTRT
condition|)
return|return
literal|0
return|;
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
return|;
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
return|;
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
return|return
literal|100
return|;
case|case
name|TRUNCATE
case|:
return|return
literal|99
return|;
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|IOR
case|:
comment|/* XXX guess.  */
return|return
literal|8
return|;
case|case
name|ADDRESSOF
case|:
case|case
name|MEM
case|:
comment|/* XXX another guess.  */
comment|/* Memory costs quite a lot for the first word, but subsequent words 	     load at the equivalent of a single insn each.  */
return|return
operator|(
literal|10
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
comment|/* XXX a guess.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
return|return
literal|14
return|;
return|return
literal|2
return|;
case|case
name|ZERO_EXTEND
case|:
comment|/* XXX still guessing.  */
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|HImode
case|:
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|SImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
default|default:
return|return
literal|99
return|;
block|}
default|default:
return|return
literal|99
return|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
comment|/* Memory costs quite a lot for the first word, but subsequent words 	 load at the equivalent of a single insn each.  */
return|return
operator|(
literal|10
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
return|return
name|optimize_size
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
else|:
literal|100
return|;
case|case
name|ROTATE
case|:
if|if
condition|(
name|mode
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|4
return|;
comment|/* Fall through */
case|case
name|ROTATERT
case|:
if|if
condition|(
name|mode
operator|!=
name|SImode
condition|)
return|return
literal|8
return|;
comment|/* Fall through */
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|8
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
return|return
operator|(
literal|1
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
case|case
name|MINUS
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
operator|(
literal|2
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|const_double_rtx_ok_for_fpa
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|const_double_rtx_ok_for_fpa
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|subcode
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|ASHIFT
operator|||
name|subcode
operator|==
name|ASHIFTRT
operator|||
name|subcode
operator|==
name|LSHIFTRT
operator|||
name|subcode
operator|==
name|ROTATE
operator|||
name|subcode
operator|==
name|ROTATERT
operator|||
operator|(
name|subcode
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Fall through */
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
operator|(
literal|2
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|const_double_rtx_ok_for_fpa
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
comment|/* Fall through */
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|IOR
case|:
name|extra_cost
operator|=
literal|0
expr_stmt|;
comment|/* Normally the frame registers will be spilt into reg+const during 	 reload, so it is a bad idea to combine them with other instructions, 	 since then they might not be moved outside of loops.  As a compromise 	 we allow integration with ops that have a constant as their second 	 operand.  */
if|if
condition|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ARM_FRAME_RTX
argument_list|(
name|REG_OR_SUBREG_RTX
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
operator|||
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ARM_FRAME_RTX
argument_list|(
name|REG_OR_SUBREG_RTX
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|extra_cost
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|4
operator|+
name|extra_cost
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_op
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|code
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|?
literal|0
else|:
name|extra_cost
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_op
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|code
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|+
name|extra_cost
operator|+
operator|(
operator|(
operator|(
operator|(
name|subcode
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|==
name|ASHIFT
operator|||
name|subcode
operator|==
name|LSHIFTRT
operator|||
name|subcode
operator|==
name|ASHIFTRT
operator|||
name|subcode
operator|==
name|ROTATE
operator|||
name|subcode
operator|==
name|ROTATERT
operator|||
operator|(
name|subcode
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
return|return
literal|8
return|;
case|case
name|MULT
case|:
comment|/* There is no point basing this on the tuning, since it is always the 	 fast variant if it exists at all.  */
if|if
condition|(
name|arm_fast_multiply
operator|&&
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
condition|)
return|return
literal|8
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|mode
operator|==
name|DImode
condition|)
return|return
literal|30
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
decl_stmt|;
name|int
name|cost
decl_stmt|,
name|const_ok
init|=
name|const_ok_for_arm
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|booth_unit_size
decl_stmt|;
if|if
condition|(
name|arm_tune_xscale
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|masked_const
decl_stmt|;
comment|/* The cost will be related to two insns. 		 First a load of the constant (MOV or LDR), then a multiply.  */
name|cost
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|const_ok
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* LDR is probably more expensive because 				   of longer result latency.  */
name|masked_const
operator|=
name|i
operator|&
literal|0xffff8000
expr_stmt|;
if|if
condition|(
name|masked_const
operator|!=
literal|0
operator|&&
name|masked_const
operator|!=
literal|0xffff8000
condition|)
block|{
name|masked_const
operator|=
name|i
operator|&
literal|0xf8000000
expr_stmt|;
if|if
condition|(
name|masked_const
operator|==
literal|0
operator|||
name|masked_const
operator|==
literal|0xf8000000
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
else|else
name|cost
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
comment|/* Tune as appropriate.  */
name|cost
operator|=
name|const_ok
condition|?
literal|4
else|:
literal|8
expr_stmt|;
name|booth_unit_size
operator|=
operator|(
operator|(
name|tune_flags
operator|&
name|FL_FAST_MULT
operator|)
condition|?
literal|8
else|:
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|&&
name|j
operator|<
literal|32
condition|;
name|j
operator|+=
name|booth_unit_size
control|)
block|{
name|i
operator|>>=
name|booth_unit_size
expr_stmt|;
name|cost
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
return|return
operator|(
operator|(
operator|(
name|tune_flags
operator|&
name|FL_FAST_MULT
operator|)
condition|?
literal|8
else|:
literal|30
operator|)
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
case|case
name|TRUNCATE
case|:
if|if
condition|(
name|arm_fast_multiply
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
condition|)
return|return
literal|8
return|;
return|return
literal|99
return|;
case|case
name|NEG
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|6
operator|)
return|;
comment|/* Fall through */
case|case
name|NOT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
return|;
return|return
literal|1
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
return|return
literal|14
return|;
return|return
literal|2
return|;
case|case
name|COMPARE
case|:
return|return
literal|1
return|;
case|case
name|ABS
case|:
return|return
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
return|;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|QImode
condition|)
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
comment|/* Fall through */
case|case
name|ZERO_EXTEND
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|HImode
case|:
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|SImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|V8QImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V2SImode
case|:
case|case
name|V4QImode
case|:
case|case
name|V2HImode
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|outer
operator|==
name|SET
condition|?
literal|2
else|:
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|AND
operator|&&
name|const_ok_for_arm
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|outer
operator|==
name|COMPARE
operator|||
name|outer
operator|==
name|PLUS
operator|||
name|outer
operator|==
name|MINUS
operator|)
operator|&&
name|const_ok_for_arm
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|5
return|;
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|6
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|const_double_rtx_ok_for_fpa
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|outer
operator|==
name|SET
condition|?
literal|2
else|:
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|outer
operator|==
name|COMPARE
operator|||
name|outer
operator|==
name|PLUS
operator|)
operator|&&
name|neg_const_double_rtx_ok_for_fpa
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|7
return|;
default|default:
return|return
literal|99
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|arm_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
operator|*
name|total
operator|=
name|arm_rtx_costs_1
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* All address computations that can be done are free, but rtx cost returns    the same for practically all of them.  So we weight the different types    of address here in the order (most pref first):    PRE/POST_INC/DEC, SHIFT or NON-INT sum, INT sum, REG, MEM or LABEL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|arm_arm_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|c
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|PRE_INC
operator|||
name|c
operator|==
name|PRE_DEC
operator|||
name|c
operator|==
name|POST_INC
operator|||
name|c
operator|==
name|POST_DEC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|==
name|MEM
operator|||
name|c
operator|==
name|LABEL_REF
operator|||
name|c
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|10
return|;
if|if
condition|(
name|c
operator|==
name|PLUS
operator|||
name|c
operator|==
name|MINUS
condition|)
block|{
name|char
name|cl0
init|=
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|cl1
init|=
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|cl0
operator|==
literal|'2'
operator|||
name|cl0
operator|==
literal|'c'
operator|||
name|cl1
operator|==
literal|'2'
operator|||
name|cl1
operator|==
literal|'c'
condition|)
return|return
literal|3
return|;
return|return
literal|4
return|;
block|}
return|return
literal|6
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|arm_thumb_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|c
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|REG
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
return|return
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|TARGET_ARM
condition|?
name|arm_arm_address_cost
argument_list|(
name|x
argument_list|)
else|:
name|arm_thumb_address_cost
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|rtx
name|i_pat
decl_stmt|,
name|d_pat
decl_stmt|;
comment|/* Some true dependencies can have a higher cost depending      on precisely how certain input operands are used.  */
if|if
condition|(
name|arm_tune_xscale
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|&&
name|recog_memoized
argument_list|(
name|dep
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|shift_opnum
init|=
name|get_attr_shift
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|attr_type
name|attr_type
init|=
name|get_attr_type
argument_list|(
name|dep
argument_list|)
decl_stmt|;
comment|/* If nonzero, SHIFT_OPNUM contains the operand number of a shifted 	 operand for INSN.  If we have a shifted input operand and the 	 instruction we depend on is another ALU instruction, then we may 	 have to account for an additional stall.  */
if|if
condition|(
name|shift_opnum
operator|!=
literal|0
operator|&&
name|attr_type
operator|==
name|TYPE_NORMAL
condition|)
block|{
name|rtx
name|shifted_operand
decl_stmt|;
name|int
name|opno
decl_stmt|;
comment|/* Get the shifted operand.  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|shifted_operand
operator|=
name|recog_data
operator|.
name|operand
index|[
name|shift_opnum
index|]
expr_stmt|;
comment|/* Iterate over all the operands in DEP.  If we write an operand 	     that overlaps with SHIFTED_OPERAND, then we have increase the 	     cost of this dependency.  */
name|extract_insn
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
comment|/* We can ignore strict inputs.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|opno
index|]
operator|==
name|OP_IN
condition|)
continue|continue;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|,
name|shifted_operand
argument_list|)
condition|)
return|return
literal|2
return|;
block|}
block|}
block|}
comment|/* XXX This is not strictly true for the FPA.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
condition|)
return|return
literal|0
return|;
comment|/* Call insns don't incur a stall, even if they follow a load.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|i_pat
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|d_pat
operator|=
name|single_set
argument_list|(
name|dep
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|d_pat
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|src_mem
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* This is a load after a store, there is no conflict if the load reads 	 from a cached area.  Assume that loads from the stack, and from the 	 constant pool are cached, and that others will miss.  This is a  	 hack.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src_mem
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|src_mem
argument_list|)
operator|)
operator|||
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|src_mem
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|src_mem
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|src_mem
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|fpa_consts_inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|strings_fpa
index|[
literal|8
index|]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"0.5"
block|,
literal|"10"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|REAL_VALUE_TYPE
name|values_fpa
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_fpa_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|strings_fpa
index|[
name|i
index|]
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|values_fpa
index|[
name|i
index|]
operator|=
name|r
expr_stmt|;
block|}
name|fpa_consts_inited
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if rtx X is a valid immediate FPA constant.  */
end_comment

begin_function
name|int
name|const_double_rtx_ok_for_fpa
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fpa_consts_inited
condition|)
name|init_fpa_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fpa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if rtx X is a valid immediate FPA constant.  */
end_comment

begin_function
name|int
name|neg_const_double_rtx_ok_for_fpa
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fpa_consts_inited
condition|)
name|init_fpa_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fpa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Predicates for `match_operand' and `match_operator'.  */
end_comment

begin_comment
comment|/* s_register_operand is the same as register_operand, but it doesn't accept    (SUBREG (MEM)...).     This function exists because at the time it was put in it led to better    code.  SUBREG(MEM) always needs a reload in the places where    s_register_operand is used, and this seemed to lead to excessive    reloading.  */
end_comment

begin_function
name|int
name|s_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
comment|/* XXX might have to check for lo regs only for thumb ??? */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A hard register operand (even before reload.  */
end_comment

begin_function
name|int
name|arm_hard_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Only accept reg, subreg(reg), const_int.  */
end_comment

begin_function
name|int
name|reg_or_int_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an item in memory, given that we are in reload.  */
end_comment

begin_function
name|int
name|arm_reload_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid memory address, but not valid for a signed byte    memory access (architecture V4).    MODE is QImode if called when computing constraints, or VOIDmode when    emitting patterns.  In this latter case we cannot use memory_operand()    because it will fail on badly formed MEMs, which is precisely what we are    trying to catch.  */
end_comment

begin_function
name|int
name|bad_signed_byte_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A sum of anything more complex than reg + reg or reg + const is bad.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
operator|(
operator|!
name|s_register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|(
operator|!
name|s_register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Big constants are also bad.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0xff
operator|||
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0xff
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Everything else is good, or can will automatically be made so.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid operands for the rhs of an ARM instruction.  */
end_comment

begin_function
name|int
name|arm_rhs_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid operands for the    rhs of an ARM instruction, or a load.  */
end_comment

begin_function
name|int
name|arm_rhsm_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid operands for the rhs of an ARM instruction, or if a    constant that is valid when negated.  */
end_comment

begin_function
name|int
name|arm_add_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|TARGET_THUMB
condition|)
return|return
name|thumb_cmp_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid ARM constants (or when valid if negated).  */
end_comment

begin_function
name|int
name|arm_addimm_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arm_not_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the operand is a memory reference which contains an    offsettable address.  */
end_comment

begin_function
name|int
name|offsettable_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|offsettable_address_p
argument_list|(
name|reload_completed
operator||
name|reload_in_progress
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the operand is a memory reference which is, or can be    made word aligned by adjusting the offset.  */
end_comment

begin_function
name|int
name|alignable_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|op
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|)
operator|)
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>=
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to s_register_operand, but does not allow hard integer     registers.  */
end_comment

begin_function
name|int
name|f_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|FPA_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid operands for the rhs of an FPA instruction.  */
end_comment

begin_function
name|int
name|fpa_rhs_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|const_double_rtx_ok_for_fpa
argument_list|(
name|op
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|fpa_add_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|(
name|const_double_rtx_ok_for_fpa
argument_list|(
name|op
argument_list|)
operator|||
name|neg_const_double_rtx_ok_for_fpa
argument_list|(
name|op
argument_list|)
operator|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a valid Cirrus memory address pattern.  */
end_comment

begin_function
name|int
name|cirrus_memory_offset
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
comment|/* Reject eliminable registers.  */
if|if
condition|(
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|op
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|ind
decl_stmt|;
name|ind
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Match: (mem (reg)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|1
return|;
comment|/* Match: 	 (mem (plus (reg) 	            (const))).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a Cirrus or general register.  */
end_comment

begin_function
name|int
name|cirrus_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|CIRRUS_REGS
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|GENERAL_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a cirrus FP register.  */
end_comment

begin_function
name|int
name|cirrus_fp_register
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|CIRRUS_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a 6bit constant (0..63).  */
end_comment

begin_function
name|int
name|cirrus_shift_const
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if INSN is an "LDR REG, ADDR" instruction.    Use by the Cirrus Maverick code which has to workaround    a hardware bug triggered by such instructions.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_memory_load_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|body
decl_stmt|,
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
return|return
name|false
return|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|REG_OR_SUBREG_RTX
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* If the destination is not a general purpose      register we do not have to worry.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|!=
name|GENERAL_REGS
condition|)
return|return
name|false
return|;
comment|/* As well as loads from memory we also have to react      to loads of invalid constants which will be turned      into loads from the minipool.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|note_invalid_constants
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if INSN is a Cirrus instruction.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_cirrus_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|attr_cirrus
name|attr
decl_stmt|;
comment|/* get_attr aborts on USE and CLOBBER.  */
if|if
condition|(
operator|!
name|insn
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
name|attr
operator|=
name|get_attr_cirrus
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|attr
operator|!=
name|CIRRUS_NOT
return|;
block|}
end_function

begin_comment
comment|/* Cirrus reorg for invalid instruction combinations.  */
end_comment

begin_function
specifier|static
name|void
name|cirrus_reorg
parameter_list|(
name|rtx
name|first
parameter_list|)
block|{
name|enum
name|attr_cirrus
name|attr
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|first
argument_list|)
decl_stmt|;
name|rtx
name|t
decl_stmt|;
name|int
name|nops
decl_stmt|;
comment|/* Any branch must be followed by 2 non Cirrus instructions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|RETURN
condition|)
block|{
name|nops
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|t
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|next_nonnote_insn
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
while|while
condition|(
name|nops
operator|--
condition|)
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* (float (blah)) is in parallel with a clobber.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|body
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|lhs
init|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|rhs
init|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* cfldrd, cfldr64, cfstrd, cfstr64 must 	 be followed by a non Cirrus insn.  */
if|if
condition|(
name|get_attr_cirrus
argument_list|(
name|first
argument_list|)
operator|==
name|CIRRUS_DOUBLE
condition|)
block|{
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|arm_memory_load_p
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|arm_regno
decl_stmt|;
comment|/* Any ldr/cfmvdlr, ldr/cfmvdhr, ldr/cfmvsr, ldr/cfmv64lr, 	     ldr/cfmv64hr combination where the Rd field is the same 	     in both instructions must be split with a non Cirrus 	     insn.  Example:  	     ldr r0, blah 	     nop 	     cfmvsr mvf0, r0.  */
comment|/* Get Arm register number for ldr insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|REG
condition|)
name|arm_regno
operator|=
name|REGNO
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|REG
condition|)
name|arm_regno
operator|=
name|REGNO
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Next insn.  */
name|first
operator|=
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arm_cirrus_insn_p
argument_list|(
name|first
argument_list|)
condition|)
return|return;
name|body
operator|=
name|PATTERN
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* (float (blah)) is in parallel with a clobber.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|)
name|body
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|FLOAT
condition|)
name|body
operator|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_attr_cirrus
argument_list|(
name|first
argument_list|)
operator|==
name|CIRRUS_MOVE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|arm_regno
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* get_attr aborts on USE and CLOBBER.  */
if|if
condition|(
operator|!
name|first
operator|||
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return;
name|attr
operator|=
name|get_attr_cirrus
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* Any coprocessor compare instruction (cfcmps, cfcmpd, ...)      must be followed by a non-coprocessor instruction.  */
if|if
condition|(
name|attr
operator|==
name|CIRRUS_COMPARE
condition|)
block|{
name|nops
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|t
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|next_nonnote_insn
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
while|while
condition|(
name|nops
operator|--
condition|)
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a constant power of two.  */
end_comment

begin_function
name|int
name|power_of_two_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
name|value
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
operator|(
name|value
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for a valid operand of a DImode operation.    Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).    Note that this disallows MEM(REG+REG), but allows    MEM(PRE/POST_INC/DEC(REG)).  */
end_comment

begin_function
name|int
name|di_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DImode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
return|return
name|TRUE
return|;
case|case
name|MEM
case|:
return|return
name|memory_address_p
argument_list|(
name|DImode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like di_operand, but don't accept constants.  */
end_comment

begin_function
name|int
name|nonimmediate_di_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DImode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|memory_address_p
argument_list|(
name|DImode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for a valid operand of a DFmode operation when -msoft-float.    Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).    Note that this disallows MEM(REG+REG), but allows    MEM(PRE/POST_INC/DEC(REG)).  */
end_comment

begin_function
name|int
name|soft_df_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|CONSTANT_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
return|return
name|TRUE
return|;
case|case
name|MEM
case|:
return|return
name|memory_address_p
argument_list|(
name|DFmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like soft_df_operand, but don't accept constants.  */
end_comment

begin_function
name|int
name|nonimmediate_soft_df_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|memory_address_p
argument_list|(
name|DFmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid index operands.  */
end_comment

begin_function
name|int
name|index_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|4096
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
operator|-
literal|4096
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid shifts by a constant. This also accepts any    power of two on the (somewhat overly relaxed) assumption that the    shift operator in this case was a mult.  */
end_comment

begin_function
name|int
name|const_shift_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|power_of_two_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for arithmetic operators which can be combined with a multiply    (shift).  */
end_comment

begin_function
name|int
name|shiftable_operator
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|||
name|code
operator|==
name|AND
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for binary logical operators.  */
end_comment

begin_function
name|int
name|logical_binary_operator
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|||
name|code
operator|==
name|AND
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for shift operators.  */
end_comment

begin_function
name|int
name|shift_operator
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MULT
condition|)
return|return
name|power_of_two_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
return|return
operator|(
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ROTATERT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if x is EQ or NE.  */
end_comment

begin_function
name|int
name|equality_operator
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if x is a comparison operator other than LTGT or UNEQ.  */
end_comment

begin_function
name|int
name|arm_comparison_operator
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|comparison_operator
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LTGT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|UNEQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for SMIN SMAX UMIN UMAX operators.  */
end_comment

begin_function
name|int
name|minmax_operator
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
return|return
name|code
operator|==
name|SMIN
operator|||
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|UMIN
operator|||
name|code
operator|==
name|UMAX
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if this is the condition code register, if we aren't given    a mode, accept any class CCmode register.  */
end_comment

begin_function
name|int
name|cc_register
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|CC_REGNUM
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if this is the condition code register, if we aren't given    a mode, accept any class CCmode register which indicates a dominance    expression.  */
end_comment

begin_function
name|int
name|dominant_cc_register
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|mode
operator|!=
name|CC_DNEmode
operator|&&
name|mode
operator|!=
name|CC_DEQmode
operator|&&
name|mode
operator|!=
name|CC_DLEmode
operator|&&
name|mode
operator|!=
name|CC_DLTmode
operator|&&
name|mode
operator|!=
name|CC_DGEmode
operator|&&
name|mode
operator|!=
name|CC_DGTmode
operator|&&
name|mode
operator|!=
name|CC_DLEUmode
operator|&&
name|mode
operator|!=
name|CC_DLTUmode
operator|&&
name|mode
operator|!=
name|CC_DGEUmode
operator|&&
name|mode
operator|!=
name|CC_DGTUmode
condition|)
return|return
name|FALSE
return|;
return|return
name|cc_register
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if X references a SYMBOL_REF.  */
end_comment

begin_function
name|int
name|symbol_mentioned_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbol_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbol_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if X references a LABEL_REF.  */
end_comment

begin_function
name|int
name|label_mentioned_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|label_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|label_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|enum
name|rtx_code
name|minmax_code
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SMAX
condition|)
return|return
name|GE
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SMIN
condition|)
return|return
name|LE
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UMIN
condition|)
return|return
name|LEU
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UMAX
condition|)
return|return
name|GEU
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if memory locations are adjacent.  */
end_comment

begin_function
name|int
name|adjacent_mem_locations
parameter_list|(
name|rtx
name|a
parameter_list|,
name|rtx
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
name|int
name|val0
init|=
literal|0
decl_stmt|,
name|val1
init|=
literal|0
decl_stmt|;
name|int
name|reg0
decl_stmt|,
name|reg1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|reg0
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|val0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|reg0
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|val1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't accept any offset that will require multiple 	 instructions to handle, since this would cause the 	 arith_adjacentmem pattern to output an overlong sequence.  */
if|if
condition|(
operator|!
name|const_ok_for_op
argument_list|(
name|PLUS
argument_list|,
name|val0
argument_list|)
operator|||
operator|!
name|const_ok_for_op
argument_list|(
name|PLUS
argument_list|,
name|val1
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|reg0
operator|==
name|reg1
operator|)
operator|&&
operator|(
operator|(
name|val1
operator|-
name|val0
operator|)
operator|==
literal|4
operator|||
operator|(
name|val0
operator|-
name|val1
operator|)
operator|==
literal|4
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a load multiple operation.  It is known to be    parallel and the first section will be tested.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|HOST_WIDE_INT
name|i
init|=
literal|1
decl_stmt|,
name|base
init|=
literal|0
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
comment|/* Check to see if this might be a write-back.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|base
operator|=
literal|1
expr_stmt|;
comment|/* Now check it more carefully.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
name|i
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|dest_regno
operator|+
name|i
operator|-
name|base
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|i
operator|-
name|base
operator|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a store multiple operation.  It is known to be    parallel and the first section will be tested.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|HOST_WIDE_INT
name|i
init|=
literal|1
decl_stmt|,
name|base
init|=
literal|0
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
comment|/* Check to see if this might be a write-back.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|base
operator|=
literal|1
expr_stmt|;
comment|/* Now check it more carefully.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
name|i
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|src_regno
operator|+
name|i
operator|-
name|base
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|i
operator|-
name|base
operator|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|load_multiple_sequence
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|nops
parameter_list|,
name|int
modifier|*
name|regs
parameter_list|,
name|int
modifier|*
name|base
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|load_offset
parameter_list|)
block|{
name|int
name|unsorted_regs
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|unsorted_offsets
index|[
literal|4
index|]
decl_stmt|;
name|int
name|order
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Can only handle 2, 3, or 4 insns at present,      though could be easily extended if required.  */
if|if
condition|(
name|nops
operator|<
literal|2
operator|||
name|nops
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Loop over the operands and check that the memory references are      suitable (ie immediate offsets from the same base register).  At      the same time, extract the target register, and the memory      offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
comment|/* Convert a subreg of a mem into the mem itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|operands
index|[
name|nops
operator|+
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|operands
operator|+
operator|(
name|nops
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Don't reorder volatile memory references; it doesn't seem worth 	 looking for the case where the order is ok anyway.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|base_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|unsorted_regs
index|[
literal|0
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|order
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base_reg
operator|!=
operator|(
name|int
operator|)
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
comment|/* Not addressed from the same base register.  */
return|return
literal|0
return|;
name|unsorted_regs
index|[
name|i
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
literal|0
index|]
index|]
condition|)
name|order
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* If it isn't an integer register, or if it overwrites the 	     base register but isn't the last insn in the list, then 	     we can't do this.  */
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|unsorted_regs
index|[
name|i
index|]
operator|>
literal|14
operator|||
operator|(
name|i
operator|!=
name|nops
operator|-
literal|1
operator|&&
name|unsorted_regs
index|[
name|i
index|]
operator|==
name|base_reg
operator|)
condition|)
return|return
literal|0
return|;
name|unsorted_offsets
index|[
name|i
index|]
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not a suitable memory address.  */
return|return
literal|0
return|;
block|}
comment|/* All the useful information has now been extracted from the      operands into unsorted_regs and unsorted_offsets; additionally,      order[0] has been set to the lowest numbered register in the      list.  Sort the registers into order, and check that the memory      offsets are ascending and adjacent.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|unsorted_regs
index|[
name|j
index|]
operator|>
name|unsorted_regs
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|&&
operator|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
operator|||
name|unsorted_regs
index|[
name|j
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
operator|)
condition|)
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
comment|/* Have we found a suitable register? if not, one must be used more 	 than once.  */
if|if
condition|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
literal|0
return|;
comment|/* Is the memory address adjacent and ascending? */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|i
index|]
index|]
operator|!=
name|unsorted_offsets
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|+
literal|4
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|base
condition|)
block|{
operator|*
name|base
operator|=
name|base_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|load_offset
operator|=
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* ldmia */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|4
condition|)
return|return
literal|2
return|;
comment|/* ldmib */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|3
return|;
comment|/* ldmda */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
operator|-
literal|4
condition|)
return|return
literal|4
return|;
comment|/* ldmdb */
comment|/* For ARM8,9& StrongARM, 2 ldr instructions are faster than an ldm      if the offset isn't small enough.  The reason 2 ldrs are faster      is because these ARMs are able to do more than one cache access      in a single cycle.  The ARM9 and StrongARM have Harvard caches,      whilst the ARM8 has a double bandwidth cache.  This means that      these cores can do both an instruction fetch and a data fetch in      a single cycle, so the trick of calculating the address into a      scratch register (one of the result regs) and then doing a load      multiple actually becomes slower (and no smaller in code size).      That is the transformation    	ldr	rd1, [rbase + offset]  	ldr	rd2, [rbase + offset + 4]        to    	add	rd1, rbase, offset  	ldmia	rd1, {rd1, rd2}        produces worse code -- '3 cycles + any stalls on rd2' instead of      '2 cycles + any stalls on rd2'.  On ARMs with only one cache      access per cycle, the first sequence could never complete in less      than 6 cycles, whereas the ldm sequence would only take 5 and      would make better use of sequential accesses if not hitting the      cache.       We cheat here and test 'arm_ld_sched' which we currently know to      only be true for the ARM8, ARM9 and StrongARM.  If this ever      changes, then the test below needs to be reworked.  */
if|if
condition|(
name|nops
operator|==
literal|2
operator|&&
name|arm_ld_sched
condition|)
return|return
literal|0
return|;
comment|/* Can't do it without setting up the offset, only do this if it takes      no more than one insn.  */
return|return
operator|(
name|const_ok_for_arm
argument_list|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
argument_list|)
operator|)
condition|?
literal|5
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|emit_ldm_seq
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|nops
parameter_list|)
block|{
name|int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|load_multiple_sequence
argument_list|(
name|operands
argument_list|,
name|nops
argument_list|,
name|regs
argument_list|,
operator|&
name|base_reg
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ib\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?da\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?db\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"add%%?\t%s%s, %s%s, #%ld"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"sub%%?\t%s%s, %s%s, #%ld"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
operator|(
name|long
operator|)
operator|-
name|offset
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|base_reg
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s, {%s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|", %s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}\t%@ phole ldm"
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|int
name|store_multiple_sequence
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|nops
parameter_list|,
name|int
modifier|*
name|regs
parameter_list|,
name|int
modifier|*
name|base
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|load_offset
parameter_list|)
block|{
name|int
name|unsorted_regs
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|unsorted_offsets
index|[
literal|4
index|]
decl_stmt|;
name|int
name|order
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Can only handle 2, 3, or 4 insns at present, though could be easily      extended if required.  */
if|if
condition|(
name|nops
operator|<
literal|2
operator|||
name|nops
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Loop over the operands and check that the memory references are      suitable (ie immediate offsets from the same base register).  At      the same time, extract the target register, and the memory      offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
comment|/* Convert a subreg of a mem into the mem itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|operands
index|[
name|nops
operator|+
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|operands
operator|+
operator|(
name|nops
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Don't reorder volatile memory references; it doesn't seem worth 	 looking for the case where the order is ok anyway.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|base_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|unsorted_regs
index|[
literal|0
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|order
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base_reg
operator|!=
operator|(
name|int
operator|)
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
comment|/* Not addressed from the same base register.  */
return|return
literal|0
return|;
name|unsorted_regs
index|[
name|i
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
literal|0
index|]
index|]
condition|)
name|order
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* If it isn't an integer register, then we can't do this.  */
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|unsorted_regs
index|[
name|i
index|]
operator|>
literal|14
condition|)
return|return
literal|0
return|;
name|unsorted_offsets
index|[
name|i
index|]
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not a suitable memory address.  */
return|return
literal|0
return|;
block|}
comment|/* All the useful information has now been extracted from the      operands into unsorted_regs and unsorted_offsets; additionally,      order[0] has been set to the lowest numbered register in the      list.  Sort the registers into order, and check that the memory      offsets are ascending and adjacent.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|unsorted_regs
index|[
name|j
index|]
operator|>
name|unsorted_regs
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|&&
operator|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
operator|||
name|unsorted_regs
index|[
name|j
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
operator|)
condition|)
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
comment|/* Have we found a suitable register? if not, one must be used more 	 than once.  */
if|if
condition|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
literal|0
return|;
comment|/* Is the memory address adjacent and ascending? */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|i
index|]
index|]
operator|!=
name|unsorted_offsets
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|+
literal|4
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|base
condition|)
block|{
operator|*
name|base
operator|=
name|base_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|load_offset
operator|=
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* stmia */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|4
condition|)
return|return
literal|2
return|;
comment|/* stmib */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|3
return|;
comment|/* stmda */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
operator|-
literal|4
condition|)
return|return
literal|4
return|;
comment|/* stmdb */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|emit_stm_seq
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|nops
parameter_list|)
block|{
name|int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|store_multiple_sequence
argument_list|(
name|operands
argument_list|,
name|nops
argument_list|,
name|regs
argument_list|,
operator|&
name|base_reg
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?ib\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?da\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?db\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s, {%s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|", %s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}\t%@ phole stm"
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|int
name|multi_register_push
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PARALLEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_PUSH_MULT
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for use in generating RTL.  */
end_comment

begin_function
name|rtx
name|arm_gen_load_multiple
parameter_list|(
name|int
name|base_regno
parameter_list|,
name|int
name|count
parameter_list|,
name|rtx
name|from
parameter_list|,
name|int
name|up
parameter_list|,
name|int
name|write_back
parameter_list|,
name|int
name|unchanging_p
parameter_list|,
name|int
name|in_struct_p
parameter_list|,
name|int
name|scalar_p
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|int
name|sign
init|=
name|up
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* XScale has load-store double instructions, but they have stricter      alignment requirements than load-store multiple, so we can not      use them.       For XScale ldm requires 2 + NREGS cycles to complete and blocks      the pipeline until completion.  	NREGS		CYCLES 	  1		  3 	  2		  4 	  3		  5 	  4		  6       An ldr instruction takes 1-3 cycles, but does not block the      pipeline.  	NREGS		CYCLES 	  1		 1-3 	  2		 2-6 	  3		 3-9 	  4		 4-12       Best case ldr will always win.  However, the more ldr instructions      we issue, the less likely we are to be able to schedule them well.      Using ldr instructions also increases code size.       As a compromise, we use ldr for counts of 1 or 2 regs, and ldm      for counts of 3 or 4 regs.  */
if|if
condition|(
name|arm_tune_xscale
operator|&&
name|count
operator|<=
literal|2
operator|&&
operator|!
name|optimize_size
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|i
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_back
condition|)
name|emit_move_insn
argument_list|(
name|from
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
name|result
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
operator|+
operator|(
name|write_back
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_back
condition|)
block|{
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|from
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|j
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|scalar_p
expr_stmt|;
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|j
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|rtx
name|arm_gen_store_multiple
parameter_list|(
name|int
name|base_regno
parameter_list|,
name|int
name|count
parameter_list|,
name|rtx
name|to
parameter_list|,
name|int
name|up
parameter_list|,
name|int
name|write_back
parameter_list|,
name|int
name|unchanging_p
parameter_list|,
name|int
name|in_struct_p
parameter_list|,
name|int
name|scalar_p
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|int
name|sign
init|=
name|up
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* See arm_gen_load_multiple for discussion of      the pros/cons of ldm/stm usage for XScale.  */
if|if
condition|(
name|arm_tune_xscale
operator|&&
name|count
operator|<=
literal|2
operator|&&
operator|!
name|optimize_size
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|i
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_back
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
name|result
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
operator|+
operator|(
name|write_back
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_back
condition|)
block|{
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|to
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|j
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|scalar_p
expr_stmt|;
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|arm_gen_movstrqi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|HOST_WIDE_INT
name|in_words_to_go
decl_stmt|,
name|out_words_to_go
decl_stmt|,
name|last_bytes
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|rtx
name|st_src
decl_stmt|,
name|st_dst
decl_stmt|,
name|fin_src
decl_stmt|,
name|fin_dst
decl_stmt|;
name|rtx
name|part_bytes_reg
init|=
name|NULL
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|int
name|dst_unchanging_p
decl_stmt|,
name|dst_in_struct_p
decl_stmt|,
name|src_unchanging_p
decl_stmt|,
name|src_in_struct_p
decl_stmt|;
name|int
name|dst_scalar_p
decl_stmt|,
name|src_scalar_p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|>
literal|64
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|&
literal|3
condition|)
return|return
literal|0
return|;
name|st_dst
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st_src
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dst_unchanging_p
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dst_in_struct_p
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dst_scalar_p
operator|=
name|MEM_SCALAR_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|src_unchanging_p
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src_in_struct_p
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src_scalar_p
operator|=
name|MEM_SCALAR_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fin_dst
operator|=
name|dst
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|st_dst
argument_list|)
expr_stmt|;
name|fin_src
operator|=
name|src
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|st_src
argument_list|)
expr_stmt|;
name|in_words_to_go
operator|=
name|ARM_NUM_INTS
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|out_words_to_go
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|/
literal|4
expr_stmt|;
name|last_bytes
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|out_words_to_go
operator|!=
name|in_words_to_go
operator|&&
operator|(
operator|(
name|in_words_to_go
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|part_bytes_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
operator|(
name|in_words_to_go
operator|-
literal|1
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|in_words_to_go
operator|>=
literal|2
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|in_words_to_go
operator|>
literal|4
condition|)
name|emit_insn
argument_list|(
name|arm_gen_load_multiple
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
name|src
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|src_unchanging_p
argument_list|,
name|src_in_struct_p
argument_list|,
name|src_scalar_p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|arm_gen_load_multiple
argument_list|(
literal|0
argument_list|,
name|in_words_to_go
argument_list|,
name|src
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|src_unchanging_p
argument_list|,
name|src_in_struct_p
argument_list|,
name|src_scalar_p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_words_to_go
condition|)
block|{
if|if
condition|(
name|out_words_to_go
operator|>
literal|4
condition|)
name|emit_insn
argument_list|(
name|arm_gen_store_multiple
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
name|dst
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|dst_unchanging_p
argument_list|,
name|dst_in_struct_p
argument_list|,
name|dst_scalar_p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|out_words_to_go
operator|!=
literal|1
condition|)
name|emit_insn
argument_list|(
name|arm_gen_store_multiple
argument_list|(
literal|0
argument_list|,
name|out_words_to_go
argument_list|,
name|dst
argument_list|,
name|TRUE
argument_list|,
operator|(
name|last_bytes
operator|==
literal|0
condition|?
name|FALSE
else|:
name|TRUE
operator|)
argument_list|,
name|dst_unchanging_p
argument_list|,
name|dst_in_struct_p
argument_list|,
name|dst_scalar_p
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_bytes
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|in_words_to_go
operator|-=
name|in_words_to_go
operator|<
literal|4
condition|?
name|in_words_to_go
else|:
literal|4
expr_stmt|;
name|out_words_to_go
operator|-=
name|out_words_to_go
operator|<
literal|4
condition|?
name|out_words_to_go
else|:
literal|4
expr_stmt|;
block|}
comment|/* OUT_WORDS_TO_GO will be zero here if there are byte stores to do.  */
if|if
condition|(
name|out_words_to_go
condition|)
block|{
name|rtx
name|sreg
decl_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|sreg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|fin_src
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|src
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|fin_dst
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|dst
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|in_words_to_go
operator|--
expr_stmt|;
if|if
condition|(
name|in_words_to_go
condition|)
comment|/* Sanity check */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|in_words_to_go
condition|)
block|{
if|if
condition|(
name|in_words_to_go
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_scalar_p
expr_stmt|;
name|part_bytes_reg
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_bytes
operator|&&
name|part_bytes_reg
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|last_bytes
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
comment|/* The bytes we want are in the top end of the word.  */
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|8
operator|*
operator|(
literal|4
operator|-
name|last_bytes
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
name|last_bytes
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|dst
argument_list|,
name|last_bytes
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|part_bytes_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|last_bytes
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_bytes
operator|>
literal|1
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
name|part_bytes_reg
argument_list|)
argument_list|)
expr_stmt|;
name|last_bytes
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|last_bytes
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_bytes
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|part_bytes_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a memory reference for a half word, such that it will be loaded    into the top 16 bits of the word.  We can assume that the address is    known to be alignable and of the form reg, or plus (reg, const).  */
end_comment

begin_function
name|rtx
name|arm_gen_rotated_half_load
parameter_list|(
name|rtx
name|memref
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we aren't allowed to generate unaligned addresses, then fail.  */
if|if
condition|(
name|TARGET_MMU_TRAPS
operator|&&
operator|(
operator|(
name|BYTES_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
operator|^
operator|(
operator|(
name|offset
operator|&
literal|2
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
name|base
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|&
operator|~
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BYTES_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
operator|^
operator|(
operator|(
name|offset
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
condition|)
return|return
name|base
return|;
return|return
name|gen_rtx_ROTATE
argument_list|(
name|SImode
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Select a dominance comparison mode if possible for a test of the general    form (OP (COND_OR (X) (Y)) (const_int 0)).  We support three forms.    COND_OR == DOM_CC_X_AND_Y => (X&& Y)     COND_OR == DOM_CC_NX_OR_Y => ((! X) || Y)    COND_OR == DOM_CC_X_OR_Y => (X || Y)     In all cases OP will be either EQ or NE, but we don't need to know which    here.  If we are unable to support a dominance comparison we return     CC mode.  This will then fail to match for the RTL expressions that    generate this call.  */
end_comment

begin_function
name|enum
name|machine_mode
name|arm_select_dominance_cc_mode
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|HOST_WIDE_INT
name|cond_or
parameter_list|)
block|{
name|enum
name|rtx_code
name|cond1
decl_stmt|,
name|cond2
decl_stmt|;
name|int
name|swapped
init|=
literal|0
decl_stmt|;
comment|/* Currently we will probably get the wrong result if the individual      comparisons are not simple.  This also ensures that it is safe to      reverse a comparison if necessary.  */
if|if
condition|(
operator|(
name|arm_select_cc_mode
argument_list|(
name|cond1
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CCmode
operator|)
operator|||
operator|(
name|arm_select_cc_mode
argument_list|(
name|cond2
operator|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CCmode
operator|)
condition|)
return|return
name|CCmode
return|;
comment|/* The if_then_else variant of this tests the second condition if the      first passes, but is true if the first fails.  Reverse the first      condition to get a true "inclusive-or" expression.  */
if|if
condition|(
name|cond_or
operator|==
name|DOM_CC_NX_OR_Y
condition|)
name|cond1
operator|=
name|reverse_condition
argument_list|(
name|cond1
argument_list|)
expr_stmt|;
comment|/* If the comparisons are not equal, and one doesn't dominate the other,      then we can't do this.  */
if|if
condition|(
name|cond1
operator|!=
name|cond2
operator|&&
operator|!
name|comparison_dominates_p
argument_list|(
name|cond1
argument_list|,
name|cond2
argument_list|)
operator|&&
operator|(
name|swapped
operator|=
literal|1
operator|,
operator|!
name|comparison_dominates_p
argument_list|(
name|cond2
argument_list|,
name|cond1
argument_list|)
operator|)
condition|)
return|return
name|CCmode
return|;
if|if
condition|(
name|swapped
condition|)
block|{
name|enum
name|rtx_code
name|temp
init|=
name|cond1
decl_stmt|;
name|cond1
operator|=
name|cond2
expr_stmt|;
name|cond2
operator|=
name|temp
expr_stmt|;
block|}
switch|switch
condition|(
name|cond1
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|cond2
operator|==
name|EQ
operator|||
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DEQmode
return|;
switch|switch
condition|(
name|cond2
condition|)
block|{
case|case
name|LE
case|:
return|return
name|CC_DLEmode
return|;
case|case
name|LEU
case|:
return|return
name|CC_DLEUmode
return|;
case|case
name|GE
case|:
return|return
name|CC_DGEmode
return|;
case|case
name|GEU
case|:
return|return
name|CC_DGEUmode
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|cond2
operator|==
name|LT
operator|||
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DLTmode
return|;
if|if
condition|(
name|cond2
operator|==
name|LE
condition|)
return|return
name|CC_DLEmode
return|;
if|if
condition|(
name|cond2
operator|==
name|NE
condition|)
return|return
name|CC_DNEmode
return|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|cond2
operator|==
name|GT
operator|||
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DGTmode
return|;
if|if
condition|(
name|cond2
operator|==
name|GE
condition|)
return|return
name|CC_DGEmode
return|;
if|if
condition|(
name|cond2
operator|==
name|NE
condition|)
return|return
name|CC_DNEmode
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|cond2
operator|==
name|LTU
operator|||
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DLTUmode
return|;
if|if
condition|(
name|cond2
operator|==
name|LEU
condition|)
return|return
name|CC_DLEUmode
return|;
if|if
condition|(
name|cond2
operator|==
name|NE
condition|)
return|return
name|CC_DNEmode
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|cond2
operator|==
name|GTU
operator|||
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DGTUmode
return|;
if|if
condition|(
name|cond2
operator|==
name|GEU
condition|)
return|return
name|CC_DGEUmode
return|;
if|if
condition|(
name|cond2
operator|==
name|NE
condition|)
return|return
name|CC_DNEmode
return|;
break|break;
comment|/* The remaining cases only occur when both comparisons are the        same.  */
case|case
name|NE
case|:
return|return
name|CC_DNEmode
return|;
case|case
name|LE
case|:
return|return
name|CC_DLEmode
return|;
case|case
name|GE
case|:
return|return
name|CC_DGEmode
return|;
case|case
name|LEU
case|:
return|return
name|CC_DLEUmode
return|;
case|case
name|GEU
case|:
return|return
name|CC_DGEUmode
return|;
default|default:
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|machine_mode
name|arm_select_cc_mode
parameter_list|(
name|enum
name|rtx_code
name|op
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
comment|/* All floating point compares return CCFP if it is an equality      comparison, and CCFPE otherwise.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|CCFPmode
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|TARGET_CIRRUS
condition|)
return|return
name|CCFPmode
return|;
return|return
name|CCFPEmode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* A compare with a shifted operand.  Because of canonicalization, the      comparison will have to be swapped when we emit the assembler.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATERT
operator|)
condition|)
return|return
name|CC_SWPmode
return|;
comment|/* This is a special case that is used by combine to allow a       comparison of a shifted byte load to be split into a zero-extend      followed by a comparison of the shifted integer (only valid for      equalities and unsigned inequalities).  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|24
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|QImode
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|||
name|op
operator|==
name|GEU
operator|||
name|op
operator|==
name|GTU
operator|||
name|op
operator|==
name|LTU
operator|||
name|op
operator|==
name|LEU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|CC_Zmode
return|;
comment|/* A construct for a conditional compare, if the false arm contains      0, then both conditions must be true, otherwise either condition      must be true.  Not all conditions are possible, so CCmode is      returned if it can't be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|==
name|const1_rtx
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|arm_select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Alternate canonicalizations of the above.  These are somewhat cleaner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|arm_select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DOM_CC_X_AND_Y
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IOR
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|arm_select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DOM_CC_X_OR_Y
argument_list|)
return|;
comment|/* An operation (on Thumb) where we want to test for a single bit.      This is done by shifting that bit up into the top bit of a      scratch register; we can then branch on the sign bit.  */
if|if
condition|(
name|TARGET_THUMB
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
condition|)
return|return
name|CC_Nmode
return|;
comment|/* An operation that sets the condition codes as a side-effect, the      V flag is not set correctly, so we can only use comparisons where      this doesn't matter.  (For LT and GE we can use "mi" and "pl"      instead.)  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
name|y
operator|==
name|const0_rtx
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|||
name|op
operator|==
name|LT
operator|||
name|op
operator|==
name|GE
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|XOR
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NOT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATERT
operator|||
operator|(
name|TARGET_ARM
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
operator|)
condition|)
return|return
name|CC_NOOVmode
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|)
condition|)
return|return
name|CC_Zmode
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
operator|(
name|op
operator|==
name|LTU
operator|||
name|op
operator|==
name|GEU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|y
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|y
argument_list|)
operator|)
condition|)
return|return
name|CC_Cmode
return|;
return|return
name|CCmode
return|;
block|}
end_function

begin_comment
comment|/* X and Y are two things to compare using CODE.  Emit the compare insn and    return the rtx for register 0 in the proper mode.  FP means this is a    floating point compare: I don't think that it is needed on the arm.  */
end_comment

begin_function
name|rtx
name|arm_gen_compare_reg
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|CC_REGNUM
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_comment
comment|/* Generate a sequence of insns that will generate the correct return    address mask depending on the physical architecture that the program    is running on.  */
end_comment

begin_function
name|rtx
name|arm_gen_return_addr_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_return_addr_mask
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_function
name|void
name|arm_reload_in_hi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|ref
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|scratch
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_BYTE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* We have a pseudo which has been spilt onto the stack; there 	 are two cases here: the first where there is a simple 	 stack-slot replacement and a second where the stack-slot is 	 out of range, or is used as a subreg.  */
if|if
condition|(
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
condition|)
block|{
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The slot is out of range, or was dressed up in a SUBREG.  */
name|base
operator|=
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
block|}
else|else
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the case where the address is too complex to be offset by 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|base_plus
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The addend must be CONST_INT, or we would have dealt with it above.  */
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rework the address into a legal sequence of insns.  */
comment|/* Valid range for lo is -4095 -> 4095 */
name|lo
operator|=
operator|(
name|offset
operator|>=
literal|0
condition|?
operator|(
name|offset
operator|&
literal|0xfff
operator|)
else|:
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|&
literal|0xfff
operator|)
operator|)
expr_stmt|;
comment|/* Corner case, if lo is the max offset then we would be out of range 	 once we have added the additional 1 below, so bump the msb into the 	 pre-loading insn(s).  */
if|if
condition|(
name|lo
operator|==
literal|4095
condition|)
name|lo
operator|&=
literal|0x7ff
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
operator|(
operator|(
name|offset
operator|-
name|lo
operator|)
operator|&
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|^
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
expr_stmt|;
if|if
condition|(
name|hi
operator|+
name|lo
operator|!=
name|offset
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Get the base address; addsi3 knows how to handle constants 	     that require more than one insn.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_plus
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
name|offset
operator|=
name|lo
expr_stmt|;
block|}
block|}
comment|/* Operands[2] may overlap operands[0] (though it won't overlap      operands[1]), that's why we asked for a DImode reg -- so we can      use the bit that does not overlap.  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqisi2
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqisi2
argument_list|(
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle storing a half-word to memory during reload by synthesizing as two    byte stores.  Take care not to clobber the input values until after we    have moved them somewhere safe.  This code assumes that if the DImode    scratch in operands[2] overlaps either the input value or output address    in some way, then that value must die in this insn (we absolutely need    two scratch registers for some corner cases).  */
end_comment

begin_function
name|void
name|arm_reload_out_hi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|ref
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|outval
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|scratch
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_BYTE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* We have a pseudo which has been spilt onto the stack; there 	 are two cases here: the first where there is a simple 	 stack-slot replacement and a second where the stack-slot is 	 out of range, or is used as a subreg.  */
if|if
condition|(
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
condition|)
block|{
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The slot is out of range, or was dressed up in a SUBREG.  */
name|base
operator|=
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
block|}
else|else
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the case where the address is too complex to be offset by 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Be careful not to destroy OUTVAL.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|base_plus
argument_list|,
name|outval
argument_list|)
condition|)
block|{
comment|/* Updating base_plus might destroy outval, see if we can 	     swap the scratch and base_plus.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|scratch
argument_list|,
name|outval
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|scratch
decl_stmt|;
name|scratch
operator|=
name|base_plus
expr_stmt|;
name|base_plus
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|scratch_hi
init|=
name|gen_rtx_REG
argument_list|(
name|HImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Be conservative and copy OUTVAL into the scratch now, 		 this should only be necessary if outval is a subreg 		 of something larger than a word.  */
comment|/* XXX Might this clobber base?  I can't see how it can, 		 since scratch is known to overlap with OUTVAL, and 		 must be wider than a word.  */
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|scratch_hi
argument_list|,
name|outval
argument_list|)
argument_list|)
expr_stmt|;
name|outval
operator|=
name|scratch_hi
expr_stmt|;
block|}
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|base_plus
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The addend must be CONST_INT, or we would have dealt with it above.  */
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rework the address into a legal sequence of insns.  */
comment|/* Valid range for lo is -4095 -> 4095 */
name|lo
operator|=
operator|(
name|offset
operator|>=
literal|0
condition|?
operator|(
name|offset
operator|&
literal|0xfff
operator|)
else|:
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|&
literal|0xfff
operator|)
operator|)
expr_stmt|;
comment|/* Corner case, if lo is the max offset then we would be out of range 	 once we have added the additional 1 below, so bump the msb into the 	 pre-loading insn(s).  */
if|if
condition|(
name|lo
operator|==
literal|4095
condition|)
name|lo
operator|&=
literal|0x7ff
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
operator|(
operator|(
name|offset
operator|-
name|lo
operator|)
operator|&
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|^
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
expr_stmt|;
if|if
condition|(
name|hi
operator|+
name|lo
operator|!=
name|offset
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Be careful not to destroy OUTVAL.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|base_plus
argument_list|,
name|outval
argument_list|)
condition|)
block|{
comment|/* Updating base_plus might destroy outval, see if we 		 can swap the scratch and base_plus.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|scratch
argument_list|,
name|outval
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|scratch
decl_stmt|;
name|scratch
operator|=
name|base_plus
expr_stmt|;
name|base_plus
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|scratch_hi
init|=
name|gen_rtx_REG
argument_list|(
name|HImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Be conservative and copy outval into scratch now, 		     this should only be necessary if outval is a 		     subreg of something larger than a word.  */
comment|/* XXX Might this clobber base?  I can't see how it 		     can, since scratch is known to overlap with 		     outval.  */
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|scratch_hi
argument_list|,
name|outval
argument_list|)
argument_list|)
expr_stmt|;
name|outval
operator|=
name|scratch_hi
expr_stmt|;
block|}
block|}
comment|/* Get the base address; addsi3 knows how to handle constants 	     that require more than one insn.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_plus
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
name|offset
operator|=
name|lo
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|outval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|outval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|scratch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|outval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|outval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|scratch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a symbolic form of X to the debug file, F.  */
end_comment

begin_function
specifier|static
name|void
name|arm_print_value
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_DOUBLE
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"<0x%lx,0x%lx>"
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_VECTOR
case|:
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CONST_STRING
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\"%s\""
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SYMBOL_REF
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"`%s'"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"L%d"
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST
case|:
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS
case|:
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|PC
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"pc"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"????"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for manipulation of the constant pool.  */
end_comment

begin_comment
comment|/* Arm instructions cannot load a large constant directly into a    register; they have to come from a pc relative load.  The constant    must therefore be placed in the addressable range of the pc    relative load.  Depending on the precise pc relative load    instruction the range is somewhere between 256 bytes and 4k.  This    means that we often have to dump a constant inside a function, and    generate code to branch around it.     It is important to minimize this, since the branches will slow    things down and make the code larger.     Normally we can hide the table after an existing unconditional    branch so that there is no interruption of the flow, but in the    worst case the code looks like this:  	ldr	rn, L1 	... 	b	L2 	align 	L1:	.long value 	L2: 	...  	ldr	rn, L3 	... 	b	L4 	align 	L3:	.long value 	L4: 	...     We fix this by performing a scan after scheduling, which notices    which instructions need to have their operands fetched from the    constant table and builds the table.     The algorithm starts by building a table of all the constants that    need fixing up and all the natural barriers in the function (places    where a constant table can be dropped without breaking the flow).    For each fixup we note how far the pc-relative replacement will be    able to reach and the offset of the instruction into the function.     Having built the table we then group the fixes together to form    tables that are as large as possible (subject to addressing    constraints) and emit each table of constants after the last    barrier that is within range of all the instructions in the group.    If a group does not contain a barrier, then we forcibly create one    by inserting a jump instruction into the flow.  Once the table has    been inserted, the insns are then modified to reference the    relevant entry in the pool.     Possible enhancements to the algorithm (not implemented) are:     1) For some processors and object formats, there may be benefit in    aligning the pools to the start of cache lines; this alignment    would need to be taken into account when calculating addressability    of a pool.  */
end_comment

begin_comment
comment|/* These typedefs are located at the start of this file, so that    they can be used in the prototypes there.  This comment is to    remind readers of that fact so that the following structures    can be understood more easily.       typedef struct minipool_node    Mnode;      typedef struct minipool_fixup   Mfix;  */
end_comment

begin_struct
struct|struct
name|minipool_node
block|{
comment|/* Doubly linked chain of entries.  */
name|Mnode
modifier|*
name|next
decl_stmt|;
name|Mnode
modifier|*
name|prev
decl_stmt|;
comment|/* The maximum offset into the code that this entry can be placed.  While      pushing fixes for forward references, all entries are sorted in order      of increasing max_address.  */
name|HOST_WIDE_INT
name|max_address
decl_stmt|;
comment|/* Similarly for an entry inserted for a backwards ref.  */
name|HOST_WIDE_INT
name|min_address
decl_stmt|;
comment|/* The number of fixes referencing this entry.  This can become zero      if we "unpush" an entry.  In this case we ignore the entry when we      come to emit the code.  */
name|int
name|refcount
decl_stmt|;
comment|/* The offset from the start of the minipool.  */
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* The value in table.  */
name|rtx
name|value
decl_stmt|;
comment|/* The mode of value.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The size of the value.  With iWMMXt enabled      sizes> 4 also imply an alignment of 8-bytes.  */
name|int
name|fix_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|minipool_fixup
block|{
name|Mfix
modifier|*
name|next
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|fix_size
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|Mnode
modifier|*
name|minipool
decl_stmt|;
name|HOST_WIDE_INT
name|forwards
decl_stmt|;
name|HOST_WIDE_INT
name|backwards
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Fixes less than a word need padding out to a word boundary.  */
end_comment

begin_define
define|#
directive|define
name|MINIPOOL_FIX_SIZE
parameter_list|(
name|mode
parameter_list|)
define|\
value|(GET_MODE_SIZE ((mode))>= 4 ? GET_MODE_SIZE ((mode)) : 4)
end_define

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|minipool_vector_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|minipool_vector_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|minipool_vector_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The linked list of all minipool fixes required for this function.  */
end_comment

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_fix_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_fix_tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The fix entry for the current minipool, once it has been placed.  */
end_comment

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_barrier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determines if INSN is the start of a jump table.  Returns the end    of the TABLE or NULL_RTX.  */
end_comment

begin_function
specifier|static
name|rtx
name|is_jump_table
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|table
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|table
operator|=
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|==
name|next_real_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|table
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|table
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
return|return
name|table
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|JUMP_TABLES_IN_TEXT_SECTION
end_ifndef

begin_define
define|#
directive|define
name|JUMP_TABLES_IN_TEXT_SECTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|HOST_WIDE_INT
name|get_jump_table_size
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* ADDR_VECs only take room if read-only data does into the text      section.  */
if|if
condition|(
name|JUMP_TABLES_IN_TEXT_SECTION
if|#
directive|if
operator|!
name|defined
argument_list|(
name|READONLY_DATA_SECTION
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|READONLY_DATA_SECTION_ASM_OP
argument_list|)
operator|||
literal|1
endif|#
directive|endif
condition|)
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|elt
init|=
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|?
literal|1
else|:
literal|0
decl_stmt|;
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|elt
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move a minipool fix MP from its current location to before MAX_MP.    If MAX_MP is NULL, then MP doesn't need moving, but the addressing    constraints may need updating.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_forward_ref
parameter_list|(
name|Mnode
modifier|*
name|mp
parameter_list|,
name|Mnode
modifier|*
name|max_mp
parameter_list|,
name|HOST_WIDE_INT
name|max_address
parameter_list|)
block|{
comment|/* This should never be true and the code below assumes these are      different.  */
if|if
condition|(
name|mp
operator|==
name|max_mp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_mp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|max_address
operator|<
name|mp
operator|->
name|max_address
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_address
operator|>
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
comment|/* Unlink MP from its current position.  Since max_mp is non-null,        mp->prev must be non-null.  */
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
comment|/* Re-insert it before MAX_MP.  */
name|mp
operator|->
name|next
operator|=
name|max_mp
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|max_mp
operator|->
name|prev
expr_stmt|;
name|max_mp
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|max_mp
operator|=
name|mp
expr_stmt|;
comment|/* Scan over the preceding entries and adjust their addresses as      required.  */
while|while
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|>
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
condition|)
block|{
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|=
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|max_mp
return|;
block|}
end_function

begin_comment
comment|/* Add a constant to the minipool for a forward reference.  Returns the    node added or NULL if the constant will not fit in this pool.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|add_minipool_forward_ref
parameter_list|(
name|Mfix
modifier|*
name|fix
parameter_list|)
block|{
comment|/* If set, max_mp is the first pool_entry that has a lower      constraint than the one we are trying to add.  */
name|Mnode
modifier|*
name|max_mp
init|=
name|NULL
decl_stmt|;
name|HOST_WIDE_INT
name|max_address
init|=
name|fix
operator|->
name|address
operator|+
name|fix
operator|->
name|forwards
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
comment|/* If this fix's address is greater than the address of the first      entry, then we can't put the fix in this pool.  We subtract the      size of the current fix to ensure that if the table is fully      packed we still have enough room to insert this value by suffling      the other fixes forwards.  */
if|if
condition|(
name|minipool_vector_head
operator|&&
name|fix
operator|->
name|address
operator|>=
name|minipool_vector_head
operator|->
name|max_address
operator|-
name|fix
operator|->
name|fix_size
condition|)
return|return
name|NULL
return|;
comment|/* Scan the pool to see if a constant with the same value has      already been added.  While we are doing this, also note the      location where we must insert the constant if it doesn't already      exist.  */
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|&&
name|fix
operator|->
name|mode
operator|==
name|mp
operator|->
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|fix
operator|->
name|value
argument_list|,
name|mp
operator|->
name|value
argument_list|)
condition|)
block|{
comment|/* More than one fix references this entry.  */
name|mp
operator|->
name|refcount
operator|++
expr_stmt|;
return|return
name|move_minipool_fix_forward_ref
argument_list|(
name|mp
argument_list|,
name|max_mp
argument_list|,
name|max_address
argument_list|)
return|;
block|}
comment|/* Note the insertion point if necessary.  */
if|if
condition|(
name|max_mp
operator|==
name|NULL
operator|&&
name|mp
operator|->
name|max_address
operator|>
name|max_address
condition|)
name|max_mp
operator|=
name|mp
expr_stmt|;
comment|/* If we are inserting an 8-bytes aligned quantity and 	 we have not already found an insertion point, then 	 make sure that all such 8-byte aligned quantities are 	 placed at the start of the pool.  */
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
name|max_mp
operator|==
name|NULL
operator|&&
name|fix
operator|->
name|fix_size
operator|==
literal|8
operator|&&
name|mp
operator|->
name|fix_size
operator|!=
literal|8
condition|)
block|{
name|max_mp
operator|=
name|mp
expr_stmt|;
name|max_address
operator|=
name|mp
operator|->
name|max_address
expr_stmt|;
block|}
block|}
comment|/* The value is not currently in the minipool, so we need to create      a new entry for it.  If MAX_MP is NULL, the entry will be put on      the end of the list since the placement is less constrained than      any existing entry.  Otherwise, we insert the new fix before      MAX_MP and, if necessary, adjust the constraints on the other      entries.  */
name|mp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|fix_size
operator|=
name|fix
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|->
name|mode
operator|=
name|fix
operator|->
name|mode
expr_stmt|;
name|mp
operator|->
name|value
operator|=
name|fix
operator|->
name|value
expr_stmt|;
name|mp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
comment|/* Not yet required for a backwards ref.  */
name|mp
operator|->
name|min_address
operator|=
operator|-
literal|65536
expr_stmt|;
if|if
condition|(
name|max_mp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|minipool_vector_tail
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
name|minipool_vector_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_address
operator|>
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|max_mp
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|max_mp
operator|->
name|prev
expr_stmt|;
name|max_mp
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|max_mp
operator|=
name|mp
expr_stmt|;
comment|/* Scan over the preceding entries and adjust their addresses as      required.  */
while|while
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|>
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
condition|)
block|{
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|=
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|max_mp
return|;
block|}
end_function

begin_function
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_backward_ref
parameter_list|(
name|Mnode
modifier|*
name|mp
parameter_list|,
name|Mnode
modifier|*
name|min_mp
parameter_list|,
name|HOST_WIDE_INT
name|min_address
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* This should never be true, and the code below assumes these are      different.  */
if|if
condition|(
name|mp
operator|==
name|min_mp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|min_mp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|min_address
operator|>
name|mp
operator|->
name|min_address
condition|)
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
block|}
else|else
block|{
comment|/* We will adjust this below if it is too loose.  */
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
comment|/* Unlink MP from its current position.  Since min_mp is non-null, 	 mp->next must be non-null.  */
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
operator|->
name|next
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
operator|->
name|next
expr_stmt|;
comment|/* Reinsert it after MIN_MP.  */
name|mp
operator|->
name|prev
operator|=
name|min_mp
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|min_mp
operator|->
name|next
expr_stmt|;
name|min_mp
operator|->
name|next
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
name|min_mp
operator|=
name|mp
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
name|mp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
name|offset
operator|+=
name|mp
operator|->
name|fix_size
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|&&
name|mp
operator|->
name|next
operator|->
name|min_address
operator|<
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|next
operator|->
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
block|}
return|return
name|min_mp
return|;
block|}
end_function

begin_comment
comment|/* Add a constant to the minipool for a backward reference.  Returns the    node added or NULL if the constant will not fit in this pool.       Note that the code for insertion for a backwards reference can be    somewhat confusing because the calculated offsets for each fix do    not take into account the size of the pool (which is still under    construction.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|add_minipool_backward_ref
parameter_list|(
name|Mfix
modifier|*
name|fix
parameter_list|)
block|{
comment|/* If set, min_mp is the last pool_entry that has a lower constraint      than the one we are trying to add.  */
name|Mnode
modifier|*
name|min_mp
init|=
name|NULL
decl_stmt|;
comment|/* This can be negative, since it is only a constraint.  */
name|HOST_WIDE_INT
name|min_address
init|=
name|fix
operator|->
name|address
operator|-
name|fix
operator|->
name|backwards
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
comment|/* If we can't reach the current pool from this insn, or if we can't      insert this entry at the end of the pool without pushing other      fixes out of range, then we don't try.  This ensures that we      can't fail later on.  */
if|if
condition|(
name|min_address
operator|>=
name|minipool_barrier
operator|->
name|address
operator|||
operator|(
name|minipool_vector_tail
operator|->
name|min_address
operator|+
name|fix
operator|->
name|fix_size
operator|>=
name|minipool_barrier
operator|->
name|address
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Scan the pool to see if a constant with the same value has      already been added.  While we are doing this, also note the      location where we must insert the constant if it doesn't already      exist.  */
for|for
control|(
name|mp
operator|=
name|minipool_vector_tail
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|&&
name|fix
operator|->
name|mode
operator|==
name|mp
operator|->
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|fix
operator|->
name|value
argument_list|,
name|mp
operator|->
name|value
argument_list|)
comment|/* Check that there is enough slack to move this entry to the 	     end of the table (this is conservative).  */
operator|&&
operator|(
name|mp
operator|->
name|max_address
operator|>
operator|(
name|minipool_barrier
operator|->
name|address
operator|+
name|minipool_vector_tail
operator|->
name|offset
operator|+
name|minipool_vector_tail
operator|->
name|fix_size
operator|)
operator|)
condition|)
block|{
name|mp
operator|->
name|refcount
operator|++
expr_stmt|;
return|return
name|move_minipool_fix_backward_ref
argument_list|(
name|mp
argument_list|,
name|min_mp
argument_list|,
name|min_address
argument_list|)
return|;
block|}
if|if
condition|(
name|min_mp
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|min_address
operator|+=
name|fix
operator|->
name|fix_size
expr_stmt|;
else|else
block|{
comment|/* Note the insertion point if necessary.  */
if|if
condition|(
name|mp
operator|->
name|min_address
operator|<
name|min_address
condition|)
block|{
comment|/* For now, we do not allow the insertion of 8-byte alignment 		 requiring nodes anywhere but at the start of the pool.  */
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
name|fix
operator|->
name|fix_size
operator|==
literal|8
operator|&&
name|mp
operator|->
name|fix_size
operator|!=
literal|8
condition|)
return|return
name|NULL
return|;
else|else
name|min_mp
operator|=
name|mp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|max_address
operator|<
name|minipool_barrier
operator|->
name|address
operator|+
name|mp
operator|->
name|offset
operator|+
name|fix
operator|->
name|fix_size
condition|)
block|{
comment|/* Inserting before this entry would push the fix beyond 		 its maximum address (which can happen if we have 		 re-located a forwards fix); force the new fix to come 		 after it.  */
name|min_mp
operator|=
name|mp
expr_stmt|;
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|fix
operator|->
name|fix_size
expr_stmt|;
block|}
comment|/* If we are inserting an 8-bytes aligned quantity and 	     we have not already found an insertion point, then 	     make sure that all such 8-byte aligned quantities are 	     placed at the start of the pool.  */
elseif|else
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
name|min_mp
operator|==
name|NULL
operator|&&
name|fix
operator|->
name|fix_size
operator|==
literal|8
operator|&&
name|mp
operator|->
name|fix_size
operator|<
literal|8
condition|)
block|{
name|min_mp
operator|=
name|mp
expr_stmt|;
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|fix
operator|->
name|fix_size
expr_stmt|;
block|}
block|}
block|}
comment|/* We need to create a new entry.  */
name|mp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|fix_size
operator|=
name|fix
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|->
name|mode
operator|=
name|fix
operator|->
name|mode
expr_stmt|;
name|mp
operator|->
name|value
operator|=
name|fix
operator|->
name|value
expr_stmt|;
name|mp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|max_address
operator|=
name|minipool_barrier
operator|->
name|address
operator|+
literal|65536
expr_stmt|;
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
if|if
condition|(
name|min_mp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|minipool_vector_head
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
name|minipool_vector_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|next
operator|=
name|min_mp
operator|->
name|next
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|min_mp
expr_stmt|;
name|min_mp
operator|->
name|next
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|min_mp
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
condition|)
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
else|else
name|mp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Scan over the following entries and adjust their offsets.  */
while|while
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|next
operator|->
name|min_address
operator|<
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|next
operator|->
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
condition|)
name|mp
operator|->
name|next
operator|->
name|offset
operator|=
name|mp
operator|->
name|offset
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|next
operator|->
name|offset
operator|=
name|mp
operator|->
name|offset
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|next
expr_stmt|;
block|}
return|return
name|min_mp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|assign_minipool_offsets
parameter_list|(
name|Mfix
modifier|*
name|barrier
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
name|minipool_barrier
operator|=
name|barrier
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
name|mp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
name|offset
operator|+=
name|mp
operator|->
name|fix_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the literal table */
end_comment

begin_function
specifier|static
name|void
name|dump_minipool
parameter_list|(
name|rtx
name|scan
parameter_list|)
block|{
name|Mnode
modifier|*
name|mp
decl_stmt|;
name|Mnode
modifier|*
name|nmp
decl_stmt|;
name|int
name|align64
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
operator|&&
name|mp
operator|->
name|fix_size
operator|==
literal|8
condition|)
block|{
name|align64
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Emitting minipool after insn %u; address %ld; align %d (bytes)\n"
argument_list|,
name|INSN_UID
argument_list|(
name|scan
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|minipool_barrier
operator|->
name|address
argument_list|,
name|align64
condition|?
literal|8
else|:
literal|4
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_label_after
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|align64
condition|?
name|gen_align_8
argument_list|()
else|:
name|gen_align_4
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_label_after
argument_list|(
name|minipool_vector_label
argument_list|,
name|scan
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|nmp
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";;  Offset %u, min %ld, max %ld "
argument_list|,
operator|(
name|unsigned
operator|)
name|mp
operator|->
name|offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mp
operator|->
name|min_address
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mp
operator|->
name|max_address
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|rtl_dump_file
argument_list|,
name|mp
operator|->
name|value
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mp
operator|->
name|fix_size
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_consttable_1
case|case
literal|1
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_1
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_2
case|case
literal|2
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_2
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_4
case|case
literal|4
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_4
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_8
case|case
literal|8
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_8
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|nmp
operator|=
name|mp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|minipool_vector_head
operator|=
name|minipool_vector_tail
operator|=
name|NULL
expr_stmt|;
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_end
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_barrier_after
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the cost of forcibly inserting a barrier after INSN.  */
end_comment

begin_function
specifier|static
name|int
name|arm_barrier_cost
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* Basing the location of the pool on the loop depth is preferable,      but at the moment, the basic block information seems to be      corrupt by this stage of the compilation.  */
name|int
name|base_cost
init|=
literal|50
decl_stmt|;
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|base_cost
operator|-=
literal|20
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* It will always be better to place the table before the label, rather 	 than after it.  */
return|return
literal|50
return|;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
return|return
name|base_cost
return|;
case|case
name|JUMP_INSN
case|:
return|return
name|base_cost
operator|-
literal|10
return|;
default|default:
return|return
name|base_cost
operator|+
literal|10
return|;
block|}
block|}
end_function

begin_comment
comment|/* Find the best place in the insn stream in the range    (FIX->address,MAX_ADDRESS) to forcibly insert a minipool barrier.    Create the barrier by inserting a jump and add a new fix entry for    it.  */
end_comment

begin_function
specifier|static
name|Mfix
modifier|*
name|create_fix_barrier
parameter_list|(
name|Mfix
modifier|*
name|fix
parameter_list|,
name|HOST_WIDE_INT
name|max_address
parameter_list|)
block|{
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|rtx
name|from
init|=
name|fix
operator|->
name|insn
decl_stmt|;
name|rtx
name|selected
init|=
name|from
decl_stmt|;
name|int
name|selected_cost
decl_stmt|;
name|HOST_WIDE_INT
name|selected_address
decl_stmt|;
name|Mfix
modifier|*
name|new_fix
decl_stmt|;
name|HOST_WIDE_INT
name|max_count
init|=
name|max_address
operator|-
name|fix
operator|->
name|address
decl_stmt|;
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|selected_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
expr_stmt|;
while|while
condition|(
name|from
operator|&&
name|count
operator|<
name|max_count
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|int
name|new_cost
decl_stmt|;
comment|/* This code shouldn't have been called if there was a natural barrier 	 within range.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Count the length of this insn.  */
name|count
operator|+=
name|get_attr_length
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* If there is a jump table, add its length.  */
name|tmp
operator|=
name|is_jump_table
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|count
operator|+=
name|get_jump_table_size
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Jump tables aren't in a basic block, so base the cost on 	     the dispatch insn.  If we select this location, we will 	     still put the pool after the table.  */
name|new_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|max_count
operator|&&
name|new_cost
operator|<=
name|selected_cost
condition|)
block|{
name|selected
operator|=
name|tmp
expr_stmt|;
name|selected_cost
operator|=
name|new_cost
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
operator|+
name|count
expr_stmt|;
block|}
comment|/* Continue after the dispatch table.  */
name|from
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|max_count
operator|&&
name|new_cost
operator|<=
name|selected_cost
condition|)
block|{
name|selected
operator|=
name|from
expr_stmt|;
name|selected_cost
operator|=
name|new_cost
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
operator|+
name|count
expr_stmt|;
block|}
name|from
operator|=
name|NEXT_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
comment|/* Create a new JUMP_INSN that branches around a barrier.  */
name|from
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|selected
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|from
argument_list|)
operator|=
name|label
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
comment|/* Create a minipool barrier entry for the new barrier.  */
name|new_fix
operator|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_fix
argument_list|)
argument_list|)
expr_stmt|;
name|new_fix
operator|->
name|insn
operator|=
name|barrier
expr_stmt|;
name|new_fix
operator|->
name|address
operator|=
name|selected_address
expr_stmt|;
name|new_fix
operator|->
name|next
operator|=
name|fix
operator|->
name|next
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|new_fix
expr_stmt|;
return|return
name|new_fix
return|;
block|}
end_function

begin_comment
comment|/* Record that there is a natural barrier in the insn stream at    ADDRESS.  */
end_comment

begin_function
specifier|static
name|void
name|push_minipool_barrier
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|HOST_WIDE_INT
name|address
parameter_list|)
block|{
name|Mfix
modifier|*
name|fix
init|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
decl_stmt|;
name|fix
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|fix
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|minipool_fix_head
operator|!=
name|NULL
condition|)
name|minipool_fix_tail
operator|->
name|next
operator|=
name|fix
expr_stmt|;
else|else
name|minipool_fix_head
operator|=
name|fix
expr_stmt|;
name|minipool_fix_tail
operator|=
name|fix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record INSN, which will need fixing up to load a value from the    minipool.  ADDRESS is the offset of the insn since the start of the    function; LOC is a pointer to the part of the insn which requires    fixing; VALUE is the constant that must be loaded, which is of type    MODE.  */
end_comment

begin_function
specifier|static
name|void
name|push_minipool_fix
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|HOST_WIDE_INT
name|address
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|value
parameter_list|)
block|{
name|Mfix
modifier|*
name|fix
init|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
comment|/* PIC symbol references need to be converted into offsets into the      based area.  */
comment|/* XXX This shouldn't be done here.  */
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|value
operator|=
name|aof_pic_entry
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AOF_ASSEMBLER */
name|fix
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|fix
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|fix
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|fix
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|fix
operator|->
name|fix_size
operator|=
name|MINIPOOL_FIX_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|fix
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|fix
operator|->
name|forwards
operator|=
name|get_attr_pool_range
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|->
name|backwards
operator|=
name|get_attr_neg_pool_range
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|->
name|minipool
operator|=
name|NULL
expr_stmt|;
comment|/* If an insn doesn't have a range defined for it, then it isn't      expecting to be reworked by this code.  Better to abort now than      to generate duff assembly code.  */
if|if
condition|(
name|fix
operator|->
name|forwards
operator|==
literal|0
operator|&&
name|fix
operator|->
name|backwards
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* With iWMMXt enabled, the pool is aligned to an 8-byte boundary.      So there might be an empty word before the start of the pool.      Hence we reduce the forward range by 4 to allow for this      possibility.  */
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
name|fix
operator|->
name|fix_size
operator|==
literal|8
condition|)
name|fix
operator|->
name|forwards
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; %smode fixup for i%d; addr %lu, range (%ld,%ld): "
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address
argument_list|,
operator|-
literal|1
operator|*
operator|(
name|long
operator|)
name|fix
operator|->
name|backwards
argument_list|,
operator|(
name|long
operator|)
name|fix
operator|->
name|forwards
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|rtl_dump_file
argument_list|,
name|fix
operator|->
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Add it to the chain of fixes.  */
name|fix
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|minipool_fix_head
operator|!=
name|NULL
condition|)
name|minipool_fix_tail
operator|->
name|next
operator|=
name|fix
expr_stmt|;
else|else
name|minipool_fix_head
operator|=
name|fix
expr_stmt|;
name|minipool_fix_tail
operator|=
name|fix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan INSN and note any of its operands that need fixing.    If DO_PUSHES is false we do not actually push any of the fixups    needed.  The function returns TRUE is any fixups were needed/pushed.    This is used by arm_memory_load_p() which needs to know about loads    of constants that will be converted into minipool loads.  */
end_comment

begin_function
specifier|static
name|bool
name|note_invalid_constants
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|HOST_WIDE_INT
name|address
parameter_list|,
name|int
name|do_pushes
parameter_list|)
block|{
name|bool
name|result
init|=
name|false
decl_stmt|;
name|int
name|opno
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|n_alternatives
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* Fill in recog_op_alt with information about the constraints of this insn.  */
name|preprocess_constraints
argument_list|()
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
comment|/* Things we need to fix can only occur in inputs.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|opno
index|]
operator|!=
name|OP_IN
condition|)
continue|continue;
comment|/* If this alternative is a memory reference, then any mention 	 of constants in this alternative is really to fool reload 	 into allowing us to accept one there.  We need to fix them up 	 now so that we output the right code.  */
if|if
condition|(
name|recog_op_alt
index|[
name|opno
index|]
index|[
name|which_alternative
index|]
operator|.
name|memory_ok
condition|)
block|{
name|rtx
name|op
init|=
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_pushes
condition|)
name|push_minipool_fix
argument_list|(
name|insn
argument_list|,
name|address
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
name|opno
index|]
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|result
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_pushes
condition|)
block|{
name|rtx
name|cop
init|=
name|avoid_constant_pool_reference
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* Casting the address of something to a mode narrower 		     than a word can cause avoid_constant_pool_reference() 		     to return the pool reference itself.  That's no good to 		     us here.  Lets just hope that we can use the  		     constant pool value directly.  */
if|if
condition|(
name|op
operator|==
name|cop
condition|)
name|cop
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|push_minipool_fix
argument_list|(
name|insn
argument_list|,
name|address
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
name|opno
index|]
argument_list|,
name|cop
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Gcc puts the pool in the wrong place for ARM, since we can only    load addresses a limited distance around the pc.  We do some    special munging to move the constant pool values to the correct    point in the code.  */
end_comment

begin_function
specifier|static
name|void
name|arm_reorg
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
init|=
literal|0
decl_stmt|;
name|Mfix
modifier|*
name|fix
decl_stmt|;
name|minipool_fix_head
operator|=
name|minipool_fix_tail
operator|=
name|NULL
expr_stmt|;
comment|/* The first insn must always be a note, or the code below won't      scan it properly.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Scan all the insns and record the operands that will need fixing.  */
for|for
control|(
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|TARGET_CIRRUS_FIX_INVALID_INSNS
operator|&&
operator|(
name|arm_cirrus_insn_p
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|arm_memory_load_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|cirrus_reorg
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|push_minipool_barrier
argument_list|(
name|insn
argument_list|,
name|address
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|table
decl_stmt|;
name|note_invalid_constants
argument_list|(
name|insn
argument_list|,
name|address
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|address
operator|+=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the insn is a vector jump, add the size of the table 	     and skip the table.  */
if|if
condition|(
operator|(
name|table
operator|=
name|is_jump_table
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|address
operator|+=
name|get_jump_table_size
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|insn
operator|=
name|table
expr_stmt|;
block|}
block|}
block|}
name|fix
operator|=
name|minipool_fix_head
expr_stmt|;
comment|/* Now scan the fixups and perform the required changes.  */
while|while
condition|(
name|fix
condition|)
block|{
name|Mfix
modifier|*
name|ftmp
decl_stmt|;
name|Mfix
modifier|*
name|fdel
decl_stmt|;
name|Mfix
modifier|*
name|last_added_fix
decl_stmt|;
name|Mfix
modifier|*
name|last_barrier
init|=
name|NULL
decl_stmt|;
name|Mfix
modifier|*
name|this_fix
decl_stmt|;
comment|/* Skip any further barriers before the next fix.  */
while|while
condition|(
name|fix
operator|&&
name|GET_CODE
argument_list|(
name|fix
operator|->
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|fix
operator|=
name|fix
operator|->
name|next
expr_stmt|;
comment|/* No more fixes.  */
if|if
condition|(
name|fix
operator|==
name|NULL
condition|)
break|break;
name|last_added_fix
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ftmp
operator|=
name|fix
init|;
name|ftmp
condition|;
name|ftmp
operator|=
name|ftmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ftmp
operator|->
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
if|if
condition|(
name|ftmp
operator|->
name|address
operator|>=
name|minipool_vector_head
operator|->
name|max_address
condition|)
break|break;
name|last_barrier
operator|=
name|ftmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ftmp
operator|->
name|minipool
operator|=
name|add_minipool_forward_ref
argument_list|(
name|ftmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|last_added_fix
operator|=
name|ftmp
expr_stmt|;
comment|/* Keep track of the last fix added.  */
block|}
comment|/* If we found a barrier, drop back to that; any fixes that we 	 could have reached but come after the barrier will now go in 	 the next mini-pool.  */
if|if
condition|(
name|last_barrier
operator|!=
name|NULL
condition|)
block|{
comment|/* Reduce the refcount for those fixes that won't go into this  	     pool after all.  */
for|for
control|(
name|fdel
operator|=
name|last_barrier
operator|->
name|next
init|;
name|fdel
operator|&&
name|fdel
operator|!=
name|ftmp
condition|;
name|fdel
operator|=
name|fdel
operator|->
name|next
control|)
block|{
name|fdel
operator|->
name|minipool
operator|->
name|refcount
operator|--
expr_stmt|;
name|fdel
operator|->
name|minipool
operator|=
name|NULL
expr_stmt|;
block|}
name|ftmp
operator|=
name|last_barrier
expr_stmt|;
block|}
else|else
block|{
comment|/* ftmp is first fix that we can't fit into this pool and 	     there no natural barriers that we could use.  Insert a 	     new barrier in the code somewhere between the previous 	     fix and this one, and arrange to jump around it.  */
name|HOST_WIDE_INT
name|max_address
decl_stmt|;
comment|/* The last item on the list of fixes must be a barrier, so 	     we can never run off the end of the list of fixes without 	     last_barrier being set.  */
if|if
condition|(
name|ftmp
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|max_address
operator|=
name|minipool_vector_head
operator|->
name|max_address
expr_stmt|;
comment|/* Check that there isn't another fix that is in range that 	     we couldn't fit into this pool because the pool was 	     already too large: we need to put the pool before such an 	     instruction.  */
if|if
condition|(
name|ftmp
operator|->
name|address
operator|<
name|max_address
condition|)
name|max_address
operator|=
name|ftmp
operator|->
name|address
expr_stmt|;
name|last_barrier
operator|=
name|create_fix_barrier
argument_list|(
name|last_added_fix
argument_list|,
name|max_address
argument_list|)
expr_stmt|;
block|}
name|assign_minipool_offsets
argument_list|(
name|last_barrier
argument_list|)
expr_stmt|;
while|while
condition|(
name|ftmp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ftmp
operator|->
name|insn
argument_list|)
operator|!=
name|BARRIER
operator|&&
operator|(
operator|(
name|ftmp
operator|->
name|minipool
operator|=
name|add_minipool_backward_ref
argument_list|(
name|ftmp
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
break|break;
name|ftmp
operator|=
name|ftmp
operator|->
name|next
expr_stmt|;
block|}
comment|/* Scan over the fixes we have identified for this pool, fixing them 	 up and adding the constants to the pool itself.  */
for|for
control|(
name|this_fix
operator|=
name|fix
init|;
name|this_fix
operator|&&
name|ftmp
operator|!=
name|this_fix
condition|;
name|this_fix
operator|=
name|this_fix
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_fix
operator|->
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|rtx
name|addr
init|=
name|plus_constant
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|minipool_vector_label
argument_list|)
argument_list|,
name|this_fix
operator|->
name|minipool
operator|->
name|offset
argument_list|)
decl_stmt|;
operator|*
name|this_fix
operator|->
name|loc
operator|=
name|gen_rtx_MEM
argument_list|(
name|this_fix
operator|->
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|dump_minipool
argument_list|(
name|last_barrier
operator|->
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|=
name|ftmp
expr_stmt|;
block|}
comment|/* From now on we must synthesize any constants that we can't handle      directly.  This can happen if the RTL gets split during final      instruction generation.  */
name|after_arm_reorg
operator|=
literal|1
expr_stmt|;
comment|/* Free the minipool memory.  */
name|obstack_free
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
name|minipool_startobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to output assembly language.  */
end_comment

begin_comment
comment|/* If the rtx is the correct value then return the string of the number.    In this way we can ensure that valid double constants are generated even    when cross compiling.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|fp_immediate_constant
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fpa_consts_inited
condition|)
name|init_fpa_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fpa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|strings_fpa
index|[
name|i
index|]
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As for fp_immediate_constant, but value is passed directly, not in rtx.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fp_const_from_val
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fpa_consts_inited
condition|)
name|init_fpa_table
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
operator|*
name|r
argument_list|,
name|values_fpa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|strings_fpa
index|[
name|i
index|]
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the operands of a LDM/STM instruction to STREAM.    MASK is the ARM register set mask of which only bits 0-15 are important.    REG is the base register, either the frame pointer or the stack pointer,    INSTR is the possibly suffixed load or store instruction.  */
end_comment

begin_function
specifier|static
name|void
name|print_multi_reg
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|instr
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|not_first
init|=
name|FALSE
decl_stmt|;
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
name|instr
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", {"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|not_first
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|not_first
operator|=
name|TRUE
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
comment|/* Add a ^ character for the 26-bit ABI, but only if we were loading      the PC.  Otherwise we would generate an UNPREDICTABLE instruction.      Strictly speaking the instruction would be unpredicatble only if      we were writing back the base register as well, but since we never      want to generate an LDM type 2 instruction (register bank switching)      which is what you get if the PC is not being loaded, we do not need      to check for writeback.  */
if|if
condition|(
operator|!
name|TARGET_APCS_32
operator|&&
operator|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a 'call' insn.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_call
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
comment|/* Handle calls to lr using ip (which may be clobbered in subr anyway).  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|LR_REGNUM
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %|lr"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_INTERWORK
condition|)
name|output_asm_insn
argument_list|(
literal|"bx%?\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|pc, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a 'call' insn that is a reference in memory.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_call_mem
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
if|if
condition|(
name|TARGET_INTERWORK
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%|ip, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bx%?\t%|ip"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno_use_in
argument_list|(
name|LR_REGNUM
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* LR is used in the memory address.  We load the address in the 	 first instruction.  It's safe to use IP as the target of the 	 load since the call will kill it anyway.  */
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%|ip, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|pc, %|ip"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%|pc, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to an fpa registers.    OPERANDS[0] is an fpa register.    OPERANDS[1] is the first registers of an arm register pair.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_fpa_from_arm
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stm%?fd\t%|sp!, {%0, %1, %2}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldf%?e\t%0, [%|sp], #12"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from an fpa register to arm registers.    OPERANDS[0] is the first registers of an arm register pair.    OPERANDS[1] is an fpa register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_arm_from_fpa
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stf%?e\t%1, [%|sp, #-12]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?fd\t%|sp!, {%0, %1, %2}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to arm registers of a long double    OPERANDS[0] is the destination.    OPERANDS[1] is the source.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_arm_from_arm
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
comment|/* We have to be careful here because the two might overlap.  */
name|int
name|dest_start
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|src_start
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dest_start
operator|<
name|src_start
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|dest_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|src_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|dest_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|src_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to an fpa registers.    OPERANDS[0] is an fpa register.    OPERANDS[1] is the first registers of an arm register pair.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_double_fpa_from_arm
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stm%?fd\t%|sp!, {%0, %1}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldf%?d\t%0, [%|sp], #8"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from an fpa register to arm registers.    OPERANDS[0] is the first registers of an arm register pair.    OPERANDS[1] is an fpa register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_double_arm_from_fpa
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stf%?d\t%1, [%|sp, #-8]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?fd\t%|sp!, {%0, %1}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move between double words.    It must be REG<-REG, REG<-CONST_DOUBLE, REG<-CONST_INT, REG<-MEM    or MEM<-REG and all MEMs must be offsettable addresses.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_move_double
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|otherops
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|int
name|reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|otherops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|reg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|reg1
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg1
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ensure the second source is not overwritten.  */
if|if
condition|(
name|reg1
operator|==
name|reg0
operator|+
operator|(
name|WORDS_BIG_ENDIAN
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"mov%?\t%Q0, %Q1\n\tmov%?\t%R0, %R1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov%?\t%R0, %R1\n\tmov%?\t%Q0, %Q1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_VECTOR
condition|)
block|{
name|HOST_WIDE_INT
name|hint
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|V2SImode
case|:
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|hint
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|16
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hint
operator|=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|16
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|hint
argument_list|)
expr_stmt|;
name|hint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|16
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|16
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|hint
argument_list|)
expr_stmt|;
break|break;
case|case
name|V8QImode
case|:
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|hint
argument_list|)
expr_stmt|;
name|hint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|hint
operator|<<=
literal|8
expr_stmt|;
name|hint
operator||=
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|hint
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|output_mov_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
name|output_mov_immediate
argument_list|(
name|otherops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_mov_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
name|output_mov_immediate
argument_list|(
name|otherops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
comment|/* If HOST_WIDE_INT is more than 32 bits, the intval tells us 	     what the upper word is.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Sign extend the intval into the high-order word.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
operator|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
name|const0_rtx
operator|)
expr_stmt|;
block|}
else|else
name|otherops
index|[
literal|1
index|]
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
name|const0_rtx
expr_stmt|;
endif|#
directive|endif
name|output_mov_immediate
argument_list|(
name|otherops
argument_list|)
expr_stmt|;
name|output_mov_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MEM
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%m1, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen now.  */
break|break;
case|case
name|PRE_DEC
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?db\t%m1!, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%m1!, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen now.  */
break|break;
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|output_asm_insn
argument_list|(
literal|"adr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%0, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arm_add_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|otherops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
case|case
operator|-
literal|8
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?db\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
operator|-
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?da\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ib\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sub%?\t%0, %1, #%n2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"add%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"add%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"sub%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|"ldm%?ia\t%0, %M0"
return|;
block|}
else|else
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Take care of overlapping base/data reg.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Constraints should prevent this.  */
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MEM
operator|&&
name|code1
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ia\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen now.  */
break|break;
case|case
name|PRE_DEC
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?db\t%m0!, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ia\t%m0!, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen now.  */
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|8
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?db\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
operator|-
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?da\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ib\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
comment|/* Fall through */
default|default:
name|otherops
index|[
literal|0
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?\t%1, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?\t%1, %0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Constraints should prevent this.  */
name|abort
argument_list|()
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output an arbitrary MOV reg, #n.    OPERANDS[0] is a register.  OPERANDS[1] is a const_int.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_immediate
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|HOST_WIDE_INT
name|n
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/* Try to use one MOV.  */
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|n
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Try to use one MVN.  */
elseif|else
if|if
condition|(
name|const_ok_for_arm
argument_list|(
operator|~
name|n
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|~
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mvn%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|n_ones
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If all else fails, make it out of ORRs or BICs as appropriate.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n
operator|&
literal|1
operator|<<
name|i
condition|)
name|n_ones
operator|++
expr_stmt|;
if|if
condition|(
name|n_ones
operator|>
literal|16
condition|)
comment|/* Shorter to use MVN with BIC in this case.  */
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"mvn%?\t%0, %1"
argument_list|,
literal|"bic%?\t%0, %0, %1"
argument_list|,
literal|1
argument_list|,
operator|~
name|n
argument_list|)
expr_stmt|;
else|else
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"mov%?\t%0, %1"
argument_list|,
literal|"orr%?\t%0, %0, %1"
argument_list|,
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output an ADD r, s, #n where n may be too big for one instruction.    If adding zero to one register, output nothing.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_add_immediate
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|HOST_WIDE_INT
name|n
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"sub%?\t%0, %1, %2"
argument_list|,
literal|"sub%?\t%0, %0, %2"
argument_list|,
literal|2
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
else|else
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"add%?\t%0, %1, %2"
argument_list|,
literal|"add%?\t%0, %0, %2"
argument_list|,
literal|2
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a multiple immediate operation.    OPERANDS is the vector of operands referred to in the output patterns.    INSTR1 is the output pattern to use for the first constant.    INSTR2 is the output pattern to use for subsequent constants.    IMMED_OP is the index of the constant slot in OPERANDS.    N is the constant value.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|output_multi_immediate
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
specifier|const
name|char
modifier|*
name|instr1
parameter_list|,
specifier|const
name|char
modifier|*
name|instr2
parameter_list|,
name|int
name|immed_op
parameter_list|,
name|HOST_WIDE_INT
name|n
parameter_list|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
name|n
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* Quick and easy output.  */
name|operands
index|[
name|immed_op
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|output_asm_insn
argument_list|(
name|instr1
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|instr
init|=
name|instr1
decl_stmt|;
comment|/* Note that n is never zero here (which would give no output).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
condition|)
block|{
name|operands
index|[
name|immed_op
index|]
operator|=
name|GEN_INT
argument_list|(
name|n
operator|&
operator|(
literal|255
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|instr
operator|=
name|instr2
expr_stmt|;
name|i
operator|+=
literal|6
expr_stmt|;
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Return the appropriate ARM instruction for the operation code.    The returned result should not be overwritten.  OP is the rtx of the    operation.  SHIFT_FIRST_ARG is TRUE if the first argument of the operator    was shifted.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arithmetic_instr
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|shift_first_arg
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
return|return
literal|"add"
return|;
case|case
name|MINUS
case|:
return|return
name|shift_first_arg
condition|?
literal|"rsb"
else|:
literal|"sub"
return|;
case|case
name|IOR
case|:
return|return
literal|"orr"
return|;
case|case
name|XOR
case|:
return|return
literal|"eor"
return|;
case|case
name|AND
case|:
return|return
literal|"and"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ensure valid constant shifts and return the appropriate shift mnemonic    for the operation code.  The returned result should not be overwritten.    OP is the rtx code of the shift.    On exit, *AMOUNTP will be -1 if the shift is by a register, or a constant    shift.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|shift_op
parameter_list|(
name|rtx
name|op
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|amountp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mnem
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
operator|*
name|amountp
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|amountp
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASHIFT
case|:
name|mnem
operator|=
literal|"asl"
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|mnem
operator|=
literal|"asr"
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|mnem
operator|=
literal|"lsr"
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
name|mnem
operator|=
literal|"ror"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* We never have to worry about the amount being other than a 	 power of 2, since this case can never be reloaded from a reg.  */
if|if
condition|(
operator|*
name|amountp
operator|!=
operator|-
literal|1
condition|)
operator|*
name|amountp
operator|=
name|int_log2
argument_list|(
operator|*
name|amountp
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
literal|"asl"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|amountp
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* This is not 100% correct, but follows from the desire to merge 	 multiplication by a power of 2 with the recognizer for a 	 shift.>=32 is not a valid shift for "asl", so we must try and 	 output a shift that produces the correct arithmetical result. 	 Using lsr #32 is identical except for the fact that the carry bit 	 is not set correctly if we set the flags; but we never use the  	 carry bit from such an operation, so we can ignore that.  */
if|if
condition|(
name|code
operator|==
name|ROTATERT
condition|)
comment|/* Rotate is just modulo 32.  */
operator|*
name|amountp
operator|&=
literal|31
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|amountp
operator|!=
operator|(
operator|*
name|amountp
operator|&
literal|31
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|mnem
operator|=
literal|"lsr"
expr_stmt|;
operator|*
name|amountp
operator|=
literal|32
expr_stmt|;
block|}
comment|/* Shifts of 0 are no-ops.  */
if|if
condition|(
operator|*
name|amountp
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|mnem
return|;
block|}
end_function

begin_comment
comment|/* Obtain the shift from the POWER of two.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|int_log2
parameter_list|(
name|HOST_WIDE_INT
name|power
parameter_list|)
block|{
name|HOST_WIDE_INT
name|shift
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|shift
operator|)
operator|&
name|power
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|shift
operator|>
literal|31
condition|)
name|abort
argument_list|()
expr_stmt|;
name|shift
operator|++
expr_stmt|;
block|}
return|return
name|shift
return|;
block|}
end_function

begin_comment
comment|/* Output a .ascii pseudo-op, keeping track of lengths.  This is because    /bin/as is horribly restrictive.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ASCII_LEN
value|51
end_define

begin_function
name|void
name|output_ascii_pseudo_op
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len_so_far
init|=
literal|0
decl_stmt|;
name|fputs
argument_list|(
literal|"\t.ascii\t\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|len_so_far
operator|>=
name|MAX_ASCII_LEN
condition|)
block|{
name|fputs
argument_list|(
literal|"\"\n\t.ascii\t\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TARGET_TAB
case|:
name|fputs
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TARGET_FF
case|:
name|fputs
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TARGET_BS
case|:
name|fputs
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TARGET_CR
case|:
name|fputs
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TARGET_NEWLINE
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c
operator|=
name|p
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
operator|)
operator|||
name|c
operator|==
name|TARGET_TAB
condition|)
comment|/* This is a good place for a line break.  */
name|len_so_far
operator|=
name|MAX_ASCII_LEN
expr_stmt|;
else|else
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\\'
case|:
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|++
expr_stmt|;
comment|/* Drop through.  */
default|default:
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
block|}
block|}
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the register sabe mask for registers 0 through 12    inclusive.  This code is used by both arm_compute_save_reg_mask    and arm_compute_initial_elimination_offset.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg0_reg12_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|func_type
init|=
name|arm_current_func_type
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|save_reg_mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|max_reg
decl_stmt|;
comment|/* Interrupt functions must not corrupt any registers, 	 even call clobbered ones.  If this is a leaf function 	 we can just examine the registers used by the RTL, but 	 otherwise we have to assume that whatever function is 	 called might clobber anything, and so we have to save 	 all the call-clobbered registers as well.  */
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_FIQ
condition|)
comment|/* FIQ handlers have registers r8 - r12 banked, so 	   we only need to check r0 - r7, Normal ISRs only 	   bank r14 and r15, so we must check up to r12. 	   r13 is the stack pointer which is always preserved, 	   so we do not need to consider it here.  */
name|max_reg
operator|=
literal|7
expr_stmt|;
else|else
name|max_reg
operator|=
literal|12
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|max_reg
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|||
operator|(
operator|!
name|current_function_is_leaf
operator|&&
name|call_used_regs
index|[
name|reg
index|]
operator|)
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In the normal case we only need to save those registers 	 which are call saved and which are used by this function.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
literal|10
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
comment|/* Handle the frame pointer as a special case.  */
if|if
condition|(
operator|!
name|TARGET_APCS_FRAME
operator|&&
operator|!
name|frame_pointer_needed
operator|&&
name|regs_ever_live
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
comment|/* If we aren't loading the PIC register, 	 don't stack it even though it may be live.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|TARGET_SINGLE_PIC_BASE
operator|&&
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|PIC_OFFSET_TABLE_REGNUM
expr_stmt|;
block|}
return|return
name|save_reg_mask
return|;
block|}
end_function

begin_comment
comment|/* Compute a bit mask of which registers need to be    saved on the stack for the current function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|save_reg_mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|func_type
init|=
name|arm_current_func_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* This should never really happen.  */
return|return
literal|0
return|;
comment|/* If we are creating a stack frame, then we must save the frame pointer,      IP (which will hold the old stack pointer), LR and the PC.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
comment|/* Volatile functions do not return, so there      is no need to save any other registers.  */
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
return|return
name|save_reg_mask
return|;
name|save_reg_mask
operator||=
name|arm_compute_save_reg0_reg12_mask
argument_list|()
expr_stmt|;
comment|/* Decide if we need to save the link register.      Interrupt routines have their own banked link register,      so they never need to save it.      Otherwise if we do not use the link register we do not need to save      it.  If we are pushing other registers onto the stack however, we      can save an instruction in the epilogue by pushing the link register      now and then popping it back into the PC.  This incurs extra memory      accesses though, so we only do it when optimizing for size, and only      if we know that we will not need a fancy return sequence.  */
if|if
condition|(
name|regs_ever_live
index|[
name|LR_REGNUM
index|]
operator|||
operator|(
name|save_reg_mask
operator|&&
name|optimize_size
operator|&&
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
operator|)
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|LR_REGNUM
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
condition|)
name|save_reg_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
operator|(
operator|(
name|bit_count
argument_list|(
name|save_reg_mask
argument_list|)
operator|+
name|ARM_NUM_INTS
argument_list|(
name|current_function_pretend_args_size
argument_list|)
operator|)
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* The total number of registers that are going to be pushed 	 onto the stack is odd.  We need to ensure that the stack 	 is 64-bit aligned before we start to save iWMMXt registers, 	 and also before we start to create locals.  (A local variable 	 might be a double or long long which we will load/store using 	 an iWMMXt instruction).  Therefore we need to push another 	 ARM register, so that the stack will be 64-bit aligned.  We 	 try to avoid using the arg registers (r0 -r3) as they might be 	 used to pass values in a tail call.  */
for|for
control|(
name|reg
operator|=
literal|4
init|;
name|reg
operator|<=
literal|12
condition|;
name|reg
operator|++
control|)
if|if
condition|(
operator|(
name|save_reg_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|reg
operator|<=
literal|12
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
else|else
block|{
name|cfun
operator|->
name|machine
operator|->
name|sibcall_blocked
operator|=
literal|1
expr_stmt|;
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
return|return
name|save_reg_mask
return|;
block|}
end_function

begin_comment
comment|/* Generate a function exit sequence.  If REALLY_RETURN is false, then do    everything bar the final return instruction.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_return_instruction
parameter_list|(
name|rtx
name|operand
parameter_list|,
name|int
name|really_return
parameter_list|,
name|int
name|reverse
parameter_list|)
block|{
name|char
name|conditional
index|[
literal|10
index|]
decl_stmt|;
name|char
name|instr
index|[
literal|100
index|]
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|unsigned
name|long
name|live_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
operator|&&
name|TARGET_ABORT_NORETURN
condition|)
block|{
comment|/* If this function was declared non-returning, and we have 	 found a tail call, then we have to trust that the called 	 function won't return.  */
if|if
condition|(
name|really_return
condition|)
block|{
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
comment|/* Otherwise, trap an attempted return by aborting.  */
name|ops
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|NEED_PLT_RELOC
condition|?
literal|"abort(PLT)"
else|:
literal|"abort"
argument_list|)
expr_stmt|;
name|assemble_external_libcall
argument_list|(
name|ops
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|reverse
condition|?
literal|"bl%D0\t%a1"
else|:
literal|"bl%d0\t%a1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
if|if
condition|(
name|current_function_calls_alloca
operator|&&
operator|!
name|really_return
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|conditional
argument_list|,
literal|"%%?%%%c0"
argument_list|,
name|reverse
condition|?
literal|'D'
else|:
literal|'d'
argument_list|)
expr_stmt|;
name|return_used_this_function
operator|=
literal|1
expr_stmt|;
name|live_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
if|if
condition|(
name|live_regs_mask
condition|)
block|{
specifier|const
name|char
modifier|*
name|return_reg
decl_stmt|;
comment|/* If we do not have any special requirements for function exit  	 (eg interworking, or ISR) then we can load the return address  	 directly into the PC.  Otherwise we must load it into LR.  */
if|if
condition|(
name|really_return
operator|&&
operator|!
name|TARGET_INTERWORK
condition|)
name|return_reg
operator|=
name|reg_names
index|[
name|PC_REGNUM
index|]
expr_stmt|;
else|else
name|return_reg
operator|=
name|reg_names
index|[
name|LR_REGNUM
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
condition|)
block|{
comment|/* There are three possible reasons for the IP register 	     being saved.  1) a stack frame was created, in which case 	     IP contains the old stack pointer, or 2) an ISR routine 	     corrupted it, or 3) it was saved to align the stack on 	     iWMMXt.  In case 1, restore IP into SP, otherwise just 	     restore IP.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|live_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
expr_stmt|;
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|&&
operator|!
name|TARGET_REALLY_IWMMXT
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* On some ARM architectures it is faster to use LDR rather than 	 LDM to load a single register.  On other architectures, the 	 cost is the same.  In 26 bit mode, or for exception handlers, 	 we have to use LDM to load the PC so that the CPSR is also 	 restored.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|live_regs_mask
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
literal|1
operator|<<
name|reg
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|reg
operator|<=
name|LAST_ARM_REGNUM
operator|&&
operator|(
name|reg
operator|!=
name|LR_REGNUM
operator|||
operator|!
name|really_return
operator|||
operator|(
name|TARGET_APCS_32
operator|&&
operator|!
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldr%s\t%%|%s, [%%|sp], #4"
argument_list|,
name|conditional
argument_list|,
operator|(
name|reg
operator|==
name|LR_REGNUM
operator|)
condition|?
name|return_reg
else|:
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* Generate the load multiple instruction to restore the 	     registers.  Note we can get here, even if 	     frame_pointer_needed is true, but only if sp already 	     points to the base of the saved core registers.  */
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|stack_adjust
init|=
name|arm_get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
decl_stmt|;
if|if
condition|(
name|stack_adjust
operator|!=
literal|0
operator|&&
name|stack_adjust
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|stack_adjust
operator|&&
name|arm_arch5
condition|)
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldm%sib\t%%|sp, {"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we can't use ldmib (SA110 bug), then try to pop r3 		     instead.  */
if|if
condition|(
name|stack_adjust
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldm%sfd\t%%|sp, {"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldm%sfd\t%%|sp!, {"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
name|p
operator|=
name|instr
operator|+
name|strlen
argument_list|(
name|instr
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|SP_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|reg_names
index|[
name|reg
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
literal|"%|"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
operator|+=
name|l
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%%|%s}"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|", "
argument_list|,
name|return_reg
argument_list|)
expr_stmt|;
comment|/* Decide if we need to add the ^ symbol to the end of the 		 register list.	 This causes the saved condition codes 		 register to be copied into the current condition codes 		 register.  We do the copy if we are conforming to the 32-bit 		 ABI and this is an interrupt function, or if we are 		 conforming to the 26-bit ABI.  There is a special case for 		 the 26-bit ABI however, which is if we are writing back the 		 stack pointer but not loading the PC.  In this case adding 		 the ^ symbol would create a type 2 LDM instruction, where 		 writeback is UNPREDICTABLE.  We are safe in leaving the ^ 		 character off in this case however, since the actual return 		 instruction will be a MOVS which will restore the CPSR.  */
if|if
condition|(
operator|(
name|TARGET_APCS_32
operator|&&
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|TARGET_APCS_32
operator|&&
name|really_return
operator|)
condition|)
name|strcat
argument_list|(
name|p
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
comment|/* See if we need to generate an extra instruction to 	 perform the actual function return.  */
if|if
condition|(
name|really_return
operator|&&
name|func_type
operator|!=
name|ARM_FT_INTERWORKED
operator|&&
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The return has already been handled 	     by loading the LR into the PC.  */
name|really_return
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|really_return
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
case|case
name|ARM_FT_ISR
case|:
case|case
name|ARM_FT_FIQ
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"sub%ss\t%%|pc, %%|lr, #4"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"bx%s\t%%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"mov%ss\t%%|pc, %%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ARMv5 implementations always provide BX, so interworking 	     is the default unless APCS-26 is in use.  */
if|if
condition|(
operator|(
name|insn_flags
operator|&
name|FL_ARCH5
operator|)
operator|!=
literal|0
operator|&&
name|TARGET_APCS_32
condition|)
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"bx%s\t%%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"mov%s%s\t%%|pc, %%|lr"
argument_list|,
name|conditional
argument_list|,
name|TARGET_APCS_32
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
break|break;
block|}
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Write the function name into the code section, directly preceding    the function prologue.     Code will be output similar to this:      t0 	 .ascii "arm_poke_function_name", 0 	 .align      t1 	 .word 0xff000000 + (t1 - t0)      arm_poke_function_name 	 mov     ip, sp 	 stmfd   sp!, {fp, ip, lr, pc} 	 sub     fp, ip, #4     When performing a stack backtrace, code can inspect the value    of 'pc' stored at 'fp' + 0.  If the trace function then looks    at location pc - 12 and the top 8 bits are set, then we know    that there is a function name embedded immediately preceding this    location and has length ((pc[-3])& 0xff000000).     We assume that pc is declared as a pointer to an unsigned long.     It is of no benefit to output the function name if we are assembling    a leaf function.  These function types will not contain a stack    backtrace structure, therefore it is not possible to determine the    function name.  */
end_comment

begin_function
name|void
name|arm_poke_function_name
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|long
name|alignlength
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|alignlength
operator|=
name|ROUND_UP_WORD
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ASCII
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|stream
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
name|GEN_INT
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xff000000
operator|+
name|alignlength
argument_list|)
expr_stmt|;
name|assemble_aligned_integer
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place some comments into the assembler stream    describing the current function.  */
end_comment

begin_function
specifier|static
name|void
name|arm_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|HOST_WIDE_INT
name|frame_size
parameter_list|)
block|{
name|unsigned
name|long
name|func_type
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_ARM
condition|)
block|{
name|thumb_output_function_prologue
argument_list|(
name|f
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Sanity check.  */
if|if
condition|(
name|arm_ccfsm_state
operator|||
name|arm_target_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
default|default:
case|case
name|ARM_FT_NORMAL
case|:
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Function supports interworking.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION_HANDLER
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ C++ Exception Handler.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_ISR
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Interrupt Service Routine.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_FIQ
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Fast Interrupt Service Routine.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ ARM Exception Handler.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Naked Function: prologue and epilogue provided by programmer.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Volatile: function does not return.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Nested: function declared inside another function.\n"
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ args = %d, pretend = %d, frame = %wd\n"
argument_list|,
name|current_function_args_size
argument_list|,
name|current_function_pretend_args_size
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ frame_needed = %d, uses_anonymous_args = %d\n"
argument_list|,
name|frame_pointer_needed
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ link register save eliminated.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
if|if
condition|(
name|flag_pic
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|return_used_this_function
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|arm_output_epilogue
parameter_list|(
name|rtx
name|sibling
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|unsigned
name|long
name|saved_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
comment|/* Floats_offset is the offset from the "virtual" frame.  In an APCS       frame that is $fp + 4 for a non-variadic function.  */
name|int
name|floats_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|frame_size
init|=
name|arm_get_frame_size
argument_list|()
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|asm_out_file
decl_stmt|;
name|rtx
name|eh_ofs
init|=
name|cfun
operator|->
name|machine
operator|->
name|eh_epilogue_sp_ofs
decl_stmt|;
name|unsigned
name|int
name|lrm_count
init|=
literal|0
decl_stmt|;
name|int
name|really_return
init|=
operator|(
name|sibling
operator|==
name|NULL
operator|)
decl_stmt|;
comment|/* If we have already generated the return instruction      then it is futile to generate anything else.  */
if|if
condition|(
name|use_return_insn
argument_list|(
name|FALSE
argument_list|,
name|sibling
argument_list|)
operator|&&
name|return_used_this_function
condition|)
return|return
literal|""
return|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* Naked functions don't have epilogues.  */
return|return
literal|""
return|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
operator|&&
name|TARGET_ABORT_NORETURN
condition|)
block|{
name|rtx
name|op
decl_stmt|;
comment|/* A volatile function should never return.  Call abort.  */
name|op
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|NEED_PLT_RELOC
condition|?
literal|"abort(PLT)"
else|:
literal|"abort"
argument_list|)
expr_stmt|;
name|assemble_external_libcall
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bl\t%a0"
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_EXCEPTION_HANDLER
operator|&&
operator|!
name|really_return
condition|)
comment|/* If we are throwing an exception, then we really must        be doing a return,  so we can't tail-call.  */
name|abort
argument_list|()
expr_stmt|;
name|saved_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_IWMMXT
condition|)
name|lrm_count
operator|=
name|bit_count
argument_list|(
name|saved_regs_mask
argument_list|)
expr_stmt|;
comment|/* XXX We should adjust floats_offset for any anonymous args, and then      re-adjust vfp_offset below to compensate.  */
comment|/* Compute how far away the floats will be.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
name|floats_offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|int
name|vfp_offset
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FPUTYPE_FPA_EMU2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|LAST_ARM_FP_REGNUM
init|;
name|reg
operator|>=
name|FIRST_ARM_FP_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|floats_offset
operator|+=
literal|12
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldfe\t%r, [%r, #-%d]\n"
argument_list|,
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|start_reg
init|=
name|LAST_ARM_FP_REGNUM
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_ARM_FP_REGNUM
init|;
name|reg
operator|>=
name|FIRST_ARM_FP_REGNUM
condition|;
name|reg
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|floats_offset
operator|+=
literal|12
expr_stmt|;
comment|/* We can't unstack more than four registers at once.  */
if|if
condition|(
name|start_reg
operator|-
name|reg
operator|==
literal|3
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, 4, [%r, #-%d]\n"
argument_list|,
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, %d, [%r, #-%d]\n"
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Just in case the last register checked also needs unstacking.  */
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, %d, [%r, #-%d]\n"
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IWMMXT
condition|)
block|{
comment|/* The frame pointer is guaranteed to be non-double-word aligned. 	     This is because it is set to (old_stack_pointer - 4) and the 	     old_stack_pointer was double word aligned.  Thus the offset to 	     the iWMMXt registers to be loaded must also be non-double-word 	     sized, so that the resultant address *is* double-word aligned. 	     We can ignore floats_offset since that was already included in 	     the live_regs_mask.  */
name|lrm_count
operator|+=
operator|(
name|lrm_count
operator|%
literal|2
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|reg
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\twldrd\t%r, [%r, #-%d]\n"
argument_list|,
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|lrm_count
operator|*
literal|4
argument_list|)
expr_stmt|;
name|lrm_count
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* saved_regs_mask should contain the IP, which at the time of stack 	 frame generation actually contains the old stack pointer.  So a 	 quick way to unwind the stack is just pop the IP register directly 	 into the stack pointer.  */
if|if
condition|(
operator|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
expr_stmt|;
name|saved_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
comment|/* There are two registers left in saved_regs_mask - LR and PC.  We 	 only need to restore the LR register (the return address), but to 	 save time we can load it directly into the PC, unless we need a 	 special function exit sequence, or we are not really returning.  */
if|if
condition|(
name|really_return
operator|&&
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
condition|)
comment|/* Delete the LR from the register mask, so that the LR on 	   the stack is loaded into the PC in the register mask.  */
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
else|else
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
comment|/* We must use SP as the base register, because SP is one of the          registers being restored.  If an interrupt or page fault          happens in the ldm instruction, the SP might or might not          have been restored.  That would be bad, as then SP will no          longer indicate the safe area of stack, and we can get stack          corruption.  Using SP as the base register means that it will          be reset correctly to the original value, should an interrupt          occur.  If the stack pointer already points at the right          place, then omit the subtraction.  */
if|if
condition|(
operator|(
operator|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
operator|+
name|floats_offset
operator|)
operator|!=
literal|4
operator|*
operator|(
literal|1
operator|+
operator|(
name|int
operator|)
name|bit_count
argument_list|(
name|saved_regs_mask
argument_list|)
operator|)
operator|)
operator|||
name|current_function_calls_alloca
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #%d\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|FP_REGNUM
argument_list|,
literal|4
operator|*
name|bit_count
argument_list|(
name|saved_regs_mask
argument_list|)
argument_list|)
expr_stmt|;
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r"
argument_list|,
name|SP_REGNUM
argument_list|,
name|saved_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* Interrupt handlers will have pushed the 	   IP onto the stack, so restore it now.  */
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r!"
argument_list|,
name|SP_REGNUM
argument_list|,
literal|1
operator|<<
name|IP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Restore stack pointer if necessary.  */
if|if
condition|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
operator|!=
literal|0
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FPUTYPE_FPA_EMU2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|reg
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldfe\t%r, [%r], #12\n"
argument_list|,
name|reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|start_reg
init|=
name|FIRST_ARM_FP_REGNUM
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|reg
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
if|if
condition|(
name|reg
operator|-
name|start_reg
operator|==
literal|3
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, 4, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, %d, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|reg
operator|-
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Just in case the last register checked also needs unstacking.  */
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, %d, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|reg
operator|-
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IWMMXT
condition|)
for|for
control|(
name|reg
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|reg
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\twldrd\t%r, [%r, #+8]!\n"
argument_list|,
name|reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
comment|/* If we can, restore the LR into the PC.  */
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
operator|&&
name|really_return
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|&&
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
name|saved_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
block|}
comment|/* Load the registers off the stack.  If we only have one register 	 to load use the LDR instruction - it is faster.  */
if|if
condition|(
name|saved_regs_mask
operator|==
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
comment|/* The exception handler ignores the LR, so we do 	     not really need to load it off the stack.  */
if|if
condition|(
name|eh_ofs
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, #4\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldr\t%r, [%r], #4\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|saved_regs_mask
condition|)
block|{
if|if
condition|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
condition|)
comment|/* Note - write back to the stack register is not enabled 	       (ie "ldmfd sp!...").  We know that the stack pointer is 	       in the list of registers and if we add writeback the 	       instruction becomes UNPREDICTABLE.  */
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r"
argument_list|,
name|SP_REGNUM
argument_list|,
name|saved_regs_mask
argument_list|)
expr_stmt|;
else|else
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r!"
argument_list|,
name|SP_REGNUM
argument_list|,
name|saved_regs_mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
condition|)
block|{
comment|/* Unwind the pre-pushed regs.  */
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|really_return
operator|||
operator|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|&&
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
operator|)
condition|)
return|return
literal|""
return|;
comment|/* Generate the return instruction.  */
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
case|case
name|ARM_FT_EXCEPTION_HANDLER
case|:
comment|/* Even in 26-bit mode we do a mov (rather than a movs) 	 because we don't have the PSR bits set in the address.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|EXCEPTION_LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_ISR
case|:
case|case
name|ARM_FT_FIQ
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsubs\t%r, %r, #4\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmovs\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|frame_pointer_needed
condition|)
comment|/* If we used the frame pointer then the return address 	   will have been loaded off the stack directly into the 	   PC, so there is no need to issue a MOV instruction 	   here.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|current_function_pretend_args_size
operator|==
literal|0
operator|&&
operator|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
condition|)
comment|/* Similarly we may have been able to load LR into the PC 	   even if we did not create a stack frame.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TARGET_APCS_32
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmovs\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|frame_size
parameter_list|)
block|{
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
comment|/* ??? Probably not safe to set this here, since it assumes that a 	 function will be emitted as assembly immediately after we generate 	 RTL for it.  This does not happen for inline functions.  */
name|return_used_this_function
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to take into account any stack-frame rounding.  */
name|frame_size
operator|=
name|arm_get_frame_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_return_insn
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|)
operator|&&
name|return_used_this_function
operator|&&
operator|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|frame_pointer_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Reset the ARM-specific per-function variables.  */
name|after_arm_reorg
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate and emit an insn that we will recognize as a push_multi.    Unfortunately, since this insn does not reflect very well the actual    semantics of the operation, we need to annotate the insn for the benefit    of DWARF2 frame unwind information.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_multi_reg_push
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
name|int
name|num_regs
init|=
literal|0
decl_stmt|;
name|int
name|num_dwarf_regs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|par
decl_stmt|;
name|rtx
name|dwarf
decl_stmt|;
name|int
name|dwarf_par_index
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|num_regs
operator|++
expr_stmt|;
if|if
condition|(
name|num_regs
operator|==
literal|0
operator|||
name|num_regs
operator|>
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We don't record the PC in the dwarf frame information.  */
name|num_dwarf_regs
operator|=
name|num_regs
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
condition|)
name|num_dwarf_regs
operator|--
expr_stmt|;
comment|/* For the body of the insn we are going to generate an UNSPEC in      parallel with several USEs.  This allows the insn to be recognized      by the push_multi pattern in the arm.md file.  The insn looks      something like this:         (parallel [             (set (mem:BLK (pre_dec:BLK (reg:SI sp))) 	        (unspec:BLK [(reg:SI r4)] UNSPEC_PUSH_MULT))            (use (reg:SI 11 fp))            (use (reg:SI 12 ip))            (use (reg:SI 14 lr))            (use (reg:SI 15 pc))         ])       For the frame note however, we try to be more explicit and actually      show each register being stored into the stack frame, plus a (single)      decrement of the stack pointer.  We do it this way in order to be      friendly to the stack unwinding code, which only wants to see a single      stack decrement per instruction.  The RTL we generate for the note looks      something like this:        (sequence [             (set (reg:SI sp) (plus:SI (reg:SI sp) (const_int -20)))            (set (mem:SI (reg:SI sp)) (reg:SI r4))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 4))) (reg:SI fp))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 8))) (reg:SI ip))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 12))) (reg:SI lr))         ])        This sequence is used both by the code to support stack unwinding for       exceptions handlers and the code to generate dwarf2 frame debugging.  */
name|par
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num_regs
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num_dwarf_regs
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf_par_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
name|UNSPEC_PUSH_MULT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|PC_REGNUM
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|dwarf_par_index
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|dwarf_par_index
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|i
operator|++
init|;
name|j
operator|<
name|num_regs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|PC_REGNUM
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|4
operator|*
name|j
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|dwarf_par_index
operator|++
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
name|par
operator|=
name|emit_insn
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
operator|*
name|num_regs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|REG_NOTES
argument_list|(
name|par
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|par
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|par
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|emit_sfm
parameter_list|(
name|int
name|base_reg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|rtx
name|par
decl_stmt|;
name|rtx
name|dwarf
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|par
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|base_reg
operator|++
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
name|UNSPEC_PUSH_MULT
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|count
operator|-
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|base_reg
operator|++
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|count
operator|-
name|i
operator|-
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
name|par
operator|=
name|emit_insn
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|par
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|par
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|par
return|;
block|}
end_function

begin_comment
comment|/* Compute the distance from register FROM to register TO.    These can be the arg pointer (26), the soft frame pointer (25),    the stack pointer (13) or the hard frame pointer (11).    Typical stack layout looks like this:         old stack pointer -> |    |                              ----                             |    | \                             |    |   saved arguments for                             |    |   vararg functions 			    |    | /                               --    hard FP& arg pointer -> |    | \                             |    |   stack                             |    |   frame                             |    | /                               --                             |    | \                             |    |   call saved                             |    |   registers       soft frame pointer -> |    | /                               --                             |    | \                             |    |   local                             |    |   variables                             |    | /                               --                             |    | \                             |    |   outgoing                             |    |   arguments    current stack pointer -> |    | /                               --    For a given function some or all of these stack components   may not be needed, giving rise to the possibility of   eliminating some of the registers.    The values returned by this function must reflect the behavior   of arm_expand_prologue() and arm_compute_save_reg_mask().    The sign of the number returned reflects the direction of stack   growth, so the values are positive for all eliminations except   from the soft frame pointer to the hard frame pointer.  */
end_comment

begin_function
name|unsigned
name|int
name|arm_compute_initial_elimination_offset
parameter_list|(
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|)
block|{
name|unsigned
name|int
name|local_vars
init|=
name|arm_get_frame_size
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|outgoing_args
init|=
name|current_function_outgoing_args_size
decl_stmt|;
name|unsigned
name|int
name|stack_frame
decl_stmt|;
name|unsigned
name|int
name|call_saved_registers
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Volatile functions never return, so there is      no need to save call saved registers.  */
name|call_saved_registers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|reg_mask
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Make sure that we compute which registers will be saved 	 on the stack using the same algorithm that is used by 	 the prologue creation code.  */
name|reg_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
comment|/* Now count the number of bits set in save_reg_mask. 	 If we have already counted the registers in the stack 	 frame, do not count them again.  Non call-saved registers 	 might be saved in the call-save area of the stack, if 	 doing so will preserve the stack's alignment.  Hence we 	 must count them here.  For each set bit we need 4 bytes 	 of stack space.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|reg_mask
operator|&=
literal|0x07ff
expr_stmt|;
name|call_saved_registers
operator|+=
literal|4
operator|*
name|bit_count
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
comment|/* If the hard floating point registers are going to be 	 used then they must be saved on the stack as well.          Each register occupies 12 bytes of stack space.  */
for|for
control|(
name|reg
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|reg
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|call_saved_registers
operator|+=
literal|12
expr_stmt|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
comment|/* Check for the call-saved iWMMXt registers.  */
for|for
control|(
name|reg
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|reg
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|call_saved_registers
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* The stack frame contains 4 registers - the old frame pointer,      the old stack pointer, the return address and PC of the start      of the function.  */
name|stack_frame
operator|=
name|frame_pointer_needed
condition|?
literal|16
else|:
literal|0
expr_stmt|;
comment|/* OK, now we have enough information to compute the distances.      There must be an entry in these switch tables for each pair      of registers in ELIMINABLE_REGS, even if some of the entries      seem to be redundant or useless.  */
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|ARG_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|THUMB_HARD_FRAME_POINTER_REGNUM
case|:
return|return
literal|0
return|;
case|case
name|FRAME_POINTER_REGNUM
case|:
comment|/* This is the reverse of the soft frame pointer 	     to hard frame pointer elimination below.  */
if|if
condition|(
name|call_saved_registers
operator|==
literal|0
operator|&&
name|stack_frame
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|call_saved_registers
operator|+
name|stack_frame
operator|-
literal|4
operator|)
return|;
case|case
name|ARM_HARD_FRAME_POINTER_REGNUM
case|:
comment|/* If there is no stack frame then the hard 	     frame pointer and the arg pointer coincide.  */
if|if
condition|(
name|stack_frame
operator|==
literal|0
operator|&&
name|call_saved_registers
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */
return|return
operator|(
name|frame_pointer_needed
operator|&&
name|current_function_needs_context
operator|&&
operator|!
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
operator|)
condition|?
literal|4
else|:
literal|0
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
comment|/* If nothing has been pushed on the stack at all 	     then this will return -4.  This *is* correct!  */
return|return
name|call_saved_registers
operator|+
name|stack_frame
operator|+
name|local_vars
operator|+
name|outgoing_args
operator|-
literal|4
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FRAME_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|THUMB_HARD_FRAME_POINTER_REGNUM
case|:
return|return
literal|0
return|;
case|case
name|ARM_HARD_FRAME_POINTER_REGNUM
case|:
comment|/* The hard frame pointer points to the top entry in the 	     stack frame.  The soft frame pointer to the bottom entry 	     in the stack frame.  If there is no stack frame at all, 	     then they are identical.  */
if|if
condition|(
name|call_saved_registers
operator|==
literal|0
operator|&&
name|stack_frame
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|-
operator|(
name|call_saved_registers
operator|+
name|stack_frame
operator|-
literal|4
operator|)
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
return|return
name|local_vars
operator|+
name|outgoing_args
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|/* You cannot eliminate from the stack pointer. 	 In theory you could eliminate from the hard frame 	 pointer to the stack pointer, but this will never 	 happen, since if a stack frame is not needed the 	 hard frame pointer will never be used.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Calculate the size of the stack frame, taking into account any    padding that is required to ensure stack-alignment.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|arm_get_frame_size
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|base_size
init|=
name|ROUND_UP_WORD
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|entry_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|func_type
init|=
name|arm_current_func_type
argument_list|()
decl_stmt|;
name|int
name|leaf
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_ARM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ATPCS
condition|)
return|return
name|base_size
return|;
comment|/* We need to know if we are a leaf function.  Unfortunately, it      is possible to be called after start_sequence has been called,      which causes get_insns to return the insns for the sequence,      not the function, which will cause leaf_function_p to return      the incorrect result.       To work around this, we cache the computed frame size.  This      works because we will only be calling RTL expanders that need      to know about leaf functions once reload has completed, and the      frame size cannot be changed after that time, so we can safely      use the cached value.  */
if|if
condition|(
name|reload_completed
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|frame_size
return|;
name|leaf
operator|=
name|leaf_function_p
argument_list|()
expr_stmt|;
comment|/* A leaf function does not need any stack alignment if it has nothing      on the stack.  */
if|if
condition|(
name|leaf
operator|&&
name|base_size
operator|==
literal|0
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We know that SP will be word aligned on entry, and we must      preserve that condition at any subroutine call.  But those are      the only constraints.  */
comment|/* Space for variadic functions.  */
if|if
condition|(
name|current_function_pretend_args_size
condition|)
name|entry_size
operator|+=
name|current_function_pretend_args_size
expr_stmt|;
comment|/* Space for saved registers.  */
name|entry_size
operator|+=
name|bit_count
argument_list|(
name|arm_compute_save_reg_mask
argument_list|()
argument_list|)
operator|*
literal|4
expr_stmt|;
comment|/* Space for saved FPA registers.  */
if|if
condition|(
operator|!
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
for|for
control|(
name|regno
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|regno
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|entry_size
operator|+=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
block|{
comment|/* Check for the call-saved iWMMXt registers.  */
for|for
control|(
name|regno
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|regno
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|entry_size
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry_size
operator|+
name|base_size
operator|+
name|current_function_outgoing_args_size
operator|)
operator|&
literal|7
condition|)
name|base_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|entry_size
operator|+
name|base_size
operator|+
name|current_function_outgoing_args_size
operator|)
operator|&
literal|7
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|=
name|base_size
expr_stmt|;
return|return
name|base_size
return|;
block|}
end_function

begin_comment
comment|/* Generate the prologue instructions for entry into an ARM function.  */
end_comment

begin_function
name|void
name|arm_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|rtx
name|amount
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ip_rtx
decl_stmt|;
name|unsigned
name|long
name|live_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|int
name|fp_offset
init|=
literal|0
decl_stmt|;
name|int
name|saved_pretend_args
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|args_to_push
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return;
comment|/* Make a copy of c_f_p_a_s as we may need to modify it locally.  */
name|args_to_push
operator|=
name|current_function_pretend_args_size
expr_stmt|;
comment|/* Compute which register we will have to save onto the stack.  */
name|live_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
name|ip_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Interrupt functions must not corrupt any registers. 	     Creating a frame pointer however, corrupts the IP 	     register, so we must push it first.  */
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
literal|1
operator|<<
name|IP_REGNUM
argument_list|)
expr_stmt|;
comment|/* Do not set RTX_FRAME_RELATED_P on this insn. 	     The dwarf stack unwinding code only wants to see one 	     stack decrement per function, and this is not it.  If 	     this instruction is labeled as being part of the frame 	     creation sequence then dwarf2out_frame_debug_expr will 	     abort when it encounters the assignment of IP to FP 	     later on, since the use of SP here establishes SP as 	     the CFA register and not IP.  	     Anyway this instruction is not really part of the stack 	     frame creation although it is part of the prologue.  */
block|}
elseif|else
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* The Static chain register is the same as the IP register 	     used as a scratch register during stack frame creation. 	     To get around this need to find somewhere to store IP 	     whilst the frame is being created.  We try the following 	     places in order: 	      	       1. The last argument register. 	       2. A slot on the stack above the frame.  (This only 	          works if the function is not a varargs function). 	       3. Register r3, after pushing the argument registers 	          onto the stack.  	     Note - we only need to tell the dwarf2 backend about the SP 	     adjustment in the second variant; the static chain register 	     doesn't need to be unwound, as it doesn't contain a value 	     inherited from the caller.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|==
literal|0
condition|)
block|{
name|insn
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args_to_push
operator|==
literal|0
condition|)
block|{
name|rtx
name|dwarf
decl_stmt|;
name|insn
operator|=
name|gen_rtx_PRE_DEC
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fp_offset
operator|=
literal|4
expr_stmt|;
comment|/* Just tell the dwarf backend that we adjusted SP.  */
name|dwarf
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|fp_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Store the args on the stack.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
condition|)
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
operator|(
literal|0xf0
operator|>>
operator|(
name|args_to_push
operator|/
literal|4
operator|)
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|args_to_push
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved_pretend_args
operator|=
literal|1
expr_stmt|;
name|fp_offset
operator|=
name|args_to_push
expr_stmt|;
name|args_to_push
operator|=
literal|0
expr_stmt|;
comment|/* Now reuse r3 to preserve IP.  */
name|insn
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp_offset
condition|)
block|{
name|insn
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|fp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|ip_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|insn
operator|=
name|gen_movsi
argument_list|(
name|ip_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|args_to_push
condition|)
block|{
comment|/* Push the argument registers, or reserve space for them.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
condition|)
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
operator|(
literal|0xf0
operator|>>
operator|(
name|args_to_push
operator|/
literal|4
operator|)
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|args_to_push
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is an interrupt service routine, and the link register      is going to be pushed, and we are not creating a stack frame,      (which would involve an extra push of IP and a pop in the epilogue)      subtracting four from LR now will mean that the function return      can be done with a single instruction.  */
if|if
condition|(
operator|(
name|func_type
operator|==
name|ARM_FT_ISR
operator|||
name|func_type
operator|==
name|ARM_FT_FIQ
operator|)
operator|&&
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|frame_pointer_needed
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|live_regs_mask
condition|)
block|{
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
name|live_regs_mask
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IWMMXT
condition|)
for|for
control|(
name|reg
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|reg
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|insn
operator|=
name|gen_rtx_PRE_DEC
argument_list|(
name|V2SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_MEM
argument_list|(
name|V2SImode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|gen_rtx_REG
argument_list|(
name|V2SImode
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Save any floating point call-saved registers used by this 	 function.  */
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FPUTYPE_FPA_EMU2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|LAST_ARM_FP_REGNUM
init|;
name|reg
operator|>=
name|FIRST_ARM_FP_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|insn
operator|=
name|gen_rtx_PRE_DEC
argument_list|(
name|XFmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|start_reg
init|=
name|LAST_ARM_FP_REGNUM
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_ARM_FP_REGNUM
init|;
name|reg
operator|>=
name|FIRST_ARM_FP_REGNUM
condition|;
name|reg
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
if|if
condition|(
name|start_reg
operator|-
name|reg
operator|==
literal|3
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* Create the new frame pointer.  */
name|insn
operator|=
name|GEN_INT
argument_list|(
operator|-
operator|(
literal|4
operator|+
name|args_to_push
operator|+
name|fp_offset
operator|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|ip_rtx
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Recover the static chain register.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|saved_pretend_args
condition|)
name|insn
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
comment|/* if (current_function_pretend_args_size == 0) */
block|{
name|insn
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|ip_rtx
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add a USE to stop propagate_one_insn() from barfing.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|ip_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|amount
operator|=
name|GEN_INT
argument_list|(
operator|-
operator|(
name|arm_get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|!=
name|const0_rtx
condition|)
block|{
comment|/* This add can produce multiple insns for a large constant, so we 	 need to get tricky.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|amount
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|last
operator|=
name|last
condition|?
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
else|:
name|get_insns
argument_list|()
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|last
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|last
operator|!=
name|insn
condition|)
do|;
comment|/* If the frame pointer is needed, emit a special barrier that 	 will prevent the scheduler from moving stores to the frame 	 before the stack adjustment.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_stack_tie
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are profiling, make sure no instructions are scheduled before      the call to mcount.  Similarly if the user has requested no      scheduling in the prolog.  */
if|if
condition|(
name|current_function_profile
operator|||
name|TARGET_NO_SCHED_PRO
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If the link register is being kept alive, with the return address in it,      then make sure that it does not get reused by the ce2 pass.  */
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If CODE is 'd', then the X is a condition operand and the instruction    should only be executed if the condition is true.    if CODE is 'D', then the X is a condition operand and the instruction    should only be executed if the condition is false: however, if the mode    of the comparison is CCFPEmode, then always execute the instruction -- we    do this because in these circumstances !GE does not necessarily imply LT;    in these cases the instruction pattern will take care to make sure that    an instruction containing %d will follow, thereby undoing the effects of    doing this instruction unconditionally.    If CODE is 'N' then X is a floating point operand that must be negated    before output.    If CODE is 'B' then output a bitwise inverted value of X (a const int).    If X is a REG and CODE is `M', output a ldm/stm style multi-reg.  */
end_comment

begin_function
name|void
name|arm_print_operand
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'@'
case|:
name|fputs
argument_list|(
name|ASM_COMMENT_START
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'_'
case|:
name|fputs
argument_list|(
name|user_label_prefix
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'|'
case|:
name|fputs
argument_list|(
name|REGISTER_PREFIX
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'?'
case|:
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
operator|||
name|arm_ccfsm_state
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|TARGET_THUMB
operator|||
name|current_insn_predicate
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|arm_current_cc
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_insn_predicate
condition|)
block|{
name|enum
name|arm_cond_code
name|code
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
name|abort
argument_list|()
expr_stmt|;
name|code
operator|=
name|get_arm_condition_code
argument_list|(
name|current_insn_predicate
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|code
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'N'
case|:
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|fp_const_from_val
argument_list|(
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'B'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|val
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'~'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|stream
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'i'
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arithmetic_instr
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* Truncate Cirrus shift counts.  */
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
return|return;
block|}
name|arm_print_operand
argument_list|(
name|stream
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arithmetic_instr
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
block|{
name|HOST_WIDE_INT
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|shift
init|=
name|shift_op
argument_list|(
name|x
argument_list|,
operator|&
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", %s "
argument_list|,
name|shift_op
argument_list|(
name|x
argument_list|,
operator|&
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|arm_print_operand
argument_list|(
name|stream
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
comment|/* An explanation of the 'Q', 'R' and 'H' register operands: 	  	 In a pair of registers containing a DI or DF value the 'Q' 	 operand returns the register number of the register containing 	 the least significant part of the value.  The 'R' operand returns 	 the register number of the register containing the most 	 significant part of the value. 	  	 The 'H' operand returns the higher of the two register numbers. 	 On a run where WORDS_BIG_ENDIAN is true the 'H' operand is the 	 same as the 'Q' operand, since the most significant part of the 	 value is held in the lower number register.  The reverse is true 	 on systems where WORDS_BIG_ENDIAN is false. 	  	 The purpose of these operands is to distinguish between cases 	 where the endian-ness of the values is important (for example 	 when they are added together), and cases where the endian-ness 	 is irrelevant, but the order of register operations is important. 	 For example when loading a value from memory into a register 	 pair, the endian-ness does not matter.  Provided that the value 	 from the lower memory address is put into the lower numbered 	 register, and the value from the higher address is put into the 	 higher numbered register, the load will work regardless of whether 	 the value being loaded is big-wordian or little-wordian.  The 	 order of the two register loads can matter however, if the address 	 of the memory location is actually held in one of the registers 	 being overwritten by the load.  */
case|case
literal|'Q'
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"{%r-%r}"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|ARM_NUM_REGS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'d'
case|:
comment|/* CONST_TRUE_RTX means always -- that's the default.  */
if|if
condition|(
name|x
operator|==
name|const_true_rtx
condition|)
return|return;
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|get_arm_condition_code
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
comment|/* CONST_TRUE_RTX means not always -- ie never.  We shouldn't ever 	 want to do that.  */
if|if
condition|(
name|x
operator|==
name|const_true_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|get_arm_condition_code
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
comment|/* Cirrus registers can be accessed in a variety of ways:          single floating point (f) 	 double floating point (d) 	 32bit integer         (fx) 	 64bit integer         (dx).  */
case|case
literal|'W'
case|:
comment|/* Cirrus register in F mode.  */
case|case
literal|'X'
case|:
comment|/* Cirrus register in D mode.  */
case|case
literal|'Y'
case|:
comment|/* Cirrus register in FX mode.  */
case|case
literal|'Z'
case|:
comment|/* Cirrus register in DX mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CIRRUS_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"mv%s%s"
argument_list|,
name|code
operator|==
literal|'W'
condition|?
literal|"f"
else|:
name|code
operator|==
literal|'X'
condition|?
literal|"d"
else|:
name|code
operator|==
literal|'Y'
condition|?
literal|"fx"
else|:
literal|"dx"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
comment|/* Print cirrus register in the mode specified by the register's mode.  */
case|case
literal|'V'
case|:
block|{
name|int
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CIRRUS_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"mv%s%s"
argument_list|,
name|mode
operator|==
name|DFmode
condition|?
literal|"d"
else|:
name|mode
operator|==
name|SImode
condition|?
literal|"fx"
else|:
name|mode
operator|==
name|DImode
condition|?
literal|"dx"
else|:
literal|"f"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'U'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_IWMMXT_GR_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_IWMMXT_GR_REGNUM
condition|)
comment|/* Bad value for wCG register number.  */
name|abort
argument_list|()
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_IWMMXT_GR_REGNUM
argument_list|)
expr_stmt|;
return|return;
comment|/* Print an iWMMXt control register name.  */
case|case
literal|'w'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|16
condition|)
comment|/* Bad value for wC register number.  */
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|wc_reg_names
index|[
literal|16
index|]
init|=
block|{
literal|"wCID"
block|,
literal|"wCon"
block|,
literal|"wCSSF"
block|,
literal|"wCASF"
block|,
literal|"wC4"
block|,
literal|"wC5"
block|,
literal|"wC6"
block|,
literal|"wC7"
block|,
literal|"wCGR0"
block|,
literal|"wCGR1"
block|,
literal|"wCGR2"
block|,
literal|"wCGR3"
block|,
literal|"wC12"
block|,
literal|"wC13"
block|,
literal|"wC14"
block|,
literal|"wC15"
block|}
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|wc_reg_names
index|[
name|INTVAL
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|output_memory_reference_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#%s"
argument_list|,
name|fp_immediate_constant
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This should never happen now.  */
else|else
block|{
name|fputc
argument_list|(
literal|'#'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|stream
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
end_ifndef

begin_comment
comment|/* Target hook for assembling integer objects.  The ARM version needs to    handle word-sized values specially.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|UNITS_PER_WORD
operator|&&
name|aligned_p
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.word\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Mark symbols as position independent.  We only do this in the 	 .text segment, not in the .data segment.  */
if|if
condition|(
name|NEED_GOT_RELOC
operator|&&
name|flag_pic
operator|&&
name|making_const_table
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|||
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
name|fputs
argument_list|(
literal|"(GOTOFF)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|fputs
argument_list|(
literal|"(GOTOFF)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"(GOT)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|VECTOR_MODE_SUPPORTED_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|units
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_VECTOR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|V2SImode
case|:
name|size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|V8QImode
case|:
name|size
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
decl_stmt|;
name|elt
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|elt
argument_list|,
name|size
argument_list|,
name|i
operator|==
literal|0
condition|?
name|BIGGEST_ALIGNMENT
else|:
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* A finite state machine takes care of noticing whether or not instructions    can be conditionally executed, and thus decrease execution time and code    size by deleting branch instructions.  The fsm is controlled by    final_prescan_insn, and controls the actions of ASM_OUTPUT_OPCODE.  */
end_comment

begin_comment
comment|/* The state of the fsm controlling condition codes are:    0: normal, do nothing special    1: make ASM_OUTPUT_OPCODE not output this instruction    2: make ASM_OUTPUT_OPCODE not output this instruction    3: make instructions conditional    4: make instructions conditional     State transitions (state->state by whom under condition):    0 -> 1 final_prescan_insn if the `target' is a label    0 -> 2 final_prescan_insn if the `target' is an unconditional branch    1 -> 3 ASM_OUTPUT_OPCODE after not having output the conditional branch    2 -> 4 ASM_OUTPUT_OPCODE after not having output the conditional branch    3 -> 0 (*targetm.asm_out.internal_label) if the `target' label is reached           (the target label has CODE_LABEL_NUMBER equal to arm_target_label).    4 -> 0 final_prescan_insn if the `target' unconditional branch is reached           (the target insn is arm_target_insn).     If the jump clobbers the conditions then we use states 2 and 4.     A similar thing can be done with conditional return insns.     XXX In case the `target' is an unconditional branch, this conditionalising    of the instructions always reduces code size, but not always execution    time.  But then, I want to reduce the code size to somewhere near what    /bin/cc produces.  */
end_comment

begin_comment
comment|/* Returns the index of the ARM condition code string in    `arm_condition_codes'.  COMPARISON should be an rtx like    `(eq (...) (...))'.  */
end_comment

begin_function
specifier|static
name|enum
name|arm_cond_code
name|get_arm_condition_code
parameter_list|(
name|rtx
name|comparison
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
name|enum
name|rtx_code
name|comp_code
init|=
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
name|mode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|comp_code
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CC_DNEmode
case|:
name|code
operator|=
name|ARM_NE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DEQmode
case|:
name|code
operator|=
name|ARM_EQ
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGEmode
case|:
name|code
operator|=
name|ARM_GE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGTmode
case|:
name|code
operator|=
name|ARM_GT
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLEmode
case|:
name|code
operator|=
name|ARM_LE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLTmode
case|:
name|code
operator|=
name|ARM_LT
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGEUmode
case|:
name|code
operator|=
name|ARM_CS
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGTUmode
case|:
name|code
operator|=
name|ARM_HI
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLEUmode
case|:
name|code
operator|=
name|ARM_LS
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLTUmode
case|:
name|code
operator|=
name|ARM_CC
expr_stmt|;
name|dominance
label|:
if|if
condition|(
name|comp_code
operator|!=
name|EQ
operator|&&
name|comp_code
operator|!=
name|NE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|comp_code
operator|==
name|EQ
condition|)
return|return
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|code
argument_list|)
return|;
return|return
name|code
return|;
case|case
name|CC_NOOVmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_PL
return|;
case|case
name|LT
case|:
return|return
name|ARM_MI
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_Zmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_Nmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_MI
return|;
case|case
name|EQ
case|:
return|return
name|ARM_PL
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CCFPEmode
case|:
case|case
name|CCFPmode
case|:
comment|/* These encodings assume that AC=1 in the FPA system control 	 byte.  This allows us to handle all cases except UNEQ and 	 LTGT.  */
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|GE
case|:
return|return
name|ARM_GE
return|;
case|case
name|GT
case|:
return|return
name|ARM_GT
return|;
case|case
name|LE
case|:
return|return
name|ARM_LS
return|;
case|case
name|LT
case|:
return|return
name|ARM_MI
return|;
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|ORDERED
case|:
return|return
name|ARM_VC
return|;
case|case
name|UNORDERED
case|:
return|return
name|ARM_VS
return|;
case|case
name|UNLT
case|:
return|return
name|ARM_LT
return|;
case|case
name|UNLE
case|:
return|return
name|ARM_LE
return|;
case|case
name|UNGT
case|:
return|return
name|ARM_HI
return|;
case|case
name|UNGE
case|:
return|return
name|ARM_PL
return|;
comment|/* UNEQ and LTGT do not have a representation.  */
case|case
name|UNEQ
case|:
comment|/* Fall through.  */
case|case
name|LTGT
case|:
comment|/* Fall through.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_SWPmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_LE
return|;
case|case
name|GT
case|:
return|return
name|ARM_LT
return|;
case|case
name|LE
case|:
return|return
name|ARM_GE
return|;
case|case
name|LT
case|:
return|return
name|ARM_GT
return|;
case|case
name|GEU
case|:
return|return
name|ARM_LS
return|;
case|case
name|GTU
case|:
return|return
name|ARM_CC
return|;
case|case
name|LEU
case|:
return|return
name|ARM_CS
return|;
case|case
name|LTU
case|:
return|return
name|ARM_HI
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_Cmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|LTU
case|:
return|return
name|ARM_CS
return|;
case|case
name|GEU
case|:
return|return
name|ARM_CC
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CCmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_GE
return|;
case|case
name|GT
case|:
return|return
name|ARM_GT
return|;
case|case
name|LE
case|:
return|return
name|ARM_LE
return|;
case|case
name|LT
case|:
return|return
name|ARM_LT
return|;
case|case
name|GEU
case|:
return|return
name|ARM_CS
return|;
case|case
name|GTU
case|:
return|return
name|ARM_HI
return|;
case|case
name|LEU
case|:
return|return
name|ARM_LS
return|;
case|case
name|LTU
case|:
return|return
name|ARM_CC
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_final_prescan_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* BODY will hold the body of INSN.  */
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* This will be 1 if trying to repeat the trick, and things need to be      reversed if it appears to fail.  */
name|int
name|reverse
init|=
literal|0
decl_stmt|;
comment|/* JUMP_CLOBBERS will be one implies that the conditions if a branch is      taken are clobbered, even if the rtl suggests otherwise.  It also      means that we have to grub around within the jump expression to find      out what the conditions are when the jump isn't taken.  */
name|int
name|jump_clobbers
init|=
literal|0
decl_stmt|;
comment|/* If we start with a return insn, we only succeed if we find another one.  */
name|int
name|seeking_return
init|=
literal|0
decl_stmt|;
comment|/* START_INSN will hold the insn from where we start looking.  This is the      first insn after the following code_label if REVERSE is true.  */
name|rtx
name|start_insn
init|=
name|insn
decl_stmt|;
comment|/* If in state 4, check if the target branch is reached, in order to      change back to state 0.  */
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|arm_target_insn
condition|)
block|{
name|arm_target_insn
operator|=
name|NULL
expr_stmt|;
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
comment|/* If in state 3, it is possible to repeat the trick, if this insn is an      unconditional branch to a label, and immediately following this branch      is the previous target label which is only used once, and the label this      branch jumps to is not too far off.  */
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* XXX Isn't this always a barrier?  */
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|start_insn
argument_list|)
operator|==
name|arm_target_label
operator|&&
name|LABEL_NUSES
argument_list|(
name|start_insn
argument_list|)
operator|==
literal|1
condition|)
name|reverse
operator|=
name|TRUE
expr_stmt|;
else|else
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|start_insn
argument_list|)
operator|==
name|arm_target_label
operator|&&
name|LABEL_NUSES
argument_list|(
name|start_insn
argument_list|)
operator|==
literal|1
condition|)
block|{
name|reverse
operator|=
name|TRUE
expr_stmt|;
name|seeking_return
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return;
block|}
else|else
return|return;
block|}
if|if
condition|(
name|arm_ccfsm_state
operator|!=
literal|0
operator|&&
operator|!
name|reverse
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return;
comment|/* This jump might be paralleled with a clobber of the condition codes       the jump should always come first */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|body
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
operator|||
operator|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
name|int
name|insns_skipped
decl_stmt|;
name|int
name|fail
init|=
name|FALSE
decl_stmt|,
name|succeed
init|=
name|FALSE
decl_stmt|;
comment|/* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */
name|int
name|then_not_else
init|=
name|TRUE
decl_stmt|;
name|rtx
name|this_insn
init|=
name|start_insn
decl_stmt|,
name|label
init|=
literal|0
decl_stmt|;
comment|/* If the jump cannot be done with one instruction, we cannot  	 conditionally execute the instruction in the inverse case.  */
if|if
condition|(
name|get_attr_conds
argument_list|(
name|insn
argument_list|)
operator|==
name|CONDS_JUMP_CLOB
condition|)
block|{
name|jump_clobbers
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Register the insn jumped to.  */
if|if
condition|(
name|reverse
condition|)
block|{
if|if
condition|(
operator|!
name|seeking_return
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|then_not_else
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
name|seeking_return
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|seeking_return
operator|=
literal|1
expr_stmt|;
name|then_not_else
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* See how many insns this branch skips, and what kind of insns.  If all 	 insns are okay, and the label or unconditional branch to the same 	 label is not too far away, succeed.  */
for|for
control|(
name|insns_skipped
operator|=
literal|0
init|;
operator|!
name|fail
operator|&&
operator|!
name|succeed
operator|&&
name|insns_skipped
operator|++
operator|<
name|max_insns_skipped
condition|;
control|)
block|{
name|rtx
name|scanbody
decl_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_insn
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* Succeed if it is the target label, otherwise fail since 		 control falls in from somewhere else.  */
if|if
condition|(
name|this_insn
operator|==
name|label
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
comment|/* Succeed if the following insn is the target label. 		 Otherwise fail.   		 If return insns are used then the last insn in a function  		 will be a barrier.  */
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|this_insn
operator|==
name|label
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
comment|/* If using 32-bit addresses the cc is not preserved over 		 calls.  */
if|if
condition|(
name|TARGET_APCS_32
condition|)
block|{
comment|/* Succeed if the following insn is the target label, 		     or if the following two insns are a barrier and 		     the target label.  */
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|this_insn
operator|==
name|label
operator|&&
name|insns_skipped
operator|<
name|max_insns_skipped
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* If this is an unconditional branch to the same label, succeed. 		 If it is to another label, do nothing.  If it is conditional, 		 fail.  */
comment|/* XXX Probably, the tests for SET and the PC are 		 unnecessary.  */
name|scanbody
operator|=
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
operator|&&
operator|!
name|reverse
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Fail if a conditional return is undesirable (eg on a 		 StrongARM), but still allow this if optimizing for size.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|RETURN
operator|&&
operator|!
name|use_return_insn
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|!
name|optimize_size
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|RETURN
operator|&&
name|seeking_return
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
switch|switch
condition|(
name|get_attr_conds
argument_list|(
name|this_insn
argument_list|)
condition|)
block|{
case|case
name|CONDS_NOCOND
case|:
break|break;
default|default:
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
comment|/* Unrecognized jump (eg epilogue).  */
break|break;
case|case
name|INSN
case|:
comment|/* Instructions using or affecting the condition codes make it 		 fail.  */
name|scanbody
operator|=
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|PARALLEL
operator|)
operator|||
name|get_attr_conds
argument_list|(
name|this_insn
argument_list|)
operator|!=
name|CONDS_NOCOND
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
comment|/* A conditional cirrus instruction must be followed by 		 a non Cirrus instruction.  However, since we 		 conditionalize instructions in this function and by 		 the time we get here we can't add instructions 		 (nops), because shorten_branches() has already been 		 called, we will disable conditionalizing Cirrus 		 instructions to be safe.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|get_attr_cirrus
argument_list|(
name|this_insn
argument_list|)
operator|!=
name|CIRRUS_NOT
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|succeed
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|seeking_return
operator|)
operator|&&
operator|(
name|arm_ccfsm_state
operator|==
literal|1
operator|||
name|reverse
operator|)
condition|)
name|arm_target_label
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seeking_return
operator|||
name|arm_ccfsm_state
operator|==
literal|2
condition|)
block|{
while|while
condition|(
name|this_insn
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
name|BARRIER
operator|||
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_insn
condition|)
block|{
comment|/* Oh, dear! we ran off the end.. give up.  */
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
name|arm_target_insn
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|arm_target_insn
operator|=
name|this_insn
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|jump_clobbers
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arm_current_cc
operator|=
name|get_arm_condition_code
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NE
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from 		 what it was.  */
if|if
condition|(
operator|!
name|reverse
condition|)
name|arm_current_cc
operator|=
name|get_arm_condition_code
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reverse
operator|||
name|then_not_else
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
block|}
comment|/* Restore recog_data (getting the attributes of other insns can 	 destroy this array, but final.c assumes that it remains intact 	 across this call; since the insn has been recognized already we 	 call recog direct).  */
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if REGNO is a valid register    for holding a quantity of tyoe MODE.  */
end_comment

begin_function
name|int
name|arm_hard_regno_mode_ok
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
name|regno
operator|==
name|CC_REGNUM
return|;
if|if
condition|(
name|TARGET_THUMB
condition|)
comment|/* For the Thumb we only allow values bigger than SImode in        registers 0 - 6, so that there is always a second low        register available to hold the upper part of the value.        We probably we ought to ensure that the register is the        start of an even numbered register pair.  */
return|return
operator|(
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
operator|<
literal|2
operator|)
operator|||
operator|(
name|regno
operator|<
name|LAST_LO_REGNUM
operator|)
return|;
if|if
condition|(
name|IS_CIRRUS_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
comment|/* We have outlawed SI values in Cirrus registers because they        reside in the lower 32 bits, but SF values reside in the        upper 32 bits.  This causes gcc all sorts of grief.  We can't        even split the registers into pairs because Cirrus SI values        get sign extended to 64bits-- aldyh.  */
return|return
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|)
operator|||
operator|(
name|mode
operator|==
name|DImode
operator|)
return|;
if|if
condition|(
name|IS_IWMMXT_GR_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|mode
operator|==
name|SImode
return|;
if|if
condition|(
name|IS_IWMMXT_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|VALID_IWMMXT_REG_MODE
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
name|regno
operator|<=
name|LAST_ARM_REGNUM
condition|)
comment|/* We allow any value to be stored in the general registers.  */
return|return
literal|1
return|;
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
comment|/* We only allow integers in the fake hard registers.  */
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
return|;
comment|/* The only registers left are the FPA registers      which we only allow to hold FP values.  */
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|regno
operator|>=
name|FIRST_ARM_FP_REGNUM
operator|&&
name|regno
operator|<=
name|LAST_ARM_FP_REGNUM
return|;
block|}
end_function

begin_function
name|int
name|arm_regno_class
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
name|STACK_REG
return|;
if|if
condition|(
name|regno
operator|==
name|CC_REGNUM
condition|)
return|return
name|CC_REG
return|;
if|if
condition|(
name|regno
operator|<
literal|8
condition|)
return|return
name|LO_REGS
return|;
return|return
name|HI_REGS
return|;
block|}
if|if
condition|(
name|regno
operator|<=
name|LAST_ARM_REGNUM
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|GENERAL_REGS
return|;
if|if
condition|(
name|regno
operator|==
name|CC_REGNUM
condition|)
return|return
name|NO_REGS
return|;
if|if
condition|(
name|IS_CIRRUS_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|CIRRUS_REGS
return|;
if|if
condition|(
name|IS_IWMMXT_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|IWMMXT_REGS
return|;
if|if
condition|(
name|IS_IWMMXT_GR_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|IWMMXT_GR_REGS
return|;
return|return
name|FPA_REGS
return|;
block|}
end_function

begin_comment
comment|/* Handle a special case when computing the offset    of an argument from the frame pointer.  */
end_comment

begin_function
name|int
name|arm_debugger_arg_offset
parameter_list|(
name|int
name|value
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* We are only interested if dbxout_parms() failed to compute the offset.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We can only cope with the case where the address is held in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* If we are using the frame pointer to point at the argument, then      an offset of 0 is correct.  */
if|if
condition|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* If we are using the stack pointer to point at the      argument, then an offset of 0 is correct.  */
if|if
condition|(
operator|(
name|TARGET_THUMB
operator|||
operator|!
name|frame_pointer_needed
operator|)
operator|&&
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
name|SP_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* Oh dear.  The argument is pointed to by a register rather      than being held in a register, or being stored at a known      offset from the frame pointer.  Since GDB only understands      those two kinds of argument we must translate the address      held in the register into an offset from the frame pointer.      We do this by searching through the insns for the function      looking to see where this register gets its value.  If the      register is initialized from the frame pointer plus an offset      then we are in luck and we can continue, otherwise we give up.            This code is exercised by producing debugging information      for a function with arguments like this:                  double func (double a, double b, int c, double d) {return d;}            Without this code the stab for parameter 'd' will be set to      an offset of 0 from the frame pointer, rather than 8.  */
comment|/* The if() statement says:       If the insn is a normal instruction      and if the insn is setting the value in a register      and if the register being set is the register holding the address of the argument      and if the address is computing by an addition      that involves adding to a register      which is the frame pointer      a constant integer       then...  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|debug_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"unable to compute real location of stacked parameter"
argument_list|)
expr_stmt|;
name|value
operator|=
literal|8
expr_stmt|;
comment|/* XXX magic hack */
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|def_mbuiltin
parameter_list|(
name|MASK
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do									\     {									\       if ((MASK)& insn_flags)						\         builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL, NULL_TREE);	\     }									\   while (0)
end_define

begin_struct
struct|struct
name|builtin_description
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|arm_builtins
name|code
decl_stmt|;
specifier|const
name|enum
name|rtx_code
name|comparison
decl_stmt|;
specifier|const
name|unsigned
name|int
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
define|#
directive|define
name|IWMMXT_BUILTIN
parameter_list|(
name|code
parameter_list|,
name|string
parameter_list|,
name|builtin
parameter_list|)
define|\
value|{ FL_IWMMXT, CODE_FOR_##code, "__builtin_arm_" string, \     ARM_BUILTIN_##builtin, 0, 0 },
name|IWMMXT_BUILTIN
argument_list|(
argument|addv8qi3
argument_list|,
literal|"waddb"
argument_list|,
argument|WADDB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|addv4hi3
argument_list|,
literal|"waddh"
argument_list|,
argument|WADDH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|addv2si3
argument_list|,
literal|"waddw"
argument_list|,
argument|WADDW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|subv8qi3
argument_list|,
literal|"wsubb"
argument_list|,
argument|WSUBB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|subv4hi3
argument_list|,
literal|"wsubh"
argument_list|,
argument|WSUBH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|subv2si3
argument_list|,
literal|"wsubw"
argument_list|,
argument|WSUBW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ssaddv8qi3
argument_list|,
literal|"waddbss"
argument_list|,
argument|WADDSSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ssaddv4hi3
argument_list|,
literal|"waddhss"
argument_list|,
argument|WADDSSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ssaddv2si3
argument_list|,
literal|"waddwss"
argument_list|,
argument|WADDSSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sssubv8qi3
argument_list|,
literal|"wsubbss"
argument_list|,
argument|WSUBSSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sssubv4hi3
argument_list|,
literal|"wsubhss"
argument_list|,
argument|WSUBSSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sssubv2si3
argument_list|,
literal|"wsubwss"
argument_list|,
argument|WSUBSSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|usaddv8qi3
argument_list|,
literal|"waddbus"
argument_list|,
argument|WADDUSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|usaddv4hi3
argument_list|,
literal|"waddhus"
argument_list|,
argument|WADDUSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|usaddv2si3
argument_list|,
literal|"waddwus"
argument_list|,
argument|WADDUSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ussubv8qi3
argument_list|,
literal|"wsubbus"
argument_list|,
argument|WSUBUSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ussubv4hi3
argument_list|,
literal|"wsubhus"
argument_list|,
argument|WSUBUSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ussubv2si3
argument_list|,
literal|"wsubwus"
argument_list|,
argument|WSUBUSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|mulv4hi3
argument_list|,
literal|"wmulul"
argument_list|,
argument|WMULUL
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|smulv4hi3_highpart
argument_list|,
literal|"wmulsh"
argument_list|,
argument|WMULSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|umulv4hi3_highpart
argument_list|,
literal|"wmuluh"
argument_list|,
argument|WMULUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|eqv8qi3
argument_list|,
literal|"wcmpeqb"
argument_list|,
argument|WCMPEQB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|eqv4hi3
argument_list|,
literal|"wcmpeqh"
argument_list|,
argument|WCMPEQH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|eqv2si3
argument_list|,
literal|"wcmpeqw"
argument_list|,
argument|WCMPEQW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtuv8qi3
argument_list|,
literal|"wcmpgtub"
argument_list|,
argument|WCMPGTUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtuv4hi3
argument_list|,
literal|"wcmpgtuh"
argument_list|,
argument|WCMPGTUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtuv2si3
argument_list|,
literal|"wcmpgtuw"
argument_list|,
argument|WCMPGTUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtv8qi3
argument_list|,
literal|"wcmpgtsb"
argument_list|,
argument|WCMPGTSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtv4hi3
argument_list|,
literal|"wcmpgtsh"
argument_list|,
argument|WCMPGTSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtv2si3
argument_list|,
literal|"wcmpgtsw"
argument_list|,
argument|WCMPGTSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|umaxv8qi3
argument_list|,
literal|"wmaxub"
argument_list|,
argument|WMAXUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|smaxv8qi3
argument_list|,
literal|"wmaxsb"
argument_list|,
argument|WMAXSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|umaxv4hi3
argument_list|,
literal|"wmaxuh"
argument_list|,
argument|WMAXUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|smaxv4hi3
argument_list|,
literal|"wmaxsh"
argument_list|,
argument|WMAXSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|umaxv2si3
argument_list|,
literal|"wmaxuw"
argument_list|,
argument|WMAXUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|smaxv2si3
argument_list|,
literal|"wmaxsw"
argument_list|,
argument|WMAXSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|uminv8qi3
argument_list|,
literal|"wminub"
argument_list|,
argument|WMINUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sminv8qi3
argument_list|,
literal|"wminsb"
argument_list|,
argument|WMINSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|uminv4hi3
argument_list|,
literal|"wminuh"
argument_list|,
argument|WMINUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sminv4hi3
argument_list|,
literal|"wminsh"
argument_list|,
argument|WMINSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|uminv2si3
argument_list|,
literal|"wminuw"
argument_list|,
argument|WMINUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sminv2si3
argument_list|,
literal|"wminsw"
argument_list|,
argument|WMINSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_anddi3
argument_list|,
literal|"wand"
argument_list|,
argument|WAND
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_nanddi3
argument_list|,
literal|"wandn"
argument_list|,
argument|WANDN
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_iordi3
argument_list|,
literal|"wor"
argument_list|,
argument|WOR
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_xordi3
argument_list|,
literal|"wxor"
argument_list|,
argument|WXOR
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_uavgv8qi3
argument_list|,
literal|"wavg2b"
argument_list|,
argument|WAVG2B
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_uavgv4hi3
argument_list|,
literal|"wavg2h"
argument_list|,
argument|WAVG2H
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_uavgrndv8qi3
argument_list|,
literal|"wavg2br"
argument_list|,
argument|WAVG2BR
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_uavgrndv4hi3
argument_list|,
literal|"wavg2hr"
argument_list|,
argument|WAVG2HR
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckilb
argument_list|,
literal|"wunpckilb"
argument_list|,
argument|WUNPCKILB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckilh
argument_list|,
literal|"wunpckilh"
argument_list|,
argument|WUNPCKILH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckilw
argument_list|,
literal|"wunpckilw"
argument_list|,
argument|WUNPCKILW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckihb
argument_list|,
literal|"wunpckihb"
argument_list|,
argument|WUNPCKIHB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckihh
argument_list|,
literal|"wunpckihh"
argument_list|,
argument|WUNPCKIHH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckihw
argument_list|,
literal|"wunpckihw"
argument_list|,
argument|WUNPCKIHW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wmadds
argument_list|,
literal|"wmadds"
argument_list|,
argument|WMADDS
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wmaddu
argument_list|,
literal|"wmaddu"
argument_list|,
argument|WMADDU
argument_list|)
define|#
directive|define
name|IWMMXT_BUILTIN2
parameter_list|(
name|code
parameter_list|,
name|builtin
parameter_list|)
define|\
value|{ FL_IWMMXT, CODE_FOR_##code, NULL, ARM_BUILTIN_##builtin, 0, 0 },
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackhss
argument_list|,
argument|WPACKHSS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackwss
argument_list|,
argument|WPACKWSS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackdss
argument_list|,
argument|WPACKDSS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackhus
argument_list|,
argument|WPACKHUS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackwus
argument_list|,
argument|WPACKWUS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackdus
argument_list|,
argument|WPACKDUS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashlv4hi3_di
argument_list|,
argument|WSLLH
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashlv4hi3
argument_list|,
argument|WSLLHI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashlv2si3_di
argument_list|,
argument|WSLLW
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashlv2si3
argument_list|,
argument|WSLLWI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashldi3_di
argument_list|,
argument|WSLLD
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashldi3_iwmmxt
argument_list|,
argument|WSLLDI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrv4hi3_di
argument_list|,
argument|WSRLH
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrv4hi3
argument_list|,
argument|WSRLHI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrv2si3_di
argument_list|,
argument|WSRLW
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrv2si3
argument_list|,
argument|WSRLWI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrdi3_di
argument_list|,
argument|WSRLD
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrdi3
argument_list|,
argument|WSRLDI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrv4hi3_di
argument_list|,
argument|WSRAH
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrv4hi3
argument_list|,
argument|WSRAHI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrv2si3_di
argument_list|,
argument|WSRAW
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrv2si3
argument_list|,
argument|WSRAWI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrdi3_di
argument_list|,
argument|WSRAD
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrdi3
argument_list|,
argument|WSRADI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rorv4hi3_di
argument_list|,
argument|WRORH
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rorv4hi3
argument_list|,
argument|WRORHI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rorv2si3_di
argument_list|,
argument|WRORW
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rorv2si3
argument_list|,
argument|WRORWI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rordi3_di
argument_list|,
argument|WRORD
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rordi3
argument_list|,
argument|WRORDI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wmacuz
argument_list|,
argument|WMACUZ
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wmacsz
argument_list|,
argument|WMACSZ
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_tmovmskb
argument_list|,
literal|"tmovmskb"
argument_list|,
argument|TMOVMSKB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_tmovmskh
argument_list|,
literal|"tmovmskh"
argument_list|,
argument|TMOVMSKH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_tmovmskw
argument_list|,
literal|"tmovmskw"
argument_list|,
argument|TMOVMSKW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_waccb
argument_list|,
literal|"waccb"
argument_list|,
argument|WACCB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wacch
argument_list|,
literal|"wacch"
argument_list|,
argument|WACCH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_waccw
argument_list|,
literal|"waccw"
argument_list|,
argument|WACCW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehub
argument_list|,
literal|"wunpckehub"
argument_list|,
argument|WUNPCKEHUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehuh
argument_list|,
literal|"wunpckehuh"
argument_list|,
argument|WUNPCKEHUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehuw
argument_list|,
literal|"wunpckehuw"
argument_list|,
argument|WUNPCKEHUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehsb
argument_list|,
literal|"wunpckehsb"
argument_list|,
argument|WUNPCKEHSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehsh
argument_list|,
literal|"wunpckehsh"
argument_list|,
argument|WUNPCKEHSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehsw
argument_list|,
literal|"wunpckehsw"
argument_list|,
argument|WUNPCKEHSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckelub
argument_list|,
literal|"wunpckelub"
argument_list|,
argument|WUNPCKELUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckeluh
argument_list|,
literal|"wunpckeluh"
argument_list|,
argument|WUNPCKELUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckeluw
argument_list|,
literal|"wunpckeluw"
argument_list|,
argument|WUNPCKELUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckelsb
argument_list|,
literal|"wunpckelsb"
argument_list|,
argument|WUNPCKELSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckelsh
argument_list|,
literal|"wunpckelsh"
argument_list|,
argument|WUNPCKELSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckelsw
argument_list|,
literal|"wunpckelsw"
argument_list|,
argument|WUNPCKELSW
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up all the iWMMXt builtins.  This is    not called if TARGET_IWMMXT is zero.  */
end_comment

begin_function
specifier|static
name|void
name|arm_init_iwmmxt_builtins
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
name|tree
name|int_ftype_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v8qi_v8qi_int
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_int
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_di_di
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_int
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_int_int
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8qi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4hi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v2si
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8qi_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4hi_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v2si_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v8qi_int_int
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int_int
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_int_int
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Miscellaneous.  */
name|tree
name|v8qi_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v2si_v2si
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v8qi_v8qi
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_di
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_di
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_int_int
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_void
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v8qi
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v4hi
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v2si
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4hi
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v8qi
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Normal vector binops.  */
name|tree
name|v8qi_ftype_v8qi_v8qi
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_v2si
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_di
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Add all builtins that are more or less simple operations on two      operands.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
comment|/* Use one of the operands; the target can have a different mode for 	 mask-generating compares.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
condition|)
continue|continue;
name|mode
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V8QImode
case|:
name|type
operator|=
name|v8qi_ftype_v8qi_v8qi
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|type
operator|=
name|v4hi_ftype_v4hi_v4hi
expr_stmt|;
break|break;
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_v2si_v2si
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|type
operator|=
name|di_ftype_di_di
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|def_mbuiltin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the remaining MMX insns with somewhat more complicated types.  */
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wzero"
argument_list|,
name|di_ftype_void
argument_list|,
name|ARM_BUILTIN_WZERO
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_setwcx"
argument_list|,
name|void_ftype_int_int
argument_list|,
name|ARM_BUILTIN_SETWCX
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_getwcx"
argument_list|,
name|int_ftype_int
argument_list|,
name|ARM_BUILTIN_GETWCX
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsllh"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|ARM_BUILTIN_WSLLH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsllw"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|ARM_BUILTIN_WSLLW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wslld"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WSLLD
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsllhi"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WSLLHI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsllwi"
argument_list|,
name|v2si_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_WSLLWI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wslldi"
argument_list|,
name|di_ftype_di_int
argument_list|,
name|ARM_BUILTIN_WSLLDI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrlh"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|ARM_BUILTIN_WSRLH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrlw"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|ARM_BUILTIN_WSRLW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrld"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WSRLD
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrlhi"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WSRLHI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrlwi"
argument_list|,
name|v2si_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_WSRLWI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrldi"
argument_list|,
name|di_ftype_di_int
argument_list|,
name|ARM_BUILTIN_WSRLDI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrah"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|ARM_BUILTIN_WSRAH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsraw"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|ARM_BUILTIN_WSRAW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrad"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WSRAD
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrahi"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WSRAHI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrawi"
argument_list|,
name|v2si_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_WSRAWI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsradi"
argument_list|,
name|di_ftype_di_int
argument_list|,
name|ARM_BUILTIN_WSRADI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrorh"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|ARM_BUILTIN_WRORH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrorw"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|ARM_BUILTIN_WRORW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrord"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WRORD
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrorhi"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WRORHI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrorwi"
argument_list|,
name|v2si_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_WRORWI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrordi"
argument_list|,
name|di_ftype_di_int
argument_list|,
name|ARM_BUILTIN_WRORDI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wshufh"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WSHUFH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsadb"
argument_list|,
name|v2si_ftype_v8qi_v8qi
argument_list|,
name|ARM_BUILTIN_WSADB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsadh"
argument_list|,
name|v2si_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WSADH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsadbz"
argument_list|,
name|v2si_ftype_v8qi_v8qi
argument_list|,
name|ARM_BUILTIN_WSADBZ
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsadhz"
argument_list|,
name|v2si_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WSADHZ
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmsb"
argument_list|,
name|int_ftype_v8qi_int
argument_list|,
name|ARM_BUILTIN_TEXTRMSB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmsh"
argument_list|,
name|int_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_TEXTRMSH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmsw"
argument_list|,
name|int_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_TEXTRMSW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmub"
argument_list|,
name|int_ftype_v8qi_int
argument_list|,
name|ARM_BUILTIN_TEXTRMUB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmuh"
argument_list|,
name|int_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_TEXTRMUH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmuw"
argument_list|,
name|int_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_TEXTRMUW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tinsrb"
argument_list|,
name|v8qi_ftype_v8qi_int_int
argument_list|,
name|ARM_BUILTIN_TINSRB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tinsrh"
argument_list|,
name|v4hi_ftype_v4hi_int_int
argument_list|,
name|ARM_BUILTIN_TINSRH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tinsrw"
argument_list|,
name|v2si_ftype_v2si_int_int
argument_list|,
name|ARM_BUILTIN_TINSRW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_waccb"
argument_list|,
name|di_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WACCB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wacch"
argument_list|,
name|di_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WACCH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_waccw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WACCW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmovmskb"
argument_list|,
name|int_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_TMOVMSKB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmovmskh"
argument_list|,
name|int_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_TMOVMSKH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmovmskw"
argument_list|,
name|int_ftype_v2si
argument_list|,
name|ARM_BUILTIN_TMOVMSKW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackhss"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WPACKHSS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackhus"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WPACKHUS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackwus"
argument_list|,
name|v4hi_ftype_v2si_v2si
argument_list|,
name|ARM_BUILTIN_WPACKWUS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackwss"
argument_list|,
name|v4hi_ftype_v2si_v2si
argument_list|,
name|ARM_BUILTIN_WPACKWSS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackdus"
argument_list|,
name|v2si_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WPACKDUS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackdss"
argument_list|,
name|v2si_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WPACKDSS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehub"
argument_list|,
name|v4hi_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WUNPCKEHUB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehuh"
argument_list|,
name|v2si_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WUNPCKEHUH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehuw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WUNPCKEHUW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehsb"
argument_list|,
name|v4hi_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WUNPCKEHSB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehsh"
argument_list|,
name|v2si_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WUNPCKEHSH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehsw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WUNPCKEHSW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckelub"
argument_list|,
name|v4hi_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WUNPCKELUB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckeluh"
argument_list|,
name|v2si_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WUNPCKELUH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckeluw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WUNPCKELUW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckelsb"
argument_list|,
name|v4hi_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WUNPCKELSB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckelsh"
argument_list|,
name|v2si_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WUNPCKELSH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckelsw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WUNPCKELSW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wmacs"
argument_list|,
name|di_ftype_di_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WMACS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wmacsz"
argument_list|,
name|di_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WMACSZ
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wmacu"
argument_list|,
name|di_ftype_di_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WMACU
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wmacuz"
argument_list|,
name|di_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WMACUZ
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_walign"
argument_list|,
name|v8qi_ftype_v8qi_v8qi_int
argument_list|,
name|ARM_BUILTIN_WALIGN
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmia"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIA
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiaph"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIAPH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiabb"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIABB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiabt"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIABT
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiatb"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIATB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiatt"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIATT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
name|arm_init_iwmmxt_builtins
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Errors in the source file can cause expand_expr to return const0_rtx    where we expect a vector.  To avoid crashing, use one of the vector    clear instructions.  */
end_comment

begin_function
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|x
operator|!=
name|const0_rtx
condition|)
return|return
name|x
return|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iwmmxt_clrdi
argument_list|(
name|mode
operator|==
name|DImode
condition|?
name|x
else|:
name|gen_rtx_SUBREG
argument_list|(
name|DImode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of arm_expand_builtin to take care of binop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|arm_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
comment|/* In case the insn wants input operands in modes different from      the result, abort.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|||
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of arm_expand_builtin to take care of unop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|arm_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|do_load
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_load
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|arm_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|;
name|tree
name|arg1
decl_stmt|;
name|tree
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
decl_stmt|;
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|enum
name|machine_mode
name|mode2
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ARM_BUILTIN_TEXTRMSB
case|:
case|case
name|ARM_BUILTIN_TEXTRMUB
case|:
case|case
name|ARM_BUILTIN_TEXTRMSH
case|:
case|case
name|ARM_BUILTIN_TEXTRMUH
case|:
case|case
name|ARM_BUILTIN_TEXTRMSW
case|:
case|case
name|ARM_BUILTIN_TEXTRMUW
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|ARM_BUILTIN_TEXTRMSB
condition|?
name|CODE_FOR_iwmmxt_textrmsb
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TEXTRMUB
condition|?
name|CODE_FOR_iwmmxt_textrmub
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TEXTRMSH
condition|?
name|CODE_FOR_iwmmxt_textrmsh
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TEXTRMUH
condition|?
name|CODE_FOR_iwmmxt_textrmuh
else|:
name|CODE_FOR_iwmmxt_textrmw
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"selector must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_TINSRB
case|:
case|case
name|ARM_BUILTIN_TINSRH
case|:
case|case
name|ARM_BUILTIN_TINSRW
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|ARM_BUILTIN_TINSRB
condition|?
name|CODE_FOR_iwmmxt_tinsrb
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TINSRH
condition|?
name|CODE_FOR_iwmmxt_tinsrh
else|:
name|CODE_FOR_iwmmxt_tinsrw
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"selector must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_SETWCX
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iwmmxt_tmcr
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ARM_BUILTIN_GETWCX
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iwmmxt_tmrc
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_WSHUFH
case|:
name|icode
operator|=
name|CODE_FOR_iwmmxt_wshufh
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"mask must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_WSADB
case|:
return|return
name|arm_expand_binop_builtin
argument_list|(
name|CODE_FOR_iwmmxt_wsadb
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ARM_BUILTIN_WSADH
case|:
return|return
name|arm_expand_binop_builtin
argument_list|(
name|CODE_FOR_iwmmxt_wsadh
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ARM_BUILTIN_WSADBZ
case|:
return|return
name|arm_expand_binop_builtin
argument_list|(
name|CODE_FOR_iwmmxt_wsadbz
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ARM_BUILTIN_WSADHZ
case|:
return|return
name|arm_expand_binop_builtin
argument_list|(
name|CODE_FOR_iwmmxt_wsadhz
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Several three-argument builtins.  */
case|case
name|ARM_BUILTIN_WMACS
case|:
case|case
name|ARM_BUILTIN_WMACU
case|:
case|case
name|ARM_BUILTIN_WALIGN
case|:
case|case
name|ARM_BUILTIN_TMIA
case|:
case|case
name|ARM_BUILTIN_TMIAPH
case|:
case|case
name|ARM_BUILTIN_TMIATT
case|:
case|case
name|ARM_BUILTIN_TMIATB
case|:
case|case
name|ARM_BUILTIN_TMIABT
case|:
case|case
name|ARM_BUILTIN_TMIABB
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|ARM_BUILTIN_WMACS
condition|?
name|CODE_FOR_iwmmxt_wmacs
else|:
name|fcode
operator|==
name|ARM_BUILTIN_WMACU
condition|?
name|CODE_FOR_iwmmxt_wmacu
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIA
condition|?
name|CODE_FOR_iwmmxt_tmia
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIAPH
condition|?
name|CODE_FOR_iwmmxt_tmiaph
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIABB
condition|?
name|CODE_FOR_iwmmxt_tmiabb
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIABT
condition|?
name|CODE_FOR_iwmmxt_tmiabt
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIATB
condition|?
name|CODE_FOR_iwmmxt_tmiatb
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIATT
condition|?
name|CODE_FOR_iwmmxt_tmiatt
else|:
name|CODE_FOR_iwmmxt_walign
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_WZERO
case|:
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iwmmxt_clrdi
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
operator|(
specifier|const
expr|enum
name|arm_builtins
operator|)
name|fcode
condition|)
return|return
name|arm_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_1arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
operator|(
specifier|const
expr|enum
name|arm_builtins
operator|)
name|fcode
condition|)
return|return
name|arm_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
comment|/* @@@ Should really do something sensible here.  */
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recursively search through all of the blocks in a function    checking to see if any of the variables created in that    function match the RTX called 'orig'.  If they do then    replace them with the RTX called 'new'.  */
end_comment

begin_function
specifier|static
name|void
name|replace_symbols_in_block
parameter_list|(
name|tree
name|block
parameter_list|,
name|rtx
name|orig
parameter_list|,
name|rtx
name|new
parameter_list|)
block|{
for|for
control|(
init|;
name|block
condition|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
control|)
block|{
name|tree
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|block
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|sym
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|sym
condition|;
name|sym
operator|=
name|TREE_CHAIN
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|DECL_NAME
argument_list|(
name|sym
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|sym
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
name|DECL_IGNORED_P
argument_list|(
name|sym
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|sym
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|DECL_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|DECL_RTL
argument_list|(
name|sym
argument_list|)
argument_list|,
name|orig
argument_list|)
condition|)
continue|continue;
name|SET_DECL_RTL
argument_list|(
name|sym
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
name|replace_symbols_in_block
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|orig
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number (counting from 0) of    the least significant set bit in MASK.  */
end_comment

begin_function
specifier|inline
specifier|static
name|int
name|number_of_first_bit_set
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
name|int
name|bit
decl_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
condition|;
operator|++
name|bit
control|)
continue|continue;
return|return
name|bit
return|;
block|}
end_function

begin_comment
comment|/* Generate code to return from a thumb function.    If 'reg_containing_return_addr' is -1, then the return address is    actually on the stack, at the stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_exit
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|reg_containing_return_addr
parameter_list|,
name|rtx
name|eh_ofs
parameter_list|)
block|{
name|unsigned
name|regs_available_for_popping
decl_stmt|;
name|unsigned
name|regs_to_pop
decl_stmt|;
name|int
name|pops_needed
decl_stmt|;
name|unsigned
name|available
decl_stmt|;
name|unsigned
name|required
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|restore_a4
init|=
name|FALSE
decl_stmt|;
comment|/* Compute the registers we need to pop.  */
name|regs_to_pop
operator|=
literal|0
expr_stmt|;
name|pops_needed
operator|=
literal|0
expr_stmt|;
comment|/* There is an assumption here, that if eh_ofs is not NULL, the      normal return address will have been pushed.  */
if|if
condition|(
name|reg_containing_return_addr
operator|==
operator|-
literal|1
operator|||
name|eh_ofs
condition|)
block|{
comment|/* When we are generating a return for __builtin_eh_return,  	 reg_containing_return_addr must specify the return regno.  */
if|if
condition|(
name|eh_ofs
operator|&&
name|reg_containing_return_addr
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regs_to_pop
operator||=
literal|1
operator|<<
name|LR_REGNUM
expr_stmt|;
operator|++
name|pops_needed
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
block|{
comment|/* Restore the (ARM) frame pointer and stack pointer.  */
name|regs_to_pop
operator||=
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
name|pops_needed
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* If there is nothing to pop then just emit the BX instruction and      return.  */
if|if
condition|(
name|pops_needed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|eh_ofs
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|REGNO
argument_list|(
name|eh_ofs
argument_list|)
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise if we are not supporting interworking and we have not created      a backtrace structure and the function was not entered in ARM mode then      just pop the return address straight into the PC.  */
elseif|else
if|if
condition|(
operator|!
name|TARGET_INTERWORK
operator|&&
operator|!
name|TARGET_BACKTRACE
operator|&&
operator|!
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|eh_ofs
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, #4\n"
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|REGNO
argument_list|(
name|eh_ofs
argument_list|)
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tpop\t{%r}\n"
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find out how many of the (return) argument registers we can corrupt.  */
name|regs_available_for_popping
operator|=
literal|0
expr_stmt|;
comment|/* If returning via __builtin_eh_return, the bottom three registers      all contain information needed for the return.  */
if|if
condition|(
name|eh_ofs
condition|)
name|size
operator|=
literal|12
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|RTX_CODE
comment|/* If we can deduce the registers used from the function's 	 return value.  This is more reliable that examining 	 regs_ever_live[] because that will be set if the register is 	 ever used in the function, not just if the register is used 	 to hold a return value.  */
if|if
condition|(
name|current_function_return_rtx
operator|!=
literal|0
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|current_function_return_rtx
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* In a void function we can use any argument register. 	     In a function that returns a structure on the stack 	     we can use the second and third argument registers.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|1
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
else|else
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
literal|4
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
literal|8
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Match registers to be popped with registers into which we pop them.  */
for|for
control|(
name|available
operator|=
name|regs_available_for_popping
operator|,
name|required
operator|=
name|regs_to_pop
init|;
name|required
operator|!=
literal|0
operator|&&
name|available
operator|!=
literal|0
condition|;
name|available
operator|&=
operator|~
operator|(
name|available
operator|&
operator|-
name|available
operator|)
operator|,
name|required
operator|&=
operator|~
operator|(
name|required
operator|&
operator|-
name|required
operator|)
control|)
operator|--
name|pops_needed
expr_stmt|;
comment|/* If we have any popping registers left over, remove them.  */
if|if
condition|(
name|available
operator|>
literal|0
condition|)
name|regs_available_for_popping
operator|&=
operator|~
name|available
expr_stmt|;
comment|/* Otherwise if we need another popping register we can use      the fourth argument register.  */
elseif|else
if|if
condition|(
name|pops_needed
condition|)
block|{
comment|/* If we have not found any free argument registers and 	 reg a4 contains the return address, we must move it.  */
if|if
condition|(
name|regs_available_for_popping
operator|==
literal|0
operator|&&
name|reg_containing_return_addr
operator|==
name|LAST_ARG_REGNUM
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
literal|12
condition|)
block|{
comment|/* Register a4 is being used to hold part of the return value, 	     but we have dire need of a free, low register.  */
name|restore_a4
operator|=
name|TRUE
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_containing_return_addr
operator|!=
name|LAST_ARG_REGNUM
condition|)
block|{
comment|/* The fourth argument register is available.  */
name|regs_available_for_popping
operator||=
literal|1
operator|<<
name|LAST_ARG_REGNUM
expr_stmt|;
operator|--
name|pops_needed
expr_stmt|;
block|}
block|}
comment|/* Pop as many registers as we can.  */
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Process the registers we popped.  */
if|if
condition|(
name|reg_containing_return_addr
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* The return address was popped into the lowest numbered register.  */
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Remove this register for the mask of available registers, so that          the return address will not be corrupted by further pops.  */
name|regs_available_for_popping
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|reg_containing_return_addr
operator|)
expr_stmt|;
block|}
comment|/* If we popped other registers then handle them here.  */
if|if
condition|(
name|regs_available_for_popping
condition|)
block|{
name|int
name|frame_pointer
decl_stmt|;
comment|/* Work out which register currently contains the frame pointer.  */
name|frame_pointer
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Move it into the correct place.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|,
name|frame_pointer
argument_list|)
expr_stmt|;
comment|/* (Temporarily) remove it from the mask of popped registers.  */
name|regs_available_for_popping
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|frame_pointer
operator|)
expr_stmt|;
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|regs_available_for_popping
condition|)
block|{
name|int
name|stack_pointer
decl_stmt|;
comment|/* We popped the stack pointer as well, 	     find the register that contains it.  */
name|stack_pointer
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Move it into the stack register.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|stack_pointer
argument_list|)
expr_stmt|;
comment|/* At this point we have popped all necessary registers, so 	     do not worry about restoring regs_available_for_popping 	     to its correct value:  	     assert (pops_needed == 0) 	     assert (regs_available_for_popping == (1<< frame_pointer)) 	     assert (regs_to_pop == (1<< STACK_POINTER))  */
block|}
else|else
block|{
comment|/* Since we have just move the popped value into the frame 	     pointer, the popping register is available for reuse, and 	     we know that we still have the stack pointer left to pop.  */
name|regs_available_for_popping
operator||=
operator|(
literal|1
operator|<<
name|frame_pointer
operator|)
expr_stmt|;
block|}
block|}
comment|/* If we still have registers left on the stack, but we no longer have      any registers into which we can pop them, then we must move the return      address into the link register and make available the register that      contained it.  */
if|if
condition|(
name|regs_available_for_popping
operator|==
literal|0
operator|&&
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|regs_available_for_popping
operator||=
literal|1
operator|<<
name|reg_containing_return_addr
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
comment|/* If we have registers left on the stack then pop some more.      We know that at most we will want to pop FP and SP.  */
if|if
condition|(
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|int
name|popped_into
decl_stmt|;
name|int
name|move_to
decl_stmt|;
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* We have popped either FP or SP. 	 Move whichever one it is into the correct register.  */
name|popped_into
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
name|move_to
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_to_pop
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|move_to
argument_list|,
name|popped_into
argument_list|)
expr_stmt|;
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|move_to
operator|)
expr_stmt|;
operator|--
name|pops_needed
expr_stmt|;
block|}
comment|/* If we still have not popped everything then we must have only      had one register available to us and we are now popping the SP.  */
if|if
condition|(
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|int
name|popped_into
decl_stmt|;
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|regs_available_for_popping
argument_list|)
expr_stmt|;
name|popped_into
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|popped_into
argument_list|)
expr_stmt|;
comment|/* 	assert (regs_to_pop == (1<< STACK_POINTER)) 	assert (pops_needed == 1)       */
block|}
comment|/* If necessary restore the a4 register.  */
if|if
condition|(
name|restore_a4
condition|)
block|{
if|if
condition|(
name|reg_containing_return_addr
operator|!=
name|LR_REGNUM
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LAST_ARG_REGNUM
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eh_ofs
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|REGNO
argument_list|(
name|eh_ofs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return to caller.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to push or pop registers to or from the stack.  F is the    assembly file.  MASK is the registers to push or pop.  PUSH is    non-zero if we should push, and zero if we should pop.  For debugging    output, if pushing, adjust CFA_OFFSET by the amount of space added    to the stack.  REAL_REGS should have the same number of bits set as    MASK, and will be used instead (in the same order) to describe which    registers were saved - this is used to mark the save slots when we    push high registers after moving them to low registers.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_pushpop
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|push
parameter_list|,
name|int
modifier|*
name|cfa_offset
parameter_list|,
name|int
name|real_regs
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|lo_mask
init|=
name|mask
operator|&
literal|0xFF
decl_stmt|;
name|int
name|pushed_words
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lo_mask
operator|==
literal|0
operator|&&
operator|!
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
condition|)
block|{
comment|/* Special case.  Do not generate a POP PC statement here, do it in 	 thumb_exit() */
name|thumb_exit
argument_list|(
name|f
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t{"
argument_list|,
name|push
condition|?
literal|"push"
else|:
literal|"pop"
argument_list|)
expr_stmt|;
comment|/* Look at the low registers first.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
operator|,
name|lo_mask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|lo_mask
operator|&
literal|1
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lo_mask
operator|&
operator|~
literal|1
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|pushed_words
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/* Catch pushing the LR.  */
if|if
condition|(
name|mask
operator|&
literal|0xFF
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
name|pushed_words
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/* Catch popping the PC.  */
if|if
condition|(
name|TARGET_INTERWORK
operator|||
name|TARGET_BACKTRACE
condition|)
block|{
comment|/* The PC is never poped directly, instead 	     it is popped into r3 and then BX is used.  */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|thumb_exit
argument_list|(
name|f
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|mask
operator|&
literal|0xFF
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|push
operator|&&
name|pushed_words
operator|&&
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|int
name|pushed_mask
init|=
name|real_regs
decl_stmt|;
operator|*
name|cfa_offset
operator|+=
name|pushed_words
operator|*
literal|4
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|SP_REGNUM
argument_list|,
operator|*
name|cfa_offset
argument_list|)
expr_stmt|;
name|pushed_words
operator|=
literal|0
expr_stmt|;
name|pushed_mask
operator|=
name|real_regs
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
literal|14
condition|;
name|regno
operator|++
operator|,
name|pushed_mask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|pushed_mask
operator|&
literal|1
condition|)
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|regno
argument_list|,
literal|4
operator|*
name|pushed_words
operator|++
operator|-
operator|*
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|thumb_final_prescan_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|flag_print_asm_name
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%@ 0x%04x\n"
argument_list|,
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|thumb_shiftable_const
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|val
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
literal|0xff
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
comment|/* XXX */
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|mask
operator|<<
name|i
operator|)
operator|)
operator|==
name|val
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the current function contains,    or might contain a far jump.  */
end_comment

begin_function
name|int
name|thumb_far_jump_used_p
parameter_list|(
name|int
name|in_prologue
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* This test is only important for leaf functions.  */
comment|/* assert (!leaf_function_p ()); */
comment|/* If we have already decided that far jumps may be used,      do not bother checking again, and always return true even if      it turns out that they are not being used.  Once we have made      the decision that far jumps are present (and that hence the link      register will be pushed onto the stack) we cannot go back on it.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|far_jump_used
condition|)
return|return
literal|1
return|;
comment|/* If this function is not being called from the prologue/epilogue      generation code then it must be being called from the      INITIAL_ELIMINATION_OFFSET macro.  */
if|if
condition|(
operator|!
name|in_prologue
condition|)
block|{
comment|/* In this case we know that we are being asked about the elimination 	 of the arg pointer register.  If that register is not being used, 	 then there are no arguments on the stack, and we do not have to 	 worry that a far jump might force the prologue to push the link 	 register, changing the stack offsets.  In this case we can just 	 return false, since the presence of far jumps in the function will 	 not affect stack offsets.  	 If the arg pointer is live (or if it was live, but has now been 	 eliminated and so set to dead) then we do have to test to see if 	 the function might contain a far jump.  This test can lead to some 	 false negatives, since before reload is completed, then length of 	 branch instructions is not known, so gcc defaults to returning their 	 longest length, which in turn sets the far jump attribute to true.  	 A false negative will not result in bad code being generated, but it 	 will result in a needless push and pop of the link register.  We 	 hope that this does not occur too often.  */
if|if
condition|(
name|regs_ever_live
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|cfun
operator|->
name|machine
operator|->
name|arg_pointer_live
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|arg_pointer_live
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check to see if the function contains a branch      insn with the far jump attribute set.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* Ignore tablejump patterns.  */
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|&&
name|get_attr_far_jump
argument_list|(
name|insn
argument_list|)
operator|==
name|FAR_JUMP_YES
condition|)
block|{
comment|/* Record the fact that we have decided that 	     the function does use far jumps.  */
name|cfun
operator|->
name|machine
operator|->
name|far_jump_used
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if FUNC must be entered in ARM mode.  */
end_comment

begin_function
name|int
name|is_called_in_ARM_mode
parameter_list|(
name|tree
name|func
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ignore the problem about functions whoes address is taken.  */
if|if
condition|(
name|TARGET_CALLEE_INTERWORKING
operator|&&
name|TREE_PUBLIC
argument_list|(
name|func
argument_list|)
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|ARM_PE
return|return
name|lookup_attribute
argument_list|(
literal|"interfacearm"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|func
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
return|;
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The bits which aren't usefully expanded as rtl.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|thumb_unexpanded_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|live_regs_mask
init|=
literal|0
decl_stmt|;
name|int
name|high_regs_pushed
init|=
literal|0
decl_stmt|;
name|int
name|leaf_function
init|=
name|leaf_function_p
argument_list|()
decl_stmt|;
name|int
name|had_to_push_lr
decl_stmt|;
name|rtx
name|eh_ofs
init|=
name|cfun
operator|->
name|machine
operator|->
name|eh_epilogue_sp_ofs
decl_stmt|;
if|if
condition|(
name|return_used_this_function
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return
literal|""
return|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|regno
argument_list|)
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|8
init|;
name|regno
operator|<
literal|13
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|regno
argument_list|)
condition|)
name|high_regs_pushed
operator|++
expr_stmt|;
comment|/* The prolog may have pushed some high registers to use as      work registers.  eg the testsuite file:      gcc/testsuite/gcc/gcc.c-torture/execute/complex-2.c      compiles to produce: 	push	{r4, r5, r6, r7, lr} 	mov	r7, r9 	mov	r6, r8 	push	{r6, r7}      as part of the prolog.  We have to undo that pushing here.  */
if|if
condition|(
name|high_regs_pushed
condition|)
block|{
name|int
name|mask
init|=
name|live_regs_mask
decl_stmt|;
name|int
name|next_hi_reg
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|RTX_CODE
comment|/* If we can deduce the registers used from the function's return value. 	 This is more reliable that examining regs_ever_live[] because that 	 will be set if the register is ever used in the function, not just if 	 the register is used to hold a return value.  */
if|if
condition|(
name|current_function_return_rtx
operator|!=
literal|0
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|current_function_return_rtx
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Unless we are returning a type of size> 12 register r3 is          available.  */
if|if
condition|(
name|size
operator|<
literal|13
condition|)
name|mask
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
comment|/* Oh dear!  We have no low registers into which we can pop            high registers!  */
name|internal_error
argument_list|(
literal|"no low registers available for popping high registers"
argument_list|)
expr_stmt|;
for|for
control|(
name|next_hi_reg
operator|=
literal|8
init|;
name|next_hi_reg
operator|<
literal|13
condition|;
name|next_hi_reg
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|next_hi_reg
argument_list|)
condition|)
break|break;
while|while
condition|(
name|high_regs_pushed
condition|)
block|{
comment|/* Find lo register(s) into which the high register(s) can              be popped.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
name|high_regs_pushed
operator|--
expr_stmt|;
if|if
condition|(
name|high_regs_pushed
operator|==
literal|0
condition|)
break|break;
block|}
name|mask
operator|&=
operator|(
literal|2
operator|<<
name|regno
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* A noop if regno == 8 */
comment|/* Pop the values into the low register(s).  */
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* Move the value(s) into the high registers.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|next_hi_reg
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|next_hi_reg
operator|++
init|;
name|next_hi_reg
operator|<
literal|13
condition|;
name|next_hi_reg
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|next_hi_reg
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
block|}
name|had_to_push_lr
operator|=
operator|(
name|live_regs_mask
operator|||
operator|!
name|leaf_function
operator|||
name|thumb_far_jump_used_p
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_BACKTRACE
operator|&&
operator|(
operator|(
name|live_regs_mask
operator|&
literal|0xFF
operator|)
operator|==
literal|0
operator|)
operator|&&
name|regs_ever_live
index|[
name|LAST_ARG_REGNUM
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* The stack backtrace structure creation code had to 	 push R7 in order to get a work register, so we pop 	 it now.  */
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|LAST_LO_REGNUM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
operator|==
literal|0
operator|||
name|TARGET_BACKTRACE
condition|)
block|{
if|if
condition|(
name|had_to_push_lr
operator|&&
operator|!
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|eh_ofs
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|PC_REGNUM
expr_stmt|;
comment|/* Either no argument registers were pushed or a backtrace 	 structure was created which includes an adjusted stack 	 pointer, so just pop everything.  */
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|live_regs_mask
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|live_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_ofs
condition|)
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|,
name|eh_ofs
argument_list|)
expr_stmt|;
comment|/* We have either just popped the return address into the 	 PC or it is was kept in LR for the entire function or 	 it is still on the stack because we do not want to 	 return by doing a pop {pc}.  */
elseif|else
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|had_to_push_lr
operator|&&
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|?
operator|-
literal|1
else|:
name|LR_REGNUM
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pop everything but the return address.  */
name|live_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|live_regs_mask
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|live_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|had_to_push_lr
condition|)
comment|/* Get the return address into a temporary register.  */
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
literal|1
operator|<<
name|LAST_ARG_REGNUM
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|1
operator|<<
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
comment|/* Remove the argument registers that were pushed onto the stack.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_ofs
condition|)
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|,
name|eh_ofs
argument_list|)
expr_stmt|;
else|else
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
name|had_to_push_lr
condition|?
name|LAST_ARG_REGNUM
else|:
name|LR_REGNUM
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Functions to save and restore machine-specific function data.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|arm_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|machine_function
modifier|*
name|machine
decl_stmt|;
name|machine
operator|=
operator|(
name|machine_function
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARM_FT_UNKNOWN
operator|!=
literal|0
name|machine
operator|->
name|func_type
operator|=
name|ARM_FT_UNKNOWN
expr_stmt|;
endif|#
directive|endif
return|return
name|machine
return|;
block|}
end_function

begin_comment
comment|/* Return an RTX indicating where the return address to the    calling function can be found.  */
end_comment

begin_function
name|rtx
name|arm_return_addr
parameter_list|(
name|int
name|count
parameter_list|,
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|TARGET_APCS_32
condition|)
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNUM
argument_list|)
return|;
else|else
block|{
name|rtx
name|lr
init|=
name|gen_rtx_AND
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|RETURN_ADDR_MASK26
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|get_func_hard_reg_initial_val
argument_list|(
name|cfun
argument_list|,
name|lr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Do anything needed before RTL is emitted for each function.  */
end_comment

begin_function
name|void
name|arm_init_expanders
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Arrange to initialize and mark the machine per-function status.  */
name|init_machine_status
operator|=
name|arm_init_machine_status
expr_stmt|;
block|}
end_function

begin_function
name|HOST_WIDE_INT
name|thumb_get_frame_size
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|base_size
init|=
name|ROUND_UP_WORD
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|count_regs
init|=
literal|0
decl_stmt|;
name|int
name|entry_size
init|=
literal|0
decl_stmt|;
name|int
name|leaf
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_THUMB
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_ATPCS
condition|)
return|return
name|base_size
return|;
comment|/* We need to know if we are a leaf function.  Unfortunately, it      is possible to be called after start_sequence has been called,      which causes get_insns to return the insns for the sequence,      not the function, which will cause leaf_function_p to return      the incorrect result.       To work around this, we cache the computed frame size.  This      works because we will only be calling RTL expanders that need      to know about leaf functions once reload has completed, and the      frame size cannot be changed after that time, so we can safely      use the cached value.  */
if|if
condition|(
name|reload_completed
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|frame_size
return|;
name|leaf
operator|=
name|leaf_function_p
argument_list|()
expr_stmt|;
comment|/* A leaf function does not need any stack alignment if it has nothing      on the stack.  */
if|if
condition|(
name|leaf
operator|&&
name|base_size
operator|==
literal|0
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We know that SP will be word aligned on entry, and we must      preserve that condition at any subroutine call.  But those are      the only constraints.  */
comment|/* Space for variadic functions.  */
if|if
condition|(
name|current_function_pretend_args_size
condition|)
name|entry_size
operator|+=
name|current_function_pretend_args_size
expr_stmt|;
comment|/* Space for pushed lo registers.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|regno
argument_list|)
condition|)
name|count_regs
operator|++
expr_stmt|;
comment|/* Space for backtrace structure.  */
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
block|{
if|if
condition|(
name|count_regs
operator|==
literal|0
operator|&&
name|regs_ever_live
index|[
name|LAST_ARG_REGNUM
index|]
operator|!=
literal|0
condition|)
name|entry_size
operator|+=
literal|20
expr_stmt|;
else|else
name|entry_size
operator|+=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|count_regs
operator|||
operator|!
name|leaf
operator|||
name|thumb_far_jump_used_p
argument_list|(
literal|1
argument_list|)
condition|)
name|count_regs
operator|++
expr_stmt|;
comment|/* LR */
name|entry_size
operator|+=
name|count_regs
operator|*
literal|4
expr_stmt|;
name|count_regs
operator|=
literal|0
expr_stmt|;
comment|/* Space for pushed hi regs.  */
for|for
control|(
name|regno
operator|=
literal|8
init|;
name|regno
operator|<
literal|13
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|regno
argument_list|)
condition|)
name|count_regs
operator|++
expr_stmt|;
name|entry_size
operator|+=
name|count_regs
operator|*
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|entry_size
operator|+
name|base_size
operator|+
name|current_function_outgoing_args_size
operator|)
operator|&
literal|7
condition|)
name|base_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|entry_size
operator|+
name|base_size
operator|+
name|current_function_outgoing_args_size
operator|)
operator|&
literal|7
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame_size
operator|=
name|base_size
expr_stmt|;
return|return
name|base_size
return|;
block|}
end_function

begin_comment
comment|/* Generate the rest of a function's prologue.  */
end_comment

begin_function
name|void
name|thumb_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|dwarf
decl_stmt|;
name|HOST_WIDE_INT
name|amount
init|=
operator|(
name|thumb_get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|)
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"interrupt Service Routines cannot be coded in Thumb mode"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|amount
condition|)
block|{
name|amount
operator|=
name|ROUND_UP_WORD
argument_list|(
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|<
literal|512
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
comment|/* The stack decrement is too big for an immediate value in a single 	     insn.  In theory we could issue multiple subtracts, but after 	     three of them it becomes more space efficient to place the full 	     value in the constant pool and load into a register.  (Also the 	     ARM debugger really likes to see only one stack decrement per 	     function).  So instead we look for a scratch register into which 	     we can load the decrement, and then we subtract this from the 	     stack pointer.  Unfortunately on the thumb the only available 	     scratch registers are the argument registers, and we cannot use 	     these as they may hold arguments to the function.  Instead we 	     attempt to locate a call preserved register which is used by this 	     function.  If we can find one, then we know that it will have 	     been pushed at the start of the prologue and so we can corrupt 	     it now.  */
for|for
control|(
name|regno
operator|=
name|LAST_ARG_REGNUM
operator|+
literal|1
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
operator|(
name|frame_pointer_needed
operator|&&
operator|(
name|regno
operator|==
name|THUMB_HARD_FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|regno
operator|>
name|LAST_LO_REGNUM
condition|)
comment|/* Very unlikely.  */
block|{
name|rtx
name|spare
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
decl_stmt|;
comment|/* Choose an arbitrary, non-argument low register.  */
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|LAST_LO_REGNUM
argument_list|)
expr_stmt|;
comment|/* Save it by copying it into a high, scratch register.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|spare
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add a USE to stop propagate_one_insn() from barfing.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|spare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrement the stack.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|dwarf
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the low register's original value.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|spare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit a USE of the restored scratch register, so that flow 		 analysis will not consider the restore redundant.  The 		 register won't be used again in this function and isn't 		 restored by the epilogue.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|dwarf
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|current_function_profile
operator|||
name|TARGET_NO_SCHED_PRO
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|thumb_expand_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
name|HOST_WIDE_INT
name|amount
init|=
operator|(
name|thumb_get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|)
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|amount
condition|)
block|{
name|amount
operator|=
name|ROUND_UP_WORD
argument_list|(
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|<
literal|512
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* r3 is always free in the epilogue.  */
name|rtx
name|reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit a USE (stack_pointer_rtx), so that      the stack adjustment will not be deleted.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_profile
operator|||
name|TARGET_NO_SCHED_PRO
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Emit a clobber for each insn that will be restored in the epilogue,      so that flow2 will get register lifetimes correct.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|13
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|LR_REGNUM
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|live_regs_mask
init|=
literal|0
decl_stmt|;
name|int
name|high_regs_pushed
init|=
literal|0
decl_stmt|;
name|int
name|cfa_offset
init|=
literal|0
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return;
if|if
condition|(
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Generate code sequence to switch us into Thumb mode.  */
comment|/* The .code 32 directive has already been emitted by 	 ASM_DECLARE_FUNCTION_NAME.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\torr\t%r, %r, #1\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
comment|/* Generate a label, so that the debugger will notice the 	 change in instruction sets.  This label is also used by 	 the assembler to bypass the ARM code when this function 	 is called from a Thumb encoded function elsewhere in the 	 same file.  Hence the definition of STUB_NAME here must 	 agree with the definition in gas/config/tc-arm.c.  */
define|#
directive|define
name|STUB_NAME
value|".real_start_of"
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.code\t16\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM_PE
if|if
condition|(
name|arm_dllexport_name_p
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|arm_strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl %s%U%s\n"
argument_list|,
name|STUB_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.thumb_func\n"
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%s%U%s:\n"
argument_list|,
name|STUB_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
condition|)
block|{
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
condition|)
block|{
name|int
name|num_pushes
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tpush\t{"
argument_list|)
expr_stmt|;
name|num_pushes
operator|=
name|ARM_NUM_INTS
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|LAST_ARG_REGNUM
operator|+
literal|1
operator|-
name|num_pushes
init|;
name|regno
operator|<=
name|LAST_ARG_REGNUM
condition|;
name|regno
operator|++
control|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r%s"
argument_list|,
name|regno
argument_list|,
name|regno
operator|==
name|LAST_ARG_REGNUM
condition|?
literal|""
else|:
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #%d\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
comment|/* We don't need to record the stores for unwinding (would it 	 help the debugger any if we did?), but record the change in 	 the stack pointer.  */
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|cfa_offset
operator|=
name|cfa_offset
operator|+
name|current_function_pretend_args_size
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|SP_REGNUM
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|regno
argument_list|)
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
if|if
condition|(
name|live_regs_mask
operator|||
operator|!
name|leaf_function_p
argument_list|()
operator|||
name|thumb_far_jump_used_p
argument_list|(
literal|1
argument_list|)
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|LR_REGNUM
expr_stmt|;
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|int
name|work_register
init|=
literal|0
decl_stmt|;
name|int
name|wr
decl_stmt|;
comment|/* We have been asked to create a stack backtrace structure.          The code looks like this: 	  	 0   .align 2 	 0   func:          0     sub   SP, #16         Reserve space for 4 registers. 	 2     push  {R7}            Get a work register.          4     add   R7, SP, #20     Get the stack pointer before the push.          6     str   R7, [SP, #8]    Store the stack pointer (before reserving the space).          8     mov   R7, PC          Get hold of the start of this code plus 12.         10     str   R7, [SP, #16]   Store it.         12     mov   R7, FP          Get hold of the current frame pointer.         14     str   R7, [SP, #4]    Store it.         16     mov   R7, LR          Get hold of the current return address.         18     str   R7, [SP, #12]   Store it.         20     add   R7, SP, #16     Point at the start of the backtrace structure.         22     mov   FP, R7          Put this value into the frame pointer.  */
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
literal|0xFF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* See if the a4 register is free.  */
if|if
condition|(
name|regs_ever_live
index|[
name|LAST_ARG_REGNUM
index|]
operator|==
literal|0
condition|)
name|work_register
operator|=
name|LAST_ARG_REGNUM
expr_stmt|;
else|else
comment|/* We must push a register of our own.  */
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|LAST_LO_REGNUM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|work_register
operator|==
literal|0
condition|)
block|{
comment|/* Select a register from the list that will be pushed to              use as our work register.  */
for|for
control|(
name|work_register
operator|=
operator|(
name|LAST_LO_REGNUM
operator|+
literal|1
operator|)
init|;
name|work_register
operator|--
condition|;
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|work_register
operator|)
operator|&
name|live_regs_mask
condition|)
break|break;
block|}
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #16\t%@ Create stack backtrace structure\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|cfa_offset
operator|=
name|cfa_offset
operator|+
literal|16
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|SP_REGNUM
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|live_regs_mask
argument_list|,
literal|1
argument_list|,
operator|&
name|cfa_offset
argument_list|,
name|live_regs_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|wr
operator|=
literal|1
operator|<<
literal|15
init|;
name|wr
operator|!=
literal|0
condition|;
name|wr
operator|>>=
literal|1
control|)
if|if
condition|(
name|wr
operator|&
name|live_regs_mask
condition|)
name|offset
operator|+=
literal|4
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|16
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Make sure that the instruction fetching the PC is in the right place 	 to calculate "start of backtrace creation code + 12".  */
if|if
condition|(
name|live_regs_mask
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\t\t%@ Backtrace structure created\n"
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|,
name|work_register
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|live_regs_mask
argument_list|,
literal|1
argument_list|,
operator|&
name|cfa_offset
argument_list|,
name|live_regs_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|8
init|;
name|regno
operator|<
literal|13
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|regno
argument_list|)
condition|)
name|high_regs_pushed
operator|++
expr_stmt|;
if|if
condition|(
name|high_regs_pushed
condition|)
block|{
name|int
name|pushable_regs
init|=
literal|0
decl_stmt|;
name|int
name|mask
init|=
name|live_regs_mask
operator|&
literal|0xff
decl_stmt|;
name|int
name|next_hi_reg
decl_stmt|;
for|for
control|(
name|next_hi_reg
operator|=
literal|12
init|;
name|next_hi_reg
operator|>
name|LAST_LO_REGNUM
condition|;
name|next_hi_reg
operator|--
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|next_hi_reg
argument_list|)
condition|)
break|break;
name|pushable_regs
operator|=
name|mask
expr_stmt|;
if|if
condition|(
name|pushable_regs
operator|==
literal|0
condition|)
block|{
comment|/* Desperation time -- this probably will never happen.  */
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|LAST_ARG_REGNUM
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|LAST_ARG_REGNUM
expr_stmt|;
block|}
while|while
condition|(
name|high_regs_pushed
operator|>
literal|0
condition|)
block|{
name|int
name|real_regs_mask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|LAST_LO_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|regno
argument_list|,
name|next_hi_reg
argument_list|)
expr_stmt|;
name|high_regs_pushed
operator|--
expr_stmt|;
name|real_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|next_hi_reg
operator|)
expr_stmt|;
if|if
condition|(
name|high_regs_pushed
condition|)
block|{
for|for
control|(
name|next_hi_reg
operator|--
init|;
name|next_hi_reg
operator|>
name|LAST_LO_REGNUM
condition|;
name|next_hi_reg
operator|--
control|)
if|if
condition|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|next_hi_reg
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
name|mask
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|regno
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|mask
argument_list|,
literal|1
argument_list|,
operator|&
name|cfa_offset
argument_list|,
name|real_regs_mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pushable_regs
operator|==
literal|0
operator|&&
operator|(
name|THUMB_REG_PUSHED_P
argument_list|(
name|LAST_ARG_REGNUM
argument_list|)
operator|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LAST_ARG_REGNUM
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the case of a double word load into a low register from    a computed memory address.  The computed address may involve a    register which is overwritten by the load.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|thumb_load_double_from_address
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|rtx
name|arg1
decl_stmt|;
name|rtx
name|arg2
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the memory address.  */
name|addr
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Work out how the memory address is computed.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST
case|:
comment|/* Compute<address> + 4 for the high order load.  */
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|arg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg1
argument_list|)
condition|)
name|base
operator|=
name|arg2
operator|,
name|offset
operator|=
name|arg1
expr_stmt|;
else|else
name|base
operator|=
name|arg1
operator|,
name|offset
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Catch the case of<address> =<reg> +<reg> */
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|reg_offset
init|=
name|REGNO
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|int
name|reg_base
init|=
name|REGNO
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|int
name|reg_dest
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* Add the base and offset registers together into the              higher destination register.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tadd\t%r, %r, %r"
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|,
name|reg_base
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
comment|/* Load the lower destination register from the address in              the higher destination register.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tldr\t%r, [%r, #0]"
argument_list|,
name|reg_dest
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Load the higher destination register from its own address              plus 4.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tldr\t%r, [%r, #4]"
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute<address> + 4 for the high order load.  */
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the computed address is held in the low order register 	     then load the high order register first, otherwise always 	     load the low order register first.  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LABEL_REF
case|:
comment|/* With no registers to worry about we can just load the value          directly.  */
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|thumb_output_move_mem_multiple
parameter_list|(
name|int
name|n
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"ldmia\t%1!, {%4, %5}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stmia\t%0!, {%4, %5}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|operands
index|[
literal|6
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"ldmia\t%1!, {%4, %5, %6}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stmia\t%0!, {%4, %5, %6}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Routines for generating rtl.  */
end_comment

begin_function
name|void
name|thumb_expand_movstrqi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|out
init|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|in
init|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|len
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|12
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movmem12b
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movmem8b
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|out
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|2
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|in
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|out
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|in
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|out
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|thumb_cmp_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|256
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|)
operator|||
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|thumb_cmpneg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
operator|-
literal|256
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if a result can be stored in OP without clobbering the    condition code register.  Prior to reload we only accept a    register.  After reload we have to be able to handle memory as    well, since a pseudo may not get a hard reg and reload cannot    handle output-reloads on jump insns.     We could possibly handle mem before reload as well, but that might    complicate things with the need to handle increment    side-effects.  */
end_comment

begin_function
name|int
name|thumb_cbrch_target_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle storing a half-word to memory during reload.  */
end_comment

begin_function
name|void
name|thumb_reload_out_hi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|emit_insn
argument_list|(
name|gen_thumb_movhi_clobber
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle reading a half-word from memory during reload.  */
end_comment

begin_function
name|void
name|thumb_reload_in_hi
parameter_list|(
name|rtx
modifier|*
name|operands
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the length of a function name prefix     that starts with the character 'c'.  */
end_comment

begin_function
specifier|static
name|int
name|arm_get_strip_length
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
name|ARM_NAME_ENCODING_LENGTHS
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a function's name with any    and all prefix encodings stripped from it.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arm_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|skip
decl_stmt|;
while|while
condition|(
operator|(
name|skip
operator|=
name|arm_get_strip_length
argument_list|(
operator|*
name|name
argument_list|)
operator|)
condition|)
name|name
operator|+=
name|skip
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* If there is a '*' anywhere in the name's prefix, then    emit the stripped name verbatim, otherwise prepend an    underscore if leading underscores are being used.  */
end_comment

begin_function
name|void
name|arm_asm_output_labelref
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|skip
decl_stmt|;
name|int
name|verbatim
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|skip
operator|=
name|arm_get_strip_length
argument_list|(
operator|*
name|name
argument_list|)
operator|)
condition|)
block|{
name|verbatim
operator||=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
expr_stmt|;
name|name
operator|+=
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|verbatim
condition|)
name|fputs
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%U%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|rtx
name|aof_pic_label
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
end_ifdef

begin_comment
comment|/* Special functions only needed when producing AOF syntax assembler.  */
end_comment

begin_struct
struct|struct
name|pic_chain
block|{
name|struct
name|pic_chain
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pic_chain
modifier|*
name|aof_pic_chain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|rtx
name|aof_pic_entry
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|pic_chain
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|aof_pic_label
operator|==
name|NULL_RTX
condition|)
block|{
name|aof_pic_label
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"x$adcons"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|chainp
operator|=
operator|&
name|aof_pic_chain
init|;
operator|*
name|chainp
condition|;
name|offset
operator|+=
literal|4
operator|,
name|chainp
operator|=
operator|&
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|chainp
operator|)
operator|->
name|symname
operator|==
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|plus_constant
argument_list|(
name|aof_pic_label
argument_list|,
name|offset
argument_list|)
return|;
operator|*
name|chainp
operator|=
operator|(
expr|struct
name|pic_chain
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pic_chain
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|chainp
operator|)
operator|->
name|symname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|aof_pic_label
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|aof_dump_pic_table
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|pic_chain
modifier|*
name|chain
decl_stmt|;
if|if
condition|(
name|aof_pic_chain
operator|==
name|NULL
condition|)
return|return;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tAREA |%r$$adcons|, BASED %r\n"
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"|x$adcons|\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|aof_pic_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|fputs
argument_list|(
literal|"\tDCD\t"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|f
argument_list|,
name|chain
operator|->
name|symname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|arm_text_section_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|aof_text_section
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\tAREA |C$$code%d|, CODE, READONLY"
argument_list|,
name|arm_text_section_count
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", PIC, REENTRANT"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|arm_data_section_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|aof_data_section
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\tAREA |C$$data%d|, DATA"
argument_list|,
name|arm_data_section_count
operator|++
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* The AOF assembler is religiously strict about declarations of    imported and exported symbols, so that it is impossible to declare    a function as imported near the beginning of the file, and then to    export it later on.  It is, however, possible to delay the decision    until all the functions in the file have been compiled.  To get    around this, we maintain a list of the imports and exports, and    delete from it any that are subsequently defined.  At the end of    compilation we spit the remainder of the list out before the END    directive.  */
end_comment

begin_struct
struct|struct
name|import
block|{
name|struct
name|import
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|import
modifier|*
name|imports_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|aof_add_import
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|import
modifier|*
name|new
decl_stmt|;
for|for
control|(
name|new
operator|=
name|imports_list
init|;
name|new
condition|;
name|new
operator|=
name|new
operator|->
name|next
control|)
if|if
condition|(
name|new
operator|->
name|name
operator|==
name|name
condition|)
return|return;
name|new
operator|=
operator|(
expr|struct
name|import
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|import
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|imports_list
expr_stmt|;
name|imports_list
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aof_delete_import
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|import
modifier|*
modifier|*
name|old
decl_stmt|;
for|for
control|(
name|old
operator|=
operator|&
name|imports_list
init|;
operator|*
name|old
condition|;
name|old
operator|=
operator|&
operator|(
operator|*
name|old
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|old
operator|)
operator|->
name|name
operator|==
name|name
condition|)
block|{
operator|*
name|old
operator|=
operator|(
operator|*
name|old
operator|)
operator|->
name|next
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|int
name|arm_main_function
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|aof_dump_imports
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
comment|/* The AOF assembler needs this to cause the startup code to be extracted      from the library.  Brining in __main causes the whole thing to work      automagically.  */
if|if
condition|(
name|arm_main_function
condition|)
block|{
name|text_section
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"\tIMPORT __main\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tDCD __main\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Now dump the remaining imports.  */
while|while
condition|(
name|imports_list
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tIMPORT\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|f
argument_list|,
name|imports_list
operator|->
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|imports_list
operator|=
name|imports_list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aof_globalize_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|default_globalize_label
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"main"
argument_list|)
condition|)
name|arm_main_function
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aof_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"__r0\tRN\t0\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__a1\tRN\t0\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__a2\tRN\t1\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__a3\tRN\t2\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__a4\tRN\t3\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v1\tRN\t4\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v2\tRN\t5\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v3\tRN\t6\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v4\tRN\t7\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v5\tRN\t8\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v6\tRN\t9\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__sl\tRN\t10\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__fp\tRN\t11\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__ip\tRN\t12\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__sp\tRN\t13\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__lr\tRN\t14\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__pc\tRN\t15\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f0\tFN\t0\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f1\tFN\t1\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f2\tFN\t2\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f3\tFN\t3\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f4\tFN\t4\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f5\tFN\t5\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f6\tFN\t6\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f7\tFN\t7\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aof_file_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|aof_dump_pic_table
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|aof_dump_imports
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tEND\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AOF_ASSEMBLER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_comment
comment|/* Switch to an arbitrary section NAME with attributes as specified    by FLAGS.  ALIGN specifies any known alignment requirements for    the section; 0 if the default should be used.     Differs from the default elf version only in the prefix character    used before the section type.  */
end_comment

begin_function
specifier|static
name|void
name|arm_elf_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|char
name|flagchars
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
if|if
condition|(
operator|!
name|named_section_first_declaration
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_DEBUG
operator|)
condition|)
operator|*
name|f
operator|++
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_SMALL
condition|)
operator|*
name|f
operator|++
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_MERGE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_STRINGS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'S'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_TLS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\""
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_NOTYPE
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_BSS
condition|)
name|type
operator|=
literal|"nobits"
expr_stmt|;
else|else
name|type
operator|=
literal|"progbits"
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",%%%s"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_ENTSIZE
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",%d"
argument_list|,
name|flags
operator|&
name|SECTION_ENTSIZE
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_PE
end_ifndef

begin_comment
comment|/* Symbols in the text segment can be accessed without indirecting via the    constant pool; it may take an extra binary operation, but this is still    faster than indirecting via memory.  Don't do this when not optimizing,    since we won't be calculating al of the offsets necessary to do this    simplification.  */
end_comment

begin_function
specifier|static
name|void
name|arm_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
comment|/* This doesn't work with AOF syntax, since the string table may be in      a different AREA.  */
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|flag_writable_strings
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|STRING_CST
operator|)
condition|)
name|SYMBOL_REF_FLAG
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If we are referencing a function that is weak then encode a long call      flag in the function name, otherwise if the function is static or      or known to be defined in this file then encode a short call flag.  */
if|if
condition|(
name|first
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|arm_encode_call_attribute
argument_list|(
name|decl
argument_list|,
name|LONG_CALL_FLAG_CHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|arm_encode_call_attribute
argument_list|(
name|decl
argument_list|,
name|SHORT_CALL_FLAG_CHAR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ARM_PE */
end_comment

begin_function
specifier|static
name|void
name|arm_internal_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|unsigned
name|long
name|labelno
parameter_list|)
block|{
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
operator|&&
operator|(
name|unsigned
operator|)
name|arm_target_label
operator|==
name|labelno
operator|&&
operator|!
name|strcmp
argument_list|(
name|prefix
argument_list|,
literal|"L"
argument_list|)
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
name|arm_target_insn
operator|=
name|NULL
expr_stmt|;
block|}
name|default_internal_label
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code to add DELTA to the first argument, and then jump    to FUNCTION.  Used for C++ multiple inheritance.  */
end_comment

begin_function
specifier|static
name|void
name|arm_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
specifier|static
name|int
name|thunk_label
init|=
literal|0
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|int
name|mi_delta
init|=
name|delta
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|mi_op
init|=
name|mi_delta
operator|<
literal|0
condition|?
literal|"sub"
else|:
literal|"add"
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|int
name|this_regno
init|=
operator|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mi_delta
operator|<
literal|0
condition|)
name|mi_delta
operator|=
operator|-
name|mi_delta
expr_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
name|int
name|labelno
init|=
name|thunk_label
operator|++
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LTHUMBFUNC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tldr\tr12, "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|mi_delta
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mi_delta
operator|&
operator|(
literal|3
operator|<<
name|shift
operator|)
operator|)
operator|==
literal|0
condition|)
name|shift
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%r, %r, #%d\n"
argument_list|,
name|mi_op
argument_list|,
name|this_regno
argument_list|,
name|this_regno
argument_list|,
name|mi_delta
operator|&
operator|(
literal|0xff
operator|<<
name|shift
operator|)
argument_list|)
expr_stmt|;
name|mi_delta
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbx\tr12\n"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|,
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"\tb\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEED_PLT_RELOC
condition|)
name|fputs
argument_list|(
literal|"(PLT)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|arm_emit_vector_const
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_VECTOR
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|V2SImode
case|:
name|pattern
operator|=
literal|"%08x"
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|pattern
operator|=
literal|"%04x"
expr_stmt|;
break|break;
case|case
name|V8QImode
case|:
name|pattern
operator|=
literal|"%02x"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|rtx
name|element
decl_stmt|;
name|element
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|pattern
argument_list|,
name|INTVAL
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|arm_output_load_gr
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|rtx
name|wcgr
decl_stmt|;
name|rtx
name|sum
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|sum
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|offset
operator|=
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|<
literal|1024
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|>
operator|-
literal|1024
operator|)
operator|)
condition|)
return|return
literal|"wldrw%?\t%0, %1"
return|;
comment|/* Fix up an out-of-range load of a GR register.  */
name|output_asm_insn
argument_list|(
literal|"str%?\t%0, [sp, #-4]!\t@ Start of GR load expansion"
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|wcgr
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|wcgr
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"tmcr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [sp], #4\t@ End of GR load expansion"
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

end_unit

